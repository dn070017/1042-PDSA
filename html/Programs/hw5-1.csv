"r04447001","0","1.43","173056","@63e7bdf90fd4d5e82df445577037420f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].polarOrder());

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(a[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@63e7bdf90fd4d5e82df445577037420f@"
"r04447001","0","1.43","173056","@dd9eef44181c2898130c5b3489b83b73@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].polarOrder());

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(a[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@dd9eef44181c2898130c5b3489b83b73@"
"r04447001","0","0.47","102432","@8289fafc209178a5b044052fcd2ab6ff@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER());

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(a[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@8289fafc209178a5b044052fcd2ab6ff@"
"r04447001","0","0.54","104480","@b2a3da16d3c39dbd575e7a8d0ef9e225@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(a[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@b2a3da16d3c39dbd575e7a8d0ef9e225@"
"r04447001","0","0.52","107024","@431dea4e3a2f04a523ea8f77afe0bae9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a;
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        Arrays.sort(finalindex);
        
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@431dea4e3a2f04a523ea8f77afe0bae9@"
"r04447001","0","0.54","104480","@c56489e807181d8bcddcbfcdb7ca2821@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a;
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        int[] finalindex2 = new int[currentpoint];
        for(int i = 0; i < currentpoint; i++){
            finalindex2[i] = finalindex[i];
        }//resizing array
        Arrays.sort(finalindex2);
        
        return finalindex2;
    }

    public static void main(String[] args) throws Exception {
        
        
        /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }*/
}

@c56489e807181d8bcddcbfcdb7ca2821@"
"r04447001","0","0.52","107840","@16db1eb4ab3824d6c125cc088db85758@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a;
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        int[] finalindex2 = new int[currentpoint];
        for(int i = 0; i < currentpoint; i++){
            finalindex2[i] = finalindex[i];
        }//resizing array
        Arrays.sort(finalindex2);
        
        return finalindex2;
    }
}

   // public static void main(String[] args) throws Exception {}
        
        
        /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }*/
//}

@16db1eb4ab3824d6c125cc088db85758@"
"r04447001","2","0.51","104848","@5042419ee13f6f79224b5c45f821d40b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a.clone();
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        
        /*for(int i = 0; i < finalnum; i++){
        System.out.print(finalindex[i]+"" "");
        System.out.println();
        }*/
        
        Arrays.sort(finalindex);
        
        return finalindex;
    }
    public static void main(String[] args) {
        Point2D[] test = new Point2D[10];
        for(int i = 0; i <10; i++){
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        test[i] = new Point2D(x,y);
        }
        for(int i = 0; i < 10; i++){
            StdDraw.filledCircle(test[i].x(), test[i].y(), 0.01);
            StdDraw.text(test[i].x(), test[i].y()+0.05, String.valueOf(i));
        }
        int[] result = ConvexHullVertex(test);
        for(int i = 0; i < result.length; i++){
        System.out.print(result[i]+"" "");
        }
    }
    
}

           
   // public static void main(String[] args) throws Exception {}
        
        
        /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }*/
//}

@5042419ee13f6f79224b5c45f821d40b@"
"b02611019","0","0.52","107024","@87bfd2998dd56219bdd6466ed6197f05@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class ConvexHullVertex {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);

        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
//             StdOut.print(an[i]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
//            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);

    }
}

@87bfd2998dd56219bdd6466ed6197f05@"
"b02611019","0","0.52","107840","@87bfd2998dd56219bdd6466ed6197f05@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class ConvexHullVertex {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);

        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
//             StdOut.print(an[i]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
//            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);

    }
}

@87bfd2998dd56219bdd6466ed6197f05@"
"b02611019","0","0","0","@46ee7fd3ad02ee5de54b63cb9d5de1f1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);

        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
//             StdOut.print(an[i]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
//            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);

    }
}

@46ee7fd3ad02ee5de54b63cb9d5de1f1@"
"b02611019","0","0.52","106144","@21eef52b1ab088425f7bb60f5ad6dad3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i=0;i<a.length;i++){
            map.put(a[i], i);
        }
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);

        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
//             StdOut.print(an[i]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);

    }
}

@21eef52b1ab088425f7bb60f5ad6dad3@"
"r04447001","2","0.48","107840","@adc0ff26228a4daa700aff136c66d0f6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a.clone();
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2 = k1+1;
        /*for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }*/
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        
        /*for(int i = 0; i < finalnum; i++){
        System.out.print(finalindex[i]+"" "");
        System.out.println();
        }*/
        
        Arrays.sort(finalindex);
        
        return finalindex;
    }
    public static void main(String[] args) {
        Point2D[] test = new Point2D[10];
        for(int i = 0; i <10; i++){
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        test[i] = new Point2D(x,y);
        }
        for(int i = 0; i < 10; i++){
            StdDraw.filledCircle(test[i].x(), test[i].y(), 0.01);
            StdDraw.text(test[i].x(), test[i].y()+0.05, String.valueOf(i));
        }
        int[] result = ConvexHullVertex(test);
        for(int i = 0; i < result.length; i++){
        System.out.print(result[i]+"" "");
        }
    }
    
}

           
   // public static void main(String[] args) throws Exception {}
        
        
        /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }*/
//}

@adc0ff26228a4daa700aff136c66d0f6@"
"r04447001","5","0.102","107568","@11ba812005525a6c7f649f42404e7243@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a.clone();
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, N, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        
        /*for(int i = 0; i < finalnum; i++){
        System.out.print(finalindex[i]+"" "");
        System.out.println();
        }*/
        
        Arrays.sort(finalindex);
        
        return finalindex;
    }
    public static void main(String[] args) {
        Point2D[] test = new Point2D[10];
        for(int i = 0; i <10; i++){
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        test[i] = new Point2D(x,y);
        }
        for(int i = 0; i < 10; i++){
            StdDraw.filledCircle(test[i].x(), test[i].y(), 0.01);
            StdDraw.text(test[i].x(), test[i].y()+0.05, String.valueOf(i));
        }
        int[] result = ConvexHullVertex(test);
        for(int i = 0; i < result.length; i++){
        System.out.print(result[i]+"" "");
        }
    }
    
}

           
   // public static void main(String[] args) throws Exception {}
        
        
        /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }*/
//}

@11ba812005525a6c7f649f42404e7243@"
"b02611019","0","0.52","108064","@5d4dc2f1b04e67960813620d22cdb3fc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i=0;i<a.length;i++){
            map.put(a[i], i);
        }
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);
        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {
/*
        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);
*/
    }
}

@5d4dc2f1b04e67960813620d22cdb3fc@"
"b02611019","5","0.106","107952","@d23592e606ed5bd03fd4b4ff56ec171a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i=0;i<a.length;i++){
            map.put(a[i], i);
        }
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);
        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
//            StdOut.print(an[i]);
//            StdOut.print(an.length);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {
/*
        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);
*/
    }
}

@d23592e606ed5bd03fd4b4ff56ec171a@"
"r04942099","0","0.51","106672","@2b702bbbe5b9c7d28274dc5460de40ff@
import java.util.Arrays;



public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        points = a;
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            return index;
    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
}

@2b702bbbe5b9c7d28274dc5460de40ff@"
"r04942099","5","0.102","107904","@2ddd9a429126da731a37fb8c3ff93a64@
import java.util.Arrays;



public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            return index;
    }

    public static void main(String[] args) {
int N = 30;

        StdDraw.setCanvasSize(600, 600);
        StdDraw.setXscale(-100, 700);
        StdDraw.setYscale(-100, 700);
        StdDraw.setPenRadius(.02);

        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            int x = StdRandom.uniform(600);
            int y = StdRandom.uniform(600);
            points[i] = new Point2D(x, y);
            points[i].draw();

        }
        
        int[] test = new int[N];
        test = MyConvexHull.ConvexHullVertex(points);
        Merge.sort(points);

        Arrays.sort(points, points[0].POLAR_ORDER);
        for (int i = 0; i < N; ++i) {
            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
        }

        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        //System.out.println(vals.size());
        
        StdDraw.setPenColor(StdDraw.GREEN);
        int number = vals.size();
        
        
        for(int i=0; i<number;i++){
            System.out.println(test[i]);
        }
        
        
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
            vertex[u].draw();
        }
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
}

@2ddd9a429126da731a37fb8c3ff93a64@"
"r04921104","0","0.51","106672","@3c59c8f7deea8551388d1c86ba47a0d5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.MergeX;

import java.util.Comparator;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int number;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.number = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

      
        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }


        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j],points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int)record.pop();               
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;
        
        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int)record.pop()].number;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        int N = 10;
        Point2D[] points = new Point2D[N];

        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(StdRandom.uniform(0, 1.0), StdRandom.uniform(0, 1.0));
            //StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));///////////////////
            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }

        int[] index_res = ConvexHullVertex(points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());

        
        ////////////cc + convexhull/////////////
        MergeX.sort(points,Point2D.Y_ORDER);
        
        double thr = 0.25;
        UF cc = new UF(points.length);
        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < points.length-1; i++) {
            for (int j = 1; j < points.length - i; j++) {
                if (points[i].distanceTo(points[i + j]) <= thr) {
                    cc.union(i, i + j);
                    StdDraw.line(points[i].x(), points[i].y(), points[i+j].x(), points[i+j].y());
                    points[i].drawTo(points[i + j]);
                }else if (points[i + j].y() - points[i].y() >thr)
                    break;
            }
        }

        Point2D[][] ccpoints = new Point2D[cc.count()][];
        int[] ccsize = new int[cc.count()];
        for (int i = 0; i < points.length; i++) {
           
        }

        //List<List<Point2D>> ccpoints = new ArrayList<>(4);
        //ccpoints.isEmpty();
        //StdOut.println(ccpoints.isEmpty());
        ////////////cc + convexhull/////////////
    }

}

@3c59c8f7deea8551388d1c86ba47a0d5@"
"r04921104","0","0.102","107904","@13024802079d2953ba05029ee82c7cf2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.MergeX;

import java.util.Comparator;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int number;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.number = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

      
        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }


        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j],points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int)record.pop();               
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;
        
        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int)record.pop()].number;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        int N = 10;
        Point2D[] points = new Point2D[N];

        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(StdRandom.uniform(0, 1.0), StdRandom.uniform(0, 1.0));
            //StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));///////////////////
            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }

        int[] index_res = ConvexHullVertex(points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());

        
        ////////////cc + convexhull/////////////
        MergeX.sort(points,Point2D.Y_ORDER);
        
        double thr = 0.25;
        UF cc = new UF(points.length);
        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < points.length-1; i++) {
            for (int j = 1; j < points.length - i; j++) {
                if (points[i].distanceTo(points[i + j]) <= thr) {
                    cc.union(i, i + j);
                    StdDraw.line(points[i].x(), points[i].y(), points[i+j].x(), points[i+j].y());
                    points[i].drawTo(points[i + j]);
                }else if (points[i + j].y() - points[i].y() >thr)
                    break;
            }
        }

        Point2D[][] ccpoints = new Point2D[cc.count()][];
        int[] ccsize = new int[cc.count()];
        for (int i = 0; i < points.length; i++) {
           
        }

        //List<List<Point2D>> ccpoints = new ArrayList<>(4);
        //ccpoints.isEmpty();
        //StdOut.println(ccpoints.isEmpty());
        ////////////cc + convexhull/////////////
    }

}

@13024802079d2953ba05029ee82c7cf2@"
"r04921104","5","0.1","107936","@eec1def4a8570774b94e64107e1980ea@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.MergeX;

import java.util.Comparator;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int number;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.number = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

      
        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }


        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j],points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int)record.pop();               
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;
        
        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int)record.pop()].number;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        int N = 10;
        Point2D[] points = new Point2D[N];

        //StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(StdRandom.uniform(0, 1.0), StdRandom.uniform(0, 1.0));
            //StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
            //StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));///////////////////
            //StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }

        int[] index_res = ConvexHullVertex(points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());

        
        ////////////cc + convexhull/////////////
        MergeX.sort(points,Point2D.Y_ORDER);
        
        double thr = 0.25;
        UF cc = new UF(points.length);
        //StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < points.length-1; i++) {
            for (int j = 1; j < points.length - i; j++) {
                if (points[i].distanceTo(points[i + j]) <= thr) {
                    cc.union(i, i + j);
                   // StdDraw.line(points[i].x(), points[i].y(), points[i+j].x(), points[i+j].y());
                   // points[i].drawTo(points[i + j]);
                }else if (points[i + j].y() - points[i].y() >thr)
                    break;
            }
        }

        Point2D[][] ccpoints = new Point2D[cc.count()][];
        int[] ccsize = new int[cc.count()];
        for (int i = 0; i < points.length; i++) {
           
        }

        //List<List<Point2D>> ccpoints = new ArrayList<>(4);
        //ccpoints.isEmpty();
        //StdOut.println(ccpoints.isEmpty());
        ////////////cc + convexhull/////////////
    }

}

@eec1def4a8570774b94e64107e1980ea@"
"b03611023","0","0","0","@137451f7c576ec41cf85a88b8cc4bbef@import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
          
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          /*  StdDraw.setPenColor(StdDraw.RED);
            StdDraw.setPenRadius(.02);
             p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
            StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
          for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
           // System.out.print(a[i].y());           
           }*/
           int[] con = new int[size];
           for(int q = 0;q<size;q++){
               con[q] = 1;
           }
           Stack<Point2D> hull = new Stack<>();
           Stack<Integer> in = new Stack<>();
           int[] point = new int[size];
          int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
           
           hull.push(a[0]);
           in.push(point[0]);
           hull.push(a[1]);
           in.push(point[1]);
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();
           int ttop = in.pop();
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();
               ttop = in.pop();
           }
              hull.push(top);
              in.push(ttop);
              hull.push(a[i]);
              in.push(point[i]);
           }
          i = in.size();
          int[] ans = new int[size];
          for(int  j = i-1;j>=0;j--){
              ans[j] = in.pop();
          }
       /*   for(int j = 0;j<i;j++){
              System.out.print(ans[j]);
          }*/
      return ans;
    }
        public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}

@137451f7c576ec41cf85a88b8cc4bbef@"
"b03611023","0","0.54","106000","@9c92d027020d5f614851abd52134f97d@import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
          
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          // StdDraw.setPenColor(StdDraw.RED);
           // StdDraw.setPenRadius(.02);
           //  p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
          //  StdDraw.setPenRadius();
       // StdDraw.setPenColor(StdDraw.BLUE);
         /* for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
            //System.out.print(a[i].y());           
           }*/
           int[] con = new int[size];
           for(int q = 0;q<size;q++){
               con[q] = 1;
           }
           Stack<Point2D> hull = new Stack<>();
           Stack<Integer> in = new Stack<>();
           int[] point = new int[size];
          int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
           
           hull.push(a[0]);
           in.push(point[0]);
           hull.push(a[1]);
           in.push(point[1]);
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();
           int ttop = in.pop();
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();
               ttop = in.pop();
           }
              hull.push(top);
              in.push(ttop);
              hull.push(a[i]);
              in.push(point[i]);
           }
          i = in.size();
          int[] ans = new int[size];
          for(int  j = i-1;j>=0;j--){
              ans[j] = in.pop();
          }
       /*  for(int j = 0;j<i;j++){
              System.out.print(ans[j]);
          }*/
      return ans;
    }
        public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}

@9c92d027020d5f614851abd52134f97d@"
"b03611023","0","0.52","107904","@ebbb71c891cbcd9ceb6078810a4dd14c@import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
         
           int[] point = new int[size];
            int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
          Point2D[] copy = new Point2D[size];
          for(int j = 0;j<size;j++){
              copy[j] = new Point2D(a[j].x(), a[j].y());
          }
        
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
        
        
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          // StdDraw.setPenColor(StdDraw.RED);
           // StdDraw.setPenRadius(.02);
           //  p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
           
           for(int j = 0;j<size;j++){
               for(int l = 0;l<size;l++){
                   if(a[j].equals(copy[l])){
                       point[j] = l;
                       break;
                   }
               }
             //  System.out.print(a[j].y());
              // System.out.print(copy[j].y());
               //System.out.print(point[j]);
           }
          //  StdDraw.setPenRadius();
       // StdDraw.setPenColor(StdDraw.BLUE);
         /* for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
            //System.out.print(a[i].y());           
           }*/
       
           Stack<Point2D> hull = new Stack<>();
           Stack<Integer> in = new Stack<>();
           
         
           
           hull.push(a[0]);
           in.push(point[0]);
           hull.push(a[1]);
           in.push(point[1]);
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();
           int ttop = in.pop();
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();
               ttop = in.pop();
           }
              hull.push(top);
              in.push(ttop);
              hull.push(a[i]);
              in.push(point[i]);
           }
          i = in.size();
          int[] ans = new int[size];
          for(int  j = i-1;j>=0;j--){
              ans[j] = in.pop();
          }
     /*    for(int j = 0;j<i;j++){
              System.out.print(ans[j]);
          }*/
      return ans;
    }
        public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}

@ebbb71c891cbcd9ceb6078810a4dd14c@"
"b03611023","5","0.104","105296","@b44e0327234f9d3c5a123ac1aa151676@import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
         
           int[] point = new int[size];
           int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
          Point2D[] copy = new Point2D[size];
          for(int j = 0;j<size;j++){
              copy[j] = new Point2D(a[j].x(), a[j].y());
          }
        
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
        
        
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          // StdDraw.setPenColor(StdDraw.RED);
           // StdDraw.setPenRadius(.02);
           //  p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
           
           for(int j = 0;j<size;j++){
               for(int l = 0;l<size;l++){
                   if(a[j].equals(copy[l])){
                       point[j] = l;
                       break;
                   }
               }
             //  System.out.print(a[j].y());
              // System.out.print(copy[j].y());
               //System.out.print(point[j]);
           }
          //  StdDraw.setPenRadius();
       // StdDraw.setPenColor(StdDraw.BLUE);
         /* for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
            //System.out.print(a[i].y());           
           }*/
       
           Stack<Point2D> hull = new Stack<>();
           Stack<Integer> in = new Stack<>();
           
         
           
           hull.push(a[0]);
           in.push(point[0]);
           hull.push(a[1]);
           in.push(point[1]);
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();
           int ttop = in.pop();
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();
               ttop = in.pop();
           }
              hull.push(top);
              in.push(ttop);
              hull.push(a[i]);
              in.push(point[i]);
           }
          i = hull.size();
          int[] ans = new int[i];
          Point2D[] ww = new Point2D[i];
         for(int j =0;j<i;j++){
             ww[j] = hull.pop();
          }
         
         for(int j = 0;j<i;j++){
               for(int l = 0;l<size;l++){
                   if(ww[j].equals(copy[l])){
                       ans[j] = l;
                       break;
                   }
               }
             //  System.out.print(a[j].y());
              // System.out.print(copy[j].y());
              // System.out.print(ans[j]);
           }
       /*   for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
        Arrays.sort(ans);
        /*  for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
      
      
     
      return ans;
    }
        public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}

@b44e0327234f9d3c5a123ac1aa151676@"
"b03611023","5","0.106","105984","@9499a8f6414888e78bf4831e7735e374@import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
         
           int[] point = new int[size];
           int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
          Point2D[] copy = new Point2D[size];
          for(int j = 0;j<size;j++){
              copy[j] = new Point2D(a[j].x(), a[j].y());
          }
        
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
        
        
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          // StdDraw.setPenColor(StdDraw.RED);
           // StdDraw.setPenRadius(.02);
           //  p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
           
         
          //  StdDraw.setPenRadius();
       // StdDraw.setPenColor(StdDraw.BLUE);
         /* for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
            //System.out.print(a[i].y());           
           }*/
       
           Stack<Point2D> hull = new Stack<>();
           
           
         
           
           hull.push(a[0]);         
           hull.push(a[1]);
          
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();         
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();               
           }
              hull.push(top);          
              hull.push(a[i]);             
           }
          i = hull.size();
          int[] ans = new int[i];
          Point2D[] ww = new Point2D[i];
         for(int j =0;j<i;j++){
             ww[j] = hull.pop();
          }         
         for(int j = 0;j<i;j++){
               for(int l = 0;l<size;l++){
                   if(ww[j].equals(copy[l])){
                       ans[j] = l;
                       break;
                   }
               }
             //  System.out.print(a[j].y());
              // System.out.print(copy[j].y());
              // System.out.print(ans[j]);
           }
       /*   for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
        Arrays.sort(ans);
        /*  for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
      
      
     
      return ans;
    }
        public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}

@9499a8f6414888e78bf4831e7735e374@"
"r04546032","0","0.106","105984","@9adc95fe6b2a8df38b136fbec3a0c464@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
    protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = a[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER());

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }

        assert isConvex();
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(""data.txt""))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@9adc95fe6b2a8df38b136fbec3a0c464@"
"r04546032","2","0.52","107888","@582a97d699f5ef6d71e555294fc388b0@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
    protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = a[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = i;
                }
            }
        }
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(""data.txt""))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@582a97d699f5ef6d71e555294fc388b0@"
"r04546032","2","0.52","107952","@33800b460dd0d8a332771cd1f844ceba@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
    protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = a[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = i;
                }
            }
        }
        if(isConvex())
        {return indices;}
        else
            return null;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(""data.txt""))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@33800b460dd0d8a332771cd1f844ceba@"
"r04546032","5","0.104","104880","@b19e2c5209c84c6ae37e052e860a90ff@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(""data.txt""))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
          //  Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                      //  Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@b19e2c5209c84c6ae37e052e860a90ff@"
"r03945012","0",NULL,NULL,"@21299f2e406f4905d1a73071b1ac9c34@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static Stack<Integer> ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        GrahamScan graham = new GrahamScan(a);
        Stack<Integer> s = new Stack<Integer>();
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    s.push(i);
                    a[i].draw();
                }
            }
        }
        return s;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        StdOut.println(ConvexHullVertex(points));
    }
    
}

@21299f2e406f4905d1a73071b1ac9c34@"
"r03945012","0","0","0","@1ec6e46e295a8bc80b829562d829e64b@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        GrahamScan graham = new GrahamScan(a);
        Stack<Integer> s = new Stack<Integer>();
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    s.push(i);
                    a[i].draw();
                }
            }
        }
        int[] x;
        StdOut.println(s.size());
        x = new int[s.size()+1];
        for (int i=0; i< s.size(); i++){
            x[s.size()-i] = s.pop();
        }
        return x;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        StdOut.println(ConvexHullVertex(points));
    }
    
}

@1ec6e46e295a8bc80b829562d829e64b@"
"r03945012","0","0","0","@cb92cc3348660faa580b98fb105c61e0@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int[] x = new int[a.length];
        int count = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    a[i].draw();
                    count +=1;
                }
            }
        }
        return x;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        StdOut.println(ConvexHullVertex(points));
    }
    
}

@cb92cc3348660faa580b98fb105c61e0@"
"r03945012","0","0","0","@0ea9fbfe86207903dae90d93bbb629ff@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int[] x = new int[a.length];
        int count = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    a[i].draw();
                    count +=1;
                }
            }
        }
        return x;
    }


    
    
    public static void main(String[] args) {

    }
    
}

@0ea9fbfe86207903dae90d93bbb629ff@"
"r03945012","0","0","0","@0ea9fbfe86207903dae90d93bbb629ff@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int[] x = new int[a.length];
        int count = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    a[i].draw();
                    count +=1;
                }
            }
        }
        return x;
    }


    
    
    public static void main(String[] args) {

    }
    
}

@0ea9fbfe86207903dae90d93bbb629ff@"
"r03945012","0","0.53","104944","@4ec5356d10b02799691c8d96b444de7d@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int[] x = new int[a.length];
        int count = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    count +=1;
                }
            }
        }
        return x;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            // points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        int[] x = ConvexHullVertex(points);
        for(int i = 0; i<x.length; i++)
            StdOut.println(x[i]);
    }
    
}

@4ec5356d10b02799691c8d96b444de7d@"
"r03945012","0","0","0","@9e0c0d01c930fad55a8b2405e6cd95ed@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int count = 0;
        int size = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    p.draw();
                    size +=1;
                }
            }
        }
        int[] x = new int[size];
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    count +=1;
                }
            }
        }    
        return x;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            // points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        int[] x = ConvexHullVertex(points);
        for(int i = 0; i<x.length; i++)
            StdOut.println(x[i]);
    }
    
}

@9e0c0d01c930fad55a8b2405e6cd95ed@"
"r03945012","5","0.102","106560","@8d816aa2aaea6143e12033f6a5e88562@

/**
 * 1042 PDSA
 * hw05-1_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int count = 0;
        int size = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    size +=1;
                }
            }
        }
        int[] x = new int[size];
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    count +=1;
                }
            }
        }    
        return x;
    }


    
    
    public static void main(String[] args) {
        int N = 50;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(.01);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            // points[i].draw();
        }
        MyConvexHull test = new MyConvexHull();
        int[] x = ConvexHullVertex(points);
        for(int i = 0; i<x.length; i++)
            StdOut.println(x[i]);
    }
    
}

@8d816aa2aaea6143e12033f6a5e88562@"
"r04546014","0","0","0","@43ff9707deba3348769c6e8b8708927b@
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) {
        Point2D[] pp = new Point2D[5];
        for (int i = 0; i < 5; i++) {
            double rnd1 = StdRandom.random();
            double rnd2 = StdRandom.random();
            pp[i] = new Point2D.Double(rnd1, rnd2);
        }
        ConvexHullVertex(pp);

    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].getY();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].getX() - a[minP].getX()) / (a[i].getY() - a[minP].getY());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }

        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.getX() - a.getX()) * (c.getY() - a.getY()) - (b.getY() - a.getY()) * (c.getX() - a.getX());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@43ff9707deba3348769c6e8b8708927b@"
"r04546014","0","0","0","@e1d40ce90ec4a610d503b3cb6c2192bb@
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) {
       
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].getY();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].getX() - a[minP].getX()) / (a[i].getY() - a[minP].getY());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.getX() - a.getX()) * (c.getY() - a.getY()) - (b.getY() - a.getY()) * (c.getX() - a.getX());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@e1d40ce90ec4a610d503b3cb6c2192bb@"
"r04546014","0","0.53","104944","@b76e0edab5ed348fe13c37f097b8af0d@import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) {
        
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].getY();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].getX() - a[minP].getX()) / (a[i].getY() - a[minP].getY());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.getX() - a.getX()) * (c.getY() - a.getY()) - (b.getY() - a.getY()) * (c.getX() - a.getX());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@b76e0edab5ed348fe13c37f097b8af0d@"
"r04546014","0","0.53","104944","@dbdee843e099dc616a14fc895eb1e5b4@import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

public class MyConvexHull {

    public static void main(String[] args) {        
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].y;
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].x - a[minP].x) / (a[i].y - a[minP].y);
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@dbdee843e099dc616a14fc895eb1e5b4@"
"r04546014","0","0.102","106560","@d29864e1a74afc6b769512ac9947dcbf@//
//import java.awt.geom.Point2D;
import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) {
        Point2D[] pp = new Point2D[100];
        for (int i = 0; i < 100; i++) {
            double rnd1 = StdRandom.random();
            double rnd2 = StdRandom.random();
            pp[i]=new Point2D(rnd1,rnd2);
        }
        ConvexHullVertex(pp);
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].y();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].x() - a[minP].x()) / (a[i].y() - a[minP].y());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@d29864e1a74afc6b769512ac9947dcbf@"
"r04546014","5","0.104","107792","@036cdeb7fb71e06f6fbaee86f75a244f@import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) {
       
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].y();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].x() - a[minP].x()) / (a[i].y() - a[minP].y());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@036cdeb7fb71e06f6fbaee86f75a244f@"
"r04921094","0","0","0","@1bba6be7e763903d7e23668c52cbe5a8@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length, before = 1;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		for(int i = 0; i < size; i++){
			// myPoints[0].point.drawTo(myPoints[i].point);
			StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		}

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		  // index[indexi] = size - 1;

		for(int i : index){
			System.out.print(i + "" "");
		}
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			System.out.print(""Stack: "");
			for(int j : cvStack){
					System.out.print(j + "" "");
				}
			System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		Point2D[] a = new Point2D[10];
		double l = 0, r = 1;
		for(int i = 0; i<10; i++){
			a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		}
		MyConvexHull ch = new MyConvexHull();
		ch.drawConvexHull(ch.ConvexHullVertex(a), a);
	}
}
@1bba6be7e763903d7e23668c52cbe5a8@"
"r04921094","0","0","0","@4bcf7a3491399ad041e646ba37fd2ff8@import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length, before = 1;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		for(int i = 0; i < size; i++){
			// myPoints[0].point.drawTo(myPoints[i].point);
			StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		}

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		  // index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	// public static void main(String[] args) {
	// 	Point2D[] a = new Point2D[10];
	// 	double l = 0, r = 1;
	// 	for(int i = 0; i<10; i++){
	// 		a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
	// 	}
	// 	MyConvexHull ch = new MyConvexHull();
	// 	ch.drawConvexHull(ch.ConvexHullVertex(a), a);
	// }
}
@4bcf7a3491399ad041e646ba37fd2ff8@"
"r04921094","0","0","0","@9a28972645ca9067dc989671ee0d17e1@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length, before = 1;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		for(int i = 0; i < size; i++){
			// myPoints[0].point.drawTo(myPoints[i].point);
			StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		}

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		  // index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	// public static void main(String[] args) {
	// 	Point2D[] a = new Point2D[10];
	// 	double l = 0, r = 1;
	// 	for(int i = 0; i<10; i++){
	// 		a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
	// 	}
	// 	MyConvexHull ch = new MyConvexHull();
	// 	ch.drawConvexHull(ch.ConvexHullVertex(a), a);
	// }
}
@9a28972645ca9067dc989671ee0d17e1@"
"r04921094","0","0","0","@fe5db1b0a8bddd9259bdd2f125456a51@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length, before = 1;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		for(int i = 0; i < size; i++){
			// myPoints[0].point.drawTo(myPoints[i].point);
			StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		}

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		// index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		Arrays.sort(index);
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public static void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		Point2D[] a = new Point2D[10];
		double l = 0, r = 1;
		for(int i = 0; i<10; i++){
			a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		}
		// MyConvexHull ch = new MyConvexHull();
		int[] array = MyConvexHull.ConvexHullVertex(a);
		MyConvexHull.drawConvexHull(array, a);
		for(int i = 0; i< array.length; i++){
			System.out.print(array[i] + "" "");
		}
	}
}
@fe5db1b0a8bddd9259bdd2f125456a51@"
"r04921094","0","0","0","@dec59a36c179bd210680f31745c9d899@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		// for(int i = 0; i < size; i++){
		// 	myPoints[i] = new MyPoint2D(a[i], i);
		// 	StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
		// 	// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		// }

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		// StdDraw.setPenColor(StdDraw.RED);
		// StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		// for(int i = 0; i < size; i++){
		// 	// myPoints[0].point.drawTo(myPoints[i].point);
		// 	StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		// }

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		// index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public static void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		Point2D[] a = new Point2D[10];
		double l = 0, r = 1;
		for(int i = 0; i<10; i++){
			a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		}
		// MyConvexHull ch = new MyConvexHull();
		int[] array = MyConvexHull.ConvexHullVertex(a);
		MyConvexHull.drawConvexHull(array, a);
		for(int i = 0; i< array.length; i++){
			System.out.print(array[i] + "" "");
		}
	}
}
@dec59a36c179bd210680f31745c9d899@"
"r04921094","5","0.104","107568","@0785368124d50247e4ad712c1cc4b066@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			// StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		// StdDraw.setPenColor(StdDraw.RED);
		// StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		// for(int i = 0; i < size; i++){
		// 	// myPoints[0].point.drawTo(myPoints[i].point);
		// 	StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		// }

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		// index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public static void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		Point2D[] a = new Point2D[10];
		double l = 0, r = 1;
		for(int i = 0; i<10; i++){
			a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		}
		// MyConvexHull ch = new MyConvexHull();
		int[] array = MyConvexHull.ConvexHullVertex(a);
		MyConvexHull.drawConvexHull(array, a);
		for(int i = 0; i< array.length; i++){
			System.out.print(array[i] + "" "");
		}
	}
}
@0785368124d50247e4ad712c1cc4b066@"
"r04921094","5","0.102","107904","@0785368124d50247e4ad712c1cc4b066@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;

// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
			// StdDraw.filledCircle(myPoints[i].point.x(), myPoints[i].point.y(), 0.01);
			// System.out.println("""" + i + "":"" + myPoints[i].point.x() + "","" + myPoints[i].point.y());
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		// StdDraw.setPenColor(StdDraw.RED);
		// StdDraw.filledCircle(low.point.x(), low.point.y(), 0.01);

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());
		// for(int i = 0; i < size; i++){
		// 	// myPoints[0].point.drawTo(myPoints[i].point);
		// 	StdDraw.text(myPoints[i].point.x(), myPoints[i].point.y() + 0.03, """" + i);
		// }

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
			// Comparator comparator = myPoints[before].polarOrder();
			// System.out.println(""Base on "" + before + "", compare"" + i + "","" + convexHullStack.peek());
			// if(myPoints[i].point.ccw(myPoints[i].point, myPoints[before].point, myPoints[convexHullStack.peek()].point) == -1){
			// // if(comparator.compare(myPoints[convexHullStack.peek()], myPoints[i]) == 1){
			// 	convexHullStack.push(before);
			// 	System.out.println(""Compare true, Push:"" + before);
			// 	before = i;
			// 	System.out.print(""Stack: "");
			// 	for(int j : convexHullStack){
			// 		System.out.print(j + "" "");
			// 	}
			// 	System.out.println();
			// 	System.out.println(""Before: "" + before);
			// }
			// else{
			// 	System.out.println(""Compare false, before = "" + i);
			// 	before = i;
			// }
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		// System.out.println(""cvStack size:"" + convexHullStack.size());
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		// index[indexi] = size - 1;

		// for(int i : index){
		// 	System.out.print(i + "" "");
		// }
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
			// System.out.print(""Stack: "");
			// for(int j : cvStack){
			// 		System.out.print(j + "" "");
			// 	}
			// System.out.println();
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public static void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		Point2D[] a = new Point2D[10];
		double l = 0, r = 1;
		for(int i = 0; i<10; i++){
			a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		}
		// MyConvexHull ch = new MyConvexHull();
		int[] array = MyConvexHull.ConvexHullVertex(a);
		MyConvexHull.drawConvexHull(array, a);
		for(int i = 0; i< array.length; i++){
			System.out.print(array[i] + "" "");
		}
	}
}
@0785368124d50247e4ad712c1cc4b066@"
"r04631034","0","0","0","@e8b0461ff33502626b11332ef6aad896@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {
//    public static int[] ConvexHullVertex(Point2D[] a) {
//
//        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//
//    }
//    

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
//                    int N=a.length
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    cotSort(a);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              System.out.print(storge.get(count) + "" "");
                              output[count] = storge.get(count);
                    }
                    return output;
          }

          public static void main(String[] args) {
                    // TODO code application logic here
//                    int N = 10;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
////                              StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                    }
//
////          System.out.println("""");
////          System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    cotSort(a);
//
//                    for (int count = N - 1; count > -1; count--) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
////                                        a[count].draw();
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < N) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
//                              output[count] = storge.get(count);
//                    }

//                    for (int count = 0; count + 2 < N; count++) {
//                              if (Point2D.ccw(storge[count], storge[count + 1], a[count + 2]) == 1) {
//
//                                        System.out.println(""check\t"" + count + ""\t"" + (count + 1) + '\t' + (count + 2));
//                                        storge[count+2]=count+2;
//                              }
//                              else if (Point2D.ccw(a[count], a[count + 1], a[count + 2]) == -1){
//                                        
//                                        
//                              }
//                        
//                    }
          }

}

@e8b0461ff33502626b11332ef6aad896@"
"r04631034","3","0.5","107264","@983a192efafd678ea1ac4775962a6966@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
    int[] storge_index = new int[a.length];
                    for (int i = 0; i < a.length; i++) {
                              storge_index[i] = i;
                    }
                    HashMap<Double,Integer> map =new  HashMap<Double,Integer>();
                    for (int i =0;i<a.length;i++){
                              map.put(a[i].y(),i);
                    }

                    MergeX.sort(a, Point2D.Y_ORDER);    //sort


                    cotSort(a);



                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y()) ;
                    }
                    return output;
          }
          
          
          
          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N = 10;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
////                              StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                    }
//                    int[] storge_index = new int[a.length];
//                    for (int i = 0; i < a.length; i++) {
//                              storge_index[i] = i;
//                    }
//                    HashMap<Double,Integer> map =new  HashMap<Double,Integer>();
//                    for (int i =0;i<a.length;i++){
//                              map.put(a[i].y(),i);
//                    }
//                    
////          System.out.println("""");
////          System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
////                    for (int i = 1; i < a.length; i++) {
////                              if (a[i].compareTo(a[0]) == -1) {
////                                        double tempx = a[i].x();
////                                        double tempy = a[i].y();
////                                        a[i] = new Point2D(a[0].x(), a[0].y());
////                                        a[0] = new Point2D(tempx, tempy);
////                                        int temp_index=storge_index[i];
////                              }
////                              else continue;
////                    }
//
//                    cotSort(a);
//
////                    for (int count = 0; count < a.length; count++) {
//////                              System.out.print(a[count].x());
//////                              System.out.print(""  "");
//////                              System.out.println(a[count].y());
////                              if (count == 0) {
////                                        StdDraw.setPenColor(StdDraw.RED);
////                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//////                                        a[count].draw();
////                                        String str = String.valueOf(count);
////                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
////                              } else {
////                                        StdDraw.setPenColor(StdDraw.BLACK);
////                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
////                                        String str = String.valueOf(count);
////                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
////                                        StdDraw.setPenColor(StdDraw.YELLOW);
////                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
////                              }
////                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
////                                        StdDraw.setPenColor(StdDraw.GREEN);
////                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
////                                        StdDraw.setPenColor(StdDraw.RED);
////                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y()) ;
//                    }

          }

}

@983a192efafd678ea1ac4775962a6966@"
"r04631034","3","0.5","106528","@d36f73057506f39dbaaa1173225c8c4c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    int[] storge_index = new int[a.length];
                    for (int i = 0; i < a.length; i++) {
                              storge_index[i] = i;
                    }
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    cotSort(a);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
                    }
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N = 10;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
////                              StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                    }
//                    int[] storge_index = new int[a.length];
//                    for (int i = 0; i < a.length; i++) {
//                              storge_index[i] = i;
//                    }
//                    HashMap<Double,Integer> map =new  HashMap<Double,Integer>();
//                    for (int i =0;i<a.length;i++){
//                              map.put(a[i].y(),i);
//                    }
//                    
////          System.out.println("""");
////          System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
////                    for (int i = 1; i < a.length; i++) {
////                              if (a[i].compareTo(a[0]) == -1) {
////                                        double tempx = a[i].x();
////                                        double tempy = a[i].y();
////                                        a[i] = new Point2D(a[0].x(), a[0].y());
////                                        a[0] = new Point2D(tempx, tempy);
////                                        int temp_index=storge_index[i];
////                              }
////                              else continue;
////                    }
//
//                    cotSort(a);
//
////                    for (int count = 0; count < a.length; count++) {
//////                              System.out.print(a[count].x());
//////                              System.out.print(""  "");
//////                              System.out.println(a[count].y());
////                              if (count == 0) {
////                                        StdDraw.setPenColor(StdDraw.RED);
////                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//////                                        a[count].draw();
////                                        String str = String.valueOf(count);
////                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
////                              } else {
////                                        StdDraw.setPenColor(StdDraw.BLACK);
////                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
////                                        String str = String.valueOf(count);
////                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
////                                        StdDraw.setPenColor(StdDraw.YELLOW);
////                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
////                              }
////                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
////                                        StdDraw.setPenColor(StdDraw.GREEN);
////                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
////                                        StdDraw.setPenColor(StdDraw.RED);
////                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y()) ;
//                    }

          }

}

@d36f73057506f39dbaaa1173225c8c4c@"
"b99611017","0","0","0","@c5267449e40a6f11f23000237feefe89@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ans = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ans.enqueue(p);
        }
        int[] an=new int[ans.size()];
        for(int i=0;i<ans.size();i++)
        {
            an[i]=Integer.parseInt(ans.dequeue().toString());
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        
        try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];
            
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(0.015);
            
            for (int i = 0; i <= N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                //points[i].draw();
            }

// TODO code application logic here
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@c5267449e40a6f11f23000237feefe89@"
"b99611017","0","0.5","107264","@f0ecee24cedb90ca9974195ac78c0b82@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ans = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ans.enqueue(p);
        }
        int[] an=new int[ans.size()];
        for(int i=0;i<ans.size();i++)
        {
            an[i]=Integer.parseInt(ans.dequeue().toString());
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        
        try {
           /* InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];
            
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(0.015);
            
            for (int i = 0; i <= N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                //points[i].draw();*/
            }

// TODO code application logic here
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@f0ecee24cedb90ca9974195ac78c0b82@"
"b99611017","0","0","0","@5f467cde7d042d73851a1f01630eb14d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ans = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ans.enqueue(p);
        }
        int[] an=new int[ans.size()];
        for(int i=0;i<ans.size();i++)
        {
            an[i]=Integer.parseInt(ans.dequeue().toString());
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        
       /* try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];
            
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(0.015);
            
            for (int i = 0; i <= N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                //points[i].draw();
            }

// TODO code application logic here
        } catch (RuntimeException e) {
            
            throw e;
        }*/
    }
}

@5f467cde7d042d73851a1f01630eb14d@"
"b99611017","5","0.104","108160","@6f687b7e4dc9ce89bb0eadbcd2440815@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ansl = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ansl.enqueue(p);
        }
        int[] an=new int[ansl.size()];
        int count = 0;
        for(int i=0;i<a.length;i++)
        {
            for (Point2D p: preans.hull()){
                if (p == a[i]){
                    an[count] = i;
                    count ++;
                }
            }
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        
       try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];
            System.out.println(token.length);
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(0.015);
//            for(int i=0;i<token.length;i++)
//            {
//                System.out.println(token[i]);
//            }
            for (int i = 0; i < N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                
            }
            int[] ans=ConvexHullVertex(points);
            System.out.println(ans);
//            for(int i=0;i<ans.length;i++)
//            {
//                System.out.print(ans[i]);
//            }
// TODO code application logic here
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@6f687b7e4dc9ce89bb0eadbcd2440815@"
"r04921051","0","0.5","107856","@e4ec9be886df96b494c8c6ccdedddbff@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
            Arrays.sort(a, Point2D.Y_ORDER );
            Arrays.sort(a, a[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            int n = a.length;
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(a[p[0]], a[p[1]], a[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
          
    return result;
    }
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int n = Integer.parseInt(data);
            Point2D[] points = new Point2D[n];
            
            for(int i=0;i < n ; i++){
                String cor[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));
            }
            int[] result = ConvexHullVertex(points);
            
            
           /*
            
            
            StdDraw.setCanvasSize(800, 800);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
            

            
            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i=1;i < n ; i++){
                points[i].draw();
            }
            StdDraw.setPenColor(StdDraw.RED);
            for(int i = 0; i < result.length; i++){
                points[result[i]].draw();
            }   
            */

/*
            for(int i = 0; i < n;i++){
                System.out.printf(""(%f,%f)\n"",points[i].x(),points[i].y());
            }
*/            
       
        }
    }
    public  static  void printQue(Stack<Integer> q  ){
            Iterator<Integer> iterator = q.iterator();        
            while(iterator.hasNext())
              System.out.printf(""%d,"",iterator.next()); 
             System.out.printf(""\n"" ); 
    }
    
}

@e4ec9be886df96b494c8c6ccdedddbff@"
"r04921051","5","0.104","107904","@ea4d58e88def5c94bba4305cb3a0ae4a@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
    }
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int n = Integer.parseInt(data);
            Point2D[] points = new Point2D[n];
      
            for(int i=0;i < n ; i++){
                String cor[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));
                //points[i] = new Point2D(StdRandom.uniform(100),StdRandom.uniform(100));
            }
            
            int[] result = ConvexHullVertex(points);
            
/*             
            StdDraw.setCanvasSize(800, 800);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
            

            
            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i=0;i < n ; i++){
                points[i].draw();
            }
            
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.setPenRadius(.003);
            for(int i = 1; i < result.length; i++){
                points[result[i]].drawTo(points[result[i-1]]);
            }   
            points[result[result.length-1]].drawTo(points[result[0]]);


            for(int i = 0; i < n;i++){
                System.out.printf(""(%f,%f)\n"",points[i].x(),points[i].y());
            }
*/           
       
        }
    }
    public  static  void printQue(Stack<Integer> q  ){
            Iterator<Integer> iterator = q.iterator();        
            while(iterator.hasNext())
              System.out.printf(""%d,"",iterator.next()); 
             System.out.printf(""\n"" ); 
    }
    
}

@ea4d58e88def5c94bba4305cb3a0ae4a@"
"b02611023","0","0.54","118896","@be15a9de8e78060dc3c1fc3e5ddfb13e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] A) {
        Point2D[] origin = A.clone();
        Arrays.sort(A, Point2D.Y_ORDER);
        Point2D p = new Point2D(A[0].x(), A[0].y());

        Arrays.sort(A, p.POLAR_ORDER);

        Point2D a = new Point2D(0.0, 0.0);
        Point2D b = a;
        Point2D c = a;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        for (int i = 2; i < A.length; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (A[j] != null) {
                        a = new Point2D(A[j].x(), A[j].y());
                        if (A[k] != null) {
                            if (count <= 0) {
                                b = new Point2D(A[k].x(), A[k].y());
                                count++;
                                k0 = k;
                            } else {
                                c = new Point2D(A[k].x(), A[k].y());
                                count++;
                            }
                        }
                    }
                    if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
                        if (j == 0) {
                            A[k] = null;
                            n_count++;
                        } else {
                            A[k0] = null;
                            A[k] = null;
                            n_count = n_count + 2;
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[A.length - n_count];
        int l = 0;
        for (int m = 0; m < A.length; m++) {
            for (int n = 0; n < A.length; n++) {
                if (A[m] != null) {
                    if (A[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
}

@be15a9de8e78060dc3c1fc3e5ddfb13e@"
"b02611023","0","0","0","@1327e5d89f2b749dd4ae28ddc3a273a7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
//
    public static int[] ConvexHullVertex(Point2D[] A) {
        Point2D[] origin = A.clone();
        Arrays.sort(A, Point2D.Y_ORDER);
        Point2D p = new Point2D(A[0].x(), A[0].y());

        Arrays.sort(A, p.POLAR_ORDER);

        Point2D a = new Point2D(0.0, 0.0);
        Point2D b = a;
        Point2D c = a;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[A.length+1];
        for (int i = 0; i < A.length; i++) {
            point[i] = A[i];
        }
        point[A.length] = A[0];
        for (int i = 2; i < A.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (A[j] != null) {
                        a = new Point2D(A[j].x(), A[j].y());
                        if (A[k] != null) {
                            if (count <= 0) {
                                b = new Point2D(A[k].x(), A[k].y());
                                count++;
                                k0 = k;
                            } else {
                                c = new Point2D(A[k].x(), A[k].y());
                                count++;
                            }
                        }
                    }
                    if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
                        if (j == 0) {
                            A[k] = null;
                            n_count++;
                        } else {
                            A[k0] = null;
                            n_count = n_count + 2;
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[A.length - n_count];
        int l = 0;
        for (int m = 0; m < A.length; m++) {
            for (int n = 0; n < A.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
}

@1327e5d89f2b749dd4ae28ddc3a273a7@"
"b02611023","0","0.09","99952","@51aa718ffb22109ea06146719d71cdb9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
//
    public static int[] ConvexHullVertex(Point2D[] A) {
        Point2D[] origin = A.clone();
        Arrays.sort(A, Point2D.Y_ORDER);
        Point2D p = new Point2D(A[0].x(), A[0].y());

        Arrays.sort(A, p.POLAR_ORDER);

        Point2D a = new Point2D(0.0, 0.0);
        Point2D b = a;
        Point2D c = a;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[A.length+1];
        for (int i = 0; i < A.length; i++) {
            point[i] = A[i];
        }
        point[A.length] = A[0];
        for (int i = 2; i < A.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        a = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                b = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                c = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                    }
                    if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
                        if (j == 0) {
                            point[k] = null;
                            n_count++;
                        } else {
                            point[k0] = null;
                            n_count = n_count + 2;
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[A.length - n_count];
        int l = 0;
        for (int m = 0; m < A.length; m++) {
            for (int n = 0; n < A.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }

//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N+1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N+1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        index[l] = n;
//                        l++;
//                        break;
//                    }
//                }
//                if (l == (index.length - 1)) {
//                    break;
//                }
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@51aa718ffb22109ea06146719d71cdb9@"
"b02611023","0","0.51","119200","@81cd108ed8750a4a981d713cbd814583@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
//
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length+1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        point[a.length] = a[0];
        for (int i = 2; i < a.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                    }
                    if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                        if (j == 0) {
                            point[k] = null;
                            n_count ++;
                        } else {
                            point[k0] = null;
                            n_count ++;
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }

//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N+1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N+1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        index[l] = n;
//                        l++;
//                        break;
//                    }
//                }
//                if (l == (index.length - 1)) {
//                    break;
//                }
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@81cd108ed8750a4a981d713cbd814583@"
"b01b01039","0","0.31","103168","@bc09534ae58c0666fc8dbc44da6f79ab@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
	public static int[] ConvexHullVertex(Point2D[] a) {
		int first  = 0;
		int second = 1;
		int third  = 2;
		Stack<Point2D> p = new Stack<Point2D>();
		Stack<Integer> idx = new Stack<Integer>();
		idx.push(first);
		idx.push(second);
		p.push(a[first]);
		p.push(a[second]);
		while(third < a.length){
			if(Point2D.ccw(a[first], a[second], a[third]) == 1){
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				first = second;
				second = third;
				//System.out.printf(""push x : %.3f  y : %.3f\n"",a[third].x(),a[third].y());
				idx.push(third);
				p.push(a[third++]);
			}else{
				idx.pop();
				Point2D e = p.pop();
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				first--;
				second--;
			}
		}
		//ConvexHullDrawing(p);
		return(index_reverse(idx));
	}
	
	private static void ConvexHullDrawing(Stack<Point2D> p){
		Point2D source = p.peek();
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(Point2D sink : p){
			source.drawTo(sink);
			System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}

	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] index_reverse(Stack<Integer> idx){
		int n = idx.size();
		int[] idx_r = new int[n];
		while(!idx.isEmpty()){
			idx_r[--n] = idx.pop();
		}
		return(idx_r);
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            Double dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(300, 300);
			StdDraw.setXscale(0, 1);
			StdDraw.setYscale(0, 1);
			StdDraw.setPenRadius(.005);
			
			
			for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				//System.out.printf(""x : %.3f y : %.3f\n"", x, y);
				points[row] = new Point2D(x, y);
				points[row].draw();
			}
			
			Point2D ori = new Point2D(0,0);
			Arrays.sort(points, ori.Y_ORDER);
			ori = points[0];
			Arrays.sort(points, ori.POLAR_ORDER);
			StdDraw.setPenColor(StdDraw.RED);
			
			StdDraw.setPenRadius();
			StdDraw.setPenColor(StdDraw.GRAY);
			for (int i = 0; i < num; i++) {
				ori.drawTo(points[i]);
				StdDraw.show(200);
			}
			
			StdDraw.setPenColor(StdDraw.RED);
			StdDraw.setPenRadius(.01);
			ori.draw();
			
			
			ConvexHullVertex(points);
		}
    }
}
@bc09534ae58c0666fc8dbc44da6f79ab@"
"b02611023","0","0","0","@9e169a30141d0bda602e108a6cb28971@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());
        StdDraw.setPenColor(StdDraw.RED);
        p.draw();

        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length+1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        point[a.length] = a[0];
        for (int i = 2; i < a.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                n_count++;
                            } else {
                                point[k0] = null;
                                n_count = n_count + 1;
                            }
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
        


//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N+1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N+1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        index[l] = n;
//                        l++;
//                        break;
//                    }
//                }
//                if (l == (index.length - 1)) {
//                    break;
//                }
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@9e169a30141d0bda602e108a6cb28971@"
"b02611023","0","0.52","118592","@4963303b730cb9d4f6767afbca397996@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());
        
        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length+1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        point[a.length] = a[0];
        for (int i = 2; i < a.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                n_count++;
                            } else {
                                point[k0] = null;
                                n_count = n_count + 1;
                            }
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
        


//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N+1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N+1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        index[l] = n;
//                        l++;
//                        break;
//                    }
//                }
//                if (l == (index.length - 1)) {
//                    break;
//                }
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@4963303b730cb9d4f6767afbca397996@"
"b02611023","0","0.51","113728","@13c0a04d48dcb4d7c6188859e6c4692d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());
        
        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length+1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        point[a.length] = a[0];
        for (int i = 2; i < a.length+1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                n_count++;
                            } else {
                                point[k0] = null;
                                n_count = n_count + 1;
                            }
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
                if (l == (index.length - 1)) {
                    break;
                }
            }
        }
        //Arrays.sort(index);
        return index;
    }
        


//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N+1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N+1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        index[l] = n;
//                        l++;
//                        break;
//                    }
//                }
//                if (l == (index.length - 1)) {
//                    break;
//                }
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@13c0a04d48dcb4d7c6188859e6c4692d@"
"b02611023","3","0.53","118096","@663657324eb28d7dd3f0e4c207d87032@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        point[a.length] = a[0];
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                n_count++;
                            } else {
                                point[k0] = null;
                                n_count = n_count + 1;
                            }
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }
//    public static void main(String[] args) {
//        int N = 20;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N + 1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        point[N] = points[0];
//        for (int i = 2; i < N + 1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//        System.out.println();
//        int[] index = new int[N - n_count];
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        System.out.println(point[m]);
//                        index[l] = n;
//                        System.out.println(n);
//                        l++;
//                        break;
//                    }
//                }
//            }
//            if (l > (index.length - 1)) {
//                break;
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@663657324eb28d7dd3f0e4c207d87032@"
"b02611023","3","0.52","115472","@272fe22bc3326b1763a91f320b9facf0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        if(a.length == 0){
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                n_count++;
                            } else {
                                point[k0] = null;
                                n_count = n_count + 1;
                            }
                        }
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }
//    public static void main(String[] args) {
//        int N = 2;
//        Point2D[] points = new Point2D[N];
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.01);
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            System.out.println(points[i]);
//        }
//        Point2D[] origin = points.clone();
//        Arrays.sort(points, Point2D.Y_ORDER);
//        Point2D p = new Point2D(points[0].x(), points[0].y());
//        StdDraw.setPenColor(StdDraw.RED);
//        p.draw();
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.POLAR_ORDER);
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(100);
//        }
//
//        Point2D a = new Point2D(0.0, 0.0);
//        Point2D b = a;
//        Point2D c = a;
//        int count = 0;
//        int n_count = 0;
//        int k0 = 0;
//        Point2D[] point = new Point2D[N + 1];
//        for (int i = 0; i < N; i++) {
//            point[i] = points[i];
//        }
//        if(N>2){
//            point[N] = points[0];
//        }
//        for (int i = 2; i < N + 1; i++) {
//            for (int j = 0; j <= i - 2; j++) {
//                for (int k = j + 1; k <= i; k++) {
//                    if (point[j] != null) {
//                        a = new Point2D(point[j].x(), point[j].y());
//                        if (point[k] != null) {
//                            if (count <= 0) {
//                                b = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                                k0 = k;
//                            } else {
//                                c = new Point2D(point[k].x(), point[k].y());
//                                count++;
//                            }
//                        }
//                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
//                            if (j == 0) {
//                                point[k] = null;
//                                n_count++;
//                            } else {
//                                point[k0] = null;
//                                n_count = n_count + 1;
//                            }
//                        }
//                    }
//                }
//                count = 0;
//            }
//
//        }
//        System.out.println();
//        int[] index = new int[N - n_count];
//        
//        int l = 0;
//        for (int m = 0; m < N; m++) {
//            for (int n = 0; n < N; n++) {
//                if (point[m] != null) {
//                    if (point[m] == origin[n]) {
//                        System.out.println(point[m]);
//                        index[l] = n;
//                        System.out.println(n);
//                        l++;
//                        break;
//                    }
//                }
//            }
//            if (l > (index.length - 1)) {
//                break;
//            }
//        }
//        Arrays.sort(index);
//
//        System.out.println();
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        for (int i = 0; i < N; i++) {
//            if (point[i] != null) {
//                point[i].draw();
//                StdDraw.show(100);
//            }
//            System.out.println(point[i]);
//        }
//        System.out.println();
//        for (int i = 0; i < N - n_count; i++) {
//            System.out.println(index[i]);
//        }
//    }
}

@272fe22bc3326b1763a91f320b9facf0@"
"b01b01039","0","0.42","106192","@91514401836a1fec71fd4ce3fd96c6c1@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
	public static int[] ConvexHullVertex(Point2D[] a) {
		int first  = 0;
		int second = 1;
		int third  = 2;
		//Stack<Point2D> p = new Stack<Point2D>();
		Stack<Integer> idx = new Stack<Integer>();
		while(third < a.length){
			if(Point2D.ccw(a[first], a[second], a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",a[third].x(),a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		//ConvexHullDrawing(index2pos(a, idx));
		return(index_reverse(idx));
	}
	
	private static void ConvexHullDrawing(Point2D[] p){
		Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}

	private static Point2D[] index2pos(Point2D[] a, Stack<Integer> idx){
		Point2D[] c_h = new Point2D[idx.size()];
		int n = idx.size();
		for(int i = 0; i < n; i++){
			c_h[i] = a[idx.pop()];
		}
		return(c_h);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] index_reverse(Stack<Integer> idx){
		int n = idx.size();
		int[] idx_r = new int[n];
		while(!idx.isEmpty()){
			idx_r[--n] = idx.pop();
		}
		return(idx_r);
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            Double dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(700, 700);
			StdDraw.setXscale(0, 100);
			StdDraw.setYscale(0, 100);
			StdDraw.setPenRadius(.005);
			
			
			/*for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				//System.out.printf(""x : %.3f y : %.3f\n"", x, y);
				points[row] = new Point2D(x, y);
				points[row].draw();
			}*/
			
			for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(100);
				int y = StdRandom.uniform(100);
				points[i] = new Point2D(x, y);
				points[i].draw();
			}
			
			
			Point2D ori = new Point2D(0,0);
			Arrays.sort(points, ori.Y_ORDER);
			ori = points[0];
			Arrays.sort(points, ori.POLAR_ORDER);
			StdDraw.setPenColor(StdDraw.RED);
			
			StdDraw.setPenRadius();
			StdDraw.setPenColor(StdDraw.GRAY);
			for (int i = 0; i < num; i++) {
				ori.drawTo(points[i]);
				//StdDraw.show(200);
			}
			
			StdDraw.setPenColor(StdDraw.RED);
			StdDraw.setPenRadius(.01);
			ori.draw();
						
			for(Integer i : ConvexHullVertex(points)){
				System.out.println(i);
			}
		}
    }
}
@91514401836a1fec71fd4ce3fd96c6c1@"
"r04631034","0","0.52","115472","@8f4238d0853927e2c2a104ee8edf0556@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

//          public static int[] ConvexHullVertex(Point2D[] a) {
//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    cotSort(a);
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
//                                        storge.add(count_point);
//                                        count_storge++;
//                                        count_point++;
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
//                              }
//
//                    }
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    return output;
//          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 50;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
                              System.out.println(a[count]);
                    }

                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].x(), i);
                    }

                    System.out.println("""");
                    System.out.println("""");
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    cotSort(a);

                    for (int count = 0; count < a.length; count++) {
                              System.out.print(a[count].x());
                              System.out.print(""  "");
                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    System.out.println("""");
                    System.out.println("""");
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              System.out.print(map.get(a[storge.get(count)].x()) + "" "");
                              output[count] = map.get(a[storge.get(count)].x());
                    }
                    System.out.println("""");
                    for (int count = 0; count < storge.size(); count++) {
                              System.out.print(storge.get(count) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
                    }
                    System.out.println("""");
          }

}



@8f4238d0853927e2c2a104ee8edf0556@"
"r04631034","0","0.52","115472","@4b5b7c440b827f09de34d1ff5bee5f32@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

//          public static int[] ConvexHullVertex(Point2D[] a) {
//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    cotSort(a);
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
//                                        storge.add(count_point);
//                                        count_storge++;
//                                        count_point++;
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
//                              }
//
//                    }
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    return output;
//          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 50;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
                              System.out.println(a[count]);
                    }

                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].x(), i);
                    }

                    System.out.println("""");
                    System.out.println("""");
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    cotSort(a);

                    for (int count = 0; count < a.length; count++) {
                              System.out.print(a[count].x());
                              System.out.print(""  "");
                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    System.out.println("""");
                    System.out.println("""");
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              System.out.print(map.get(a[storge.get(count)].x()) + "" "");
                              output[count] = map.get(a[storge.get(count)].x());
                    }
                    System.out.println("""");
                    for (int count = 0; count < storge.size(); count++) {
                              System.out.print(storge.get(count) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
                    }
                    System.out.println("""");
          }

}




@4b5b7c440b827f09de34d1ff5bee5f32@"
"b02611016","0","0","0","@01ae5e349d831e50145ba13488eaf777@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       
 
       Insertion.sort(a);
       //compareTo(a[0],a[1]);
      Arrays.sort(a,a[0].POLAR_ORDER );
           for(int i=0;i<10;i++){ 
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
               StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i) );}
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);}
              StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i) );
       System.out.println(a[i]);}
           //a[1].POLAR_ORDER;
           int[] b=new int[a.length-1];
           int q=0;
           b[q]=0;
           q=q+1;
           b[q]=1;
            for(int i=1;i<9;i++)  {
               int c=i+1;
              for(int j=c+1;j<10;j++){
              if(a[i].POLAR_ORDER.compare(a[c],a[j])==1)
              {c=j;}
              }
              q=q+1;
              b[q]=c;
            // System.out.println(c);
               i=c-1;
              Point2D temp=new Point2D(0,0);
              
 
        }
           
           
            //System.out.print(b);
        return b;
    }

    
    
    public static void main(String[] args) {
    /*    Point2D[] a=new Point2D[10];
             for(int i=0;i<10;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
     int[]b=ConvexHullVertex(a);
     System.out.print(b);*/
             
}
   
   
    
}

@01ae5e349d831e50145ba13488eaf777@"
"b02611016","0","0.33","103600","@6d97ce7e085dc9100686beec620c766e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       
 
       Insertion.sort(a);
       //compareTo(a[0],a[1]);
      Arrays.sort(a,a[0].POLAR_ORDER );
         /*  for(int i=0;i<10;i++){ 
               if(i==0){//StdDraw.setPenColor(StdDraw.RED);
            // StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
               //StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i) );
               }
         else{
            // StdDraw.setPenColor(StdDraw.BLACK);
             //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);}
             // StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i) );
      // System.out.println(a[i]);
               }*/
           //a[1].POLAR_ORDER;
           int[] b=new int[a.length-1];
           int q=0;
           b[q]=0;
           q=q+1;
           b[q]=1;
            for(int i=1;i<9;i++)  {
               int c=i+1;
              for(int j=c+1;j<10;j++){
              if(a[i].POLAR_ORDER.compare(a[c],a[j])==1)
              {c=j;}
              }
              q=q+1;
              b[q]=c;
            // System.out.println(c);
               i=c-1;
              Point2D temp=new Point2D(0,0);
              
 
        }
           
           
            //System.out.print(b);
        return b;
    }

    
    
    public static void main(String[] args) {
        Point2D[] a=new Point2D[10];
             for(int i=0;i<10;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
     int[]b=ConvexHullVertex(a);
     System.out.print(b);
             
}
   
   
    
}

@6d97ce7e085dc9100686beec620c766e@"
"r03723070","0","0.48","107744","@c94f33355c56c15dc3b8572591035483@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Random;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
@c94f33355c56c15dc3b8572591035483@"
"r03723070","0","0","0","@fd61a9cf28a51294eecae0198850f34a@public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
@fd61a9cf28a51294eecae0198850f34a@"
"r03723070","0","0.33","103600","@f6891174fccee27cda7ac091c1a7d8fb@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Random;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@f6891174fccee27cda7ac091c1a7d8fb@"
"r03723070","0","0.48","107744","@66f425ff85af61a0771142ecf2d83a26@public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@66f425ff85af61a0771142ecf2d83a26@"
"r03723070","0","0.48","107744","@2e18706bbf51cbdd1c27d9019575b777@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@2e18706bbf51cbdd1c27d9019575b777@"
"r03723070","0","0","0","@3fc24f79f227632a3b563cdb21e1e3e8@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
@3fc24f79f227632a3b563cdb21e1e3e8@"
"r03723070","0","0.33","103600","@b2b5ec4cf1f03f5952786b4cbf980dcc@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
}
@b2b5ec4cf1f03f5952786b4cbf980dcc@"
"r03723070","0","0.33","103600","@bbe5c243c8e2af5eaed24461d2d400e6@import java.util.Random;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static String ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        return anstreurn;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@bbe5c243c8e2af5eaed24461d2d400e6@"
"r03723070","0","0.48","107744","@43e583a0e0179a0e1ce436a71817000a@import java.util.Random;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        for(int i = 0; i < AnsofNum.size();i++){
            String q = Integer.toString(AnsofNum.elementAt(i));
            anstreurn = anstreurn+q;
            //System.out.print(q);
        }
        System.out.print(anstreurn);
        int anstreurn1 = Integer.parseInt(anstreurn); 
        return anstreurn1;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@43e583a0e0179a0e1ce436a71817000a@"
"r03723070","0","0.52","107840","@64335fa0dc19bb4a68728997ee67ff86@import java.util.Random;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
    public static void main(String[] args) {
        StdDraw.setPenRadius(0.003);
        StdDraw.setPenColor(StdDraw.BLUE);
        // TODO code application logic here
        int N = 10;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        ConvexHullVertex(a);
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        //System.out.print(ConvexHullVertex(a));
    }
    
}

@64335fa0dc19bb4a68728997ee67ff86@"
"r03723070","0","0.49","102336","@397cfba01676c8e3eb31e72749ef893f@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
        
        /*
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
            System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@397cfba01676c8e3eb31e72749ef893f@"
"r03723070","0","0.49","106000","@70db3f1d4f15d44257ece64b95a4fad6@import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
                
        //draw line
        /*for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
            System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@70db3f1d4f15d44257ece64b95a4fad6@"
"b01b01039","0","0.51","107872","@1ce52057afe530a308c6414f53c0ba76@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {
	public static int[] ConvexHullVertex(Point2D[] a) {
		pre_sort(a);
		int first  = 0;
		int second = 1;
		int third  = 2;
		//Stack<Point2D> p = new Stack<Point2D>();
		Stack<Integer> idx = new Stack<Integer>();
		while(third < a.length){
			if(Point2D.ccw(a[first], a[second], a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",a[third].x(),a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else if(Point2D.ccw(a[first], a[second], a[third]) == 0){
				idx.push(first);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		//ConvexHullDrawing(index2pos(a, idx));
		return(index_reverse(idx));
	}
	
	private static void ConvexHullDrawing(Point2D[] p){
		Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}

	private static Point2D[] index2pos(Point2D[] a, Stack<Integer> idx){
		Point2D[] c_h = new Point2D[idx.size()];
		int n = idx.size();
		for(int i = 0; i < n; i++){
			c_h[i] = a[idx.pop()];
		}
		return(c_h);
	}
	
	private static Point2D[] pre_sort(Point2D[] a){
		int num = a.length;
		Point2D ori = new Point2D(0,0);
		Arrays.sort(a, ori.X_ORDER);
		Arrays.sort(a, ori.Y_ORDER);
		ori = a[0];
		Arrays.sort(a, ori.POLAR_ORDER);
		/*StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.GRAY);
		for (int i = 0; i < num; i++) {
				ori.drawTo(a[i]);
				//StdDraw.show(200);
			}
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius(.01);
		ori.draw();*/
		return(a);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] index_reverse(Stack<Integer> idx){
		int n = idx.size();
		int[] idx_r = new int[n];
		while(!idx.isEmpty()){
			idx_r[--n] = idx.pop();
		}
		return(idx_r);
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            Double dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(550, 550);
			StdDraw.setXscale(0, 100);
			StdDraw.setYscale(0, 34);
			StdDraw.setPenRadius(.005);
			
			
			/*for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				//System.out.printf(""x : %.3f y : %.3f\n"", x, y);
				points[row] = new Point2D(x, y);
				points[row].draw();
			}*/
			
			for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(75)+12;
				int y = StdRandom.uniform(2)+12;
				points[i] = new Point2D(x, y);
				//points[i].draw();
			}
			
			
			/*Point2D ori = new Point2D(0,0);
			Arrays.sort(points, ori.X_ORDER);
			Arrays.sort(points, ori.Y_ORDER);
			ori = points[0];
			Arrays.sort(points, ori.POLAR_ORDER);
			StdDraw.setPenColor(StdDraw.RED);
			
			StdDraw.setPenRadius();
			StdDraw.setPenColor(StdDraw.GRAY);
			for (int i = 0; i < num; i++) {
				ori.drawTo(points[i]);
				//StdDraw.show(200);
			}
			
			StdDraw.setPenColor(StdDraw.RED);
			StdDraw.setPenRadius(.01);
			ori.draw();*/
						
			for(Integer i : ConvexHullVertex(points)){
				System.out.println(i);
			}
		}
    }
}
@1ce52057afe530a308c6414f53c0ba76@"
"r03723070","0","0.52","107872","@86b3d57d6381dd8a1cb7d22eab718567@import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        Point2D[] copyans = new Point2D[ans.size()];
        String anstreurn = """";
                
        //draw line
        /*for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@86b3d57d6381dd8a1cb7d22eab718567@"
"r03723070","0","0.51","107648","@eccc2c986564aea48df17a4c5aaaea36@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = 1;
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@eccc2c986564aea48df17a4c5aaaea36@"
"r03723070","0","0.51","106960","@4df38dc90954927b047e64386c6229fa@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())<0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@4df38dc90954927b047e64386c6229fa@"
"r03723070","0","0.49","106816","@84d6c25678bb8b3971ac695877573c94@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@84d6c25678bb8b3971ac695877573c94@"
"r03723070","0","0.5","105968","@e7bcb8c89daf67fbb03cb9e6f4402775@import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            //String q = Integer.toString(AnsofNum.elementAt(i));
            //anstreurn = anstreurn+q;
            //System.out.print(q);
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@e7bcb8c89daf67fbb03cb9e6f4402775@"
"b01b01039","5","0.104","107936","@e93f2d607ab2a0b8024abc351c546880@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

	public static int[] ConvexHullVertex(Point2D[] a) {
		My_Point2D[] m_a = new My_Point2D[a.length];
		
		for(int idx = 0; idx < a.length; idx++){
			m_a[idx] = new My_Point2D(a[idx].x(), a[idx].y(), idx);
		}
		pre_sort(m_a);
		int first  = 0;
		int second = 1;
		int third  = 2;
		//Stack<Point2D> p = new Stack<Point2D>();
		Stack<Integer> idx = new Stack<Integer>();
		while(third < m_a.length){
			if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",m_a[third].x(),m_a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 0){
				idx.push(first);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		//ConvexHullDrawing(index2pos(m_a, idx));
		return(new2ori(m_a, idx));
	}
	
	private static int[] new2ori(My_Point2D[] a, Stack<Integer> idx){
		int[] ori = new int[idx.size()];
		int i = idx.size();
		for(Integer j : idx){
			ori[--i] = a[j].ori_idx();
		}
		Arrays.sort(ori);
		return(ori);
	}
	
	private static void ConvexHullDrawing(My_Point2D[] p){
		Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}

	private static My_Point2D[] index2pos(My_Point2D[] a, Stack<Integer> idx){
		My_Point2D[] c_h = new My_Point2D[idx.size()];
		int n = idx.size();
		int i = 0;
		for(Integer j : idx){
			c_h[i++] = a[j];
		}
		return(c_h);
	}
	
	private static My_Point2D[] pre_sort(My_Point2D[] a){
		int num = a.length;
		Point2D ori = new Point2D(0,0);
		Arrays.sort(a, ori.X_ORDER);
		Arrays.sort(a, ori.Y_ORDER);
		ori = a[0];
		Arrays.sort(a, ori.POLAR_ORDER);
		/*StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.GRAY);
		for (int i = 0; i < num; i++) {
				ori.drawTo(a[i]);
				//StdDraw.show(200);
			}
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius(.01);
		ori.draw();*/
		return(a);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] index_reverse(Stack<Integer> idx){
		int n = idx.size();
		int[] idx_r = new int[n];
		while(!idx.isEmpty()){
			idx_r[--n] = idx.pop();
		}
		return(idx_r);
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            Double dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			
			/*StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(550, 550);
			StdDraw.setXscale(0, 100);
			StdDraw.setYscale(0, 100);
			StdDraw.setPenRadius(.005);*/
			
			
			/*for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				//System.out.printf(""x : %.3f y : %.3f\n"", x, y);
				points[row] = new Point2D(x, y);
				points[row].draw();
			}*/
			
			for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(75)+12;
				int y = StdRandom.uniform(75)+12;
				points[i] = new Point2D(x, y);
				//points[i].draw();
			}
					
			for(Integer i : ConvexHullVertex(points)){
				System.out.println(i);
			}
		}
    }
}

class My_Point2D extends Point2D{
	private int ori_idx;
	
	public My_Point2D(double x, double y, int idx){
		super(x, y);
		ori_idx = idx;
	}
	
	public int ori_idx(){
		return(ori_idx);
	}
}
@e93f2d607ab2a0b8024abc351c546880@"
"b02611023","5","0.108","120352","@5a3e344bb2a54c3c50a8ea7944d6944d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        if(a.length == 0){
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    }
                    else{
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }
    /*public static void main(String[] args) {
        int N = 21;
        Point2D[] points = new Point2D[N];
        StdDraw.setCanvasSize(600, 600);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.02);
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            System.out.println(points[i]);
        }
        Point2D[] origin = points.clone();
        Arrays.sort(points, Point2D.Y_ORDER);
        Point2D p = new Point2D(points[0].x(), points[0].y());
        StdDraw.setPenColor(StdDraw.RED);
        p.draw();

        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, p.POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            p.drawTo(points[i]);
            StdDraw.show(100);
        }

        Point2D a = new Point2D(0.0, 0.0);
        Point2D b = a;
        Point2D c = a;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[N + 1];
        for (int i = 0; i < N; i++) {
            point[i] = points[i];
        }
        if(N>2){
            point[N] = points[0];
        }
        for (int i = 2; i < N + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        a = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                b = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                c = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(a, b, c) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    }
                    else{
                        break;
                    }
                }
                count = 0;
            }

        }
        System.out.println();
        int[] index = new int[N - n_count];
        
        int l = 0;
        for (int m = 0; m < N; m++) {
            for (int n = 0; n < N; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        System.out.println(point[m]);
                        index[l] = n;
                        System.out.println(n);
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);

        System.out.println();
        StdDraw.setPenColor(StdDraw.GREEN);
        Point2D pp = new Point2D(point[0].x(),point[0].y());
        for (int i = 0; i < N; i++) {
            if (point[i] != null) {
                StdDraw.setPenRadius(.02);
                StdDraw.setPenColor(StdDraw.ORANGE);
                point[i].draw();
                StdDraw.setPenRadius(.005);
                StdDraw.setPenColor(StdDraw.GREEN);
                pp.drawTo(point[i]);
                pp = new Point2D(point[i].x(),point[i].y());
                StdDraw.show(100);
            }
            System.out.println(point[i]);
        }
        StdDraw.setPenColor(StdDraw.GREEN);
        pp.drawTo(point[N]);
        StdDraw.show(100);
        System.out.println();
        for (int i = 0; i < N - n_count; i++) {
            System.out.println(index[i]);
        }
    }*/
}

@5a3e344bb2a54c3c50a8ea7944d6944d@"
"r03723070","0","0","0","@8834dda7bd77fb4afac2dad520a880a7@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@8834dda7bd77fb4afac2dad520a880a7@"
"r03723070","0","0","0","@8834dda7bd77fb4afac2dad520a880a7@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@8834dda7bd77fb4afac2dad520a880a7@"
"r03723070","0","0.51","107936","@fc1a40cfc3850f17070207dbf6b974a0@import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        
        Stack<Point2D> ans = new Stack<Point2D>();
        Stack<Integer> AnsofNum = new Stack<Integer>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(x.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
        }
        /*for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
     
    /*public static void main(String[] args) {
        int N = 30;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        int[]qq = ConvexHullVertex(a);
        for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }
         System.out.println(qq.length);
        //draw
        
         for (int i = 0; i < N; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        
        //System.out.print(qq[4]);
    }*/
    
}

@fc1a40cfc3850f17070207dbf6b974a0@"
"r03723070","0","0","0","@0521777f9752eeede232d5874539182a@import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        //Point2D[] copyans = new Point2D[ans.size()];               
       // for(int i = 0; i <ans.size();i++){
            //copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
       // }
        /*for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
     
    /*public static void main(String[] args) {
        int N = 30;             
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
        }
        int[]qq = ConvexHullVertex(a);
        for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }
         System.out.println(qq.length);
        //draw
        
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        
        //System.out.print(qq[4]);
    }*/
    
}

@0521777f9752eeede232d5874539182a@"
"r03723070","0","0","0","@594d1a1adffd6753ee99cbfc93e2df77@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        //Point2D[] copyans = new Point2D[ans.size()];               
       // for(int i = 0; i <ans.size();i++){
            //copyans[i] = ans.elementAt(i);
            
            //anstreurn.concat(AnsofNum.pop());
       // }
        /*for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }*/
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}

@594d1a1adffd6753ee99cbfc93e2df77@"
"r04945021","0","0","0","@444b9940b58f8b21d774ba6a101a6115@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
       int[] Convex = new int[a.length];//紀錄a的id，y由小到大
         
        
//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++){
            points[i] = a[i];
        }
           Arrays.sort(points); 
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A;
        int B;
        
        for (int ll=0;ll<a.length-2;ll++){
        for(A=ll+1;A<a.length;A++){
            if (!points[0].equals(points[A])) break;    
        }
        if (A==a.length) break;//全部item都一樣
        
        for(B=A+1;B<a.length;B++){
            if(Point2D.ccw(points[0], points[A], points[B])!=0) 
                break;    
        }
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) <= 0) {
                top = stack.pop();
            }
            stack.push(top);
            stack.push(points[i]);
        }
        }
       
      int Size=stack.size();
    if (stack.isEmpty())
    {
        for(int i=0;i<points.length;i++){
            for(int j=0;j<a.length;j++){
                if(points[i]==a[j])
                    Convex[i]=j;
            }
        }
    }
 else
    {

        for (int i=0;i<Size;i++){   
//            System.out.println(stack.pop());
            for(int j=0;j<a.length;j++){

                if(stack.peek()==a[j]){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }
    }
        
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
//StdDraw.setCanvasSize(200, 200);
//        StdDraw.setXscale(-10, 10);
//        StdDraw.setYscale(-10, 10);
//        StdDraw.setPenRadius(.005);
        
        
        int N=3;

Point2D[] a = new Point2D[N];
//for(int i=0;i<N;i++){
//    int x = StdRandom.uniform(N);
//    int y = StdRandom.uniform(N);
    a[0]=new Point2D(0,0);
    a[1]=new Point2D(1,5);
    a[2]=new Point2D(2,3);
    
//    a[0].draw();
//    a[1].draw();
//    a[2].draw();
//System.out.println(a[i]);
 
//}

int asd[]=ConvexHullVertex(a);
for (int i=0;i<asd.length;i++){
    System.out.println(asd[i]);
}
    }
}

@444b9940b58f8b21d774ba6a101a6115@"
"r04631041","0","0","0","@9b048db9d726b426878702f44cc7baab@import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.Selection;
import edu.princeton.cs.algs4.Stack;
public class MyConvexHull {
    
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        Selection.sort(sortdata,p.polarOrder());
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 
}

@9b048db9d726b426878702f44cc7baab@"
"r04631041","0","0","0","@4bdcc88f406284cbaf005a41efb82a8b@public class MyConvexHull {
    
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        Selection.sort(sortdata,p.polarOrder());
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 
}

@4bdcc88f406284cbaf005a41efb82a8b@"
"r04631041","0","0","0","@804f80056541e057c78e172be2b9dea7@public class MyConvexHull {
    
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        //Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        Selection.sort(sortdata,sortdata[0].polarOrder());
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 public static void main(String[] args) {
     ConvexHullVertex(10);
 }
}

@804f80056541e057c78e172be2b9dea7@"
"r03723070","0","0","0","@0200e01bc2b5c32b32aaff66f773b6ba@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar.length;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       //StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    //StdOut.println(i + "" "" + j);
                }
            } 
       }
       //find same root and combine to a array
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                /*System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);*/
            }
           }
            Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                result = result+ConvexHullVertex(c);
            }
            //System.out.println(b.length);
            //System.out.println(c.length);
            //b = (Point2D [])resizeArray(b, 5);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");*/
        //System.out.print(uf.find(1));
        System.out.print(result);
    }
    
}

@0200e01bc2b5c32b32aaff66f773b6ba@"
"r04631041","0","0","0","@6d708a211e6e8f764cbd8a9aa0e4da59@public class MyConvexHull {
    
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        //Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        //Selection.sort(sortdata,sortdata[0].polarOrder());
        Arrays.sort(sortdata,sortdata[0].polarOrder());
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 public static void main(String[] args) {
     ConvexHullVertex(10);
 }
}

@6d708a211e6e8f764cbd8a9aa0e4da59@"
"r03723070","0","0","0","@172ac37641df3647aed38ee56d1e9af0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       //StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       /*UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    //StdOut.println(i + "" "" + j);
                }
            } 
       }
       */
       //find same root and combine to a array
       /*
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);
            }
           }
            */
            /*Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                //result = result+ConvexHullVertex(c);
            }
       */

        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");
        
        //System.out.print(uf.find(1));
        System.out.print(ConvexHullVertex(a)[0]);
        System.out.print(ConvexHullVertex(a)[1]);
        System.out.print(ConvexHullVertex(a)[2]);
        System.out.print(ConvexHullVertex(a)[3]);
        System.out.print(ConvexHullVertex(a)[4]);
        System.out.print(ConvexHullVertex(a)[5]);
        //System.out.print(ConvexHullVertex(a)[6]);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        
       
    }
    

@172ac37641df3647aed38ee56d1e9af0@"
"r03723070","0","0.25","109296","@37270e7c962f3c836854823b82cb8f46@public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@37270e7c962f3c836854823b82cb8f46@"
"r03723070","0","0.49","107600","@4572be01d01ca0ef688fa6ab6dbaa7a8@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
}
@4572be01d01ca0ef688fa6ab6dbaa7a8@"
"r03723070","0","0.29","106032","@66dc5117416a26cea01e9985f4fd1baf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(++i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       //StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       /*UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    //StdOut.println(i + "" "" + j);
                }
            } 
       }
       */
       //find same root and combine to a array
       /*
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);
            }
           }
            */
            /*Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                //result = result+ConvexHullVertex(c);
            }
  
       
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");
        */   
        int [] out = ConvexHullVertex(a);
        System.out.print(out[0]);
        System.out.print(out[1]);
        System.out.print(out[2]);
        System.out.print(out[3]);
        System.out.print(out[4]);
        System.out.print(out[5]);
        
        //System.out.print(ConvexHullVertex(a)[6]);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        
       
    }
    

@66dc5117416a26cea01e9985f4fd1baf@"
"r03723070","0","0.51","105552","@766c3ad34595902328efa172e657585e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()+1] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        ar[AnsofNum.size()]=0;
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       //StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       /*UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    //StdOut.println(i + "" "" + j);
                }
            } 
       }
       */
       //find same root and combine to a array
       /*
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);
            }
           }
            */
            /*Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                //result = result+ConvexHullVertex(c);
            }
  
       
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");
        */   
        int [] out = ConvexHullVertex(a);
        System.out.print(out[0]);
        System.out.print(out[1]);
        System.out.print(out[2]);
        System.out.print(out[3]);
        System.out.print(out[4]);
        System.out.print(out[5]);
        System.out.print(out[6]);
        
        //System.out.print(ConvexHullVertex(a)[6]);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        
       
    }
    

@766c3ad34595902328efa172e657585e@"
"r04631041","0","0.51","105552","@6e12d45f39b686760b16072ae1026a77@public class MyConvexHull {
    
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        //Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        Selection.sort(sortdata,sortdata[0].PolarOrder());
        //Arrays.sort(sortdata,sortdata[0].polarOrder());
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 public static void main(String[] args) {
     ConvexHullVertex(10);
 }
}

@6e12d45f39b686760b16072ae1026a77@"
"r03723070","0","0","0","@a5b654309997534dee28e8b23baefeb0@import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Point2D[] b = a;
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        int [] br = new int [ans.size()] ;
        int countbr  = 0;
        for(int i = 0; i < ans.size();i++){
            for(int j = 0; j < a.length;j++){
                 if(a[j] == ans.elementAt(i)){
                     br[countbr] = j;
                     countbr =countbr+1;
                 }
            }
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return br;
    }
}
@a5b654309997534dee28e8b23baefeb0@"
"r03723070","5","0.104","105744","@2f92e6abfaa950dfcc2ef92f64d9e75b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int []ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Point2D[] b = Arrays.copyOf(a, a.length);
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        int [] br = new int [ans.size()] ;
        int countbr  = 0;
        for(int i = 0; i < ans.size();i++){
            for(int j = 0; j < a.length;j++){
                 if(b[j] == ans.elementAt(i)){
                     br[countbr] = j;
                     //System.out.println( br[countbr]);
                     countbr =countbr+1;
                 }
            }
           //System.out.print(ar[i]);
        }
        Arrays.sort(br);
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        /*
        System.out.print(br[0]);
        System.out.print(br[1]);
        System.out.print(br[2]);
        System.out.print(br[3]);
        System.out.print(br[4]);
        System.out.print(br[5]);
        */
        return br;
    }
}
@2f92e6abfaa950dfcc2ef92f64d9e75b@"
"r04631041","0","1.42","176288","@5013df39f352efe6a86d80f78f19a42a@public class MyConvexHull {
    public static void ConvexHullVertex(int N) {
        Point2D[] data=new Point2D[N] ;
        Point2D[] sortdata=new Point2D[N] ;
        for (int i=0 ; i<N ; i++){
        double x=StdRandom.uniform();
        double y=StdRandom.uniform();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<N ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<N ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        //Point2D p=new Point2D(sortdata[0].x(),sortdata[0].y());
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[N];
        for (int i=0 ; i<N ; i++){
        for (int j=0 ; j<N ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<N ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<N ; i++){
                if (sortdata[i].equals(temp)){
                    System.out.println(sortimformation[i]);
                }
            }
        }
        
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
        //for (int i=0 ; i<N ; i++)
        //    System.out.println(sortimformation[i]);
  
        
    }
 public static void main(String[] args) {
     ConvexHullVertex(10);
 }
}

@5013df39f352efe6a86d80f78f19a42a@"
"r04945021","1","0.64","111760","@64865ef3abbd593baa3206c0e0d70c84@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
       
         
        
//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++){
            points[i] = a[i];
        }
           Arrays.sort(points); 
           Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A;
        int B;
        
        for (int ll=0;ll<a.length-2;ll++){
        for(A=ll+1;A<a.length;A++){
            if (!points[0].equals(points[A])) break;    
        }
        if (A==a.length) break;//全部item都一樣
        
        for(B=A+1;B<a.length;B++){
            if(Point2D.ccw(points[0], points[A], points[B])!=0) 
                break;    
        }
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) <= 0) {

                top = stack.pop();
                if (stack.isEmpty())
                    break;               
            }
            stack.push(top);
            stack.push(points[i]);
        }
        }
       
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id，y由小到大
    if (stack.isEmpty())
    {
        for(int i=0;i<points.length;i++){
            for(int j=0;j<a.length;j++){
                if(points[i]==a[j])
                    Convex[i]=j;
            }
        }
    }
 else
    {

        for (int i=0;i<Size;i++){   
//            System.out.println(stack.pop());
            for(int j=0;j<a.length;j++){

                if(stack.peek()==a[j]){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }
    }
        
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
StdDraw.setCanvasSize(200, 200);
        StdDraw.setXscale(-10, 10);
        StdDraw.setYscale(-10, 10);
        StdDraw.setPenRadius(.005);
        
        
        int N=4;

Point2D[] a = new Point2D[N];
//a[0]=new Point2D(0,0);
//a[1]=new Point2D(2,1);
//a[2]=new Point2D(0,2);
//a[3]=new Point2D(1,1);
for(int i=0;i<N;i++){
    int x = StdRandom.uniform(N);
    int y = StdRandom.uniform(N);
    a[i]=new Point2D(x,y);
   a[i].draw();
System.out.println(a[i]);
// 
}

int asd[]=ConvexHullVertex(a);
for (int i=0;i<asd.length;i++){
    System.out.println(asd[i]);
}
    }
}

@64865ef3abbd593baa3206c0e0d70c84@"
"r04631041","5","0.102","107424","@518dd4b2864e24206f6207bd1dda8590@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args) {
     int N=10;
     Point2D[]data=new Point2D[N];
     for (int i=0 ; i<N ; i++){
         double x=StdRandom.uniform();
         double y=StdRandom.uniform();
         data[i]=new Point2D(x,y); 
     }
     int[] d=ConvexHullVertex(data);
     //-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
        for (int i=1 ; i<N ; i++){
           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
        }
           System.out.println("""");
        for (int i=0 ; i<d.length ; i++)
            System.out.println(d[i]);

 }
}

@518dd4b2864e24206f6207bd1dda8590@"
"r04945021","2","0.53","107536","@2aa54286cd6799e3505879c171adb9bf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
       
         
        
//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++){
            points[i] = a[i];
        }
           Arrays.sort(points); 
           Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A;
        int B;
        
//        for (int ll=0;ll<a.length-2;ll++){
        for(A=1;A<a.length;A++){
            if (!points[0].equals(points[A])) break;    
        }
//        if (A==a.length) break;//全部item都一樣
        
        for(B=A+1;B<a.length;B++){
            if(Point2D.ccw(points[0], points[A], points[B])!=0) 
                break;    
        }
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            if (Point2D.ccw(stack.peek(), top, points[i]) <= 0) {
stack.push(points[i]);            
            }
            else{
            stack.push(top);
            stack.push(points[i]);
            }
        }
        
       
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id，y由小到大
//    if (stack.isEmpty())
//    {
//        for(int i=0;i<points.length;i++){
//            for(int j=0;j<a.length;j++){
//                if(points[i]==a[j])
//                    Convex[i]=j;
//            }
//        }
//    }
// else
//    {

        for (int i=0;i<Size;i++){   
//            System.out.println(stack.pop());
            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }
//    }
        
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
StdDraw.setCanvasSize(200, 200);
        StdDraw.setXscale(-10, 10);
        StdDraw.setYscale(-10, 10);
        StdDraw.setPenRadius(.005);
        
        
        int N=5;

Point2D[] a = new Point2D[N];
//a[0]=new Point2D(0,1);
//a[1]=new Point2D(4,3);
//a[2]=new Point2D(0,2);
//a[3]=new Point2D(1,4);
//a[4]=new Point2D(2,0);
for(int i=0;i<N;i++){
    int x = StdRandom.uniform(N);
    int y = StdRandom.uniform(N);
    a[i]=new Point2D(x,y);
   a[i].draw();
System.out.println(a[i]);
 
}

int asd[]=ConvexHullVertex(a);
for (int i=0;i<asd.length;i++){
    System.out.println(asd[i]);
}
    }
}

@2aa54286cd6799e3505879c171adb9bf@"
"r04945021","2","0.52","107104","@03e770f51bb2564e14da34d3f0b291d1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
       
         
        
//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++){
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
           Arrays.sort(points); 
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
           Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A=1;
        int B=2;
        
//        for (int ll=0;ll<a.length-2;ll++){
//        for(A=1;A<a.length;A++){
//            if (!points[0].equals(points[A])) break;    
//        }
////        if (A==a.length) break;//全部item都一樣
//        
//        for(B=A+1;B<a.length;B++){
//            if(Point2D.ccw(points[0], points[A], points[B])!=0) 
//                break;    
//        }
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            if (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
                
stack.push(points[i]);            
            }
            else{
            stack.push(top);
            stack.push(points[i]);
            }
        }
        
       
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id，y由小到大


        for (int i=0;i<Size;i++){   
//            System.out.println(stack.pop());
            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }
//    }
        
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
StdDraw.setCanvasSize(400, 400);
        StdDraw.setXscale(-1, 10);
        StdDraw.setYscale(-1, 10);
        StdDraw.setPenRadius(.01);
        
        
        int N=7;

Point2D[] a = new Point2D[N];
//a[0]=new Point2D(0,1);
//a[1]=new Point2D(4,3);
//a[2]=new Point2D(0,2);
//a[3]=new Point2D(1,4);
//a[4]=new Point2D(2,0);
for(int i=0;i<N;i++){
    int x = StdRandom.uniform(N);
    int y = StdRandom.uniform(N);
    a[i]=new Point2D(x,y);
   a[i].draw();

System.out.println(a[i]);
 
}

int asd[]=ConvexHullVertex(a);
for (int i=0;i<asd.length;i++){
    System.out.println(asd[i]);
}
    }
}

@03e770f51bb2564e14da34d3f0b291d1@"
"r04945021","5","0.104","104896","@49ef132d76250528dc5e7319bc0e9e22@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
       
         
        
//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++){
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
           Arrays.sort(points); 
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
           Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A=1;
        int B=2;
        
//        for (int ll=0;ll<a.length-2;ll++){
//        for(A=1;A<a.length;A++){
//            if (!points[0].equals(points[A])) break;    
//        }
////        if (A==a.length) break;//全部item都一樣
//        
//        for(B=A+1;B<a.length;B++){
//            if(Point2D.ccw(points[0], points[A], points[B])!=0) 
//                break;    
//        }
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
               top=stack.pop();
//stack.push(points[i]);            
            }
            
            stack.push(top);
            stack.push(points[i]);
            
        }
        
       
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id，y由小到大


        for (int i=0;i<Size;i++){   
//            System.out.println(stack.pop());
            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }
//    }
        
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
StdDraw.setCanvasSize(400, 400);
        StdDraw.setXscale(-1, 10);
        StdDraw.setYscale(-1, 10);
        StdDraw.setPenRadius(.01);
        
        
        int N=7;

Point2D[] a = new Point2D[N];
//a[0]=new Point2D(0,1);
//a[1]=new Point2D(4,3);
//a[2]=new Point2D(0,2);
//a[3]=new Point2D(1,4);
//a[4]=new Point2D(2,0);
for(int i=0;i<N;i++){
    int x = StdRandom.uniform(N);
    int y = StdRandom.uniform(N);
    a[i]=new Point2D(x,y);
   a[i].draw();

System.out.println(a[i]);
 
}

int asd[]=ConvexHullVertex(a);
for (int i=0;i<asd.length;i++){
    System.out.println(asd[i]);
}
    }
}

@49ef132d76250528dc5e7319bc0e9e22@"
"r04945039","5","0.104","105744","@74f0e2ceddb7d74cce8417ffa954d346@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
  
    public static int[] convertIntegers(List<Integer> integers)
{
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }
    
    
//    idmap= new int[readtimes];
//        
//        UnionFilter(a);
//        int[] ans = new int[readtimes];
//        
//       for (int r=1;r<=CC;r++){
//           
//       System.out.println(CCcomponent(r, idmap));      
//       }
//       
//        return ans;
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }
    
    
    
   
    private static void UnionFilter(Point2D[] m){
    
    uf = new WeightedQuickUnionUF(readtimes);
    
    
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }
         
    }

    
}


    
    public static void CalaculateCC(int a,int b) {
        
        
        if(alreadyCC(a)){
            System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;
            
        }       
   
    }
    
    
   private static boolean alreadyCC(int x){
       return idmap[x]!=0;
       
}

   
   
//   public static int[] CCcomponent(int iter,int[] array){
//       int [] gan = new int[readtimes]; 
//        for (int shit=0;shit<array.length;shit++){
//            if (array[shit]==iter);
//            gan[]=shit;
//            
//        }
//}
   
   
   
   
//   public static void CCProcessor (){
//        Object ConInput =new Object();
//        for (int r=1;r<=CCnum;r++){
//           ConInput = CCcomponent(r, idmap);
//           int size = ConInput.length;
//           Point2D[] ConvexInput = new Point2D[size];
//           ConvexInput=vertex.get(ConInput);
//        }
//        
//        
//   }
      
   
    


//    private void SumConvexPoint (){
        
//    }
   
   
//    public static void ConvexBuild(int[] ids){
//        Stack<Integer> CCConvex = new Stack<Integer>();
//        vertex.get();
//        
//        
//        
//    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        
        
        distance = Double.parseDouble(br.readLine());
        readtimes = Integer.parseInt(br.readLine());
        PointsArray= new Point2D[readtimes];
        int pos=0; 
        
        for(String coordinate;( coordinate = br.readLine()) != null; ) {
            String[] cor=coordinate.split("" "");
            Double x = Double.parseDouble(cor[0]);
            Double y = Double.parseDouble(cor[1]);
        Point2D p = new Point2D(x, y); 
        PointsArray[pos]=p;
        pos++;
            }      
        
       
        //System.out.println(ConvexHullVertex(PointsArray));
        
        //getID();
         }
        catch (Exception error){
            //continue;
        }
        
        
    }
    }
    
    
    


@74f0e2ceddb7d74cce8417ffa954d346@"
"b03704074","0","0.51","106768","@6e952509ae012a36e3faa8301b6fcbad@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                //indexnew[j] = i;System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        /*for(h = 0;h<jmax;h++){
            System.out.println(""排序後的k=""+indexold[h]);
        }*/
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}
        for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@6e952509ae012a36e3faa8301b6fcbad@"
"b03704074","0","0.53","105968","@c6c6456da15e5f28337f724587ee119c@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        for(h = 0;h<jmax;h++){
            System.out.println(""排序後的k=""+indexold[h]);
        }
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}
        for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@c6c6456da15e5f28337f724587ee119c@"
"b03704074","0","0.54","107808","@c6c6456da15e5f28337f724587ee119c@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        for(h = 0;h<jmax;h++){
            System.out.println(""排序後的k=""+indexold[h]);
        }
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}
        for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@c6c6456da15e5f28337f724587ee119c@"
"b03704074","0","0.53","107536","@3e1711bc5ae99c9be46c21a66c031f2e@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        /*for(h = 0;h<jmax;h++){
            System.out.println(""排序後的k=""+indexold[h]);
        }*/
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}
        for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@3e1711bc5ae99c9be46c21a66c031f2e@"
"b03704074","0","0.54","107984","@a1bd04f8db9e0f4b2508f85a3817969f@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i = 0;i < a.length ;i++){
            double s = StdRandom.uniform();
            double m = StdRandom.uniform();
            a[i] = new Point2D(s,m);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        /*for(h = 0;h<jmax;h++){
            System.out.println(""排序後的k=""+indexold[h]);
        }*/
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        /*for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }*/
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}*/
        
        /*for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@a1bd04f8db9e0f4b2508f85a3817969f@"
"b03704074","0","0.54","107984","@65cc64fa49fd0606cc471a26c8d17477@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i = 0;i < a.length ;i++){
            double s = StdRandom.uniform();
            double m = StdRandom.uniform();
            a[i] = new Point2D(s,m);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        for(h = 0;h<jmax;h++){
            System.out.println(indexold[h]);
        }
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        /*for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }*/
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}*/
        
        /*for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@65cc64fa49fd0606cc471a26c8d17477@"
"b02611016","0","0.52","107904","@90becede356e2d3cb65b3b123edde2fa@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       Point2D[] d=a;
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
      
       }
  //      System.out.println(hm);
       Insertion.sort(d);
       //compareTo(a[0],a[1]);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
      /*     for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
      // System.out.println(a[i]);
               }*/
         
           int k=0;
           
            for(int i=0;i<a.length;i++)  {
               int c=i+1;
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              k=k+1;
             // b[q]=c;
           //  System.out.println(k);
            // System.out.println(c);
               i=c-1;
        }
              int q=0;
            int[] b=new int[k+1];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
   //          System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){q=q+1;
              b[q]=c;}
              //Point2D temp=new Point2D(0,0);
        }
          // hm.get(b[0]);
          int[] e=new int[k+1];
          int[] f=new int[k+1];
          int temp=0;
           for(int t=0;t<q;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
//               System.out.println(e[t]);
           }
            for(int t=0;t<q;t++)
           {  for(int y=t+1;y<q;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
                   
       //        System.out.println(e[t]);
           }
               
        return  e;
    }

    
    
    public static void main(String[] args) {
 /*       Point2D[] a=new Point2D[50];
             for(int i=0;i<50;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
     int[]b=ConvexHullVertex(a);
     System.out.print(b);*/
             
}
   
   
    
}

@90becede356e2d3cb65b3b123edde2fa@"
"r04631034","0","0","0","@5fa85de1cb8f8c5a2756430de7883cf1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;


/**
 *
 * @author user
 */
public class MyConvexHull {

     public static Point2D[] cotSort(Point2D[] in) {

          double[] cotan = new double[in.length];
          for (int i = 0; i < in.length; i++) {
               cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
          }

          double temp;
          Point2D temp2;
          for (int i = 1; i < cotan.length; i++) {
               for (int j = i; j > 0; j--) {
                    if (cotan[j] < cotan[j - 1]) {
                         temp = cotan[j];
                         cotan[j] = cotan[j - 1];
                         cotan[j - 1] = temp;
                         temp2 = in[j];
                         in[j] = in[j - 1];
                         in[j - 1] = temp2;
                    }
               }
          }
          return in;
     }

     public static double ccwju(Point2D a, Point2D b, Point2D c) {
          double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
          if (area2 < 0) {
               return -1;
          } else if (area2 > 0) {
               return +1;
          } else {
               return 0;
          }
     }

     public static int[] ConvexHullVertex(Point2D[] a) {
          HashMap<Double, Integer> map = new HashMap<Double, Integer>();
          for (int i = 0; i < a.length; i++) {
               map.put(a[i].x(), i);
          }

          MergeX.sort(a, Point2D.Y_ORDER);    //sort
          cotSort(a);
//          for (int count = 0; count < a.length; count++) {
//               if (count == 0) {
//                    StdDraw.setPenColor(StdDraw.RED);
//                    StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                    String str = String.valueOf(count);
//                    StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//               } else {
//                    StdDraw.setPenColor(StdDraw.BLACK);
//                    StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                    String str = String.valueOf(count);
//                    StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                    StdDraw.setPenColor(StdDraw.YELLOW);
//                    StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//               }
//          }

          ArrayList<Integer> storge = new ArrayList<Integer>();
          storge.add(0);
          storge.add(1);
          int count_storge = 0;
          int count_point = 2;
          while (count_point < a.length) {
               if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                    storge.add(count_point);
                    StdDraw.setPenColor(StdDraw.GREEN);
                    StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                    count_storge++;
                    count_point++;

               } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                    StdDraw.setPenColor(StdDraw.RED);
                    StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                    storge.remove(storge.size() - 1);
                    count_storge--;
//                                        count_point++;
               }

          }
          int[] output = new int[storge.size()];
          for (int count = 0; count < storge.size(); count++) {
               output[count] = map.get(a[storge.get(count)].x());
          }
          return output;
     }

     public static void main(String[] args) {
//                     TODO code application logic here

//                    int N = 50;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
//                    }
//
//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].x(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].x()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].x());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//          System.out.println("""");
     }

}

@5fa85de1cb8f8c5a2756430de7883cf1@"
"r04631034","0","0.52","107904","@0f1754f9a36c7ae202077154fd8d7a57@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    cotSort(a);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 50;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                                        int[] test;
                    test=MyConvexHull.ConvexHullVertex(a);
//                    System.out.println(""length""+test.length);
//                    System.out.println(""output  "");
                    for (int i = 0 ;i<test.length;i++){
                         System.out.print(test[i]+"" "");
                    }
                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}



@0f1754f9a36c7ae202077154fd8d7a57@"
"r04631034","3","0.62","107872","@911da0db684d499576b6b3b100e0cdd6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;


/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }

                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    cotSort(a);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 50;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                                        int[] test;
                    test=MyConvexHull.ConvexHullVertex(a);
//                    System.out.println(""length""+test.length);
//                    System.out.println(""output  "");
                    for (int i = 0 ;i<test.length;i++){
                         System.out.print(test[i]+"" "");
                    }
                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}



@911da0db684d499576b6b3b100e0cdd6@"
"b02611016","0","0.49","107856","@91e38d5dd0bd94bda9f57c27f8ae1394@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       Point2D[] d=a;
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
    //        System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
/*           for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
         
           int k=0;
           
            for(int i=0;i<a.length;i++)  {
               int c=i+1;
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              k=k+1;
             // b[q]=c;
           //  System.out.println(k);
    //         System.out.println(c);
               i=c-1;
        }
              int q=0;
            int[] b=new int[k+1];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
        //     System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){q=q+1;
              b[q]=c;}
              //Point2D temp=new Point2D(0,0);
        }
          // hm.get(b[0]);
          int[] e=new int[k+1];
          char f[]=new char[k+1];
          int temp=0;
           for(int t=0;t<q;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
//               System.out.println(e[t]);
           }
            for(int t=0;t<q;t++)
           {  for(int y=t+1;y<q;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
                   
               System.out.print(e[t]);
           }
              
        return  e;
    }

    
    
    public static void main(String[] args) {
        Point2D[] a=new Point2D[10];
             for(int i=0;i<10;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
     int[]b=ConvexHullVertex(a);
    /* int h=b.length-1;
     for(int i=1;i<h;i++)
     {System.out.println(b[i]);}*/
             
}
   
   
    
}

@91e38d5dd0bd94bda9f57c27f8ae1394@"
"b02611016","0","0","0","@9e110a41c38184b3b0c79cb4eae56ebe@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static String ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       Point2D[] d=a;
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
    //        System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
         
           int k=0;
           
            for(int i=0;i<a.length;i++)  {
               int c=i+1;
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              k=k+1;
             // b[q]=c;
           //  System.out.println(k);
    //         System.out.println(c);
               i=c-1;
        }
              int q=0;
            int[] b=new int[k+1];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
        //     System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){q=q+1;
              b[q]=c;}
              //Point2D temp=new Point2D(0,0);
        }
          // hm.get(b[0]);
          int[] e=new int[k+1];
          String f=null;
          int temp=0;
           for(int t=0;t<q;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
//               System.out.println(e[t]);
           }
            for(int t=0;t<q;t++)
           {  for(int y=t+1;y<q;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
           if(f==null){f=String.valueOf(e[t]);}
             else  f=f+"",""+String.valueOf(e[t]);    
         //      System.out.println(f);
           }
             // System.out.println(f);
        return  f;
    }

    
    
    public static void main(String[] args) {
   /*     Point2D[] a=new Point2D[100];
             for(int i=0;i<100;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
  //   int[]b=ConvexHullVertex(a);
          String b=ConvexHullVertex(a);*/
   /*  int h=b.length-1;
     for(int i=1;i<h;i++)
     {System.out.println(b[i]);}*/
      //       System.out.println(b);
}
   
   
    
}

@9e110a41c38184b3b0c79cb4eae56ebe@"
"b02611016","5","0.104","106000","@32969569855043b274c48ce5986f4c56@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a) {

           //StdRandom.uniform();
       Point2D[] d=a;
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
         
           int k=0;
           
            for(int i=0;i<a.length;i++)  {
               int c=i+1;
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              k=k+1;
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
               i=c-1;
        }
              int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }
          // hm.get(b[0]);
          int[] e=new int[k];
          String f=null;
          int temp=0;
           for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }
            for(int t=0;t<q+1;t++)
           {  for(int y=t+1;y<q+1;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
        
         //      System.out.println(f);
           }
             // System.out.println(f);
        return  e;
    }

    
    
    public static void main(String[] args) {
  /*      Point2D[] a=new Point2D[10];
             for(int i=0;i<10;i++){
       a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
       //StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
       }
     int[]b=ConvexHullVertex(a);
   //       String b=ConvexHullVertex(a);
     int h=b.length;
     for(int i=0;i<h;i++)
     {System.out.println(b[i]);}*/
      //       System.out.println(b);
}
   
   
    
}

@32969569855043b274c48ce5986f4c56@"
"b03704074","0","0.54","106080","@9f5bb6e281d10fd6020b83fdafe88aa5@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[a.length];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<jmax;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double s = StdRandom.uniform();
            double m = StdRandom.uniform();
            A[i] = new Point2D(s,m);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }*/
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }*/
        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}*/
        
        /*for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@9f5bb6e281d10fd6020b83fdafe88aa5@"
"b03704074","5","0.106","107904","@764bc3cfe85a00af3a71a4c4ba5f5c1c@
import java.awt.Color;


public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args) {
        int N = 10;
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N ;i++){
            double s = StdRandom.uniform();
            double m = StdRandom.uniform();
            A[i] = new Point2D(s,m);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }
        /*for(int i = 0;i < N ;i++){
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a,b);
            
            //StdDraw.filledCircle(A[i].x(),A[i].y(),0.01);
        }*/
        /*
        double min = A[0].y();
        int flag = 0;
        for(int i = 0;i < N ; i++){
            if(A[i].y()<min){
                min = A[i].y();
                flag = i;
        } }*/
        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(A[flag].x(),A[flag].y(),0.01);
        Point2D swap;    //把最小的值存在A[0]
        swap = A[0];
        A[0] = A[flag];
        A[flag] = swap;
        for(int i = 1;i < N;i++){   //i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(A[j].x()>A[j-1].x()){
                 
                    swap = A[j];
                    A[j] = A[j-1];
                    A[j-1] = swap;}
                if(A[j].x()>=A[0].x() && A[j-1].x()>=A[0].x()){ 
                    if(((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))>((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))){
                        swap = A[j-1];
                        A[j-1] = A[j];
                        A[j] = swap;} }
                else if(A[j].x()<A[0].x() && A[j-1].x()<A[0].x()){
                    if(((A[j].y()-A[0].y())/(A[j].x()-A[0].x()))<((A[j-1].y()-A[0].y())/(A[j-1].x()-A[0].x()))){
                    swap = A[j-1];
                    A[j-1] = A[j];
                    A[j] = swap;}}}}*/
        
        /*for(int i = 0;i < N;i++){
            String str = String.valueOf(i);
            StdDraw.text(A[i].x(), A[i].y()+0.03,str);}*/
        ConvexHullVertex(A);
        
    
}
}
@764bc3cfe85a00af3a71a4c4ba5f5c1c@"
"r04631034","0","0.106","107904","@320ed11815196393b0ad9a9fb837fdd9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
                    }
                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

          public static double ccwju(Point2D a, Point2D b, Point2D c) {
                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
                    if (area2 < 0) {
                              return -1;
                    } else if (area2 > 0) {
                              return +1;
                    } else {
                              return 0;
                    }
          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Arrays.sort(a, a[0].atan2Order());
//                    cotSort(a);
                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                         ;
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N =4;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                                        int[] test;
                    test=MyConvexHull.ConvexHullVertex(a);
//                    System.out.println(""length""+test.length);
//                    System.out.println(""output  "");
                    for (int i = 0 ;i<test.length;i++){
                         System.out.print(test[i]+"" "");
                    }
                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}



@320ed11815196393b0ad9a9fb837fdd9@"
"r04631034","0","0","0","@f19117ba754a1cb52ca5ef7baabf2442@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;


/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(""cotan""+cotan[i]);
                    }
                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

//          public static double ccwju(Point2D a, Point2D b, Point2D c) {
//                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
//                    if (area2 < 0) {
//                              return -1;
//                    } else if (area2 > 0) {
//                              return +1;
//                    } else {
//                              return 0;
//                    }
//          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    Arrays.sort(a, a[0].atan2Order());
                    cotSort(a);
                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point])!=-1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                       Arrays.sort(output);
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N =10;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                                        int[] test;
                    test=MyConvexHull.ConvexHullVertex(a);
//                    System.out.println(""length""+test.length);
//                    System.out.println(""output  "");
                    for (int i = 0 ;i<test.length;i++){
                         System.out.print(test[i]+"" "");
                    }
//                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}



@f19117ba754a1cb52ca5ef7baabf2442@"
"r04631034","0","0","0","@6c54b9dcb82c0a7c1beed59d1f238c04@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(""cotan""+cotan[i]);
                    }
                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

//          public static double ccwju(Point2D a, Point2D b, Point2D c) {
//                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
//                    if (area2 < 0) {
//                              return -1;
//                    } else if (area2 > 0) {
//                              return +1;
//                    } else {
//                              return 0;
//                    }
//          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(i+a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    Arrays.sort(a, a[0].atan2Order());
                    cotSort(a);
                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point])!=-1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(count+a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N =3;
//                    Point2D[] a = new Point2D[N];
////                    for (int count = 0; count < N; count++) {
////                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//////                              System.out.println(a[count]);
////                    }
//                    a[0]=new Point2D(0.1,0.1);
//                    a[1]=new Point2D(0.5,0.5);                    
//                    a[2]=new Point2D(0.5,0.5);
//                    int[] test;
//                    test=MyConvexHull.ConvexHullVertex(a);
////                    System.out.println(""length""+test.length);
////                    System.out.println(""output  "");
//                    for (int i = 0 ;i<test.length;i++){
//                         System.out.print(test[i]+"" "");
//                    }
//                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}




@6c54b9dcb82c0a7c1beed59d1f238c04@"
"r04631034","0","0","0","@2bf519bf5b97b3a2e1c83d1d4673c4be@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static Point2D[] cotSort(Point2D[] in) {

                    double[] cotan = new double[in.length];
                    for (int i = 0; i < in.length; i++) {
                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(""cotan""+cotan[i]);
                    }
                    double temp;
                    Point2D temp2;
                    for (int i = 1; i < cotan.length; i++) {
                              for (int j = i; j > 0; j--) {
                                        if (cotan[j] < cotan[j - 1]) {
                                                  temp = cotan[j];
                                                  cotan[j] = cotan[j - 1];
                                                  cotan[j - 1] = temp;
                                                  temp2 = in[j];
                                                  in[j] = in[j - 1];
                                                  in[j - 1] = temp2;
                                        }
                              }
                    }
                    return in;
          }

//          public static double ccwju(Point2D a, Point2D b, Point2D c) {
//                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
//                    if (area2 < 0) {
//                              return -1;
//                    } else if (area2 > 0) {
//                              return +1;
//                    } else {
//                              return 0;
//                    }
//          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    Arrays.sort(a, a[0].atan2Order());
                    cotSort(a);
                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point])!=-1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                                        storge.add(count_point);
                                        StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                                        count_storge++;
                                        count_point++;

                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
//                                        count_point++;
                              }

                    }
                    int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
                    }
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N =10;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }

                    int[] test;
                    test=MyConvexHull.ConvexHullVertex(a);
//                    System.out.println(""length""+test.length);
//                    System.out.println(""output  "");
                    for (int i = 0 ;i<test.length;i++){
                         System.out.print(test[i]+"" "");
                    }
//                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");

          }

}




@2bf519bf5b97b3a2e1c83d1d4673c4be@"
"b03611033","0","0","0","@de909facd60b8408bda9dbfa7e9f4aa7@
import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import edu.princeton.cs.algs4.StdDraw;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = a;
        int i=0;

        for (int j = 1; j < b.length; j++) {
            if(b[i].compareTo(b[j]) == 1) i=j;
        }
        Point2D min=b[i];
        Arrays.sort(b, min.polarOrder());
        
        int cc1=0,cc2=1,cc3=2;
        Stack<Integer> index = new Stack<>();
        /*
        StdDraw.setPenRadius();  
        b[b.length-1].drawTo(b[0]);
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
        */
        index.push(b.length-1);
        index.push(0);
        
        while(cc3 < b.length){
            
            if(Point2D.ccw(b[cc1],b[cc2],b[cc3])!=1){
                cc2=cc3;
            }
            else{
                /*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
                */
                
                index.push(cc2);
                cc1=cc2;
                cc2=cc3;
            }
            cc3++;
        }
        
        //StdOut.println(index);
        
        int count=0,temp;
        int out[]=new int[index.size()];
        int size=index.size();
        
        while(count < size){
            temp=index.pop();
            i=0;
            while(true){
                if(a[i].equals(b[temp])){
                    out[count]=i;
                    
                    break;
                }
                i++;
            }
            count++;
        }     
        Arrays.sort(out);
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            int N = Integer.parseInt(data);
            /*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double minx = 0, miny = 100;
            int i = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);
                //points[i].draw();
                if (miny > y) {
                    minx = x;
                    miny = y;
                }
                i++;
            }

           // MyConvexHull mch = new MyConvexHull();

            int result[]=MyConvexHull.ConvexHullVertex(points);
/*
            Point2D p = new Point2D(minx, miny);
            StdDraw.setPenColor(StdDraw.RED);

            p.draw();

            StdDraw.setPenRadius();
            StdDraw.setPenColor(StdDraw.BLUE);
             Arrays.sort(points, p.atan2Order());
           for (i = 0; i < N; i++) {
                p.drawTo(points[i]);
                StdDraw.show(500);
            }*/
        }
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
}

@de909facd60b8408bda9dbfa7e9f4aa7@"
"b03611033","0","0.38","105808","@9d804e765a75a15eafe10ea2633ab48b@
import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
//import edu.princeton.cs.algs4.StdDraw;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = a;
        int i=0;

        for (int j = 1; j < b.length; j++) {
            if(b[i].compareTo(b[j]) == 1) i=j;
        }
        Point2D min=b[i];
        Arrays.sort(b, min.polarOrder());
        
        int cc1=0,cc2=1,cc3=2;
        Stack<Integer> index = new Stack<>();
        /*
        StdDraw.setPenRadius();  
        b[b.length-1].drawTo(b[0]);
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
        */
        index.push(b.length-1);
        index.push(0);
        
        while(cc3 < b.length){
            
            if(Point2D.ccw(b[cc1],b[cc2],b[cc3])!=1){
                cc2=cc3;
            }
            else{
                /*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
                */
                
                index.push(cc2);
                cc1=cc2;
                cc2=cc3;
            }
            cc3++;
        }
        
        //StdOut.println(index);
        
        int count=0,temp;
        int out[]=new int[index.size()];
        int size=index.size();
        
        while(count < size){
            temp=index.pop();
            i=0;
            while(true){
                if(a[i].equals(b[temp])){
                    out[count]=i;
                    
                    break;
                }
                i++;
            }
            count++;
        }     
        Arrays.sort(out);
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            int N = Integer.parseInt(data);
            /*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double minx = 0, miny = 100;
            int i = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);
                //points[i].draw();
                if (miny > y) {
                    minx = x;
                    miny = y;
                }
                i++;
            }

           // MyConvexHull mch = new MyConvexHull();

            //MyConvexHull.ConvexHullVertex(points);
/*
            Point2D p = new Point2D(minx, miny);
            StdDraw.setPenColor(StdDraw.RED);

            p.draw();

            StdDraw.setPenRadius();
            StdDraw.setPenColor(StdDraw.BLUE);
             Arrays.sort(points, p.atan2Order());
           for (i = 0; i < N; i++) {
                p.drawTo(points[i]);
                StdDraw.show(500);
            }*/
        }
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
}

@9d804e765a75a15eafe10ea2633ab48b@"
"b03611033","0","0.51","107584","@b5865b277ac84065c8777bb15f53e1f3@
import java.io.BufferedReader;
import java.io.FileReader;
//import edu.princeton.cs.algs4.StdDraw;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = a;
        int i=0;

        for (int j = 1; j < b.length; j++) {
            if(b[i].compareTo(b[j]) == 1) i=j;
        }
        Point2D min=b[i];
        Arrays.sort(b, min.POLAR_ORDER);
        
        int cc1=0,cc2=1,cc3=2;
        Stack<Integer> index = new Stack<>();
        /*
        StdDraw.setPenRadius();  
        b[b.length-1].drawTo(b[0]);
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
        */
        index.push(b.length-1);
        index.push(0);
        
        while(cc3 < b.length){
            
            if(Point2D.ccw(b[cc1],b[cc2],b[cc3])!=1){
                cc2=cc3;
            }
            else{
                /*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
                */
                
                index.push(cc2);
                cc1=cc2;
                cc2=cc3;
            }
            cc3++;
        }
        
        //StdOut.println(index);
        
        int count=0,temp;
        int out[]=new int[index.size()];
        int size=index.size();
        
        while(count < size){
            temp=index.pop();
            i=0;
            while(true){
                if(a[i].equals(b[temp])){
                    out[count]=i;
                    
                    break;
                }
                i++;
            }
            count++;
        }     
        Arrays.sort(out);
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            int N = Integer.parseInt(data);
            /*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double minx = 0, miny = 100;
            int i = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);
                //points[i].draw();
                if (miny > y) {
                    minx = x;
                    miny = y;
                }
                i++;
            }

           // MyConvexHull mch = new MyConvexHull();

            //MyConvexHull.ConvexHullVertex(points);
/*
            Point2D p = new Point2D(minx, miny);
            StdDraw.setPenColor(StdDraw.RED);

            p.draw();

            StdDraw.setPenRadius();
            StdDraw.setPenColor(StdDraw.BLUE);
             Arrays.sort(points, p.atan2Order());
           for (i = 0; i < N; i++) {
                p.drawTo(points[i]);
                StdDraw.show(500);
            }*/
        }
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
}

@b5865b277ac84065c8777bb15f53e1f3@"
"b03611033","5","0.102","103760","@aafda7ac520ee034f6b42197d2165e06@
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        for (int copy = 0; copy < a.length; copy++) {
            b[copy] = a[copy];
        }

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);
/*
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
        StdOut.println(""==="" + min);

        

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            b[h].draw();
            StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
 */      
        int cc1,cc2,cc3,num=2;
        Stack<Integer> index1 = new Stack<>();
/*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
*/

        index1.push(0);
        index1.push(1);


        while (true) {
            index1.push(num);
            cc3=index1.pop();
            cc2=index1.pop();
            cc1=index1.pop();        
            
            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2=cc1;
                        cc1=index1.pop();
                    }
                }
            } else {
/*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
*/
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if(cc3==0) break;
            num++;
            if(num == b.length){
                num=0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();
        
        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
        */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) {

        int N = 10;
/*
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.01);
*/
        double x, y;

        Point2D[] points = new Point2D[N];
        for (int i = 0; i < 10; i++) {
            x = StdRandom.uniform();
            y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            //StdOut.println(points[i]);
        }

        // MyConvexHull mch = new MyConvexHull();
        MyConvexHull.ConvexHullVertex(points);
        /*
            Point2D p = new Point2D(minx, miny);
            StdDraw.setPenColor(StdDraw.RED);

            p.draw();

            StdDraw.setPenRadius();
            StdDraw.setPenColor(StdDraw.BLUE);
             Arrays.sort(points, p.atan2Order());
           for (i = 0; i < N; i++) {
                p.drawTo(points[i]);
                StdDraw.show(500);
            }*/

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    }
}

@aafda7ac520ee034f6b42197d2165e06@"
"r04921012","0","0.102","103760","@4edd59c644f9a966b5ddf1f4a979867e@
//package myconvexhull;

import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */

    public int CCW(Point2D a,Point2D b, Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(Point2D Point){
            this.startPoint=Point;
            }
            private Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    
                    if (dy1==0 && dy2==0) return 0;
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private Point2D p;
            private int index;
            public pointWithIndex(Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] a){
  
        boolean[] b=new boolean[a.length];
        double[] x=new double[a.length];
        double[] y=new double[a.length];
        Integer[] yIndex=new Integer [a.length];
        for(int i=0;i<a.length;i++){
            x[i]=a[i].getX();
            y[i]=a[i].getY();
            yIndex[i]=i;
        }

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        


        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(a[0]);
        

        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.index);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2].p);
        st2.push(A[0].index);
        st2.push(A[1].index);
        //st2.push(A[2].index);
        int j=2;
        while (j<a.length){
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) {
        Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);
        //for (int item : v_arr){System.out.println(item);}
    }
    
}

@4edd59c644f9a966b5ddf1f4a979867e@"
"r04631036","0","0.102","103760","@4da85dfe431ba9a07380880e7deec9b8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {
    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param  pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if any
     *         entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public MyConvexHull(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].polarOrder());

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }

        assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

   /**
     * Unit tests the <tt>ClosestPair</tt> data type.
     * Reads in an integer <tt>N</tt> and <tt>N</tt> points (specified by
     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
     * computes their convex hull; and prints out the points on the
     * convex hull to standard output.
     */
    public static void main(String[] args) {
        int N = StdIn.readInt();
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdIn.readInt();
            int y = StdIn.readInt();
            points[i] = new Point2D(x, y);
        }
        GrahamScan graham = new GrahamScan(points);
        for (Point2D p : graham.hull())
            StdOut.println(p);
    }

}
@4da85dfe431ba9a07380880e7deec9b8@"
"r04631036","0","0.62","112288","@b1090fcebcce4c664332c9001e49c8aa@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {
    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param  pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if any
     *         entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public void ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].polarOrder());

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }

        assert isConvex();
        while(!hull.isEmpty())
            for(int i=0;i<N;i++)
               if(hull.peek().y()== pts[i].y())
                   System.out.printf(""%d"" , i);
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

   /**
     * Unit tests the <tt>ClosestPair</tt> data type.
     * Reads in an integer <tt>N</tt> and <tt>N</tt> points (specified by
     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
     * computes their convex hull; and prints out the points on the
     * convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}
@b1090fcebcce4c664332c9001e49c8aa@"
"r04631036","0","0.098","105952","@6f2433dbfd5cdfb037b36fe2767647da@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {
    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param  pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if any
     *         entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public void ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, points[0].polarOrder());

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }

        assert isConvex();
        while(!hull.isEmpty())
            for(int i=0;i<N;i++)
               if(hull.peek().y()== pts[i].y())
                   System.out.printf(""%d"" , i);
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

   /**
     * Unit tests the <tt>ClosestPair</tt> data type.
     * Reads in an integer <tt>N</tt> and <tt>N</tt> points (specified by
     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
     * computes their convex hull; and prints out the points on the
     * convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}
@6f2433dbfd5cdfb037b36fe2767647da@"
"r04631036","0","0.102","103760","@774e8e16924026ec15307cb0d518b536@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {
    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param  pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if any
     *         entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public void ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, points[0].polarOrder());

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }

        assert isConvex();
        while(!hull.isEmpty())
            for(int i=0;i<N;i++)
               if(hull.peek().y()== pts[i].y())
                   System.out.printf(""%d"" , i);
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

   /**
     * Unit tests the <tt>ClosestPair</tt> data type.
     * Reads in an integer <tt>N</tt> and <tt>N</tt> points (specified by
     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
     * computes their convex hull; and prints out the points on the
     * convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}
@774e8e16924026ec15307cb0d518b536@"
"b03611015","0","0.102","103760","@583d6742e4ad1f82ee31f9962237c02b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */




import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdRandom;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public void ConvexHullVertix(int N){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        int n = 0;        
        for(int i=0;i<N;i++){
        if(hull.pop()==a[i])
            b[n]=a[i];
        n++;
        
        }
    

}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
        
        // TODO code application logic here
    }

@583d6742e4ad1f82ee31f9962237c02b@"
"b03611015","0","0.62","112288","@2ce13c2a0008624aa8fd89da89e406c2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public void ConvexHullVertix(int N){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        int n = 0;        
        for(int i=0;i<N;i++){
        if(hull.pop()==a[i])
            b[n]=a[i];
        n++;
        
        }
    

}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
        
        // TODO code application logic here
    }

@2ce13c2a0008624aa8fd89da89e406c2@"
"r04631034","0","0.098","105952","@930b03c12f32722df424cae177dea9d5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

     public static Point2D[] cotSort(Point2D[] in) {

          double[] cotan = new double[in.length];
          for (int i = 0; i < in.length; i++) {
               cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
          }

          double temp;
          Point2D temp2;
          for (int i = 1; i < cotan.length; i++) {
               for (int j = i; j > 0; j--) {
                    if (cotan[j] < cotan[j - 1]) {
                         temp = cotan[j];
                         cotan[j] = cotan[j - 1];
                         cotan[j - 1] = temp;
                         temp2 = in[j];
                         in[j] = in[j - 1];
                         in[j - 1] = temp2;
                    }
               }
          }
          return in;
     }

     public static int[] ConvexHullVertex(Point2D[] a) {
          HashMap<Double, Integer> map = new HashMap<Double, Integer>();
          for (int i = 0; i < a.length; i++) {
               map.put(a[i].y(), i);
          }
          MergeX.sort(a, Point2D.Y_ORDER);    //sort
          Point2D p = new Point2D(a[0].x(), a[0].y());
          Arrays.sort(a, p.polarOrder());
//          cotSort(a);
          ArrayList<Integer> storge = new ArrayList<Integer>();
          storge.add(0);
          storge.add(1);
          int count_storge = 0;
          int count_point = 2;
          while (count_point < a.length) {
               if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                    storge.add(count_point);
                    count_storge++;
                    count_point++;
               } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                    storge.remove(storge.size() - 1);
                    count_storge--;
               }

          }
          int[] output = new int[storge.size()];
//                    System.out.println(""storge.size()""+storge.size());
          for (int count = 0; count < storge.size(); count++) {
               output[count] = map.get(a[storge.get(count)].y());
//                              System.out.println(""a[storge.get(count)].y() ""+a[storge.get(count)].y());
//                              System.out.println(""map.get(a[storge.get(count)].y())  ""+map.get(a[storge.get(count)].y()));
          }
          return output;
     }

     public static void main(String[] args) {
//                     TODO code application logic here
//          int N = 50;
//          Point2D[] a = new Point2D[N];
//          for (int count = 0; count < N; count++) {
//               a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.println(a[count]);
//          }
//          int[] test;
//          test = MyConvexHull.ConvexHullVertex(a);
////                    System.out.println(""length""+test.length);
////                    System.out.println(""output  "");
//          for (int i = 0; i < test.length; i++) {
//               System.out.print(test[i] + "" "");
//          }

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
     }

}

@930b03c12f32722df424cae177dea9d5@"
"b03611035","0","0.62","112288","@72627c172c336e55a730f439f532b17d@import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Queue;
import edu.princeton.cs.algs4.Stack;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        StdDraw.setPenColor(Color.red);
        StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        ConvexHullVertex(a);
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.atan2Order());//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [b.length];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        for(int i=0;i<index.length;i++){
            System.out.println(index[i]);
        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@72627c172c336e55a730f439f532b17d@"
"b03611035","0","0.098","105952","@ac2a07740377eb360e805780fb7540fe@import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        StdDraw.setPenColor(Color.red);
        StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        ConvexHullVertex(a);
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.atan2Order());//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [b.length];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        for(int i=0;i<index.length;i++){
            System.out.println(index[i]);
        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@ac2a07740377eb360e805780fb7540fe@"
"b03611035","0","0.53","105696","@ddb7e609528f6e4bac8b9c1b20115619@import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        StdDraw.setPenColor(Color.red);
        StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        ConvexHullVertex(a);
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [b.length];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        for(int i=0;i<index.length;i++){
            System.out.println(index[i]);
        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@ddb7e609528f6e4bac8b9c1b20115619@"
"b03611035","0","0.53","107952","@e0ddd48809251c2c6c9c0a2fe474f1f6@import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //StdDraw.setPenColor(Color.red);
        //StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        ConvexHullVertex(a);
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [b.length];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    //System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@e0ddd48809251c2c6c9c0a2fe474f1f6@"
"r04921012","0","0.53","107952","@b76e7de014b6174dcbbf3c981c9e2e67@
//package myconvexhull;

import edu.princeton.cs.alg4.Point2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */

    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    
                    if (dy1==0 && dy2==0) return 0;
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(edu.princeton.cs.alg4.Point2D[] alg4_a){
        java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x,alg4_a.y) ;
        }
        
        
        boolean[] b=new boolean[a.length];
        double[] x=new double[a.length];
        double[] y=new double[a.length];
        Integer[] yIndex=new Integer [a.length];
        for(int i=0;i<a.length;i++){
            x[i]=a[i].getX();
            y[i]=a[i].getY();
            yIndex[i]=i;
        }

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        


        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(a[0]);
        

        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.index);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2].p);
        st2.push(A[0].index);
        st2.push(A[1].index);
        //st2.push(A[2].index);
        int j=2;
        while (j<a.length){
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) {
        Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);
        //for (int item : v_arr){System.out.println(item);}
    }
    
}

@b76e7de014b6174dcbbf3c981c9e2e67@"
"r04921012","0","0.53","105696","@92d178f977c94ae45d97477617884ab1@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */

    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    
                    if (dy1==0 && dy2==0) return 0;
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] alg4_a){
        java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x(),alg4_a.y()) ;
        }
        
        
        boolean[] b=new boolean[a.length];
        double[] x=new double[a.length];
        double[] y=new double[a.length];
        Integer[] yIndex=new Integer [a.length];
        for(int i=0;i<a.length;i++){
            x[i]=a[i].getX();
            y[i]=a[i].getY();
            yIndex[i]=i;
        }

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        


        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(a[0]);
        

        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.index);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2].p);
        st2.push(A[0].index);
        st2.push(A[1].index);
        //st2.push(A[2].index);
        int j=2;
        while (j<a.length){
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) {
        Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);
        //for (int item : v_arr){System.out.println(item);}
    }
    
}

@92d178f977c94ae45d97477617884ab1@"
"r04921012","0","0.53","107952","@e2d288013f9b3414c88480a40bf1305b@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */

    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    
                    if (dy1==0 && dy2==0) return 0;
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] alg4_a){
        java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x,alg4_a.y) ;
        }
        
        
        boolean[] b=new boolean[a.length];
        double[] x=new double[a.length];
        double[] y=new double[a.length];
        Integer[] yIndex=new Integer [a.length];
        for(int i=0;i<a.length;i++){
            x[i]=a[i].getX();
            y[i]=a[i].getY();
            yIndex[i]=i;
        }

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        


        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(a[0]);
        

        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.index);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2].p);
        st2.push(A[0].index);
        st2.push(A[1].index);
        //st2.push(A[2].index);
        int j=2;
        while (j<a.length){
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) {
        Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);
        //for (int item : v_arr){System.out.println(item);}
    }
    
}

@e2d288013f9b3414c88480a40bf1305b@"
"b03611035","0","0.52","106016","@9ff8327b6e3dfb334c048bd4b6b3e9e7@import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //StdDraw.setPenColor(Color.red);
        //StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        ConvexHullVertex(a);
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [count];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    //System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}
@9ff8327b6e3dfb334c048bd4b6b3e9e7@"
"b03611035","0","0.53","102368","@a6ec1db535d31f2c7b6b9821f934b9ab@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //StdDraw.setPenColor(Color.red);
        //StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        System.out.println(Arrays.toString(ConvexHullVertex(a)));
        
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
        }
        
        int index[]=new int [count];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<b.length;j++){
                if(temp==b[j]){
                    index[i]=j;
                    //System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@a6ec1db535d31f2c7b6b9821f934b9ab@"
"b01502105","0","0.53","107952","@77ee6e177a4170bef2e40caae5523103@
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.Stack;
import static edu.princeton.cs.algs4.MergeX.sort;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point ){
        Stack<Point2D> hull = new Stack<Point2D>();
        int N = point.length;
        Point2D origin[] = new Point2D[N];
        for(int i=0;i<N;i++){
            origin[i] = point[i];
        }
        int a=0;
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(point[i].x(), point[i].y()-5, Integer.toString(i));
//        }

        sort(point, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        point[0].draw();
        sort(point, point[0].polarOrder());
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.CYAN);
//            StdDraw.text(origin[i].x(), origin[i].y()-8, Integer.toString(i));
//        }
        
        hull.push(point[0]);
        hull.push(point[1]); 
        
//        Iterator<Point2D> k = hull.iterator();
//        while (k.hasNext()){
//            Point2D T = k.next();
//            System.out.printf(T.toString()+"" "");
//        }
//        System.out.printf(""\n"");
        
        for(int i=2;i<N;i++){
            Point2D top = hull.pop();
            while ( (Point2D.ccw(hull.peek(),top,point[i])) <= 0 ){
                top = hull.pop();
            }
            hull.push(top);
            hull.push(point[i]);
        }
        int[] index = new int[hull.size()];
        Iterator<Point2D> j = hull.iterator();
        while (j.hasNext()){
            Point2D P = j.next();
//            StdDraw.setPenColor(StdDraw.MAGENTA);
//            P.draw();
            for(int i=0;i<N;i++){
                if(origin[i].equals(P)){
                    index[a]=i;
                    a++;
//                    System.out.printf(i+"" "");
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
    
    public static void main(String[] args) {

        int N = 10;
        Point2D[] point = new Point2D[N];
        
        StdDraw.setCanvasSize(650, 650);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(0.01);
        StdDraw.setPenColor(StdDraw.BLACK);
        
        for(int i=0;i<N;i++){
            double a = StdRandom.uniform(0,100);
            double b = StdRandom.uniform(0,100);
            point[i] = new Point2D(a,b);
            point[i].draw();
            StdDraw.text(a, b-2, ""(""+a+"" , ""+b+"")"");
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a, b-3, Integer.toString(i));
        }
        int[]index = ConvexHullVertex(point);
        System.out.printf(""ConvexHullVertex = "");
        for(int i=0;i<index.length;i++){
            System.out.printf(index[i]+"" "");
        }          
    }  
}
@77ee6e177a4170bef2e40caae5523103@"
"b01502105","0","0.52","106016","@038806e8f0f37a5a0d9f16ffac2c58ad@
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point ){
        Stack<Point2D> hull = new Stack<Point2D>();
        int N = point.length;
        Point2D origin[] = new Point2D[N];
        for(int i=0;i<N;i++){
            origin[i] = point[i];
        }
        int a=0;
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(point[i].x(), point[i].y()-5, Integer.toString(i));
//        }

        sort(point, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        point[0].draw();
        sort(point, point[0].polarOrder());
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.CYAN);
//            StdDraw.text(origin[i].x(), origin[i].y()-8, Integer.toString(i));
//        }
        
        hull.push(point[0]);
        hull.push(point[1]); 
        
//        Iterator<Point2D> k = hull.iterator();
//        while (k.hasNext()){
//            Point2D T = k.next();
//            System.out.printf(T.toString()+"" "");
//        }
//        System.out.printf(""\n"");
        
        for(int i=2;i<N;i++){
            Point2D top = hull.pop();
            while ( (Point2D.ccw(hull.peek(),top,point[i])) <= 0 ){
                top = hull.pop();
            }
            hull.push(top);
            hull.push(point[i]);
        }
        int[] index = new int[hull.size()];
        Iterator<Point2D> j = hull.iterator();
        while (j.hasNext()){
            Point2D P = j.next();
//            StdDraw.setPenColor(StdDraw.MAGENTA);
//            P.draw();
            for(int i=0;i<N;i++){
                if(origin[i].equals(P)){
                    index[a]=i;
                    a++;
//                    System.out.printf(i+"" "");
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
    
    public static void main(String[] args) {

        int N = 10;
        Point2D[] point = new Point2D[N];
        
        StdDraw.setCanvasSize(650, 650);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(0.01);
        StdDraw.setPenColor(StdDraw.BLACK);
        
        for(int i=0;i<N;i++){
            double a = StdRandom.uniform(0,100);
            double b = StdRandom.uniform(0,100);
            point[i] = new Point2D(a,b);
            point[i].draw();
            StdDraw.text(a, b-2, ""(""+a+"" , ""+b+"")"");
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a, b-3, Integer.toString(i));
        }
        int[]index = ConvexHullVertex(point);
        System.out.printf(""ConvexHullVertex = "");
        for(int i=0;i<index.length;i++){
            System.out.printf(index[i]+"" "");
        }          
    }  
}
@038806e8f0f37a5a0d9f16ffac2c58ad@"
"b01502105","5","0.108","107888","@ab30d5e0592b075e905ff950602d3725@
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.Iterator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point ){
        Stack<Point2D> hull = new Stack<Point2D>();
        int N = point.length;
        Point2D origin[] = new Point2D[N];
        for(int i=0;i<N;i++){
            origin[i] = point[i];
        }
        int a=0;
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(point[i].x(), point[i].y()-5, Integer.toString(i));
//        }

        sort(point, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        point[0].draw();
        sort(point, point[0].POLAR_ORDER);
        
//        for(int i=0;i<N;i++){
//            StdDraw.setPenColor(StdDraw.CYAN);
//            StdDraw.text(origin[i].x(), origin[i].y()-8, Integer.toString(i));
//        }
        
        hull.push(point[0]);
        hull.push(point[1]); 
        
//        Iterator<Point2D> k = hull.iterator();
//        while (k.hasNext()){
//            Point2D T = k.next();
//            System.out.printf(T.toString()+"" "");
//        }
//        System.out.printf(""\n"");
        
        for(int i=2;i<N;i++){
            Point2D top = hull.pop();
            while ( (Point2D.ccw(hull.peek(),top,point[i])) <= 0 ){
                top = hull.pop();
            }
            hull.push(top);
            hull.push(point[i]);
        }
        int[] index = new int[hull.size()];
        Iterator<Point2D> j = hull.iterator();
        while (j.hasNext()){
            Point2D P = j.next();
//            StdDraw.setPenColor(StdDraw.MAGENTA);
//            P.draw();
            for(int i=0;i<N;i++){
                if(origin[i].equals(P)){
                    index[a]=i;
                    a++;
//                    System.out.printf(i+"" "");
                }
            }
        }
        Arrays.sort(index);
        return index;
    }
    
    public static void main(String[] args) {

        int N = 10;
        Point2D[] point = new Point2D[N];
        
        StdDraw.setCanvasSize(650, 650);
        StdDraw.setXscale(-20, 120);
        StdDraw.setYscale(-20, 120);
        StdDraw.setPenRadius(0.01);
        StdDraw.setPenColor(StdDraw.BLACK);
        
        for(int i=0;i<N;i++){
            double a = StdRandom.uniform(0,100);
            double b = StdRandom.uniform(0,100);
            point[i] = new Point2D(a,b);
            point[i].draw();
            StdDraw.text(a, b-2, ""(""+a+"" , ""+b+"")"");
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a, b-3, Integer.toString(i));
        }
        int[]index = ConvexHullVertex(point);
        System.out.printf(""ConvexHullVertex = "");
        for(int i=0;i<index.length;i++){
            System.out.printf(index[i]+"" "");
        }          
    }  
}
@ab30d5e0592b075e905ff950602d3725@"
"r04631034","3","0.53","105680","@a0d584f8e55c492347fac37d087dd1a6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

//          public static Point2D[] cotSort(Point2D[] in) {
//
//                    double[] cotan = new double[in.length];
//                    for (int i = 0; i < in.length; i++) {
//                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
////               System.out.println(cotan[i]);
//                    }
//
//                    double temp;
//                    Point2D temp2;
//                    for (int i = 1; i < cotan.length; i++) {
//                              for (int j = i; j > 0; j--) {
//                                        if (cotan[j] < cotan[j - 1]) {
//                                                  temp = cotan[j];
//                                                  cotan[j] = cotan[j - 1];
//                                                  cotan[j - 1] = temp;
//                                                  temp2 = in[j];
//                                                  in[j] = in[j - 1];
//                                                  in[j - 1] = temp2;
//                                        }
//                              }
//                    }
//                    return in;
//          }
//
//          public static double ccwju(Point2D a, Point2D b, Point2D c) {
//                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
//                    if (area2 < 0) {
//                              return -1;
//                    } else if (area2 > 0) {
//                              return +1;
//                    } else {
//                              return 0;
//                    }
//          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(),a[0].y());
                    MergeX.sort(a,p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
                    }
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 50;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                    int[] output;
                    output=MyConvexHull.ConvexHullVertex(a);
                    
                    for(int i =0 ;i< output.length;i++){
                              System.out.print(output[i]+"" "");
                    }
                    
                    
                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    
//
////                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
                    System.out.println("""");
          }

}

@a0d584f8e55c492347fac37d087dd1a6@"
"r04631036","0","0.62","112752","@d75673f41ab85f4ddbe2914639747615@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public void ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
        if (k1 == N) {
            return;        // all points equal
        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        double check = 0;
        assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < N; i++) {
            if (check == pts[i].y()) {
                System.out.printf(""%d"", i);
            }
        }
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@d75673f41ab85f4ddbe2914639747615@"
"b03611035","5","0.098","107936","@a27b58051f809ff816b9dec0525f003f@import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //StdDraw.setPenColor(Color.red);
        //StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        System.out.println(Arrays.toString(ConvexHullVertex(a)));
        
        }
    }
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
       // int count=2;//有幾個vertex，前兩點一定是
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;
      
        for(int i=2;i<b.length;i++){
            
         
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
            }        
        
        int index[]=new int [count];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<a.length;j++){
                if(temp.equals(a[j])){
                    index[i]=j;
                    //System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
    }

}

@a27b58051f809ff816b9dec0525f003f@"
"r04631036","0","0.66","112240","@f89ae7eedad3833f143deba6bd20b85d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new  int[30];
        int count=0;
        
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        double check = 0;
        assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < N; i++) {
            if (check == pts[i].y()) {
                //System.out.printf(""%d"", i);
                back[count]=i;
                count++;
            }
        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@f89ae7eedad3833f143deba6bd20b85d@"
"r04631036","0","0.54","107888","@ac0dd5d203f2cbb9275a4a54f9c37abd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new  int[30];
        int count=0;
        
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < N; i++) {
            if (check == pts[i].y()) {
                //System.out.printf(""%d"", i);
                back[count]=i;
                count++;
            }
        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@ac0dd5d203f2cbb9275a4a54f9c37abd@"
"r04631036","0","0.53","107632","@81dc6576461ae130e7e5f1e838d5d1cb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new  int[30];
        int count=0;
        
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < N; i++) {
            if (check == pts[i].y()) {
                //System.out.printf(""%d"", i);
                back[count]=i;
                count++;
            }
        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@81dc6576461ae130e7e5f1e838d5d1cb@"
"r04631036","0","0.51","107872","@1d3dd7bc6cee471395e23539ea777382@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new  int[30];
        int count=0;
        
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for(int i = 3; i < points.length; ++i) {
			Point2D top = hull.peek();
			Point2D nextToTop = hull.get(hull.size() - 2);
		
			while(Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
				hull.pop();
				top = hull.peek();
				nextToTop = hull.get(hull.size() - 2);
			}
			
			hull.push(points[i]);
		}
	
               // p[0] is first extreme point
//
//        // find index k1 of first point not equal to points[0]
//        int k1;
//        for (k1 = 1; k1 < N; k1++) {
//            if (!points[0].equals(points[k1])) {
//                break;
//            }
//        }
////        if (k1 == N) {
////            return;        // all points equal
////        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++) {
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
//                break;
//            }
//        }
//        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = hull.pop();
//            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
//                top = hull.pop();
//            }
//            hull.push(top);
//            hull.push(points[i]);
//        }
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < N; i++) {
            if (check == pts[i].y()) {
                //System.out.printf(""%d"", i);
                back[count]=i;
                count++;
            }
        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@1d3dd7bc6cee471395e23539ea777382@"
"r04631036","0","0.52","107104","@4aedbbba5e9b101e04f4a718f36e5df3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new  int[30];
        int count=0;
        
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for(int i = 3; i < points.length; ++i) {
			Point2D top = hull.peek();
			Point2D nextToTop = hull.get(hull.size() - 2);
		
			while(Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
				hull.pop();
				top = hull.peek();
				nextToTop = hull.get(hull.size() - 2);
			}
			
			hull.push(points[i]);
		}
	
               // p[0] is first extreme point
//
//        // find index k1 of first point not equal to points[0]
//        int k1;
//        for (k1 = 1; k1 < N; k1++) {
//            if (!points[0].equals(points[k1])) {
//                break;
//            }
//        }
////        if (k1 == N) {
////            return;        // all points equal
////        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++) {
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
//                break;
//            }
//        }
//        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = hull.pop();
//            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
//                top = hull.pop();
//            }
//            hull.push(top);
//            hull.push(points[i]);
//        }
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
        }
        for (int i = 0; i < hull.size(); i++) {
            if (check == pts[hull.size()-i-1].y()) {
                //System.out.printf(""%d"", i);
                back[count]=i;
                count++;
            }
        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@4aedbbba5e9b101e04f4a718f36e5df3@"
"r04631036","0","0.53","102912","@800520dc0a9ed93c9e4e11e812f203e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
        int[] back = new int[30];
        int count = 0;

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for (int i = 3; i < points.length; ++i) {
            Point2D top = hull.peek();
            Point2D nextToTop = hull.get(hull.size() - 2);

            while (Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
                hull.pop();
                top = hull.peek();
                nextToTop = hull.get(hull.size() - 2);
            }

            hull.push(points[i]);
        }

        // p[0] is first extreme point
//
//        // find index k1 of first point not equal to points[0]
//        int k1;
//        for (k1 = 1; k1 < N; k1++) {
//            if (!points[0].equals(points[k1])) {
//                break;
//            }
//        }
////        if (k1 == N) {
////            return;        // all points equal
////        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++) {
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
//                break;
//            }
//        }
//        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = hull.pop();
//            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
//                top = hull.pop();
//            }
//            hull.push(top);
//            hull.push(points[i]);
//        }
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();

            for (int i = 0; i < N; i++) {
                if (check == pts[i].y()) {
                    //System.out.printf(""%d"", i);
                    back[count] = i;
                    count++;
                }
            }

        }
        return back;
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@800520dc0a9ed93c9e4e11e812f203e3@"
"r04631036","0","0","0","@e83a4caf874c8019ea96bd8a08eb9f95@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
 
        int count = 0;

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for (int i = 3; i < points.length; ++i) {
            Point2D top = hull.peek();
            Point2D nextToTop = hull.get(hull.size() - 2);

            while (Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
                hull.pop();
                top = hull.peek();
                nextToTop = hull.get(hull.size() - 2);
            }

            hull.push(points[i]);
        }
        int[] back = new int[hull.size()];
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
            for (int i = 0; i < N; i++) {
                if (check == pts[i].y()) {
                    //System.out.printf(""%d"", i);
                    back[hull.size()-1-count] = i;
                    count++;
                }
            }

        }
        return back;
    }


    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@e83a4caf874c8019ea96bd8a08eb9f95@"
"r04631036","0","0.5","107184","@693bd1c3da45ca3bb787d27f53792b5d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {
 
        int count = 0;

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for (int i = 3; i < points.length; ++i) {
            Point2D top = hull.peek();
            Point2D nextToTop = hull.get(hull.size() - 2);

            while (Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
                hull.pop();
                top = hull.peek();
                nextToTop = hull.get(hull.size() - 2);
            }

            hull.push(points[i]);
        }
        int[] back = new int[hull.size()];
        double check = 0;
        //assert isConvex();
        while (!hull.isEmpty()) {
            check = hull.pop().y();
            for (int i = 0; i < N; i++) {
                if (check == pts[i].y()) {
                    //System.out.printf(""%d"", i);
                    //back[hull.size()-1-count] = i;
                    count++;
                }
            }

        }
        return back;
    }


    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@693bd1c3da45ca3bb787d27f53792b5d@"
"r04631036","0","0.2","103440","@28ce951921fd19eac186928d31beecd7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author Arthur
 */
//public class MyConvexHull {
//
//    private void ConvexHullVertex(Point2D a[]) {
//        int N = a.length;
//        Point2D[] classpoint = new Point2D[N + 1];
//
//    }
//    void swap(Point2D a, Point2D b)
//    {
//        
//    }
//    /**
//     * @param args the command line arguments
//     */
//    public static void main(String[] args) {
//        
//        int n = 10;
//        Point2D[] point = new Point2D[n];
//
//        for (int i = 0; i < n; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        double[] num;
//        num = new double[10];
//        for (int i = 0; i < n; i++) {
//            num[i] = point[i].y();
//            System.out.printf(""\n%f"", num[i]);
//
//        }
//        int minindex=-1;
//        double min=1;
//        for(int i=0;i<n;i++)
//        {
//            if(num[i]< min){
//                min=num[i];
//                minindex=i;
//            }
//        }
//        System.out.printf(""\nmin=%f\nminindex=%d"", min,minindex);
//        swap(point[1],point[minindex]);
//        Arrays.sort(point, point[1].polarOrder());
//        // TODO code application logic here
//    }
//
//}
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points, Point2D.Y_ORDER);
        hull.push(points[0]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        //Arrays.sort(points, points[0].POLAR_ORDER);
        Arrays.sort(points, points[0].POLAR_ORDER);
        hull.push(points[1]);
        hull.push(points[2]);
        for (int i = 3; i < points.length; ++i) {
            Point2D top = hull.peek();
            Point2D nextToTop = hull.get(hull.size() - 2);

            while (Point2D.ccw(points[i], nextToTop, top) >= 0 && hull.size() >= 3) {
                hull.pop();
                top = hull.peek();
                nextToTop = hull.get(hull.size() - 2);
            }

            hull.push(points[i]);
        }
        int[] back = new int[hull.size()];
        double check = 0;
        int count = 0;
        //assert isConvex();
        while (count<hull.size()) {
            check = hull.pop().y();
            for (int i = 0; i < N; i++) {
                if (check == pts[i].y()) {
                    //System.out.printf(""%d"", i);
                    back[hull.size() - 1 - count] = i;
                    count++;
                }
            }

        }
        return back;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@28ce951921fd19eac186928d31beecd7@"
"r04921028","0","0","0","@5737bd5b892839a653e84f6e65f520a9@public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           Point2D[] points = new Point2D[N];
           for(int i=0;i<N;i++){
               points[i] = new Point2D(a[pindex[i]].x(), a[pindex[i]].y());
           }
           for(int i=0;i<pindex.length;i++){
               pindex[i] = i;
           }
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(points[p1],points[p2],points[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(points[p1],points[p2],points[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-1;
            int convexsize =  convexpoint.size(); 
            
            int index[];
            index = new int[convexpoint.size()];
           
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }
@5737bd5b892839a653e84f6e65f520a9@"
"r04921028","0","0.51","105984","@45badbf60e64fd1c46cd24be290ce2b5@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           Point2D[] points = new Point2D[N];
           for(int i=0;i<N;i++){
               points[i] = new Point2D(a[pindex[i]].x(), a[pindex[i]].y());
           }
           for(int i=0;i<pindex.length;i++){
               pindex[i] = i;
           }
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(points[p1],points[p2],points[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(points[p1],points[p2],points[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-1;
            int convexsize =  convexpoint.size(); 
            
            int index[];
            index = new int[convexpoint.size()];
           
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            return index;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    
}

@45badbf60e64fd1c46cd24be290ce2b5@"
"r04921028","0","0.49","106032","@2929585ddf572556c1df441782769db8@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           Point2D[] points = new Point2D[N];
           for(int i=0;i<N;i++){
               points[i] = new Point2D(a[pindex[i]].x(), a[pindex[i]].y());
           }
           for(int i=0;i<pindex.length;i++){
               pindex[i] = i;
           }
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(points[p1],points[p2],points[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(points[p1],points[p2],points[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-1;
            int convexsize =  convexpoint.size(); 
            
            int index[];
            index = new int[convexpoint.size()];
           
            while(convexpoint.size()!=1){
                index[counter] = convexpoint.pop();
                counter--;
            }
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    
}

@2929585ddf572556c1df441782769db8@"
"r04921028","0","0.52","107920","@2c31fff545bc6b98631eb1c3014839f2@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           Point2D[] points = new Point2D[N];
           for(int i=0;i<N;i++){
               points[i] = new Point2D(a[pindex[i]].x(), a[pindex[i]].y());
           }
           for(int i=0;i<pindex.length;i++){
               pindex[i] = i;
           }
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(points[p1],points[p2],points[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(points[p1],points[p2],points[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args) {
           int N = 20;
           
           Point2D[] a = new Point2D[N];

           for(int i =0;i<N;i++){
               double x = StdRandom.uniform(20,99);
               double y = StdRandom.uniform(20,99);
               a[i] = new Point2D(x, y);
           }
           
           int index[] = ConvexHullVertex(a);
           
           for(int i=0;i<index.length;i++){
               System.out.println(index[i]);
           }
           
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    
}

@2c31fff545bc6b98631eb1c3014839f2@"
"b03611015","0","0.52","107920","@46f3e2dcbeae52cc59a8ca655baa5ddb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public void ConvexHullVertix(int N){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        int n = 0;        
        for(int i=0;i<N;i++){
        if(hull.pop()==a[i])
            b[n]=a[i];
        n++;
        
        }
    

}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
        
        // TODO code application logic here
    }


@46f3e2dcbeae52cc59a8ca655baa5ddb@"
"b03611015","0","0.62","110816","@2c17ad930f7b7e53f802b4380f9b60fa@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public void ConvexHullVertix(int N){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        int n = 0;        
        for(int i=0;i<N;i++){
        if(hull.pop()==a[i])
            b[n]=a[i];
        n++;
        
        }
    return;

}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@2c17ad930f7b7e53f802b4380f9b60fa@"
"b03611015","0","0.29","105888","@1b0d2571cafbf474777cd046347c298f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public Point2D[] ConvexHullVertix(int N){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        int n = 0;        
        for(int i=0;i<N;i++){
        if(hull.pop()==a[i])
            b[n]=a[i];
        n++;
        
        }
    return b;

}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@1b0d2571cafbf474777cd046347c298f@"
"r04631034","0","0","0","@6060e43c6eb5cea3b1c979b9a7da9d36@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

//          public static Point2D[] cotSort(Point2D[] in) {
//
//                    double[] cotan = new double[in.length];
//                    for (int i = 0; i < in.length; i++) {
//                              cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
////               System.out.println(cotan[i]);
//                    }
//
//                    double temp;
//                    Point2D temp2;
//                    for (int i = 1; i < cotan.length; i++) {
//                              for (int j = i; j > 0; j--) {
//                                        if (cotan[j] < cotan[j - 1]) {
//                                                  temp = cotan[j];
//                                                  cotan[j] = cotan[j - 1];
//                                                  cotan[j - 1] = temp;
//                                                  temp2 = in[j];
//                                                  in[j] = in[j - 1];
//                                                  in[j - 1] = temp2;
//                                        }
//                              }
//                    }
//                    return in;
//          }
//
//          public static double ccwju(Point2D a, Point2D b, Point2D c) {
//                    double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
//                    if (area2 < 0) {
//                              return -1;
//                    } else if (area2 > 0) {
//                              return +1;
//                    } else {
//                              return 0;
//                    }
//          }

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              if(!map.containsValue(a[i])){
                              map.put(a[i].y(), i);
                              }
                              else{
                                        map.put(a[i].y() , map.get(a[i].y()));
                              }
//                              System.out.println(""a[i]      ""+a[i].y()+""        key       ""+i);
                    }
//                    System.out.println(""check     ""+map.get(a[0].y()));
                    
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    Point2D p = new Point2D(a[0].x(),a[0].y());
                    MergeX.sort(a,a[0].POLAR_ORDER);

                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
                              if (count == 0) {
                                        StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                              } else {
                                        StdDraw.setPenColor(StdDraw.BLACK);
                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                                        String str = String.valueOf(count);
                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                                        StdDraw.setPenColor(StdDraw.YELLOW);
                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
                              }
                    }                    
                    
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                                                                StdDraw.setPenColor(StdDraw.GREEN);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                                                               StdDraw.setPenColor(StdDraw.RED);
                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.print(""y            "" +a[storge.get(count)].y()+""           "");
                              System.out.print(storge.get(count)+"" "");
//                              System.out.println( map.get(a[storge.get(count)].y()));
//                              System.out.println("""");
                    }
                    System.out.println("""");
                    return output;
          }
          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 100;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
                    int[] output;
                    output=MyConvexHull.ConvexHullVertex(a);
                    
                    for(int i =0 ;i< output.length;i++){
                              System.out.print(output[i]+"" "");
                    }
                    
                    
                    

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    
//
////                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
                    System.out.println("""");
          }

}

@6060e43c6eb5cea3b1c979b9a7da9d36@"
"b03611015","0","0","0","@19c4af47de94be65f22d91f4696d0136@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            a[i].draw();
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[m] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[m]==a[N])
                    c[m] = N;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@19c4af47de94be65f22d91f4696d0136@"
"b03611015","0","0","0","@04e38999c26c72d7421e9c1fc2da7209@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        int small = 0;
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[m] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[m]==a[N])
                    c[m] = N;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@04e38999c26c72d7421e9c1fc2da7209@"
"b03611015","0","0","0","@6fff8cb936de297ee1d54a153bb6e4ae@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[m] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[m]==d[N])
                    c[m] = N;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@6fff8cb936de297ee1d54a153bb6e4ae@"
"b03611015","0","0","0","@573b0239eeb1b268a612a23e4faa0b50@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[m] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[m]==d[N])
                    c[m] = N;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@573b0239eeb1b268a612a23e4faa0b50@"
"b03611015","0","0.52","108048","@a0505887fbae9051e89692ac82e2571a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i]==d[j])
                    c[i] = N;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@a0505887fbae9051e89692ac82e2571a@"
"b03611015","0","0.53","107728","@663bae67d3922931764947910a71fa2d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i]==d[j])
                    c[i] = j;
            }
        }
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@663bae67d3922931764947910a71fa2d@"
"b03611015","0","0.53","106144","@8ee976a83f7a4e29771011600190faa7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i]==d[j])
                    c[i] = j;
            }
        }
       Arrays.sort(c);
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@8ee976a83f7a4e29771011600190faa7@"
"b03611015","0","0.41","102448","@6db23fbb58720715fd42a0b48fa5879b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i]==d[j])
                    c[i] = j;
            }
        }
       Arrays.sort(c);
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@6db23fbb58720715fd42a0b48fa5879b@"
"r04921028","0","0.51","105952","@0fedba3d063f097501ea33e1c3203250@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           Point2D[] points = new Point2D[N];
           for(int i=0;i<N;i++){
               points[i] = new Point2D(a[pindex[i]].x(), a[pindex[i]].y());
           }
           for(int i=0;i<pindex.length;i++){
               pindex[i] = i;
           }
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(points[p1],points[p2],points[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(points[p1],points[p2],points[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(points[index[o-1]].x()/100, points[index[o-1]].y()/100,points[index[o]].x()/100, points[index[o]].y()/100); 
//            }
//            StdDraw.line(points[index[convexsize-1]].x()/100, points[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(points[index[0]].x()/100,points[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args) {
           int N = 20;
           
           Point2D[] a = new Point2D[N];

           for(int i =0;i<N;i++){
              double x = StdRandom.uniform(20,99);
              double y = StdRandom.uniform(20,99);
              a[i] = new Point2D(x, y);
              StdDraw.setPenRadius(0.01);
              StdDraw.setPenColor(StdDraw.BLUE);
              StdDraw.point(a[i].x()/100,a[i].y()/100);
           }
           
           
           int index[] = ConvexHullVertex(a);
           
           for(int i=0;i<index.length;i++){
               System.out.println(index[i]);
           }
           
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    
}

@0fedba3d063f097501ea33e1c3203250@"
"b03611015","1","0.52","108016","@e3230466589efd6bde6a9520dff8c53e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            
        }
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i].equals(d[j]))
                    c[i] = j;
            }
        }
       Arrays.sort(c);
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@e3230466589efd6bde6a9520dff8c53e@"
"b03611015","5","0.1","107872","@ae96007b74d6d25390f9b5d998ca48d4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Point2D> hull = new Stack<>();
        
        int N = a.length;
        Point2D[] d = new Point2D[N];
       
        for(int i=0; i<N ;i++){
            d[i] = a[i];
        }
        /*for(int i = 0; i<N; i++){
            if(a[small].compareTo(a[i]) == 1)
                small = i;
        }
        Point2D p = a[small];
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        a[small].draw();
        
         StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLACK);
        Arrays.sort(a, p.atan2Order());
        for (int i = 0; i < N; i++) {
            p.drawTo(a[i]);
            StdDraw.show(1000);
        }
       */
        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);
        
        for(int i=2; i<N; i++){
        Point2D top = hull.pop();
        while(Point2D.ccw(hull.peek(),top,a[i])<=0)
            top = hull.pop();
        hull.push(top);
        hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b =new Point2D[m];
        for(int i=0;i<m;i++){
        b[i] = hull.pop();
        }
        int[] c = new int[m];
        for(int i=0;i<m;i++){
            for(int j=0;j<N;j++)
            {
                if(b[i].equals(d[j]))
                    c[i] = j;
            }
        }
       Arrays.sort(c);
   return c;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        
        }
    }


@ae96007b74d6d25390f9b5d998ca48d4@"
"r04921028","5","0.102","107872","@74d3e2a9ccd7c2bb5eda6355f7d10f99@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args) {
           int N = 20;
           
           Point2D[] a = new Point2D[N];

           for(int i =0;i<N;i++){
              double x = StdRandom.uniform(20,99);
              double y = StdRandom.uniform(20,99);
              a[i] = new Point2D(x, y);
              StdDraw.setPenRadius(0.01);
              StdDraw.setPenColor(StdDraw.BLUE);
              StdDraw.point(a[i].x()/100,a[i].y()/100);
           }
           
           
           int index[] = ConvexHullVertex(a);
           
           for(int i=0;i<index.length;i++){
               System.out.println(index[i]);
           }
           
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    
}

@74d3e2a9ccd7c2bb5eda6355f7d10f99@"
"r04631036","0","0.52","108016","@29fe299d817f914d9889f607049b7699@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(pts, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                //System.out.printf(""index= %d\n"",ans[i]);
            }
            
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
        Point2D[] a = new Point2D[10];
        a[0] = new Point2D(0.444732, 0.870521);
        a[1] = new Point2D(0.542629, 0.928699);
        a[2] = new Point2D(0.437711, 0.518879);
        a[3] = new Point2D(0.331491, 0.709862);
        a[4] = new Point2D(0.075244, 0.825623);
        a[5] = new Point2D(0.078116, 0.931341);
        a[6] = new Point2D(0.386513, 0.516805);
        a[7] = new Point2D(0.235063, 0.145878);
        a[8] = new Point2D(0.126400, 0.103314);
        a[9] = new Point2D(0.305495, 0.779383);
        MyConvexHull mch;
        mch = new MyConvexHull();
        int[] ans;
        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@29fe299d817f914d9889f607049b7699@"
"r04631036","0","0.48","107776","@3fb87903a819adaf179a3377d84e752c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(pts, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                //System.out.printf(""index= %d\n"",ans[i]);
            }
            
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
        Point2D[] a = new Point2D[10];
        a[0] = new Point2D(0.444732, 0.870521);
        a[1] = new Point2D(0.542629, 0.928699);
        a[2] = new Point2D(0.437711, 0.518879);
        a[3] = new Point2D(0.331491, 0.709862);
        a[4] = new Point2D(0.075244, 0.825623);
        a[5] = new Point2D(0.078116, 0.931341);
        a[6] = new Point2D(0.386513, 0.516805);
        a[7] = new Point2D(0.235063, 0.145878);
        a[8] = new Point2D(0.126400, 0.103314);
        a[9] = new Point2D(0.305495, 0.779383);
        MyConvexHull mch;
        mch = new MyConvexHull();
        int[] ans;
        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@3fb87903a819adaf179a3377d84e752c@"
"r04631036","0","0.51","107824","@1755462f316e7c74d86d1dd90e44685b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(pts, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                //System.out.printf(""index= %d\n"",ans[i]);
            }
            
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.444732, 0.870521);
//        a[1] = new Point2D(0.542629, 0.928699);
//        a[2] = new Point2D(0.437711, 0.518879);
//        a[3] = new Point2D(0.331491, 0.709862);
//        a[4] = new Point2D(0.075244, 0.825623);
//        a[5] = new Point2D(0.078116, 0.931341);
//        a[6] = new Point2D(0.386513, 0.516805);
//        a[7] = new Point2D(0.235063, 0.145878);
//        a[8] = new Point2D(0.126400, 0.103314);
//        a[9] = new Point2D(0.305495, 0.779383);
//        MyConvexHull mch;
//        mch = new MyConvexHull();
//        int[] ans;
//        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@1755462f316e7c74d86d1dd90e44685b@"
"r04228002","0","0.48","107776","@808f895cc8ad0adf3b9381c7a58e948e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import java.util.Arrays;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.polarOrder());
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        int N=10;
        Point2D[] a = new Point2D[N];
        edu.princeton.cs.algs4.StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = edu.princeton.cs.algs4.StdRandom.uniform();
            Double y = edu.princeton.cs.algs4.StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        System.out.println(Arrays.toString(R));
    }
    
}

@808f895cc8ad0adf3b9381c7a58e948e@"
"r04631036","0","0.49","107488","@9fd9d10524ca992ae05381b94aeb0f40@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[k]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(pts, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                //System.out.printf(""index= %d\n"",ans[i]);
            }
            Arrays.sort(ans);
            //System.out.printf(""index= %d\n"",ans[0]);
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
        Point2D[] a = new Point2D[10];
        a[0] = new Point2D(0.444732, 0.870521);
        a[1] = new Point2D(0.542629, 0.928699);
        a[2] = new Point2D(0.437711, 0.518879);
        a[3] = new Point2D(0.331491, 0.709862);
        a[4] = new Point2D(0.075244, 0.825623);
        a[5] = new Point2D(0.078116, 0.931341);
        a[6] = new Point2D(0.386513, 0.516805);
        a[7] = new Point2D(0.235063, 0.145878);
        a[8] = new Point2D(0.126400, 0.103314);
        a[9] = new Point2D(0.305495, 0.779383);
        MyConvexHull mch;
        mch = new MyConvexHull();
        int[] ans;
        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@9fd9d10524ca992ae05381b94aeb0f40@"
"r04631036","3","0.49","107552","@531abb9132d6921265eefe2941f98ba9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(back, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
//                System.out.printf(""index= %d\n"",ans[i]);
            }
            Arrays.sort(ans);
//            System.out.printf(""index= %d\n"",ans[0]);
//            System.out.printf(""index= %d\n"",ans[1]);
//            System.out.printf(""index= %d\n"",ans[2]);
//            System.out.printf(""index= %d\n"",ans[3]);
//            System.out.printf(""index= %d\n"",ans[4]);
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.595326  ,   0.062890);
//        a[1] = new Point2D(0.754087  ,   0.057540);
//        a[2] = new Point2D(0.903658  ,   0.032424);
//        a[3] = new Point2D(0.028545  ,   0.994687);
//        a[4] = new Point2D(0.082879  ,   0.460256);
//        a[5] = new Point2D(0.315884  ,   0.953245);
//        a[6] = new Point2D(0.272979  ,   0.399204);
//        a[7] = new Point2D(0.018311  ,   0.472975);
//        a[8] = new Point2D(0.934912  ,   0.672799);
//        a[9] = new Point2D(0.117296  ,   0.071147);
//        MyConvexHull mch;
//        mch = new MyConvexHull();
//        int[] ans;
//        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@531abb9132d6921265eefe2941f98ba9@"
"r04631036","0","0.55","107520","@1ddf8c9c2ce0ea863985befe708cf429@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; i++) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(back, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                System.out.printf(""index= %d\n"",ans[i]);
            }
            Arrays.sort(ans);
//            System.out.printf(""index= %d\n"",ans[0]);
//            System.out.printf(""index= %d\n"",ans[1]);
//            System.out.printf(""index= %d\n"",ans[2]);
//            System.out.printf(""index= %d\n"",ans[3]);
//            System.out.printf(""index= %d\n"",ans[4]);
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } 
//        else if (pts.length <= 1) {
//            return null;
//        } else {
//            return null;
//        }
        return null;
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200,0.250);
//        a[1] = new Point2D(0.147,0.387);
//        a[2] = new Point2D(0.300 ,0.300);
//        a[3] = new Point2D(0.333,0.213);
//        a[4] = new Point2D(0.353,0.412);
//        a[5] = new Point2D(0.700,0.890);
//        a[6] = new Point2D(0.879,0.700);
//        a[7] = new Point2D(0.867,0.888);
//        a[8] = new Point2D(0.980,0.120);
//        a[9] = new Point2D(0.111,0.932);
//        MyConvexHull mch;
//        mch = new MyConvexHull();
//        int[] ans;
//        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@1ddf8c9c2ce0ea863985befe708cf429@"
"r04631036","0","0.5","107840","@c7d745015988174e64c09060bd0e9290@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; ++i) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(back, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                System.out.printf(""index= %d\n"",ans[i]);
            }
            Arrays.sort(ans);
//            System.out.printf(""index= %d\n"",ans[0]);
//            System.out.printf(""index= %d\n"",ans[1]);
//            System.out.printf(""index= %d\n"",ans[2]);
//            System.out.printf(""index= %d\n"",ans[3]);
//            System.out.printf(""index= %d\n"",ans[4]);
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200,0.250);
//        a[1] = new Point2D(0.147,0.387);
//        a[2] = new Point2D(0.300 ,0.300);
//        a[3] = new Point2D(0.333,0.213);
//        a[4] = new Point2D(0.353,0.412);
//        a[5] = new Point2D(0.700,0.890);
//        a[6] = new Point2D(0.879,0.700);
//        a[7] = new Point2D(0.867,0.888);
//        a[8] = new Point2D(0.980,0.120);
//        a[9] = new Point2D(0.111,0.932);
//        Point2D[] point = new Point2D[10];
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        MyConvexHull mch;
//        mch = new MyConvexHull();
//        int[] ans;
//        ans = mch.ConvexHullVertex(point);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@c7d745015988174e64c09060bd0e9290@"
"r04631036","3","0.5","105984","@ead2d6d8a5c33f808410004eb4807cff@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        if (pts.length > 1) {
            int n = pts.length, k = 0;
            Point2D[] back = new Point2D[2 * n];
            Arrays.sort(pts);
            for (int i = 0; i < n; ++i) {
                while (k >= 2 && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && Point2D.ccw(back[k - 2], back[k - 1], pts[i]) <= 0) {
                    k--;
                }
                back[k++] = pts[i];
            }
            if (k > 1) {
                back = Arrays.copyOfRange(back, 0, k - 1);
            }
            ans = new int[back.length];
            //System.out.printf(""size= %f\n"", back[4].y());
            for (int i = 0; i < back.length; i++) {
                for (int j = 0; j < points.length; j++) {
                    if (back[i].y() == points[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
//                System.out.printf(""index= %d\n"",ans[i]);
            }
            Arrays.sort(ans);
//            System.out.printf(""index= %d\n"",ans[0]);
//            System.out.printf(""index= %d\n"",ans[1]);
//            System.out.printf(""index= %d\n"",ans[2]);
//            System.out.printf(""index= %d\n"",ans[3]);
//            System.out.printf(""index= %d\n"",ans[4]);
            return ans;
//            for (int i = 0; i < back.length; i++) {
//                System.out.printf(""%f , "", back[i].y());
//            }

        } else if (pts.length <= 1) {
            return null;
        } else {
            return null;
        }
    }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
// points[0] is an extreme point of the convex hull
// (alternatively, could do easily in linear time)
//Arrays.sort(points, Point2D.Y_ORDER);
//                        for (int i = 0; i < N; i++) {
//            System.out.printf(""%f , "" ,points[i].y());
//        }
//hull.push(points[0]);
// sort by polar angle with respect to base point points[0],
// breaking ties by distance to points[0]
//Arrays.sort(points, points[0].POLAR_ORDER);
//        Arrays.sort(points, points[0].POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            StdDraw.text(points[i].x() - 0.02, points[i].y() + 0.02, Integer.toString(i));
//        }
    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200,0.250);
//        a[1] = new Point2D(0.147,0.387);
//        a[2] = new Point2D(0.300 ,0.300);
//        a[3] = new Point2D(0.333,0.213);
//        a[4] = new Point2D(0.353,0.412);
//        a[5] = new Point2D(0.700,0.890);
//        a[6] = new Point2D(0.879,0.700);
//        a[7] = new Point2D(0.867,0.888);
//        a[8] = new Point2D(0.980,0.120);
//        a[9] = new Point2D(0.111,0.932);
//        Point2D[] point = new Point2D[10];
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            point[i] = new Point2D(x, y);
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.005);
//            System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
//        MyConvexHull mch;
//        mch = new MyConvexHull();
//        int[] ans;
//        ans = mch.ConvexHullVertex(a);
//        int N = StdIn.readInt();
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdIn.readInt();
//            int y = StdIn.readInt();
//            points[i] = new Point2D(x, y);
//        }
//        MyConvexHull graham = new MyConvexHull(points);
//        for (Point2D p : graham.hull())
//            StdOut.println(p);
    }

}

@ead2d6d8a5c33f808410004eb4807cff@"
"r04228002","2","0.53","103936","@11711d32a7f216e4b41e6bf10c709a2b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.POLAR_ORDER);
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        /*
        int N=10;
        Point2D[] a = new Point2D[N];
        StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = StdRandom.uniform();
            Double y = StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        System.out.println(Arrays.toString(R));
        */
    }
    
}

@11711d32a7f216e4b41e6bf10c709a2b@"
"r04228002","2","0.52","106000","@11711d32a7f216e4b41e6bf10c709a2b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.POLAR_ORDER);
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        /*
        int N=10;
        Point2D[] a = new Point2D[N];
        StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = StdRandom.uniform();
            Double y = StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        System.out.println(Arrays.toString(R));
        */
    }
    
}

@11711d32a7f216e4b41e6bf10c709a2b@"
"r04631021","0","0.5","105984","@bad43adbf82c54fb2b799a4d49bb3059@import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.polarOrder()) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         //此時temp2為第一個出去的點
         
         System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.polarOrder()) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.polarOrder()) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2) ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y();
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         convexhullvertex ++;
                         System.out.println(theta) ;                         
                         System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         return convexhullvertex ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            StdDraw.setPenRadius(0.01) ;
            points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    StdDraw.setPenRadius(0.001) ;
                    points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
                if(points[count].compareTo(points[i])==1){
                }
            }
            //System.out.println(uf.find(count));
            count ++ ;
        }
        
        System.out.print(ConvexHullVertex(points)) ;*/
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        /*}
        catch(IOException e){
            System.out.println(""error!"");
        }*/
        // TODO code application logic here
    }
    
}

@bad43adbf82c54fb2b799a4d49bb3059@"
"r04228002","5","0.104","105760","@dc9c27ec62472d0b58407cf31d05f938@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.awt.Color;
import java.util.Arrays;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        if (N==1){
            int[] IndexList=new int[1];
            IndexList[0]=0;
            return(IndexList);
        }
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.POLAR_ORDER);
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            while(CCW!=1){
                Second=First;
                First=CHP.pop();
                CCW=Point2D.ccw(First, Second, CurrentP);
            }
            CHP.push(First);
            CHP.push(Second);
            CHP.push(CurrentP);
            /*
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            else if (CCW==-1){
                
            }
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            */
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        /*
        int N=1;
        Point2D[] a = new Point2D[N];
        StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = StdRandom.uniform();
            Double y = StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        
        System.out.println(Arrays.toString(R));
        
        int RR=R.length;
        
        int done = 0;
        for (int i=0;i<N;i++){
            for (int j =0;j<RR;j++){
                if (i==R[j]){
                    StdDraw.setPenColor(Color.red);
                    StdDraw.circle(a[i].x(), a[i].y(), 0.01);
                    done=1;
                    break;
                }
                
            }
            if (done==0){
                StdDraw.setPenColor(Color.black);
                StdDraw.circle(a[i].x(), a[i].y(), 0.01);
            }
            done=0;
        }
        */
        
        
    }
    
}

@dc9c27ec62472d0b58407cf31d05f938@"
"r04631036","0","0.51","110064","@5659fb21913ac86b2d9bac1a32c0da2a@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
        System.out.printf(""hull size=%d\n"", hull.size());
         for (int i = 0; i < ans.length; i++) {
             double check =0;
             check=hull.pop().y();
             //System.out.printf(""check=%f\n"", check);
                for (int j = 0; j < points.length; j++) {
                    if (check == pts[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                System.out.printf(""index= %d\n"",ans[i]);

            }
                         Arrays.sort(ans);
                         for(int i=0;i<ans.length;i++)
                System.out.printf(""\nindex= %d\n"",ans[i]);
                         return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.932);
//        MyConvexHull graham = new MyConvexHull();
//        graham.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@5659fb21913ac86b2d9bac1a32c0da2a@"
"r04631036","0","0.51","110064","@09459974cfb7e09daf3e29faf17820ab@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    public static Stack<Point2D> hull = new Stack<Point2D>();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
        System.out.printf(""hull size=%d\n"", hull.size());
         for (int i = 0; i < ans.length; i++) {
             double check =0;
             check=hull.pop().y();
             //System.out.printf(""check=%f\n"", check);
                for (int j = 0; j < points.length; j++) {
                    if (check == pts[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                System.out.printf(""index= %d\n"",ans[i]);

            }
                         Arrays.sort(ans);
                         for(int i=0;i<ans.length;i++)
                System.out.printf(""\nindex= %d\n"",ans[i]);
                         return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.932);
//        MyConvexHull graham = new MyConvexHull();
//        graham.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@09459974cfb7e09daf3e29faf17820ab@"
"r04631036","0","0.51","107840","@abeee9a4044496a381129a58a7a1b07c@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private  static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);
        
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
        System.out.printf(""hull size=%d\n"", hull.size());
         for (int i = 0; i < ans.length; i++) {
             double check =0;
             check=hull.pop().y();
             //System.out.printf(""check=%f\n"", check);
                for (int j = 0; j < points.length; j++) {
                    if (check == pts[j].y()) {
                        //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                        ans[i] = j;
                    }
                }
                
                System.out.printf(""index= %d\n"",ans[i]);

            }
                         Arrays.sort(ans);
                         for(int i=0;i<ans.length;i++)
                System.out.printf(""\nindex= %d\n"",ans[i]);
                         return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.932);
//        MyConvexHull graham = new MyConvexHull();
//        graham.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@abeee9a4044496a381129a58a7a1b07c@"
"r04921105","0","0.53","103840","@8c86d32be8e60d199c2ff0cb99db6488@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         point = a;
         
         Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(a, p.Y_ORDER);
         
         Arrays.sort(a, a[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(a[p0],a[p1],a[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[a.length];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       for(int x=0;x<s;x++){
           //System.out.println(result[x]);
           
       }
     
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
*/
              ConvexHullVertex(points);
             
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@8c86d32be8e60d199c2ff0cb99db6488@"
"r04921105","0","0.53","107920","@8e685af41650968ff03bbe125fd4a8f6@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         point = a;
         
         Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(a, p.Y_ORDER);
         
         Arrays.sort(a, a[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(a[p0],a[p1],a[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           System.out.println(array[x]);
           
       }
       int[] result =new int[a.length];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(a[array[i]].equals(point[j])){
                   result[i]=j;
                }
           }
       }
       for(int x=0;x<s;x++){
           System.out.println(result[x]);
           
       }
     
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
*/
              ConvexHullVertex(points);
             
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@8e685af41650968ff03bbe125fd4a8f6@"
"r04921105","0","0.52","107856","@8d668ab874f059c53816c152ca0f0c33@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(point, p.Y_ORDER);
         
         Arrays.sort(point, point[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[a.length];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       for(int x=0;x<s;x++){
          // System.out.println(result[x]);
           
       }
     
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
*/
              ConvexHullVertex(points);
             
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@8d668ab874f059c53816c152ca0f0c33@"
"r04921105","0","0.53","107904","@4cc42ada009d411d564814b16e710a82@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(point, p.Y_ORDER);
         
         Arrays.sort(point, point[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[a.length];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       for(int x=0;x<s;x++){
           //System.out.println(result[x]);
           
       }
     
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
*/
             int[] result = ConvexHullVertex(points);
             
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@4cc42ada009d411d564814b16e710a82@"
"r04921105","5","0.106","107632","@c49cc328f265664efb5f6b88b193eef4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
       int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
       
    }

    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
*/
             int[] result = ConvexHullVertex(points);
             
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@c49cc328f265664efb5f6b88b193eef4@"
"r04631036","3","0.52","107872","@a268637c9888634e53a904516896d5f2@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < points.length; j++) {
                if (check == pts[j].y()) {
                    //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                    ans[i] = j;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
        Arrays.sort(ans);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.printf(""\nindex= %d"", ans[i]);
//        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    // check that boundary of hull is strictly convex
    private boolean isConvex() {
        int N = hull.size();
        if (N <= 2) {
            return true;
        }

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i + 1) % N], points[(i + 2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.932);
//        MyConvexHull cv = new MyConvexHull();
//        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@a268637c9888634e53a904516896d5f2@"
"r03222054","0","0.39","105808","@3dae9bdf14d0602f1eeec4df5c915229@import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.Collections;
import java.lang.Double;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
import java.awt.geom.Point2D;


public class MyConvexHull 
{      
    //private Point2D[] array;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.getX() - o.getX()) * (b.getY() - o.getY()) - (a.getY() - o.getY()) * (b.getY() - o.getY());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.getY() < b.getY()) || (a.getY() == b.getY() && a.getX() < b.getX());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distance(a) < origin.distance( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distance(a) > o.distance(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] array)
    {
       int[] sequence = null;
       int count = 0;// vertex number
        int start = 0;
        for (int i=0; i<array.length; i++)
        {
            if(compare(array[i], array[start]))
                start = i;
        }
        count++;
        sequence[1] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<array.length; i++)
            {
                double angle = cross(array[sequence[count-1]], array[i], array[next]);
                if (angle > 0 ||angle == 0 && far(array[sequence[count-1]], array[i], array[next]))
                next = i;
            }
             if (next == start) break;   // 繞一圈後回到起點了
                sequence[count] = next; 
            count++;
        }
        
        return sequence;       
        }

    
    
    
    
    public static void main(String[] argv)
    {



    }
}
@3dae9bdf14d0602f1eeec4df5c915229@"
"r03222054","0","0.39","105824","@2e25b8c2f328b3a97fca4509dec679b4@
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.StdIn;
//import edu.princeton.cs.algs4.StdDraw;
import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.Collections;
import java.lang.Double;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
import java.awt.geom.Point2D;


public class MyConvexHull 
{      
    //private Point2D[] array;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.getX() - o.getX()) * (b.getY() - o.getY()) - (a.getY() - o.getY()) * (b.getY() - o.getY());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.getY() < b.getY()) || (a.getY() == b.getY() && a.getX() < b.getX());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distance(a) < origin.distance( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distance(a) > o.distance(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = null;
       int count = 0;// vertex number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[1] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) break;   // 繞一圈後回到起點了
                sequence[count] = next; 
            count++;
        }
        
        return sequence;       
        }

    
    
    
    
    public static void main(String[] argv)
    {



    }
}
       /*
    int N = 10;
    double yMin = 1;
    int index = 0;
    doublePoint[] array= new doublePoint[N];
   // ArrayList<doublePoint> array = new ArrayList<doublePoint>();
    for ( int i = 0; i<N; i++)
    {
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        if (y<yMin)
        {
            yMin = y;
            index = i;
        }
        array[i]=( new doublePoint(x,y));
    }    
    doublePoint min = array[index];
    
     doublePoint last = new doublePoint(array[index].getX()-0.0000001, array[index].getY());
     array[index] = array[N-1];
  //   array.remove(index);
  //   Vector angleArray = new Vector();
    for ( int i = 0; i<N-1; i++)
    {
        doublePoint newPoint = array[i];
        double angle = getAngle(last, min, newPoint);
        newPoint.setAngle(angle);
        array[i]= newPoint;
       
    }    

    Arrays.sort(array);
     //array.sort();
    // Collections.sort(array);
     for( int i =0; i< N-1; i++ )
     {
        System.out.println(array[i].getX());
     }
       */
         
     
     
     
     
     
     /*
     doublePoint temp = array.get(index);
     array.set(index, array.get(0)); 
     array.set(0, temp);

     int count = 0;
     for ( int i = 0; i<array.size()-1; i++)
        {
            double minAngle = 2;
            int minIndex = count+1;
            for(int j =count+1; j<array.size(); j++)
            {
                double angle = getAngle(last, array.get(i), array.get(j));
                if(angle<minAngle)
                {
                    minAngle = angle;
                    minIndex = j;
                }
            }
            temp = array.get(i+1);
            array.set(i+1, array.get(minIndex)); 
            array.set(minIndex, temp);
            last = array.get(i+1);
            count++;
    }
  
     for (int i=0; i<array.size(); i++)
     {
         System.out.print(array.get(i).x+""\n"");
     }
      */

     
        /*
        if (i == index)
        {
          StdDraw.setPenColor(StdDraw.RED);
          StdDraw.filledCircle( array[i].x , array[i].y ,0.01);
        }
        else
        {
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.filledCircle( array[i].x , array[i].y ,0.01);
        }
                */
     
        

@2e25b8c2f328b3a97fca4509dec679b4@"
"r04631021","0","0.124","115840","@dfdc7d2656673df05b6f081a7f638996@import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.PolarOrder()) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.PolarOrder()) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  convexhullvertex ++ ;
                  //System.out.println(theta) ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.PolarOrder()) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2) ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y();
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         convexhullvertex ++;
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         return convexhullvertex ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        System.out.print(final_number) ;*/
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        /*}
        catch(IOException e){
            System.out.println(""error!"");
        }*/
        // TODO code application logic here
    }
    
}

@dfdc7d2656673df05b6f081a7f638996@"
"r04631021","0","0.38","107696","@d0d31828448704ca20fc725832f1ab2f@import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER()) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER()) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  convexhullvertex ++ ;
                  //System.out.println(theta) ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER()) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2) ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y();
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         convexhullvertex ++;
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         return convexhullvertex ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        System.out.print(final_number) ;*/
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        /*}
        catch(IOException e){
            System.out.println(""error!"");
        }*/
        // TODO code application logic here
    }
    
}

@d0d31828448704ca20fc725832f1ab2f@"
"r03222054","0","0.4","105472","@36a3379b94027bc77b98f0c97705b55c@import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.Collections;
import java.lang.Double;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
//import java.awt.geom.Point2D;
import edu.princeton.cs.algs4.Point2D;



public class MyConvexHull 
{      
    //private Point2D[] array;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.x()- o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.y());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distanceTo(a) < origin.distanceTo( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distanceTo(a) > o.distanceTo(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = null;
       int count = 0;// vertex number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[1] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) break;   // 繞一圈後回到起點了
                sequence[count] = next; 
            count++;
        }
        
        return sequence;       
        }

    
    
    
    
    public static void main(String[] argv)
    {



    }
}
@36a3379b94027bc77b98f0c97705b55c@"
"r03222054","0","0","0","@99989cd7831f20b07f08f5831263af10@
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.StdIn;
//import edu.princeton.cs.algs4.StdDraw;
import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.Collections;
import java.lang.Double;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
//import java.awt.geom.Point2D;
//import edu.princeton.cs.algs4.Point2D;



public class MyConvexHull 
{      
    //private Point2D[] array;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.x()- o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.y());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distanceTo(a) < origin.distanceTo( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distanceTo(a) > o.distanceTo(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = null;
       int count = 0;// vertex number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[1] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) break;   // 繞一圈後回到起點了
                sequence[count] = next; 
            count++;
        }
        
        return sequence;       
        }

    
    
    
    
    public static void main(String[] argv)
    {



    }
}
       /*
    int N = 10;
    double yMin = 1;
    int index = 0;
    doublePoint[] array= new doublePoint[N];
   // ArrayList<doublePoint> array = new ArrayList<doublePoint>();
    for ( int i = 0; i<N; i++)
    {
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        if (y<yMin)
        {
            yMin = y;
            index = i;
        }
        array[i]=( new doublePoint(x,y));
    }    
    doublePoint min = array[index];
    
     doublePoint last = new doublePoint(array[index].getX()-0.0000001, array[index].getY());
     array[index] = array[N-1];
  //   array.remove(index);
  //   Vector angleArray = new Vector();
    for ( int i = 0; i<N-1; i++)
    {
        doublePoint newPoint = array[i];
        double angle = getAngle(last, min, newPoint);
        newPoint.setAngle(angle);
        array[i]= newPoint;
       
    }    

    Arrays.sort(array);
     //array.sort();
    // Collections.sort(array);
     for( int i =0; i< N-1; i++ )
     {
        System.out.println(array[i].getX());
     }
       */
         
     
     
     
     
     
     /*
     doublePoint temp = array.get(index);
     array.set(index, array.get(0)); 
     array.set(0, temp);

     int count = 0;
     for ( int i = 0; i<array.size()-1; i++)
        {
            double minAngle = 2;
            int minIndex = count+1;
            for(int j =count+1; j<array.size(); j++)
            {
                double angle = getAngle(last, array.get(i), array.get(j));
                if(angle<minAngle)
                {
                    minAngle = angle;
                    minIndex = j;
                }
            }
            temp = array.get(i+1);
            array.set(i+1, array.get(minIndex)); 
            array.set(minIndex, temp);
            last = array.get(i+1);
            count++;
    }
  
     for (int i=0; i<array.size(); i++)
     {
         System.out.print(array.get(i).x+""\n"");
     }
      */

     
        /*
        if (i == index)
        {
          StdDraw.setPenColor(StdDraw.RED);
          StdDraw.filledCircle( array[i].x , array[i].y ,0.01);
        }
        else
        {
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.filledCircle( array[i].x , array[i].y ,0.01);
        }
                */
     
        

@99989cd7831f20b07f08f5831263af10@"
"r03222054","4","0.5","105968","@6f3cd81a76d12ee4ecb8f01cbc05db43@
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.StdIn;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.Point2D;
import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.Collections;
import java.lang.Double;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
//import java.awt.geom.Point2D;
//import edu.princeton.cs.algs4.Point2D;



public class MyConvexHull 
{      
    //private Point2D[] array;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.x()- o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distanceTo(a) < origin.distanceTo( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distanceTo(a) > o.distanceTo(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = new int[10] ;
       
       int count = 0;// verte/*x number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[0] = start;
        
        int next = start;
        while(count<10)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) 
             {
                // System.out.print(count + ""shit\n"");
                 break;
             }
                    // 繞一圈後回到起點了
             else
                sequence[count] = next; 
            count++;
        }
        
        int[] answer = Arrays.copyOf(sequence, count);      
        
        return answer;       
        }

    
    
    
    
    public static void main(String[] argv)
    {
        Point2D[] array = {new Point2D(0,0), new Point2D(10,0),new Point2D(0,10), new Point2D(10,10), new Point2D(-5,5),new Point2D(5,5)};
        int[] sequence =ConvexHullVertex(array);
        for (int i =0; i<sequence.length ;i++)
        System.out.print(sequence[i] + ""\t"");
        



    }
}
   
@6f3cd81a76d12ee4ecb8f01cbc05db43@"
"r04631021","0","0.38","106864","@adf2d54ec884603ff60124e6f579e46c@import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  convexhullvertex ++ ;
                  //System.out.println(theta) ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2) ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y();
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         convexhullvertex ++;
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         return convexhullvertex ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        System.out.print(final_number) ;*/
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        /*}
        catch(IOException e){
            System.out.println(""error!"");
        }*/
        // TODO code application logic here
    }
    
}

@adf2d54ec884603ff60124e6f579e46c@"
"r04631041","5","0.106","106528","@3dba59dbcb8a4db8c06f50d60c76aad4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int temp=0,ans=0;    
      for (int i=0 ; i<N ; i++){
          if(i==connectimformation[i]){
              connectimformation[i]=temp;
              for (int j=0 ; j<N ; j++)
                  if (connectimformation[j]==i)
                      connectimformation[j]=temp;
          temp++;
          }
        }
      //for (int i=0 ; i<N ; i++)
      //    System.out.print(connectimformation[i]+""\t"");
      //    System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (counter3>1){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@3dba59dbcb8a4db8c06f50d60c76aad4@"
"b03611003","0","0","0","@e452a170b2d58434755f78dc75306f81@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public void DrawingPratice3() {
        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

//        a[0].drawTo(a[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

//            top.drawTo(a[i]);
//            StdDraw.show(10);
//            StdDraw.text(a[i].x(), a[i].y()+0.02, """"+i);
            hull.push(top);
            hull.push(a[i]);
        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);

        StdDraw.setPenRadius(.001);
        StdDraw.setPenColor(Color.green);

        for (int i = 1; i < a.length; i++) {
            a[i].drawTo(a[0]);

            StdDraw.show(10);
        }

        StdDraw.setPenColor(Color.BLUE);
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

            begin.drawTo(end);
            StdDraw.show();
            begin = end;
        }

        Arrays.sort(Convex);
        
        return Convex;
    }

    public static void main(String[] args) {

//        int N = 50;
//        Point2D[] a = new Point2D[N];
//        StdDraw.setPenRadius(.01);
//
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//
//            a[i] = new Point2D(x, y);
//
//            a[i].draw();
//
//        }
//        int[] num = ConvexHullVertex(a);
//        for(int i = 0; i< num.length; i++){
//            System.out.print(num[i]);
//        }
        

    }

}

@e452a170b2d58434755f78dc75306f81@"
"b03611003","0","0.53","113760","@f9dd4a589c8c88a323aa85c57cec1ae0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public void DrawingPratice3() {
        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertix(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

//        a[0].drawTo(a[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

//            top.drawTo(a[i]);
//            StdDraw.show(10);
//            StdDraw.text(a[i].x(), a[i].y()+0.02, """"+i);
            hull.push(top);
            hull.push(a[i]);
        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);

        StdDraw.setPenRadius(.001);
        StdDraw.setPenColor(Color.green);

        for (int i = 1; i < a.length; i++) {
            a[i].drawTo(a[0]);

            StdDraw.show(10);
        }

        StdDraw.setPenColor(Color.BLUE);
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

            begin.drawTo(end);
            StdDraw.show();
            begin = end;
        }

        Arrays.sort(Convex);
        
        return Convex;
    }

    public static void main(String[] args) {

//        int N = 50;
//        Point2D[] a = new Point2D[N];
//        StdDraw.setPenRadius(.01);
//
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//
//            a[i] = new Point2D(x, y);
//
//            a[i].draw();
//
//        }
//        int[] num = ConvexHullVertix(a);
//        for(int i = 0; i< num.length; i++){
//            System.out.print(num[i]);
//        }
        

    }

}

@f9dd4a589c8c88a323aa85c57cec1ae0@"
"b03611003","0","0","0","@e452a170b2d58434755f78dc75306f81@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public void DrawingPratice3() {
        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

//        a[0].drawTo(a[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

//            top.drawTo(a[i]);
//            StdDraw.show(10);
//            StdDraw.text(a[i].x(), a[i].y()+0.02, """"+i);
            hull.push(top);
            hull.push(a[i]);
        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);

        StdDraw.setPenRadius(.001);
        StdDraw.setPenColor(Color.green);

        for (int i = 1; i < a.length; i++) {
            a[i].drawTo(a[0]);

            StdDraw.show(10);
        }

        StdDraw.setPenColor(Color.BLUE);
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

            begin.drawTo(end);
            StdDraw.show();
            begin = end;
        }

        Arrays.sort(Convex);
        
        return Convex;
    }

    public static void main(String[] args) {

//        int N = 50;
//        Point2D[] a = new Point2D[N];
//        StdDraw.setPenRadius(.01);
//
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//
//            a[i] = new Point2D(x, y);
//
//            a[i].draw();
//
//        }
//        int[] num = ConvexHullVertex(a);
//        for(int i = 0; i< num.length; i++){
//            System.out.print(num[i]);
//        }
        

    }

}

@e452a170b2d58434755f78dc75306f81@"
"b03611003","0","0.106","106528","@7d7e9f4942966f644d027338d80795af@/*************************************************************************
 *  Compilation:  javac Point2D.java
 *  Execution:    java Point2D x0 y0 N
 *  Dependencies: StdDraw.java StdRandom.java
 *
 *  Immutable point data type for points in the plane.
 *
 *************************************************************************/

import java.util.Arrays;
import java.util.Comparator;


/**
 *  The <tt>Point</tt> class is an immutable data type to encapsulate a
 *  two-dimensional point with real-value coordinates.
 *  <p>
 *  Note: in order to deal with the difference behavior of double and 
 *  Double with respect to -0.0 and +0.0, the Point2D constructor converts
 *  any coordinates that are -0.0 to +0.0.
 *  
 *  For additional documentation, see <a href=""/algs4/12oop"">Section 1.2</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public class Point2D implements Comparable<Point2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<Point2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<Point2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<Point2D> R_ORDER = new ROrder();

    /**
     * Compares two points by polar angle (between 0 and 2pi) with respect to this point.
     */
    public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();

    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<Point2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<Point2D> DISTANCE_TO_ORDER = new DistanceToOrder();

    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public Point2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(Point2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }

    /**
     * Is a->b->c a counterclockwise turn?
     * @param a first point
     * @param b second point
     * @param c third point
     * @return { -1, 0, +1 } if a->b->c is a { clockwise, collinear; counterclocwise } turn.
     */
    public static int ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }

    /**
     * Returns twice the signed area of the triangle a-b-c.
     * @param a first point
     * @param b second point
     * @param c third point
     * @return twice the signed area of the triangle a-b-c
     */
    public static double area2(Point2D a, Point2D b, Point2D c) {
        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    }

    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(Point2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(Point2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(Point2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }

    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<Point2D> {
        public int compare(Point2D q1, Point2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }

    // compare other points relative to polar angle (between 0 and 2pi) they make with this Point
    private class PolarOrder implements Comparator<Point2D> {
        public int compare(Point2D q1, Point2D q2) {
            double dx1 = q1.x - x;
            double dy1 = q1.y - y;
            double dx2 = q2.x - x;
            double dy2 = q2.y - y;

            if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                if      (dx1 >= 0 && dx2 < 0) return -1;
                else if (dx2 >= 0 && dx1 < 0) return +1;
                else                          return  0;
            }
            else return -ccw(Point2D.this, q1, q2);     // both above or below

            // Note: ccw() recomputes dx1, dy1, dx2, and dy2
        }
    }

    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        Point2D that = (Point2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }

    /**
     * Plot this point using standard draw.
     */
    public void draw() {
        StdDraw.point(x, y);
    }

    /**
     * Plot a line from this point to that point using standard draw.
     * @param that the other point
     */
    public void drawTo(Point2D that) {
        StdDraw.line(this.x, this.y, that.x, that.y);
    }


    /**
     * Unit tests the point data type.
     */
    public static void main(String[] args) {
        int x0 = Integer.parseInt(args[0]);
        int y0 = Integer.parseInt(args[1]);
        int N = Integer.parseInt(args[2]);

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }

        // draw p = (x0, x1) in red
        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        p.draw();


        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, p.POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            p.drawTo(points[i]);
            StdDraw.show(100);
        }
    }
}

@7d7e9f4942966f644d027338d80795af@"
"b03611003","0","0","0","@1933b64b453a695c3bbf3107ea654522@/*************************************************************************
 *  Compilation:  javac Point2D.java
 *  Execution:    java Point2D x0 y0 N
 *  Dependencies: StdDraw.java StdRandom.java
 *
 *  Immutable point data type for points in the plane.
 *
 *************************************************************************/

import java.util.Arrays;
import java.util.Comparator;


/**
 *  The <tt>Point</tt> class is an immutable data type to encapsulate a
 *  two-dimensional point with real-value coordinates.
 *  <p>
 *  Note: in order to deal with the difference behavior of double and 
 *  Double with respect to -0.0 and +0.0, the Point2D constructor converts
 *  any coordinates that are -0.0 to +0.0.
 *  
 *  For additional documentation, see <a href=""/algs4/12oop"">Section 1.2</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public class Point2D implements Comparable<Point2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<Point2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<Point2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<Point2D> R_ORDER = new ROrder();

    /**
     * Compares two points by polar angle (between 0 and 2pi) with respect to this point.
     */
    public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();

    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<Point2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<Point2D> DISTANCE_TO_ORDER = new DistanceToOrder();

    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public Point2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(Point2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }

    /**
     * Is a->b->c a counterclockwise turn?
     * @param a first point
     * @param b second point
     * @param c third point
     * @return { -1, 0, +1 } if a->b->c is a { clockwise, collinear; counterclocwise } turn.
     */
    public static int ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }

    /**
     * Returns twice the signed area of the triangle a-b-c.
     * @param a first point
     * @param b second point
     * @param c third point
     * @return twice the signed area of the triangle a-b-c
     */
    public static double area2(Point2D a, Point2D b, Point2D c) {
        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    }

    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(Point2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(Point2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(Point2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }

    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<Point2D> {
        public int compare(Point2D q1, Point2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }

    // compare other points relative to polar angle (between 0 and 2pi) they make with this Point
    private class PolarOrder implements Comparator<Point2D> {
        public int compare(Point2D q1, Point2D q2) {
            double dx1 = q1.x - x;
            double dy1 = q1.y - y;
            double dx2 = q2.x - x;
            double dy2 = q2.y - y;

            if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                if      (dx1 >= 0 && dx2 < 0) return -1;
                else if (dx2 >= 0 && dx1 < 0) return +1;
                else                          return  0;
            }
            else return -ccw(Point2D.this, q1, q2);     // both above or below

            // Note: ccw() recomputes dx1, dy1, dx2, and dy2
        }
    }

    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<Point2D> {
        public int compare(Point2D p, Point2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        Point2D that = (Point2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }

    /**
     * Plot this point using standard draw.
     */
    public void draw() {
        StdDraw.point(x, y);
    }

    /**
     * Plot a line from this point to that point using standard draw.
     * @param that the other point
     */
    public void drawTo(Point2D that) {
        StdDraw.line(this.x, this.y, that.x, that.y);
    }


    /**
     * Unit tests the point data type.
     */
    public static void main(String[] args) {
        
    }
}

@1933b64b453a695c3bbf3107ea654522@"
"b03611003","5","0.104","107904","@f7017771cc9c0506ff10a868b49c9e04@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public void DrawingPratice3() {
        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

//        a[0].drawTo(a[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

//            top.drawTo(a[i]);
//            StdDraw.show(10);
//            StdDraw.text(a[i].x(), a[i].y()+0.02, """"+i);
            hull.push(top);
            hull.push(a[i]);
        }

//        StdDraw.setPenColor(Color.red);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//
//        StdDraw.setPenRadius(.001);
//        StdDraw.setPenColor(Color.green);

//        for (int i = 1; i < a.length; i++) {
//            a[i].drawTo(a[0]);
//
//            StdDraw.show(10);
//        }

//        StdDraw.setPenColor(Color.BLUE);
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

//            begin.drawTo(end);
//            StdDraw.show();
            begin = end;
        }

        Arrays.sort(Convex);
        
        return Convex;
    }

    public static void main(String[] args) {

        int N = 50;
        Point2D[] a = new Point2D[N];
        StdDraw.setPenRadius(.01);

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            a[i].draw();

        }
        int[] num = ConvexHullVertex(a);
        for(int i = 0; i< num.length; i++){
            System.out.print(num[i]);
        }
        

    }

}

@f7017771cc9c0506ff10a868b49c9e04@"
"r04631034","0","0.53","106496","@8273a7f14e572843166d1d6d209d6604@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put(a[i].y(), i);
                    }

                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    for (int i = 1; i < a.length; i++) {
                              if (a[0].y() == a[i].y() && a[0].x() < a[i].x()) {
                                        double tempx = a[i].x();
                                        double tempy = a[i].y();
                                        a[i] = new Point2D(a[0].x(), a[0].y());
                                        a[0] = new Point2D(tempx, tempy);
                              }

                    }

//                    Point2D p = new Point2D(a[0].x(),a[0].y());
                    MergeX.sort(a, a[0].POLAR_ORDER);

//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get(a[storge.get(count)].y());
//                              System.out.print(""y            "" +a[storge.get(count)].y()+""           "");
                              System.out.print(storge.get(count) + "" "");
//                              System.out.println( map.get(a[storge.get(count)].y()));
//                              System.out.println("""");
                    }
                    System.out.println("""");
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N = 4;
//                    Point2D[] a = new Point2D[N];
////                    for (int count = 0; count < N; count++) {
////                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//////                              System.out.println(a[count]);
////                    }
//
//                    a[0] = new Point2D(0.4, 0.3);
//                    a[1] = new Point2D(0.5, 0.5);
//                    a[2] = new Point2D(0.1, 0.1);
//                    a[3] = new Point2D(0.5, 0.1);
//
//                    int[] output;
//                    output = MyConvexHull.ConvexHullVertex(a);
//
//                    for (int i = 0; i < output.length; i++) {
//                              System.out.print(output[i] + "" "");
//                    }

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    
//
////                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
                    System.out.println("""");
          }

}

@8273a7f14e572843166d1d6d209d6604@"
"r04631041","5","0.104","107952","@228735ac02ea1322d74e1c5fe3cf767b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length; 
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@228735ac02ea1322d74e1c5fe3cf767b@"
"r04631034","0","0.49","107936","@e31dedc7c8e9bc5f11955d652f9ea642@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                                double dou= a[i].x()*10+a[i].y();
                              map.put(dou, i);
//                              System.out.println(map.get(dou));
                    }
                    
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    for (int i = 1; i < a.length; i++) {
                              if (a[0].y() == a[i].y() && a[0].x() < a[i].x()) {
                                        double tempx = a[i].x();
                                        double tempy = a[i].y();
                                        a[i] = new Point2D(a[0].x(), a[0].y());
                                        a[0] = new Point2D(tempx, tempy);
                              }

                    }

                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);

//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              double dou =a[storge.get(count)].y()+a[storge.get(count)].x()*10;
//                              output[count] = map.get(a[storge.get(count)].y());
                                                                    output[count] = map.get(dou);
//                              System.out.print(""y            "" +a[storge.get(count)].y()+""           "");
                              System.out.print(storge.get(count) + "" "");
//                              System.out.println( map.get(a[storge.get(count)].y()));
//                              System.out.println("""");
                    }
                    System.out.println("""");
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 10;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
//
//                    a[0] = new Point2D(0.4, 0.3);
//                    a[1] = new Point2D(0.5, 0.5);
//                    a[2] = new Point2D(0.1, 0.1);
//                    a[3] = new Point2D(0.5, 0.1);
//                    a[4]= new Point2D(0.9,0.1);
                    int[] output;
                    output = MyConvexHull.ConvexHullVertex(a);

                    for (int i = 0; i < output.length; i++) {
                              System.out.print(output[i] + "" "");
                    }

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    
//
////                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
                    System.out.println("""");
          }

}

@e31dedc7c8e9bc5f11955d652f9ea642@"
"r04631021","3","0.3","108848","@6e914021c64e21c9280d7731f875c646@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         Point2D[] b = new Point2D[a.length] ;
         for(int i = 0 ; i < a.length ; i++){
             b[i] = a[i];
         }
         int[] c = new int [a.length] ;
         int count = 0 ;
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         for(int i = 0 ; i < a.length ; i++){
             if (orig.x()==b[i].x()&&orig.y()==b[i].y()){
                 c[0] =i ;
                 //System.out.println(i) ;
                 break ;
             }
         }
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         for(int i = 0 ; i < a.length ; i++){
             if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[1] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
                 
             }
         }
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  for(int i = 0 ; i < a.length ; i++){
                  if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[convexhullvertex] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
             }
         }
                  convexhullvertex ++ ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2+""here"") ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y() ;
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         //System.out.println(temp2.x()+"",""+temp2.y());
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         for(int l = 0 ; l < a.length ; l++){
                     if (temp2.x()==b[l].x()&&temp2.y()==b[l].y()){
                 c[convexhullvertex] =l ;
                 //System.out.println(l+""+""+convexhullvertex) ;
                 break ;
             }
         }
                         convexhullvertex ++;
                         
              break;       
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         int[] gg = new int[convexhullvertex] ;
         for(int i = 0 ; i < convexhullvertex ; i++){
             gg[i]=c[i] ;
         }
         for(int i = 0 ; i < convexhullvertex ; i++){
             //System.out.print(gg[i]);
         }
         return gg ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        ConvexHullVertex(points) ;
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    //final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        //  System.out.print(final_number) ;
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        }
        catch(IOException e){
            System.out.println(""error!"");
        }
        // TODO code application logic here
    }
    
}

@6e914021c64e21c9280d7731f875c646@"
"r04631034","0","0.49","107856","@11871ddf71f9830d067866b352873214@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                                double dou= a[i].x()*10+a[i].y();
                              map.put(dou, i);
//                              System.out.println(map.get(dou));
                    }
                    
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    for (int i = 1; i < a.length; i++) {
                              if (a[0].y() == a[i].y() && a[0].x() < a[i].x()) {
                                        double tempx = a[i].x();
                                        double tempy = a[i].y();
                                        a[i] = new Point2D(a[0].x(), a[0].y());
                                        a[0] = new Point2D(tempx, tempy);
                              }

                    }

                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);

//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }

                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              double dou =a[storge.get(count)].y()+a[storge.get(count)].x()*10;
//                              output[count] = map.get(a[storge.get(count)].y());
                                                                    output[count] = map.get(dou);
//                              System.out.print(""y            "" +a[storge.get(count)].y()+""           "");
                              System.out.print(storge.get(count) + "" "");
//                              System.out.println( map.get(a[storge.get(count)].y()));
//                              System.out.println("""");
                    }
                    System.out.println("""");
                    
                    Arrays.sort(output);
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
                    int N = 10;
                    Point2D[] a = new Point2D[N];
                    for (int count = 0; count < N; count++) {
                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
                    }
//
//                    a[0] = new Point2D(0.4, 0.3);
//                    a[1] = new Point2D(0.5, 0.5);
//                    a[2] = new Point2D(0.1, 0.1);
//                    a[3] = new Point2D(0.5, 0.1);
//                    a[4]= new Point2D(0.9,0.1);
                    int[] output;
                    output = MyConvexHull.ConvexHullVertex(a);

                    for (int i = 0; i < output.length; i++) {
                              System.out.print(output[i] + "" "");
                    }

//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].y(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//                    
//
////                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].y()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].y());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
                    System.out.println("""");
          }

}

@11871ddf71f9830d067866b352873214@"
"r04921105","0","0.52","104544","@ae82122552f03cc0b057650fea4adadd@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         //Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(point, Point2D.Y_ORDER);
         Arrays.sort(point, point[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           System.out.println(array[x]);
           
           
       }
       int[] result =new int[a.length];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       System.out.print(""\n"");
       for(int x=0;x<s;x++){
           System.out.println(result[x]);
           
       }
     
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
          /* try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
               
*/  
            int n =10;
            Point2D[] points = new Point2D[n];
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1200);
            StdDraw.setYscale(0, 1200);
            StdDraw.setPenRadius(.01);
         
             for (int i = 0; i < n; i++) {
            int x = StdRandom.uniform(1000);
            int y = StdRandom.uniform(1000);
            points[i] = new Point2D(x, y);
            points[i].draw();
                }
             int[] result = ConvexHullVertex(points);
             
             StdDraw.setPenColor(StdDraw.BLUE);
             for (int i=0; i < result.length;i++){
             points[result[i]].draw();    
             }
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

       // }
    }
    
}

@ae82122552f03cc0b057650fea4adadd@"
"r04631034","0","0.51","105936","@50c633d3c9c5659e90a4ec3b9b812ab5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

          public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              double dou = a[i].x() * 100+ a[i].y();
                              map.put(dou, i);
//                              System.out.println(map.get(dou));
                    }

                    MergeX.sort(a, Point2D.Y_ORDER);    //sort

                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);

//                    for (int count = 0; count < a.length; count++) {
////                              System.out.print(a[count].x());
////                              System.out.print(""  "");
////                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              double dou = a[storge.get(count)].y() + a[storge.get(count)].x() * 100;
//                              output[count] = map.get(a[storge.get(count)].y());
                              output[count] = map.get(dou);
//                              System.out.print(""y            "" +a[storge.get(count)].y()+""           "");
                              System.out.print(storge.get(count) + "" "");
//                              System.out.println( map.get(a[storge.get(count)].y()));
//                              System.out.println("""");
                    }
                    System.out.println("""");
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N = 10;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.println(a[count]);
//                    }
////
////                    a[0] = new Point2D(0.4, 0.3);
////                    a[1] = new Point2D(0.5, 0.5);
////                    a[2] = new Point2D(0.1, 0.1);
////                    a[3] = new Point2D(0.5, 0.1);
////                    a[4]= new Point2D(0.9,0.1);
//                    int[] output;
//                    output = MyConvexHull.ConvexHullVertex(a);
//
//                    for (int i = 0; i < output.length; i++) {
//                              System.out.print(output[i] + "" "");
//                    }
//
//                    
//                    
//                    
//                    System.out.println("""");
          }

}

@50c633d3c9c5659e90a4ec3b9b812ab5@"
"r04921105","0","0.52","105936","@117b3691e91bf6efae1eb61351207635@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         //Point2D p = new Point2D(0, 0);
         //Arrays.sort(a, p.X_ORDER);
         Arrays.sort(point, Point2D.Y_ORDER);
         Arrays.sort(point, point[0].POLAR_ORDER);
        /*for(int i =0;i<n;i++){
            System.out.println(a[i].x());
            System.out.println(a[i].y());
         } 
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       for(int i=2;i<n;){
           //System.out.print(stack.size());
           //System.out.print(' ');
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
           stack.push(p0);
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
           p0=p1;p1=p2;p2=i+1;
           i++;
           }
           else{
           //System.out.print('_');
           //System.out.print(p0);
           //System.out.print(p1);
           //System.out.println(p2);
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       
      
       stack.push(p0);
       stack.push(p1);
      
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           System.out.println(array[x]);
           
           
       }
       int[] result =new int[s];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       System.out.print(""\n"");
       for(int x=0;x<s;x++){
           System.out.println(result[x]);
           
       }
       
           System.out.println(""======="");
           System.out.println(s);
           System.out.println(array[0]);
           System.out.println(array[s-1]);
       
        return result;
       
    }

    public static void main(String[] args) throws Exception{
          /* try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
               
*/  
            int n =20;
            Point2D[] points = new Point2D[n];
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1200);
            StdDraw.setYscale(0, 1200);
            StdDraw.setPenRadius(.01);
         
             for (int i = 0; i < n; i++) {
            int x = StdRandom.uniform(1000);
            int y = StdRandom.uniform(1000);
            points[i] = new Point2D(x, y);
            points[i].draw();
                }
             int[] result = ConvexHullVertex(points);
             
           System.out.println(""======="");
           System.out.println(result.length);
          
           System.out.println(result[0]);
           System.out.println(result[result.length-1]);
             
             StdDraw.setPenColor(StdDraw.BLUE);
             for (int i=0; i < result.length;i++){
             points[result[i]].draw();    
             }
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

       // }
    }
    
}

@117b3691e91bf6efae1eb61351207635@"
"r04631034","5","0.1","104832","@8acbaddc039256f8e6ce026baed33943@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

         public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put((a[i].x()*100+a[i].y()), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(),a[0].y());
                    MergeX.sort(a,p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get((a[storge.get(count)].x()*100)+a[storge.get(count)].y());
                    }
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
//                    int N = 10;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
////                              System.out.println(a[count]);
//                    }
////
//////                    a[0] = new Point2D(0.4, 0.3);
//////                    a[1] = new Point2D(0.5, 0.5);
//////                    a[2] = new Point2D(0.1, 0.1);
//////                    a[3] = new Point2D(0.5, 0.1);
//////                    a[4]= new Point2D(0.9,0.1);
//                    int[] output;
//                    output = MyConvexHull.ConvexHullVertex(a);
//
//                    for (int i = 0; i < output.length; i++) {
//                              System.out.print(output[i] + "" "");
//                    }
//
//                    
//                    
//                    
//                    System.out.println("""");
          }

}

@8acbaddc039256f8e6ce026baed33943@"
"r04945022","2","0.51","106000","@3519a45040b205d741b34dc0d80e2203@
import java.util.Stack;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@3519a45040b205d741b34dc0d80e2203@"
"r04945022","0","0.51","107840","@93c84aae8f994353ce2f4ab1ca1dd046@import java.util.Stack;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@93c84aae8f994353ce2f4ab1ca1dd046@"
"r04921065","0","0.51","106000","@121e997d8a35472408492a142c6ec7a4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.Insertion;
import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    static double minY;
    private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {

        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here

    int N = 30;

        StdDraw.setCanvasSize(600, 600);
        StdDraw.setXscale(-100, 700);
        StdDraw.setYscale(-100, 700);
        StdDraw.setPenRadius(.02);

        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            int x = StdRandom.uniform(600);
            int y = StdRandom.uniform(600);
            points[i] = new Point2D(x, y);
            StdDraw.point(points[i].x(), points[i].y());

        }
        Merge.sort(points);

        Arrays.sort(points, points[0].polarOrder());
        for (int i = 0; i < N; ++i) {
            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
        }

        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
 
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        StdDraw.setPenColor(StdDraw.GREEN);
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
           StdDraw.point(vertex[u].x(), vertex[u].y());
        }
        
        
        
        /*
        System.out.println(vals.size());
        Iterator<Point2D> c = vals.iterator();
        while(c.hasNext()){
            Point2D f = c.next();
            System.out.println(f);
        }
        */
        
        
    }
}



@121e997d8a35472408492a142c6ec7a4@"
"r04921065","0","0.51","107840","@026b978906ec9452763c3f3f4e3decac@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    static double minY;
    private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {

        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here

    int N = 30;

        StdDraw.setCanvasSize(600, 600);
        StdDraw.setXscale(-100, 700);
        StdDraw.setYscale(-100, 700);
        StdDraw.setPenRadius(.02);

        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            int x = StdRandom.uniform(600);
            int y = StdRandom.uniform(600);
            points[i] = new Point2D(x, y);
            StdDraw.point(points[i].x(), points[i].y());

        }
        Merge.sort(points);

        Arrays.sort(points, points[0].polarOrder());
        for (int i = 0; i < N; ++i) {
            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
        }

        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
 
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        StdDraw.setPenColor(StdDraw.GREEN);
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
           StdDraw.point(vertex[u].x(), vertex[u].y());
        }
        
        
        
        /*
        System.out.println(vals.size());
        Iterator<Point2D> c = vals.iterator();
        while(c.hasNext()){
            Point2D f = c.next();
            System.out.println(f);
        }
        */
        
        
    }
}



@026b978906ec9452763c3f3f4e3decac@"
"r04921065","0","0.51","107840","@05975011dbe044fb158ef386c9c9bf8d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    static double minY;
    private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {

        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
}



@05975011dbe044fb158ef386c9c9bf8d@"
"r04921065","0","0.098","105968","@1789f0a07ec2b680876d1f265a8c58e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    static double minY;
    private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {

        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@1789f0a07ec2b680876d1f265a8c58e3@"
"r03522809","0","0.098","105968","@ea7af6ec8795987534abbe039b975038@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {
    

public static String ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"",ans;
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);     
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      }
      ans=Arrays.toString(output);
      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        String [] convex=ConvexHullVertex(a).split("", "");
        convexsize=convex.length;
        int[]cox=new int[convexsize];
        cox[0]=0;
        j=1;
        for (i=convexsize-2;i>0;i--){ 
            
            cox[j]=Integer.parseInt(convex[i]);
            System.out.println(cox[j]);
            j++;
        }
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@ea7af6ec8795987534abbe039b975038@"
"r04945022","2","0.53","107888","@8a607370ec829307694c8fa16f3a2296@import java.util.Stack;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    if(ref.length>=3){
    return ref;
    }
    else{
      return null;
    }
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@8a607370ec829307694c8fa16f3a2296@"
"r03522809","0","0.52","106960","@900c86c3662b42955847e9af620be17d@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {
    

public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);     
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
        ans[i]= Integer.parseInt(output[i]);
      }

      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertex(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
        
//        int[]cox=new int[convexsize];
//        cox[0]=0;
//        j=1;
//        for (i=convexsize-2;i>0;i--){ 
//            
//            cox[j]=Integer.parseInt(convex[i]);
//            System.out.println(cox[j]);
//            j++;
//        }
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@900c86c3662b42955847e9af620be17d@"
"r03522809","0","0.53","107888","@0c993a699e28c6a1bfff972e731f7d3a@public class MyConvexHull {
    

public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
        ans[i]= Integer.parseInt(output[i]);
      }

      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertex(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
       
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@0c993a699e28c6a1bfff972e731f7d3a@"
"r03522809","0","0.52","107936","@602f2c7be53059611944b69eea8830e8@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {
    

public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
        ans[i]= Integer.parseInt(output[i]);
      }

      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertex(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
       
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@602f2c7be53059611944b69eea8830e8@"
"r03522809","0","0.49","107680","@831f6c4304bef630dd09f0d1a9c9e71c@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {
    

public static int[] ConvexHullVertix(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
        ans[i]= Integer.parseInt(output[i]);
      }

      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertix(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertix(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
       
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@831f6c4304bef630dd09f0d1a9c9e71c@"
"r03522809","0","0.51","107968","@1ca5a6dabe1ceca84b4ccc16376370e6@
import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D ddd;
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){

          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }

      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
        ans[i]= Integer.parseInt(output[i]);
      }

      return  ans;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertex(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
       
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@1ca5a6dabe1ceca84b4ccc16376370e6@"
"r04921065","0","0.4","106192","@ef1b07b7de1a025f0cbf92710f4c4f0b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.Insertion;
import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    static double minY;
    private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {

        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@ef1b07b7de1a025f0cbf92710f4c4f0b@"
"r04921105","5","0.1","107792","@b54d745dfc78d42e1d8d44614db014f9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         Arrays.sort(point, Point2D.Y_ORDER);
         Arrays.sort(point, point[0].POLAR_ORDER);
         
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       
       for(int i=2;i<n;){
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
                stack.push(p0);
                p0=p1;p1=p2;p2=i+1;
                i++;
           }
           else{
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       stack.push(p0);
       stack.push(p1);
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[s];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       //System.out.print(""\n"");
       //for(int x=0;x<s;x++){
           //System.out.println(result[x]);
           
      // }
       /*
           System.out.println(""======="");
           System.out.println(s);
           System.out.println(array[0]);
           System.out.println(array[s-1]);
       */
        return result;
       
    }

    public static int[] ConvexHullVertex2(Point2D[] a) {
        
        int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
    }
    
    public static void main(String[] args) throws Exception{
          /* try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
               
*/  
            int n =100;
            Point2D[] points = new Point2D[n];
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1200);
            StdDraw.setYscale(0, 1200);
            StdDraw.setPenRadius(.01);
         
             for (int i = 0; i < n; i++) {
            int x = StdRandom.uniform(1000);
            int y = StdRandom.uniform(1000);
            points[i] = new Point2D(x, y);
            points[i].draw();
                }
             int[] result = ConvexHullVertex(points);
             int[] result2 = ConvexHullVertex2(points);
             
           System.out.println(""======="");
             
             StdDraw.setPenColor(StdDraw.BLUE);
             for (int i=0; i < result.length;i++){
                 System.out.print(result[i]);
             points[result[i]].draw();    
             }
             
                 System.out.println(""~~~"");
             StdDraw.setPenColor(StdDraw.RED);
             for (int i=0; i < result2.length;i++){
                 System.out.print(result2[i]);
             points[result2[i]].draw();    
             }
               
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

       // }
    }
    
}

@b54d745dfc78d42e1d8d44614db014f9@"
"r04921065","0","0.1","107792","@9e4dda6217fba105e460b5d86f0c498b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.Insertion;
import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@9e4dda6217fba105e460b5d86f0c498b@"
"r04921105","5","0.104","105984","@07c1c617ed9063a07f5f154f6b34e198@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         Arrays.sort(point, Point2D.Y_ORDER);
         Arrays.sort(point, point[0].POLAR_ORDER);
         
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       
       for(int i=2;i<n;){
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
                stack.push(p0);
                p0=p1;p1=p2;p2=i+1;
                i++;
           }
           else{
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       stack.push(p0);
       stack.push(p1);
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[s];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       //System.out.print(""\n"");
       //for(int x=0;x<s;x++){
           //System.out.println(result[x]);
           
      // }
       /*
           System.out.println(""======="");
           System.out.println(s);
           System.out.println(array[0]);
           System.out.println(array[s-1]);
       */
        return result;
       
    }
/*
    public static int[] ConvexHullVertex2(Point2D[] a) {
        
        int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
    }
    */
    public static void main(String[] args) throws Exception{
          /* try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
               
*/  
            int n =100;
            Point2D[] points = new Point2D[n];
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1200);
            StdDraw.setYscale(0, 1200);
            StdDraw.setPenRadius(.01);
         
             for (int i = 0; i < n; i++) {
            int x = StdRandom.uniform(1000);
            int y = StdRandom.uniform(1000);
            points[i] = new Point2D(x, y);
            points[i].draw();
                }
             int[] result = ConvexHullVertex(points);
             //int[] result2 = ConvexHullVertex2(points);
             
           System.out.println(""======="");
             
             StdDraw.setPenColor(StdDraw.BLUE);
             for (int i=0; i < result.length;i++){
                 System.out.print(result[i]);
             points[result[i]].draw();    
             }
             /*
                 System.out.println(""~~~"");
             StdDraw.setPenColor(StdDraw.RED);
             for (int i=0; i < result2.length;i++){
                 System.out.print(result2[i]);
             points[result2[i]].draw();    
             }
            */   
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

       // }
    }
    
}

@07c1c617ed9063a07f5f154f6b34e198@"
"r04921065","0","0.4","106192","@f74a72b909e64b7321cb43ffba4c31ad@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@f74a72b909e64b7321cb43ffba4c31ad@"
"r04921065","0","0.4","106192","@067e2b1db7d123c6434e73f6fde9ba88@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@067e2b1db7d123c6434e73f6fde9ba88@"
"r04921065","0","0.1","107792","@43b37754e4d5f9ed8c7089de577f8663@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@43b37754e4d5f9ed8c7089de577f8663@"
"r04921065","0","0.104","105984","@60a8f335937d534479378554cc7f97b5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].POLAR_ORDER());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@60a8f335937d534479378554cc7f97b5@"
"r04921065","0","0","0","@662f16431549fa5978f1efe381b1b65a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Merge.sort(a);
        Arrays.sort(a, a[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!a[0].equals(a[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(a[0]);
        vals.push(a[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
        vals.push(a[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, a[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(a[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@662f16431549fa5978f1efe381b1b65a@"
"r04921065","0","0.1","107792","@663dabe2751d41cd3d92f16f26e672f0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.Insertion;
import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@663dabe2751d41cd3d92f16f26e672f0@"
"r04921065","0","0.1","107792","@b12b935702837a8e83d9fc818a60e674@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@b12b935702837a8e83d9fc818a60e674@"
"r04921065","0","0.104","105984","@b12b935702837a8e83d9fc818a60e674@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
//import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@b12b935702837a8e83d9fc818a60e674@"
"r03222054","5","0.1","106048","@3c4f5f6ed458eec6b9ac7ec02e092b30@
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.StdIn;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.Point2D;
import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
//import edu.princeton.cs.algs4.UF;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Array;
//import java.awt.geom.Point2D;
//import edu.princeton.cs.algs4.Point2D;



public class MyConvexHull 
{      
    //private Point2D[] array;
    //private boolean[][] connectArray;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.x()- o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distanceTo(a) < origin.distanceTo( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distanceTo(a) > o.distanceTo(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = new int[a.length] ;
       
       int count = 0;// verte/*x number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[0] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) 
             {
                // System.out.print(count + ""shit\n"");
                 break;
             }
                    // 繞一圈後回到起點了
             else
                sequence[count] = next; 
            count++;
        }
        
        int[] answer = Arrays.copyOf(sequence, count);      
        
        return answer;       
        }
    public static UF connected(Point2D[] a, double distance)
    {
        boolean[][] connectArray = new boolean[a.length][a.length];
        UF unionArray = new UF(a.length);
        for(int i =0; i<a.length; i++)
        {
            for(int j =a.length-1; j>i; j--)
            {
                if(a[i].distanceTo(a[j]) <= distance)
                {
                    connectArray[i][j] = true;
                    unionArray.union(i,j);
                }
            }
        }
        return unionArray;
        
    }

    
    
    
    
    public static void main(String[] argv) throws Exception
    {
        BufferedReader br = new BufferedReader(new FileReader(argv[0]));
        String line = br.readLine();
         double distance= Double.parseDouble(line);
         //Double.pa
         line = br.readLine();
         int number = Integer.parseInt(line);
         Point2D[] array = new Point2D[number];
         
         for(int i =0; i<number ;i++)
         {
             String[]data = br.readLine().split("" "");
             array[i] = new Point2D( Double.parseDouble(data[0]), Double.parseDouble(data[1]));
         }
         
        
        UF union= connected(array,distance);
        
       // int count =0;//number of groups
        
        
        
        //int[] sequence =ConvexHullVertex(array);
        //for (int i =0; i<sequence.length ;i++)
        //System.out.print(union.count());
        List<Integer> root = new ArrayList<Integer>();
        List<Integer> parent = new ArrayList<Integer>();
        for (int i =0; i< number; i++)
        {
            root.add (union.find(i)); 
        }
        //System.out.print(root.size());
        
        List<List<Integer>> indexArray= new ArrayList<List<Integer>>();
        for(int i =0; i<root.size(); i++)
        {
            //int index;
            if(!parent.contains(root.get(i)))
            {
                parent.add(root.get(i));
                indexArray.add(new ArrayList<Integer>());
            }
            int index = parent.indexOf(root.get(i));
           
            indexArray.get(index).add(root.get(i));
        }
        // System.out.print(indexArray.size());
        
        
        
        for(int i =0 ; i<indexArray.size(); i++)
        {
            if(indexArray.get(i).size()>=3)
            {
               // convexhull
            }
        }
        
        }
    }

   
@3c4f5f6ed458eec6b9ac7ec02e092b30@"
"r04921065","0","0.1","107792","@19a7f38e6c7588ca79436f6118709d13@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].polarOrder());
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@19a7f38e6c7588ca79436f6118709d13@"
"r04921065","0","0","0","@8eafec7f3c02b9e947f41ee7b0f5f570@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@8eafec7f3c02b9e947f41ee7b0f5f570@"
"r04921065","0","0","0","@a2f947d0b86553ae320993afd28af54c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@a2f947d0b86553ae320993afd28af54c@"
"r04921065","0","0.1","107792","@5f733617a0fdee0d0f53c763a0e012dd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N-1) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@5f733617a0fdee0d0f53c763a0e012dd@"
"r04921065","5","0.106","104720","@726b74ae4293371e05aa12dd4d827d97@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;



public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            return index;
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String data = br.readLine();
            double connect = Double.parseDouble(data);
            String data2 = br.readLine();
            int size = Integer.parseInt(data2);
            Point2D[] points = new Point2D[size];
            String open;
            String [] temp = new String[2];
            for(int i=0;i<size;i++){
                open = br.readLine();
                temp = open.split("" "");
                points[i] = new Point2D(Double.parseDouble(temp[0]), Double.parseDouble(temp[1]));
            }
            
            QuickFindUF wei = new QuickFindUF(size);
            for(int i=0;i<size;i++){
                for(int j=0;j<size;j++){
                    if(!wei.connected(i, j)){
                        if(points[i].distanceTo(points[j])<=connect) wei.union(i, j);
                    }                        
                }
            }/*
            for(int i=0; i<size;i++){
                System.out.println(wei.find(i));
            }*/
            int[] num = new int[size];
            for(int i = 0;i<size;i++){
                num[i]=0;
            }
            Point2D[][] t = new Point2D[size][size];
            for(int i = 0;i<size;i++){
                t[wei.find(i)][num[wei.find(i)]]=points[i];
                num[wei.find(i)]++;
            }
            int result=0;
            int[] temp3 = new int[size];
            //Point2D[] t2 = new Point2D[size];
            for(int i=0;i<size;i++){
            if(num[i]>=3){
                Point2D[] t2 = new Point2D[num[i]];
                for(int j=0;j<num[i];j++) t2[j] = t[i][j];
                temp3 = MyConvexHull.ConvexHullVertex(t2);
                result = result+temp3.length;
            }
            //System.out.println(temp3.length);
            //System.out.println(num[i]);
        }
            System.out.println(result);
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
}

@726b74ae4293371e05aa12dd4d827d97@"
"r04921065","5","0.102","106000","@72973b7c1958f22c8c0b67aa935e699b@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;



public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            return index;
    }

    public static void main(String[] args) throws Exception {

       
    }
}

@72973b7c1958f22c8c0b67aa935e699b@"
"r04921065","0","0","0","@77c73824f34218576c9e394d6aa1ee4d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@77c73824f34218576c9e394d6aa1ee4d@"
"r04921065","0","0","0","@4ca1da6772d71fdbdab94c645ff8ff4c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        //System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++)
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@4ca1da6772d71fdbdab94c645ff8ff4c@"
"r04921065","0","0","0","@d7e99663a307dbb1e461102d99c4a1e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        //System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        int[] IDarray = new int[number];
        for(int u = 0;u<number;u++)
            vertex[u] = vals.pop();
        
           int count = 0;
      for (int i= 0;i<N;i++){
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@d7e99663a307dbb1e461102d99c4a1e3@"
"r04921065","0","0","0","@73610963c0b253609b450b6c31ca4a2a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        //System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
           int[] IDarray = new int[number];
           int count = 0;
      for (int i= 0;i<N;i++){
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
    }
}



@73610963c0b253609b450b6c31ca4a2a@"
"r04921065","0","0","0","@3fd25d56e6d9d1bda47e0d553eb76567@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];   //a 為 原始input
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        
        Stack<Point2D> vals = new Stack<Point2D>();
        
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2]);
        
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        //System.out.println(vals.size());
        
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
           int[] IDarray = new int[number];
           int count = 0;
      for (int i= 0;i<N;i++){
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@3fd25d56e6d9d1bda47e0d553eb76567@"
"r04921065","0","0","0","@b6f22b3a776e8d57f085fa384c9a195e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
           int[] IDarray = new int[number];
           int count = 0;
      for (int i= 0;i<N;i++){
        for (int j = 0;j<number;j++)
          {
              if (a[i].equals(vertex[j]))
                  IDarray[count]=i;
              count++;
              
          }
        }
        return IDarray;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@b6f22b3a776e8d57f085fa384c9a195e@"
"r04921065","0","0","0","@d36a7faf3dca9fe8ef1531e20700ae58@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
         int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
       return index;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
}
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@d36a7faf3dca9fe8ef1531e20700ae58@"
"r04921065","5","0.108","107920","@73ac2c3f8f34837e1870d101767a5dc2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
         int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
       return index;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}



@73ac2c3f8f34837e1870d101767a5dc2@"
"r04945022","2","0.52","106000","@d9c220ca4f85dd637e68ffa57c7d7f63@import java.util.Arrays;
import java.util.Stack;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    if(ref.length>=3){
    Arrays.sort(ref);
    return ref;
    }
    else{
      return null;
    }
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}
@d9c220ca4f85dd637e68ffa57c7d7f63@"
"b03611011","0","0.41","106160","@5193d9b9a761bd739cee6d04d0f4e3f4@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int N=10;
    private String[] s;
    private int M =0;

    
    
    public static void main(String[] args) {
        int minpoint=0;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D[] ww = new Point2D[N];
        Point2D min = new Point2D(100,100);
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch(points[i].compareTo(min)){
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min=points[i];
                    minpoint=i;
                    break;
            }
        }
        cc=points.clone();

        // draw p = (x0, x1) in red
        Point2D p = new Point2D(min.x(), min.y());
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        p.draw();
        // draw line segments from p to each point, one at a time, in polar order
        
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, p.POLAR_ORDER);
        
//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(10);
//        }
        
        ww[0] = p;
        ww[1] = points[0];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = points[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
            case -1:
                j--;
                break;
            case 0:
                                ww[j+1].drawTo(ww[j+2]);
                j++;
                i++;
                break;
            case 1:
                                ww[j+1].drawTo(ww[j+2]);
                j++;
                i++;
                break;
            }
        }
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j+2; i++) {
                if(cc[k]==ww[i]){
                System.out.println(k);
                }
            }

        }
    }
    
    
}

@5193d9b9a761bd739cee6d04d0f4e3f4@"
"b03611011","0","0.38","107600","@10432058243eeee6cb4826777a86e89d@
import java.util.Arrays;

public class MyConvexHull {

    public static int N = 10;
    private String[] s;
    private int M = 0;

    public static void main(String[] args) {
        int minpoint = 0;
//        StdDraw.setCanvasSize(500, 500);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D[] ww = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
//            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        cc = points.clone();
        Point2D p = new Point2D(min.x(), min.y());
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p.draw();
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, p.POLAR_ORDER);

//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(10);
//        }
        ww[0] = p;
        ww[1] = points[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = points[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    System.out.println(k);
                }
            }

        }
    }

}

@10432058243eeee6cb4826777a86e89d@"
"r03522809","0","0.51","103920","@1386cb5846739994a7b7678a7b32c4d3@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,decide=0;
      int N = a.length,size=0;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      
      Stack convexhull = new Stack();
      b=a;
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      int[] orians=new int[size];
      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      for(i=0;i<N;i++){
          for(j=0;j<size;j++){
             int c= ans[j];
              if(b[i].compareTo(a[j])==0){orians[i]=i;}
          }
      }
      return  orians;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10,convexsize;
        Point2D[] a = new Point2D[N];
        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;

        
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        System.out.println(a[i]);
        }
        
        System.out.println(ConvexHullVertex(a));

        
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
        }

        int [] convex=ConvexHullVertex(a);
        convexsize=convex.length;
        int[] cox=new int[convexsize];
        j=0;
        for (i=convexsize-1;i>0;i--){
            System.out.println(convex[i]);
            cox[j]=convex[i];
            j++;
        }
        
       
        
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
            }
    }
    
}
@1386cb5846739994a7b7678a7b32c4d3@"
"b01703032","0","0.51","103920","@ccb144061d06d2ba5cdbc8afa2002a62@import java.awt.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;


public class MyConvexHull {
    private static int N, L;
    private static double radius = 0.01;
    private static Point2D[] a;
    
    public static String ConvexHullVertex(Point2D[] a) {
        String s = """";        
        // sorting
        Arrays.sort(a);
        Arrays.sort(a, a[0].POLAR_ORDER);
        
        int result, i1 = 0, i2 = 1, i3 = 2;
        LinkedList<Integer> list = new LinkedList<>();
        Point2D[] tmp = new Point2D[a.length + 2];
        for (int i = 0; i < a.length; i++)
            tmp[i] = a[i];
        tmp[tmp.length - 2] = a[0];
        tmp[tmp.length - 1] = a[1];
        while (i3 < tmp.length) {
            result = Point2D.ccw(tmp[i1], tmp[i2], tmp[i3]);
            // ccw
            if (result == 1) {
                if (list.isEmpty()) {
                    list.addLast(i1);
                }
                else {
                    if (list.getLast() != i1) {
                        list.addLast(i1);
                    }                    
                }
                i1 = i2;
                i2 = i3;
                i3++;
            }
            // cw or collinear
            else {
                if (list.isEmpty()) {
                    i2 = i3;
                    i3++;
                }
                else {
                    i2 = i1;
                    i1 = list.removeLast();
                }
            }
        }
        // display
        while (!list.isEmpty()) {
            s += list.removeFirst();
            s += "" "";
        }
        
        return s;
    } 
    
    public static void main(String[] args) {
        N = Integer.valueOf(args[0]);
//        L = Integer.valueOf(args[1]);
        L = 512;
        a = new Point2D[N];
        
        // create window
        StdDraw.setCanvasSize(L, L);
        StdDraw.setScale(0, L);
        StdDraw.setPenRadius(radius);
        
        // create random points
        int x, y;
        for (int i=0; i<N; i++) {
            x = StdRandom.uniform(L);
            y = StdRandom.uniform(L);
            a[i] = new Point2D(x, y);
        }
        
        String s = """";
        // convex hull
        s = ConvexHullVertex(a);
                
        

    }
}
@ccb144061d06d2ba5cdbc8afa2002a62@"
"b03611011","0","0.49","106368","@8fc007b1292c46a5e69d4638a255366e@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);

        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }

        }
        return out;
    }

    public static void main(String[] args) {
    }
}

@8fc007b1292c46a5e69d4638a255366e@"
"b03611011","4","0.39","107872","@e5c8676b0ebf2936b2e6995d8f750f4b@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);

        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }

        }
        return out;
    }

    public static void main(String[] args) {
    }
}

@e5c8676b0ebf2936b2e6995d8f750f4b@"
"b03611011","4","0.42","107872","@2ca14c86950029052fce90ed639b1dff@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);

        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }

        }
        return out;
    }

    public static void main(String[] args) {
//        int minpoint = 0;
//        int M = 10;
//        StdDraw.setCanvasSize(500, 500);
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.005);
//        Point2D[] points = new Point2D[M];
//        Point2D[] cc = new Point2D[M];
//        Point2D[] ww = new Point2D[M];
//        Point2D min = new Point2D(100, 100);
//        for (int i = 0; i < M; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//            switch (points[i].compareTo(min)) {
//                case 1:
//                    break;
//                case 0:
//                    break;
//                case -1:
//                    min = points[i];
//                    minpoint = i;
//                    break;
//            }
//        }
//        MyConvexHull t = new MyConvexHull();
//        int[] x;
//        x = t.ConvexHullVertex(points);
//        System.out.println(x);
//
//        cc = points.clone();
//
//        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(min.x(), min.y());
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p.draw();
//        // draw line segments from p to each point, one at a time, in polar order
//
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(points, p.ATAN2_ORDER);
//
////        for (int i = 0; i < N; i++) {
////            p.drawTo(points[i]);
////            StdDraw.show(10);
////        }
//        ww[0] = p;
//        ww[1] = points[0];
//        ww[0].drawTo(ww[1]);
//        int j = 0;
//        int i = 0;
//        while (i < M - 1) {
//            ww[j + 2] = points[i + 1];
//            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
//                case -1:
//                    j--;
//                    break;
//                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
//                    j++;
//                    i++;
//                    break;
//                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
//                    j++;
//                    i++;
//                    break;
//            }
//        }
//        for (int k = 0; k < M; k++) {
//            for (i = 1; i < j + 2; i++) {
//                if (cc[k] == ww[i]) {
//                    System.out.println(k);
//                }
//            }
//
//        }
//        System.out.println(j + 1);
    }
}

@2ca14c86950029052fce90ed639b1dff@"
"b03611011","4","0.43","107872","@c6ccf325672d54dcf5eb7ea5c29cfcf5@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 100;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

        cc = points.clone();

        // draw p = (x0, x1) in red
        Point2D p = new Point2D(min.x(), min.y());
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        p.draw();
        // draw line segments from p to each point, one at a time, in polar order

        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, p.ATAN2_ORDER);

//        for (int i = 0; i < N; i++) {
//            p.drawTo(points[i]);
//            StdDraw.show(10);
//        }
        ww[0] = p;
        ww[1] = points[0];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < M - 1) {
            ww[j + 2] = points[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        for (int k = 0; k < M; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    System.out.println(k);
                }
            }

        }
        System.out.println(j + 1);
    }
}

@c6ccf325672d54dcf5eb7ea5c29cfcf5@"
"b03611011","4","0.42","105984","@ea0fc25ec2b97e60bea4ee539f51f83a@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 2;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

            }
}

@ea0fc25ec2b97e60bea4ee539f51f83a@"
"r04228027","0","0.49","107632","@8adb91e96e76542cb3a2b23803904c6f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@8adb91e96e76542cb3a2b23803904c6f@"
"r04228027","0","0.49","107632","@67b1a4c212d38b404a86c8a76afb656b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
// import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@67b1a4c212d38b404a86c8a76afb656b@"
"b03611011","0","0","0","@d9ebe9808b237fc0f1d72a210f21a6bd@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 1;
        if(N==2){
        return null;
        }
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 2];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 5;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

            }
}

@d9ebe9808b237fc0f1d72a210f21a6bd@"
"r04631004","0","0.49","107616","@0f24400c83fe8c591d2bfe340069a513@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myconvexhull;


import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min_y = 10000.0;
        int temp_i = 0;
        for (int i = 0; i < a.length; i++) { //找y最小的點作為頂點
            if (a[i].y() < min_y) {
                min_y = a[i].y();
                temp_i = i;
            }
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        a[temp_i].draw();
        double[] angle = new double[a.length];
        for (int i = 0; i < a.length; i++) { //算角度
            if (i != temp_i) {
                angle[i] = Math.acos((a[i].x() - a[temp_i].x()) / Math.sqrt(Math.pow(a[i].x() - a[temp_i].x(), 2) + Math.pow(a[i].y() - a[temp_i].y(), 2))) * 180 / 3.1415;
            } else {
                angle[i] = 0;
            }
        }

        double[] angle_sort = Arrays.copyOf(angle, a.length);
        Arrays.sort(angle_sort);  //把算出來的角度做sorting

        int[] temp_index = new int[a.length];
        int[] index = new int[a.length]; //將sorting後的點與原array做比較，並將index做sorting
        for (int i = 0; i < angle_sort.length; i++) {
            for (int j = 0; j < angle.length; j++) {
                if (angle_sort[i] == angle[j] && temp_index[j] == 0) {
                    index[i] = j;
                    temp_index[j]=1;
                    break;
                }
            }
        }
        Stack<Integer> convexhull = new Stack<Integer>();
        convexhull.push(index[0]);
        convexhull.push(index[1]);
        convexhull.push(index[2]);

        int O = 0;
        int A = 0;
        int B = 0;
        for (int i = 3; i < angle_sort.length; i++) { //逆時針去計算外積，若為正值即為外凸點
            B = index[i];
            A = convexhull.pop();
            O = convexhull.pop();
            if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                convexhull.push(O);
                convexhull.push(A);
                convexhull.push(B);
            } else {
                for (int j = convexhull.size() + 2; j > 2; j--) {
                    A = O;
                    O = convexhull.pop();
                    if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                        convexhull.push(O);
                        convexhull.push(A);
                        convexhull.push(B);
                        break;
                    }
                }
            }

        }

        int[] Vertex = new int[convexhull.size()];
        for (int i = 0; i < Vertex.length; i++) {
            Vertex[i] = convexhull.pop();
        }
        Arrays.sort(Vertex);   //將結果依照小至大sorting
        return Vertex;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
//        StdDraw.setCanvasSize(200, 200);
//        StdDraw.setXscale(0, 20);
//        StdDraw.setYscale(0, 20);
//        Point2D[] points = new Point2D[10];
//        // TODO code application logic here
//        for (int i = 0; i < 10; i++) {
//            int x = StdRandom.uniform(10);
//            int y = StdRandom.uniform(10);
//            //StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//
//        int[] result = ConvexHullVertex(points);
//        for (int i = 0; i < result.length; i++) {
//            System.out.println(result[i]);
//        }

    }
}

@0f24400c83fe8c591d2bfe340069a513@"
"r04631004","0","0","0","@5f6a0b3e601091d505cd556b92d7acda@
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min_y = 10000.0;
        int temp_i = 0;
        for (int i = 0; i < a.length; i++) { //找y最小的點作為頂點
            if (a[i].y() < min_y) {
                min_y = a[i].y();
                temp_i = i;
            }
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        a[temp_i].draw();
        double[] angle = new double[a.length];
        for (int i = 0; i < a.length; i++) { //算角度
            if (i != temp_i) {
                angle[i] = Math.acos((a[i].x() - a[temp_i].x()) / Math.sqrt(Math.pow(a[i].x() - a[temp_i].x(), 2) + Math.pow(a[i].y() - a[temp_i].y(), 2))) * 180 / 3.1415;
            } else {
                angle[i] = 0;
            }
        }

        double[] angle_sort = Arrays.copyOf(angle, a.length);
        Arrays.sort(angle_sort);  //把算出來的角度做sorting

        int[] temp_index = new int[a.length];
        int[] index = new int[a.length]; //將sorting後的點與原array做比較，並將index做sorting
        for (int i = 0; i < angle_sort.length; i++) {
            for (int j = 0; j < angle.length; j++) {
                if (angle_sort[i] == angle[j] && temp_index[j] == 0) {
                    index[i] = j;
                    temp_index[j]=1;
                    break;
                }
            }
        }
        Stack<Integer> convexhull = new Stack<Integer>();
        convexhull.push(index[0]);
        convexhull.push(index[1]);
        convexhull.push(index[2]);

        int O = 0;
        int A = 0;
        int B = 0;
        for (int i = 3; i < angle_sort.length; i++) { //逆時針去計算外積，若為正值即為外凸點
            B = index[i];
            A = convexhull.pop();
            O = convexhull.pop();
            if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                convexhull.push(O);
                convexhull.push(A);
                convexhull.push(B);
            } else {
                for (int j = convexhull.size() + 2; j > 2; j--) {
                    A = O;
                    O = convexhull.pop();
                    if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                        convexhull.push(O);
                        convexhull.push(A);
                        convexhull.push(B);
                        break;
                    }
                }
            }

        }

        int[] Vertex = new int[convexhull.size()];
        for (int i = 0; i < Vertex.length; i++) {
            Vertex[i] = convexhull.pop();
        }
        Arrays.sort(Vertex);   //將結果依照小至大sorting
        return Vertex;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
//        StdDraw.setCanvasSize(200, 200);
//        StdDraw.setXscale(0, 20);
//        StdDraw.setYscale(0, 20);
//        Point2D[] points = new Point2D[10];
//        // TODO code application logic here
//        for (int i = 0; i < 10; i++) {
//            int x = StdRandom.uniform(10);
//            int y = StdRandom.uniform(10);
//            //StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//
//        int[] result = ConvexHullVertex(points);
//        for (int i = 0; i < result.length; i++) {
//            System.out.println(result[i]);
//        }

    }
}

@5f6a0b3e601091d505cd556b92d7acda@"
"r04631031","0","0.46","106368","@5677050e1e8651eedaa57b1f2b864d41@
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import static java.lang.Math.atan;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class MyConvexHull {
    public static double cross(Point2D o, Point2D a, Point2D b){
        return (a.x()-o.x())*(b.y()-a.y())-(a.y()-o.y())*(b.x()-a.x());
    }
    public static boolean ccw(Point2D o, Point2D a, Point2D b){
        boolean ans = false;
        if(cross(o,a,b)>0){
            ans = true;
        }
        else
            ans = false;
        return ans;
    }
    public static Point2D[] sort(Point2D[] a){
        //Find the lowest point
        Point2D p = new Point2D(0,0);
        p = a[0];
        for(int i = 0; i < a.length; i++){
            if(p.y()>a[i].y()){
                p = a[i];
            }
        }
        //Create array to store every point's angle
        double[] angle = new double[a.length];
        for(int i = 0; i < a.length; i++){
            angle[i] = atan((a[0].x()-p.x())/(a[0].y()-p.y()));
        }
        //Sort Point2D array a 
        Point2D temppoint = new Point2D(0,0);
        double tempangle = 0;
        for(int i = 0; i < a.length; i++){
            for(int j = i+1; j < a.length; j++){
                if(angle[i]<angle[j]){
                    tempangle = angle[i];
                    angle[i] = angle[j];
                    angle[j] = tempangle;
                    temppoint = a[i];
                    a[i] = a[j];
                    a[j] = temppoint;
                }
            }
        }
        return a;
    }
    public static int[] ConvexHullVertex(Point2D[] a){
        sort(a);
        //Create Point2D array to store convexhullvertex's points
        Stack <Point2D> vertex = new Stack <Point2D>();
        vertex.push(a[0]);
        vertex.push(a[1]);
        for(int i = 2; i < a.length; i++){
            Point2D secondpoint = vertex.pop();
            while(!ccw(vertex.peek(),secondpoint,a[i])){
                secondpoint = vertex.pop();
            }
            vertex.push(secondpoint);
            vertex.push(a[i]);
        }
        //Create int array to store points' index
        int[] p = new int[vertex.size()];
        int j = 0;
        for (Point2D q : vertex) {
             p[vertex.size()- j - 1] = Arrays.asList(a).indexOf(q);
             j++;
        }
        
        return p;
    }
}

@5677050e1e8651eedaa57b1f2b864d41@"
"r04631031","0","0.43","106000","@e49b0fd877353195d3c19af31a0b1d1d@
import static java.lang.Math.atan;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class MyConvexHull {
    public static double cross(Point2D o, Point2D a, Point2D b){
        return (a.x()-o.x())*(b.y()-a.y())-(a.y()-o.y())*(b.x()-a.x());
    }
    public static boolean ccw(Point2D o, Point2D a, Point2D b){
        boolean ans = false;
        if(cross(o,a,b)>0){
            ans = true;
        }
        else
            ans = false;
        return ans;
    }
    public static Point2D[] sort(Point2D[] a){
        //Find the lowest point
        Point2D p = new Point2D(0,0);
        p = a[0];
        for(int i = 0; i < a.length; i++){
            if(p.y()>a[i].y()){
                p = a[i];
            }
        }
        //Create array to store every point's angle
        double[] angle = new double[a.length];
        for(int i = 0; i < a.length; i++){
            angle[i] = atan((a[0].x()-p.x())/(a[0].y()-p.y()));
        }
        //Sort Point2D array a 
        Point2D temppoint = new Point2D(0,0);
        double tempangle = 0;
        for(int i = 0; i < a.length; i++){
            for(int j = i+1; j < a.length; j++){
                if(angle[i]<angle[j]){
                    tempangle = angle[i];
                    angle[i] = angle[j];
                    angle[j] = tempangle;
                    temppoint = a[i];
                    a[i] = a[j];
                    a[j] = temppoint;
                }
            }
        }
        return a;
    }
    public static int[] ConvexHullVertex(Point2D[] a){
        sort(a);
        //Create Point2D array to store convexhullvertex's points
        Stack <Point2D> vertex = new Stack <Point2D>();
        vertex.push(a[0]);
        vertex.push(a[1]);
        for(int i = 2; i < a.length; i++){
            Point2D secondpoint = vertex.pop();
            while(!ccw(vertex.peek(),secondpoint,a[i])){
                secondpoint = vertex.pop();
            }
            vertex.push(secondpoint);
            vertex.push(a[i]);
        }
        //Create int array to store points' index
        int[] p = new int[vertex.size()];
        int j = 0;
        for (Point2D q : vertex) {
             p[vertex.size()- j - 1] = Arrays.asList(a).indexOf(q);
             j++;
        }
        
        return p;
    }
}

@e49b0fd877353195d3c19af31a0b1d1d@"
"r04631031","0","0.45","107824","@122435d8f3ad5a17929813d09bb1a8a4@
import static java.lang.Math.atan;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class MyConvexHull {
    public static double cross(Point2D o, Point2D a, Point2D b){
        return (a.x()-o.x())*(b.y()-a.y())-(a.y()-o.y())*(b.x()-a.x());
    }
    public static boolean ccw(Point2D o, Point2D a, Point2D b){
        boolean ans = false;
        if(cross(o,a,b)>0){
            ans = true;
        }
        else
            ans = false;
        return ans;
    }
    public static Point2D[] sort(Point2D[] a){
        //Find the lowest point
        Point2D p = new Point2D(0,0);
        p = a[0];
        for(int i = 0; i < a.length; i++){
            if(p.y()>a[i].y()){
                p = a[i];
            }
        }
        //Create array to store every point's angle
        double[] angle = new double[a.length];
        for(int i = 0; i < a.length; i++){
            angle[i] = atan((a[0].x()-p.x())/(a[0].y()-p.y()));
        }
        //Sort Point2D array a 
        Point2D temppoint = new Point2D(0,0);
        double tempangle = 0;
        for(int i = 0; i < a.length; i++){
            for(int j = i+1; j < a.length; j++){
                if(angle[i]<angle[j]){
                    tempangle = angle[i];
                    angle[i] = angle[j];
                    angle[j] = tempangle;
                    temppoint = a[i];
                    a[i] = a[j];
                    a[j] = temppoint;
                }
            }
        }
        return a;
    }
    public static int[] ConvexHullVertex(Point2D[] a){
        sort(a);
        //Create Point2D array to store convexhullvertex's points
        Stack <Point2D> vertex = new Stack <Point2D>();
        vertex.push(a[0]);
        vertex.push(a[1]);
        for(int i = 2; i < a.length; i++){
            Point2D secondpoint = vertex.pop();
            while(!ccw(vertex.peek(),secondpoint,a[i])){
                secondpoint = vertex.pop();
            }
            vertex.push(secondpoint);
            vertex.push(a[i]);
        }
        //Create int array to store points' index
        int[] p = new int[vertex.size()];
        int j = 0;
        for (Point2D q : vertex) {
             p[vertex.size()- j - 1] = Arrays.asList(a).indexOf(q);
             j++;
        }
        for(int i = 0; i < vertex.size(); i++){
            System.out.print(p[i]);
            System.out.print("" "");
        }
        return p;
    }
    public static void main(String[] args) {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for(int i = 0; i < N; i++){
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x,y);
        }
        ConvexHullVertex(a);
    }
}

@122435d8f3ad5a17929813d09bb1a8a4@"
"b03611011","0","0","0","@f0a9855bd7fecdeb67a9971c47ae2b02@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 1;
        if (N == 2) {
            return null;
        }
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 2];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j + 2; i++) {
                if (cc[k].compareTo(ww[i])==0) {
                    out[count] = k;
                    count++;           
                    i = 0;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 10;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);
        for (int i = 0; i < x.length; i++) {
            System.out.println(x[i]);
        }

    }
}

@f0a9855bd7fecdeb67a9971c47ae2b02@"
"b03611011","0","0","0","@88c9aaceb6d4a34721feaf3cbb3b8f1f@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 1;
        if (N == 2) {
            return null;
        }
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 2];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j + 2; i++) {
                if (cc[k].compareTo(ww[i])==0) {
                    out[count] = k;
                    count++;           
                    i = 0;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {

    }
}

@88c9aaceb6d4a34721feaf3cbb3b8f1f@"
"b03611011","0","0","0","@1442df50a6822831e8b52a5578bbb0a5@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 1;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 2];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j + 2; i++) {
                if (cc[k].compareTo(ww[i])==0) {
                    out[count] = k;
                    count++;           
                    i = 0;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 100;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);
        for (int i = 0; i < x.length; i++) {
            System.out.println(x[i]);
        }

    }
}

@1442df50a6822831e8b52a5578bbb0a5@"
"b03611011","4","0.41","107904","@4b4207812cec78e486024f46fd43a29d@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Frank
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[0];
//        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 100;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

            }
}
@4b4207812cec78e486024f46fd43a29d@"
"b03611011","0","0","0","@a962eccec4577afbded66174343cc46c@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 2) {
            ww[j + 2] = point[i + 2];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 3;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

            }
}
@a962eccec4577afbded66174343cc46c@"
"b03611011","0","0","0","@33ad9ad286383d563c62b5ad66ab2544@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        if (N <= 2) {
            return null;
        }
        ww[0] = p;
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 2) {
            ww[j + 2] = point[i + 2];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 1;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

    }
}

@33ad9ad286383d563c62b5ad66ab2544@"
"b03611011","0","0","0","@7899512b175617dd59bbc2169aa03929@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        if (N <= 2) {
            return null;
        }
        ww[0] = point[0];
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 0;
        int i = 0;
        while (i < N - 1) {
            ww[j + 2] = point[i + 1];
            switch (Point2D.ccw(ww[j], ww[j + 1], ww[j + 2])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j + 1].drawTo(ww[j + 2]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j + 1];
        if (j > N / 2) {
            out = new int[j + 1];
            return out;
        }
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 1; i < j + 2; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 10;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);

    }
}

@7899512b175617dd59bbc2169aa03929@"
"b02611028","0","0","0","@279aaa9051ae3e9d97322f2df022c09f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
           /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/

        
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
           
            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                StdDraw.setPenColor(StdDraw.RED);
                StdDraw.setPenRadius(.01);
                a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(.01);
                a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            StdDraw.setPenRadius(.001);
            StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s=pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf=pp.pop();
            for (int i = 0; i < a.length; i++) {
                if(buf.equals(a[i])){
                    ans[j]=i;
                }
            }
        }
        Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
            System.out.print(ans[i]);
        }*/
        return ans;
    }

    public static void main(String[] args) {
        int Num=10;
        Point2D[] a = new Point2D[Num];
        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.01);
        
        for (int i=0;i<Num;i++){
         int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b=ConvexHullVertex(a);
    }
}

@279aaa9051ae3e9d97322f2df022c09f@"
"b02611028","0","0","0","@102595c6f683e29a22e8c5b729147885@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
           /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/

        
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
           
            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                StdDraw.setPenColor(StdDraw.RED);
                StdDraw.setPenRadius(.01);
                a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(.01);
                a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            StdDraw.setPenRadius(.001);
            StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s=pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf=pp.pop();
            for (int i = 0; i < a.length; i++) {
                if(buf.equals(a[i])){
                    ans[j]=i;
                }
            }
        }
        Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
            System.out.print(ans[i]);
        }*/
        return ans;
    }

    public static void main(String[] args) {
        /*int Num=10;
        Point2D[] a = new Point2D[Num];
        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.01);
        
        for (int i=0;i<Num;i++){
         int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b=ConvexHullVertex(a);
        for (int i=0;i<b.length;i++){
            System.out.print(b[i]);
        }*/
    }
}

@102595c6f683e29a22e8c5b729147885@"
"b02611028","0","0.52","107872","@e07c6f3664f3477db78eec4f79771dc8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
           /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/

        
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
           
            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
               // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
               // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
               // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
          //  StdDraw.setPenRadius(.001);
           // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
          //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s=pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf=pp.pop();
            for (int i = 0; i < a.length; i++) {
                if(buf.equals(a[i])){
                    ans[j]=i;
                }
            }
        }
        Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
            System.out.print(ans[i]);
        }*/
        return ans;
    }

    public static void main(String[] args) {
        /*int Num=10;
        Point2D[] a = new Point2D[Num];
        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.01);
        
        for (int i=0;i<Num;i++){
         int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b=ConvexHullVertex(a);
        for (int i=0;i<b.length;i++){
            System.out.print(b[i]);
        }*/
    }
}

@e07c6f3664f3477db78eec4f79771dc8@"
"b02611028","0","0","0","@757def7719fd59d8873c2569c56942a1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a){
           /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/

        
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
           
            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
               // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
               // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
               // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            StdDraw.setPenRadius(.001);
           // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
          //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s=pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf=pp.pop();
            for (int i = 0; i < a.length; i++) {
                if(buf.equals(a[i])){
                    ans[j]=i;
                }
            }
        }
        Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
            System.out.print(ans[i]);
        }*/
        return ans;
    }

    public static void main(String[] args) {
        /*int Num=10;
        Point2D[] a = new Point2D[Num];
        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.01);
        
        for (int i=0;i<Num;i++){
         int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b=ConvexHullVertex(a);
        for (int i=0;i<b.length;i++){
            System.out.print(b[i]);
        }*/
    }
}

@757def7719fd59d8873c2569c56942a1@"
"b02611028","0","0.49","107888","@f17440d38cf1c67decbc1cfe24f11055@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/
        Point2D[] b=a;
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
                // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
               // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
                // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
           // StdDraw.setPenRadius(.001);
            // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s = pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf = pp.pop();
            for (int i = 0; i < b.length; i++) {
                if (buf.equals(b[i])) {
                    ans[j] = i;
                }
            }
        }
        Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
         System.out.print(ans[i]);
         }*/
        return ans;
    }

    public static void main(String[] args) {
        int Num = 10;
        Point2D[] a = new Point2D[Num];
        /*StdDraw.setCanvasSize(800, 800);
         StdDraw.setXscale(0, 100);
         StdDraw.setYscale(0, 100);
         StdDraw.setPenRadius(.01);*/

        for (int i = 0; i < Num; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b = ConvexHullVertex(a);
        for (int i = 0; i < b.length; i++) {
            System.out.print(b[i]);
        }
    }
}

@f17440d38cf1c67decbc1cfe24f11055@"
"b02611028","0","0.5","106016","@05044d494c13ea65f7f0629a255746ea@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/
        Point2D[] b=a;
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
                // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
               // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
                // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
           // StdDraw.setPenRadius(.001);
            // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s = pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf = pp.pop();
            for (int i = 0; i < b.length; i++) {
                if (buf.equals(b[i])) {
                    ans[j] = i;
                }
            }
        }
        //Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
         System.out.print(ans[i]);
         }*/
        return ans;
    }

    public static void main(String[] args) {
        int Num = 10;
        Point2D[] a = new Point2D[Num];
        /*StdDraw.setCanvasSize(800, 800);
         StdDraw.setXscale(0, 100);
         StdDraw.setYscale(0, 100);
         StdDraw.setPenRadius(.01);*/

        for (int i = 0; i < Num; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            a[i] = new Point2D(x, y);
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
        }
        int[] b = ConvexHullVertex(a);
        for (int i = 0; i < b.length; i++) {
            System.out.print(b[i]);
        }
    }
}

@05044d494c13ea65f7f0629a255746ea@"
"b02611028","0","0.49","107888","@aa68672b115f764bdaac0b4b4d68753a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/
        Point2D[] b = a;
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
                // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
                // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
                // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            // StdDraw.setPenRadius(.001);
            // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s = pp.size();
        Point2D buf;
        for (int j = 0; j < s; j++) {
            buf = pp.pop();
            for (int i = 0; i < b.length; i++) {
                if (buf.equals(b[i])) {
                    ans[j] = i;
                }
            }
        }
        //Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
         System.out.print(ans[i]);
         }*/
        Arrays.sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        //try (BufferedReader br = new BufferedReader(new FileReader(""test""))) {
        int Num = 10;
        Point2D[] a = new Point2D[Num];
        /*StdDraw.setCanvasSize(800, 800);
         StdDraw.setXscale(0, 100);
         StdDraw.setYscale(0, 100);
         StdDraw.setPenRadius(.01);*/

            //for (int i = 0; i < 10; i++) {
        //int x = StdRandom.uniform(100);
        //int y = StdRandom.uniform(100);
        a[0] = new Point2D(0.200, 0.250);
        a[1] = new Point2D(0.147, 0.387);
        a[2] = new Point2D(0.300, 0.300);
        a[3] = new Point2D(0.333, 0.213);
        a[4] = new Point2D(0.353, 0.412);
        a[5] = new Point2D(0.700, 0.890);
        a[6] = new Point2D(0.879, 0.700);
        a[7] = new Point2D(0.867, 0.888);
        a[8] = new Point2D(0.980, 0.120);
        a[9] = new Point2D(0.111, 0.932);
            //System.out.print(a[i]);
        //System.out.printf(""%n"");
        //}
        int[] b = ConvexHullVertex(a);
        for (int i = 0; i < b.length; i++) {
            System.out.print(b[i]);
        }
    }
}

@aa68672b115f764bdaac0b4b4d68753a@"
"b02611028","5","0.106","107872","@45bd48244db41b1f44291c2a269a0a0e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/
        Point2D[] b = new Point2D[a.length];
        for (int i=0;i<b.length;i++){
            b[i]=a[i];
        }
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
                // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
                // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
                // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            // StdDraw.setPenRadius(.001);
            // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        int[] ans = new int[pp.size()];
        int s = pp.size();
        Point2D buf;
        /*for (int i=0;i<b.length;i++){
            System.out.print(b[i]);
        }*/
        for (int j = 0; j < s; j++) {
            buf = pp.pop();
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals(buf)) {
                    ans[j] = i;
                    //System.out.print(b[i]);
                    //System.out.printf(""%n"");
                }
            }
        }
        //Arrays.sort(ans);
        /*for (int i=0;i<ans.length;i++){
         System.out.print(ans[i]);
         }*/
        //Arrays.sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        //try (BufferedReader br = new BufferedReader(new FileReader(""test""))) {
        int Num = 10;
        Point2D[] a = new Point2D[Num];
        /*StdDraw.setCanvasSize(800, 800);
         StdDraw.setXscale(0, 100);
         StdDraw.setYscale(0, 100);
         StdDraw.setPenRadius(.01);*/

            //for (int i = 0; i < 10; i++) {
        //int x = StdRandom.uniform(100);
        //int y = StdRandom.uniform(100);
        a[0] = new Point2D(0.200, 0.250);
        a[1] = new Point2D(0.147, 0.387);
        a[2] = new Point2D(0.300, 0.300);
        a[3] = new Point2D(0.333, 0.213);
        a[4] = new Point2D(0.353, 0.412);
        a[5] = new Point2D(0.700, 0.890);
        a[6] = new Point2D(0.879, 0.700);
        a[7] = new Point2D(0.867, 0.888);
        a[8] = new Point2D(0.980, 0.120);
        a[9] = new Point2D(0.111, 0.932);
            //System.out.print(a[i]);
        //System.out.printf(""%n"");
        //}
        int[] b = ConvexHullVertex(a);
        for (int i = 0; i < b.length; i++) {
            System.out.print(b[i]);
        }
    }
}

@45bd48244db41b1f44291c2a269a0a0e@"
"b03611011","0","0","0","@848e6552409b887009549a0384ddf29b@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = point[0];
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 2;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j-2], ww[j -1], ww[j ])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 2;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x.length);

            }
}
@848e6552409b887009549a0384ddf29b@"
"b03611011","0","0","0","@f352cffd9c2d6ad65f6afaa1063a57d6@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = point[0];
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 2;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j-2], ww[j -1], ww[j ])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j-1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {

            }
}
@f352cffd9c2d6ad65f6afaa1063a57d6@"
"b03611011","0","0","0","@1ca578607c204eaf1d834a6f0c9de416@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        ww[0] = point[0];
        ww[1] = point[1];
        ww[0].drawTo(ww[1]);
        int j = 2;
        int i = 0;
        if(N==2){
        return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j-2], ww[j -1], ww[j ])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j-1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j-1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }
        return out;
    }

    public static void main(String[] args) {
        int minpoint = 0;
        int M = 9;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    minpoint = i;
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x.length);

            }
}
@1ca578607c204eaf1d834a6f0c9de416@"
"r04631004","5","0.098","107152","@2512be3c6d2b6d994e26d8cccd20f398@
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min_y = 10000.0;
        int temp_i = 0;
        for (int i = 0; i < a.length; i++) { //找y最小的點作為頂點
            if (a[i].y() < min_y) {
                min_y = a[i].y();
                temp_i = i;
            }
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.01);
//        a[temp_i].draw();
        double[] angle = new double[a.length];
        for (int i = 0; i < a.length; i++) { //算角度
            if (i != temp_i) {
                angle[i] = Math.acos((a[i].x() - a[temp_i].x()) / Math.sqrt(Math.pow(a[i].x() - a[temp_i].x(), 2) + Math.pow(a[i].y() - a[temp_i].y(), 2))) * 180 / 3.1415;
            } else {
                angle[i] = 0;
            }
        }

        double[] angle_sort = Arrays.copyOf(angle, a.length);
        Arrays.sort(angle_sort);  //把算出來的角度做sorting

        int[] temp_index = new int[a.length];
        int[] index = new int[a.length]; //將sorting後的點與原array做比較，並將index做sorting
        for (int i = 0; i < angle_sort.length; i++) {
            for (int j = 0; j < angle.length; j++) {
                if (angle_sort[i] == angle[j] && temp_index[j] == 0) {
                    index[i] = j;
                    temp_index[j]=1;
                    break;
                }
            }
        }
        Stack<Integer> convexhull = new Stack<Integer>();
        convexhull.push(index[0]);
        convexhull.push(index[1]);
        convexhull.push(index[2]);

        int O = 0;
        int A = 0;
        int B = 0;
        for (int i = 3; i < angle_sort.length; i++) { //逆時針去計算外積，若為正值即為外凸點
            B = index[i];
            A = convexhull.pop();
            O = convexhull.pop();
            if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                convexhull.push(O);
                convexhull.push(A);
                convexhull.push(B);
            } else {
                for (int j = convexhull.size() + 2; j > 2; j--) {
                    A = O;
                    O = convexhull.pop();
                    if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                        convexhull.push(O);
                        convexhull.push(A);
                        convexhull.push(B);
                        break;
                    }
                }
            }

        }

        int[] Vertex = new int[convexhull.size()];
        for (int i = 0; i < Vertex.length; i++) {
            Vertex[i] = convexhull.pop();
        }
        Arrays.sort(Vertex);   //將結果依照小至大sorting
        return Vertex;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        //StdDraw.setCanvasSize(200, 200);
        //StdDraw.setXscale(0, 5);
        //StdDraw.setYscale(0, 5);
        Point2D[] points = new Point2D[10];
        // TODO code application logic here
        for (int i = 0; i < 10; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            //StdDraw.setPenColor(StdDraw.RED);
            //System.out.println(x+"" ""+y);
            //StdDraw.setPenRadius(.01);
            points[i] = new Point2D(x, y);
            //points[i].draw();
        }

        int[] result = ConvexHullVertex(points);
//        for (int i = 0; i < result.length; i++) {
//            System.out.println(result[i]);
//        }

    }
}

@2512be3c6d2b6d994e26d8cccd20f398@"
"f02631008","0","0","0","@26158e0c650e68064d6b7136c14da728@import java.io.*;
import java.util.Scanner;
import java.io.IOException;
import java.util.Arrays;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        _parent[j] = i;
        _rank[j]++;
        /*if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }*/
    }
    public MyConvexHull(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }
    
    
    public static double angle(double x1, double y1, double x2, double y2)
    {
        double dx=x2-x1,dy=y2-y1, PI=(double)Math.PI;
        double angle=0.0;
        
        if(dx==0)
           if(dy==0)angle=0;
           else if(dy>0)angle=PI/2;
           else angle=PI*3/2;
        else if(dy==0)
           if(dx>0)angle=0;
           else angle=PI;
        else if(dx<0)angle=Math.atan(dy/dx)+PI;
        else if(dy<0)angle=Math.atan(dy/dx)+(2*PI);
        else angle=Math.atan(dy/dx);

        return (double)angle*180/PI;
    }
    
    
    public static double ccwd(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int []index = new int[a.length];
//        int[] index = { 1, 2, 3, 4, 5, 6 };
        
        int minAng = 360;
        int lastAng = 0;
        int NxtPt = 0;
        int NxtPt0 = 0;
        int EndPtFlag = 0;
        int ifflag = 0;
        int CX = 0;
        Point2D[] pts = a;
        int ArrNum = a.length;
        
        int minPtsNum = 0; 
        double lastptsy = 1;
        for(int i = 0; i < ArrNum; i++){
            if(pts[i].y() < lastptsy){
               minPtsNum = i; 
            }
            lastptsy = pts[i].y();
        }
        
//        for(int i = 0; i < ArrNum; i++){
                ifflag = 0;
                lastAng = 0;
                NxtPt = 0;
                NxtPt0 = 0;
                if(ifflag == 0){
                    NxtPt = minPtsNum;
                    while(EndPtFlag == 0){
                        double [] AngleArr = new double[ArrNum];
                        int [] AngleArrI = new int[ArrNum]; 
                        minAng = 360;
//                        System.out.println(NxtPt);
                        index[CX] = NxtPt;
                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
                                AngleArrI[j] = (int)AngleArr[j];
                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
                                    minAng = AngleArrI[j]-lastAng;
                                    NxtPt0 = j;
                                }
//                            }
                        }
                        NxtPt = NxtPt0;
                        lastAng = minAng;
//                        System.out.println(NxtPt);
                        CX++;
                        
                        if(NxtPt == minPtsNum){
                            EndPtFlag = 1;
                            break;
                        }
                    }
                    ifflag = 1;
                }
                EndPtFlag=0;
//            }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return index;
    }
    
     
    public static void main(String[] args) {
        File file = new File(args[0]);
        try{
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            double MinDis = Double.parseDouble(line_1);
//            System.out.println(MinDis);
            
            String line_2 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_2);
//            System.out.println(ArrNum);
            
            int Ai = 0;
            Point2D[] pts = new Point2D[ArrNum];
            
            while (File_in.hasNextLine())
            {
                String line_3 = File_in.nextLine();
                String[] GivePoint = line_3.split("" "");
                double Px = Double.parseDouble(GivePoint[0]);
                double Py = Double.parseDouble(GivePoint[1]);
                
                pts[Ai] = new Point2D(Px ,Py);
                Ai++;
            }
//            System.out.println(pts[3].x());
//            System.out.println(Points[3][1]);
            double Distance = 0.0;
            MyConvexHull uf = new MyConvexHull(ArrNum);
            //Distance = Math.sqrt(Math.pow(Points[0][0]-Points[1][0],2)+Math.pow(Points[0][1]-Points[1][1],2));
//            System.out.println(Distance);
                      
            
            for(int i = 0; i < ArrNum; i++){
                for(int j = 0; j < ArrNum; j++){
                    if(i != j ){
//                        StdDraw.setPenRadius(0.01);
//                        StdDraw.setPenColor(StdDraw.BLACK);
//                        StdDraw.point(pts[i].x(), pts[i].y());
//                        StdDraw.point(pts[j].x(), pts[j].y());
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.text(pts[i].x()+0.02, pts[i].y(),  Integer.toString(i));
                        
                        Distance = Math.sqrt(Math.pow(pts[i].x()-pts[j].x(),2)+Math.pow(pts[i].y()-pts[j].y(),2));

                        if(Distance <= MinDis){
                            //System.out.println(Distance);
//                            StdDraw.setPenRadius(0.001);
//                            StdDraw.setPenColor(StdDraw.GREEN);
//                            StdDraw.line(pts[i].x(), pts[i].y(), pts[j].x(), pts[j].y());
                            
                            if(pts[i].y() < pts[j].y()){
                                uf.union(i,j);
                            }
                            else{
                                uf.union(j,i);
                            }
                        }
                    }
                }
            }
//            System.out.println(uf);
            

            
            
            int[] RedArr = new int[ArrNum];
            for(int i = 0; i < ArrNum; i++){
                RedArr[i] = -1;
            }
            
            int RedFlag = 0;
            for(int i = 0; i < ArrNum; i++){
                int ParCount = 0;
                for(int j = 0; j < ArrNum; j++){
                    if(uf._parent[j] == i){
                        ParCount++;  
                        if(ParCount >= 3){
                            if(RedFlag == 0){
                                RedArr[i] = i;
                                RedFlag = 1;
                            }
                            uf._rank[i] = ParCount;
//                            StdDraw.setPenColor(StdDraw.RED);
//                            StdDraw.point(pts[i].x(), pts[i].y());
//                            System.out.println(i);
                        }
                    }
                }
                RedFlag = 0;
            }
//            System.out.println(uf);
//            System.out.println(RedArr[3]);
            
//            int CCnum = 0;
//            for(int i = 0; i < ArrNum; i++){
//                if(RedArr[i] != -1){
//                    CCnum++;
//                }
//            }
//            System.out.println(CCnum);
            
            
            
            int ArrSiz = 0;
            int[] NewArr = new int[ArrNum];
            
            
            for(int i = 0; i < ArrNum; i++){
                int Pt2count = 0;
                if(RedArr[i] != -1){
                    Point2D[] pts2 = new Point2D[uf._rank[i]];
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            pts2[Pt2count] = pts[j];
                            Pt2count++;
                        }
                    }
//                    System.out.println(ConvexHullVertex(pts2));
                    NewArr = ConvexHullVertex(pts2);
//                    System.out.println(pts2[4].x());
                }
            }
            
            for(int i = 0; i < ArrNum; i++){
//                System.out.println(NewArr[i]);
            }
            
            
//            System.out.println(uf);
//            double [] AngleArr = new double[ArrNum];
//            int [] AngleArrI = new int[ArrNum]; 
//            int minAng = 360;
//            int lastAng = 0;
//            int NxtPt = 0;
//            int NxtPt0 = 0;
//            int EndPtFlag = 0;
//            int ifflag = 0;
//            int CX = 0;
            
//            for(int i = 0; i < ArrNum; i++){
//                ifflag = 0;
//                lastAng = 0;
//                NxtPt = 0;
//                NxtPt0 = 0;
//                if(RedArr[i] != -1 && ifflag == 0){
//                    NxtPt = RedArr[i];
//                    while(EndPtFlag == 0){
//                        double [] AngleArr = new double[ArrNum];
//                        int [] AngleArrI = new int[ArrNum]; 
//                        minAng = 360;
////                        System.out.println(NxtPt);
//                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
//                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
//                                AngleArrI[j] = (int)AngleArr[j];
//                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
//                                    minAng = AngleArrI[j]-lastAng;
//                                    NxtPt0 = j;
//                                }
//                            }
//                        }
//                        NxtPt = NxtPt0;
//                        lastAng = minAng;
////                        System.out.println(NxtPt);
//                        CX++;
//                        
//                        if(NxtPt == RedArr[i]){
//                            EndPtFlag = 1;
//                            break;
//                        }
//                    }
//                    ifflag = 1;
//                }
//                EndPtFlag=0;
//            }

            
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@26158e0c650e68064d6b7136c14da728@"
"f02631008","0","0","0","@4ca649fb44882f9a595701f4274ebece@
import java.io.*;
import java.util.Scanner;
import java.io.IOException;
import java.util.Arrays;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        _parent[j] = i;
        _rank[j]++;
        /*if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }*/
    }
    public MyConvexHull(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }
    
    
    public static double angle(double x1, double y1, double x2, double y2)
    {
        double dx=x2-x1,dy=y2-y1, PI=(double)Math.PI;
        double angle=0.0;
        
        if(dx==0)
           if(dy==0)angle=0;
           else if(dy>0)angle=PI/2;
           else angle=PI*3/2;
        else if(dy==0)
           if(dx>0)angle=0;
           else angle=PI;
        else if(dx<0)angle=Math.atan(dy/dx)+PI;
        else if(dy<0)angle=Math.atan(dy/dx)+(2*PI);
        else angle=Math.atan(dy/dx);

        return (double)angle*180/PI;
    }
    
    
    public static double ccwd(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int []index = new int[a.length];
//        int[] index = { 1, 2, 3, 4, 5, 6 };
        
        int minAng = 360;
        int lastAng = 0;
        int NxtPt = 0;
        int NxtPt0 = 0;
        int EndPtFlag = 0;
        int ifflag = 0;
        int CX = 0;
        Point2D[] pts = new Point2D[a.length];
        for(int i = 0; i < a.length; i++){
            pts[i] = a[i];
        }
        
        
        
        int ArrNum = a.length;
        
        int minPtsNum = 0; 
        double lastptsy = 1;
        for(int i = 0; i < ArrNum; i++){
            if(pts[i].y() < lastptsy){
               minPtsNum = i; 
            }
            lastptsy = pts[i].y();
        }
        
//        for(int i = 0; i < ArrNum; i++){
                ifflag = 0;
                lastAng = 0;
                NxtPt = 0;
                NxtPt0 = 0;
                if(ifflag == 0){
                    NxtPt = minPtsNum;
                    while(EndPtFlag == 0){
                        double [] AngleArr = new double[ArrNum];
                        int [] AngleArrI = new int[ArrNum]; 
                        minAng = 360;
//                        System.out.println(NxtPt);
                        index[CX] = NxtPt;
                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
                                AngleArrI[j] = (int)AngleArr[j];
                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
                                    minAng = AngleArrI[j]-lastAng;
                                    NxtPt0 = j;
                                }
//                            }
                        }
                        NxtPt = NxtPt0;
                        lastAng = minAng;
//                        System.out.println(NxtPt);
                        CX++;
                        
                        if(NxtPt == minPtsNum){
                            EndPtFlag = 1;
                            break;
                        }
                    }
                    ifflag = 1;
                }
                EndPtFlag=0;
//            }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return index;
    }
    
     
    public static void main(String[] args) {
        File file = new File(args[0]);
        try{
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            double MinDis = Double.parseDouble(line_1);
//            System.out.println(MinDis);
            
            String line_2 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_2);
//            System.out.println(ArrNum);
            
            int Ai = 0;
            Point2D[] pts = new Point2D[ArrNum];
            
            while (File_in.hasNextLine())
            {
                String line_3 = File_in.nextLine();
                String[] GivePoint = line_3.split("" "");
                double Px = Double.parseDouble(GivePoint[0]);
                double Py = Double.parseDouble(GivePoint[1]);
                
                pts[Ai] = new Point2D(Px ,Py);
                Ai++;
            }
//            System.out.println(pts[3].x());
//            System.out.println(Points[3][1]);
            double Distance = 0.0;
            MyConvexHull uf = new MyConvexHull(ArrNum);
            //Distance = Math.sqrt(Math.pow(Points[0][0]-Points[1][0],2)+Math.pow(Points[0][1]-Points[1][1],2));
//            System.out.println(Distance);
                      
            
            for(int i = 0; i < ArrNum; i++){
                for(int j = 0; j < ArrNum; j++){
                    if(i != j ){
//                        StdDraw.setPenRadius(0.01);
//                        StdDraw.setPenColor(StdDraw.BLACK);
//                        StdDraw.point(pts[i].x(), pts[i].y());
//                        StdDraw.point(pts[j].x(), pts[j].y());
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.text(pts[i].x()+0.02, pts[i].y(),  Integer.toString(i));
                        
                        Distance = Math.sqrt(Math.pow(pts[i].x()-pts[j].x(),2)+Math.pow(pts[i].y()-pts[j].y(),2));

                        if(Distance <= MinDis){
                            //System.out.println(Distance);
//                            StdDraw.setPenRadius(0.001);
//                            StdDraw.setPenColor(StdDraw.GREEN);
//                            StdDraw.line(pts[i].x(), pts[i].y(), pts[j].x(), pts[j].y());
                            
                            if(pts[i].y() < pts[j].y()){
                                uf.union(i,j);
                            }
                            else{
                                uf.union(j,i);
                            }
                        }
                    }
                }
            }
//            System.out.println(uf);
            

            
            
            int[] RedArr = new int[ArrNum];
            for(int i = 0; i < ArrNum; i++){
                RedArr[i] = -1;
            }
            
            int RedFlag = 0;
            for(int i = 0; i < ArrNum; i++){
                int ParCount = 0;
                for(int j = 0; j < ArrNum; j++){
                    if(uf._parent[j] == i){
                        ParCount++;  
                        if(ParCount >= 3){
                            if(RedFlag == 0){
                                RedArr[i] = i;
                                RedFlag = 1;
                            }
                            uf._rank[i] = ParCount;
//                            StdDraw.setPenColor(StdDraw.RED);
//                            StdDraw.point(pts[i].x(), pts[i].y());
//                            System.out.println(i);
                        }
                    }
                }
                RedFlag = 0;
            }
//            System.out.println(uf);
//            System.out.println(RedArr[3]);
            
//            int CCnum = 0;
//            for(int i = 0; i < ArrNum; i++){
//                if(RedArr[i] != -1){
//                    CCnum++;
//                }
//            }
//            System.out.println(CCnum);
            
            
            
            int ArrSiz = 0;
            int[] NewArr = new int[ArrNum];
            
            
            for(int i = 0; i < ArrNum; i++){
                int Pt2count = 0;
                if(RedArr[i] != -1){
                    Point2D[] pts2 = new Point2D[uf._rank[i]];
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            pts2[Pt2count] = pts[j];
                            Pt2count++;
                        }
                    }
//                    System.out.println(ConvexHullVertex(pts2));
                    NewArr = ConvexHullVertex(pts2);
//                    System.out.println(pts2[4].x());
                }
            }
            
            for(int i = 0; i < ArrNum; i++){
//                System.out.println(NewArr[i]);
            }
            
            
//            System.out.println(uf);
//            double [] AngleArr = new double[ArrNum];
//            int [] AngleArrI = new int[ArrNum]; 
//            int minAng = 360;
//            int lastAng = 0;
//            int NxtPt = 0;
//            int NxtPt0 = 0;
//            int EndPtFlag = 0;
//            int ifflag = 0;
//            int CX = 0;
            
//            for(int i = 0; i < ArrNum; i++){
//                ifflag = 0;
//                lastAng = 0;
//                NxtPt = 0;
//                NxtPt0 = 0;
//                if(RedArr[i] != -1 && ifflag == 0){
//                    NxtPt = RedArr[i];
//                    while(EndPtFlag == 0){
//                        double [] AngleArr = new double[ArrNum];
//                        int [] AngleArrI = new int[ArrNum]; 
//                        minAng = 360;
////                        System.out.println(NxtPt);
//                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
//                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
//                                AngleArrI[j] = (int)AngleArr[j];
//                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
//                                    minAng = AngleArrI[j]-lastAng;
//                                    NxtPt0 = j;
//                                }
//                            }
//                        }
//                        NxtPt = NxtPt0;
//                        lastAng = minAng;
////                        System.out.println(NxtPt);
//                        CX++;
//                        
//                        if(NxtPt == RedArr[i]){
//                            EndPtFlag = 1;
//                            break;
//                        }
//                    }
//                    ifflag = 1;
//                }
//                EndPtFlag=0;
//            }

            
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@4ca649fb44882f9a595701f4274ebece@"
"f02631008","3","0.28","105232","@a53341902e0c900f22c4065e4773f8ef@
import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         Point2D[] b = new Point2D[a.length] ;
         for(int i = 0 ; i < a.length ; i++){
             b[i] = a[i];
         }
         int[] c = new int [a.length] ;
         int count = 0 ;
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         for(int i = 0 ; i < a.length ; i++){
             if (orig.x()==b[i].x()&&orig.y()==b[i].y()){
                 c[0] =i ;
                 //System.out.println(i) ;
                 break ;
             }
         }
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         for(int i = 0 ; i < a.length ; i++){
             if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[1] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
                 
             }
         }
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  for(int i = 0 ; i < a.length ; i++){
                  if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[convexhullvertex] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
             }
         }
                  convexhullvertex ++ ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2+""here"") ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y() ;
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         //System.out.println(temp2.x()+"",""+temp2.y());
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         for(int l = 0 ; l < a.length ; l++){
                     if (temp2.x()==b[l].x()&&temp2.y()==b[l].y()){
                 c[convexhullvertex] =l ;
                 //System.out.println(l+""+""+convexhullvertex) ;
                 break ;
             }
         }
                         convexhullvertex ++;
                         
              break;       
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         int[] gg = new int[convexhullvertex] ;
         for(int i = 0 ; i < convexhullvertex ; i++){
             gg[i]=c[i] ;
         }
         for(int i = 0 ; i < convexhullvertex ; i++){
             //System.out.print(gg[i]);
         }
         return gg ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        ConvexHullVertex(points) ;
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    //final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        //  System.out.print(final_number) ;
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        }
        catch(IOException e){
            System.out.println(""error!"");
        }
        // TODO code application logic here
    }
    
}

@a53341902e0c900f22c4065e4773f8ef@"
"f02631008","0","0","0","@10821a5dba8f3655abf43a183ce75d4e@import java.io.*;
import java.util.Scanner;
import java.io.IOException;
import java.util.Arrays;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        _parent[j] = i;
        _rank[j]++;
        /*if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }*/
    }
    public MyConvexHull(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }
    
    
    public static double angle(double x1, double y1, double x2, double y2)
    {
        double dx=x2-x1,dy=y2-y1, PI=(double)Math.PI;
        double angle=0.0;
        
        if(dx==0)
           if(dy==0)angle=0;
           else if(dy>0)angle=PI/2;
           else angle=PI*3/2;
        else if(dy==0)
           if(dx>0)angle=0;
           else angle=PI;
        else if(dx<0)angle=Math.atan(dy/dx)+PI;
        else if(dy<0)angle=Math.atan(dy/dx)+(2*PI);
        else angle=Math.atan(dy/dx);

        return (double)angle*180/PI;
    }
    
    
    public static double ccwd(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
//        int[] index = { 1, 2, 3, 4, 5, 6 };
        
        int minAng = 360;
        int lastAng = 0;
        int NxtPt = 0;
        int NxtPt0 = 0;
        int EndPtFlag = 0;
        int ifflag = 0;
        int CX = 0;
        int []index = new int[a.length];
        Point2D[] pts = new Point2D[a.length];
        for(int i = 0; i < a.length; i++){
            pts[i] = a[i];
        }
        
        
        
        int ArrNum = a.length;
        
        int minPtsNum = 0; 
        double lastptsy = 1;
        for(int i = 0; i < ArrNum; i++){
            if(pts[i].y() < lastptsy){
               minPtsNum = i; 
            }
            lastptsy = pts[i].y();
        }
        
//        for(int i = 0; i < ArrNum; i++){
                ifflag = 0;
                lastAng = 0;
                NxtPt = 0;
                NxtPt0 = 0;
                if(ifflag == 0){
                    NxtPt = minPtsNum;
                    while(EndPtFlag == 0){
                        double [] AngleArr = new double[ArrNum];
                        int [] AngleArrI = new int[ArrNum]; 
                        minAng = 360;
//                        System.out.println(NxtPt);
                        index[CX] = NxtPt;
                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
                                AngleArrI[j] = (int)AngleArr[j];
                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
                                    minAng = AngleArrI[j]-lastAng;
                                    NxtPt0 = j;
                                }
//                            }
                        }
                        NxtPt = NxtPt0;
                        lastAng = minAng;
//                        System.out.println(NxtPt);
                        CX++;
                        
                        if(NxtPt == minPtsNum){
                            EndPtFlag = 1;
                            break;
                        }
                    }
                    ifflag = 1;
                }
                EndPtFlag=0;
//            }
                
        int []index2 = new int[CX];
        for(int i = 0; i < CX; i++){
            index2[i] = index[i];
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return index2;
    }
    
     
    public static void main(String[] args) {
        File file = new File(args[0]);
        try{
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            double MinDis = Double.parseDouble(line_1);
//            System.out.println(MinDis);
            
            String line_2 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_2);
//            System.out.println(ArrNum);
            
            int Ai = 0;
            Point2D[] pts = new Point2D[ArrNum];
            
            while (File_in.hasNextLine())
            {
                String line_3 = File_in.nextLine();
                String[] GivePoint = line_3.split("" "");
                double Px = Double.parseDouble(GivePoint[0]);
                double Py = Double.parseDouble(GivePoint[1]);
                
                pts[Ai] = new Point2D(Px ,Py);
                Ai++;
            }
//            System.out.println(pts[3].x());
//            System.out.println(Points[3][1]);
            double Distance = 0.0;
            MyConvexHull uf = new MyConvexHull(ArrNum);
            //Distance = Math.sqrt(Math.pow(Points[0][0]-Points[1][0],2)+Math.pow(Points[0][1]-Points[1][1],2));
//            System.out.println(Distance);
                      
            
            for(int i = 0; i < ArrNum; i++){
                for(int j = 0; j < ArrNum; j++){
                    if(i != j ){
//                        StdDraw.setPenRadius(0.01);
//                        StdDraw.setPenColor(StdDraw.BLACK);
//                        StdDraw.point(pts[i].x(), pts[i].y());
//                        StdDraw.point(pts[j].x(), pts[j].y());
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.text(pts[i].x()+0.02, pts[i].y(),  Integer.toString(i));
                        
                        Distance = Math.sqrt(Math.pow(pts[i].x()-pts[j].x(),2)+Math.pow(pts[i].y()-pts[j].y(),2));

                        if(Distance <= MinDis){
                            //System.out.println(Distance);
//                            StdDraw.setPenRadius(0.001);
//                            StdDraw.setPenColor(StdDraw.GREEN);
//                            StdDraw.line(pts[i].x(), pts[i].y(), pts[j].x(), pts[j].y());
                            
                            if(pts[i].y() < pts[j].y()){
                                uf.union(i,j);
                            }
                            else{
                                uf.union(j,i);
                            }
                        }
                    }
                }
            }
//            System.out.println(uf);
            

            
            
            int[] RedArr = new int[ArrNum];
            for(int i = 0; i < ArrNum; i++){
                RedArr[i] = -1;
            }
            
            int RedFlag = 0;
            for(int i = 0; i < ArrNum; i++){
                int ParCount = 0;
                for(int j = 0; j < ArrNum; j++){
                    if(uf._parent[j] == i){
                        ParCount++;  
                        if(ParCount >= 3){
                            if(RedFlag == 0){
                                RedArr[i] = i;
                                RedFlag = 1;
                            }
                            uf._rank[i] = ParCount;
//                            StdDraw.setPenColor(StdDraw.RED);
//                            StdDraw.point(pts[i].x(), pts[i].y());
//                            System.out.println(i);
                        }
                    }
                }
                RedFlag = 0;
            }
//            System.out.println(uf);
//            System.out.println(RedArr[3]);
            
//            int CCnum = 0;
//            for(int i = 0; i < ArrNum; i++){
//                if(RedArr[i] != -1){
//                    CCnum++;
//                }
//            }
//            System.out.println(CCnum);
            
            
            
            int ArrSiz = 0;
            int[] NewArr = new int[ArrNum];
            
            
            for(int i = 0; i < ArrNum-6; i++){
                int Pt2count = 0;
                if(RedArr[i] != -1){
                    Point2D[] pts2 = new Point2D[uf._rank[i]];
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            pts2[Pt2count] = pts[j];
                            Pt2count++;
                        }
                    }
//                    System.out.println(ConvexHullVertex(pts2));
                    NewArr = ConvexHullVertex(pts2);
                    
//                    System.out.println(NumArr[j]);
                }
            }
            
            for(int i = 0; i < NewArr.length; i++){
//                System.out.println(NewArr[i]);
            }
            
            
//            System.out.println(uf);
//            double [] AngleArr = new double[ArrNum];
//            int [] AngleArrI = new int[ArrNum]; 
//            int minAng = 360;
//            int lastAng = 0;
//            int NxtPt = 0;
//            int NxtPt0 = 0;
//            int EndPtFlag = 0;
//            int ifflag = 0;
//            int CX = 0;
            
//            for(int i = 0; i < ArrNum; i++){
//                ifflag = 0;
//                lastAng = 0;
//                NxtPt = 0;
//                NxtPt0 = 0;
//                if(RedArr[i] != -1 && ifflag == 0){
//                    NxtPt = RedArr[i];
//                    while(EndPtFlag == 0){
//                        double [] AngleArr = new double[ArrNum];
//                        int [] AngleArrI = new int[ArrNum]; 
//                        minAng = 360;
////                        System.out.println(NxtPt);
//                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
//                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
//                                AngleArrI[j] = (int)AngleArr[j];
//                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
//                                    minAng = AngleArrI[j]-lastAng;
//                                    NxtPt0 = j;
//                                }
//                            }
//                        }
//                        NxtPt = NxtPt0;
//                        lastAng = minAng;
////                        System.out.println(NxtPt);
//                        CX++;
//                        
//                        if(NxtPt == RedArr[i]){
//                            EndPtFlag = 1;
//                            break;
//                        }
//                    }
//                    ifflag = 1;
//                }
//                EndPtFlag=0;
//            }

            
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@10821a5dba8f3655abf43a183ce75d4e@"
"r04945022","0","0.51","106112","@0e1312f77be82527c2a74bca6536abe1@
import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
    //     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@0e1312f77be82527c2a74bca6536abe1@"
"b03611011","0","0","0","@ed0c256987823e4c91dae629905c263e@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.textLeft(point[i].x(), point[i].y()+2, word);

        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;
    }

    public static void main(String[] args) {
        int M = 10;
        StdDraw.setCanvasSize(500, 500);
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[M];
        Point2D[] cc = new Point2D[M];
        Point2D[] ww = new Point2D[M];
        Point2D min = new Point2D(100, 100);
        for (int i = 0; i < M; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            String word = Integer.toString(i);
            StdDraw.setPenColor(StdDraw.BLUE);
            points[i].draw();
            StdDraw.textLeft(x, y-3, word);
            switch (points[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = points[i];
                    break;
            }
        }
        MyConvexHull t = new MyConvexHull();
        int[] x;
        x = t.ConvexHullVertex(points);
        System.out.println(x);
    }
}

@ed0c256987823e4c91dae629905c263e@"
"b03611011","0","0","0","@6f4054ce0c5268e2071eeb5cf41631e9@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        for (int i = 0; i < point.length; i++) {
            switch (point[i].compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point[i];
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.textLeft(point[i].x(), point[i].y()+2, word);

        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;
    }

    public static void main(String[] args) {

    }
}

@6f4054ce0c5268e2071eeb5cf41631e9@"
"r03522809","0","0.51","108192","@94d311670c536ca9269794eb55e69f2c@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
       System.out.println(convexsize);
        j=0;

      System.out.println("" "");

        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[j]=i;
                System.out.println(i);
               }
            }
        }
      return  orians;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
//            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}
@94d311670c536ca9269794eb55e69f2c@"
"r03522809","0","0.52","106016","@9ba4f7a034ca4f358cd74403e12f9591@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);
        j=0;

//      System.out.println("" "");

        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[j]=i;
//                System.out.println(i);
               }
            }
        }
      return  orians;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
//            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}
@9ba4f7a034ca4f358cd74403e12f9591@"
"r04945022","0","0.5","106064","@d2b9d4ab04cb163646d512aedfa9e951@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, a[0])>0){
         ;
     }else{
         stack.push(test);
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@d2b9d4ab04cb163646d512aedfa9e951@"
"r04945022","0","0.5","106560","@80fa3bf108ac91e4e95b0a92091922ed@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>=0){
         ;
     }else{
         stack.push(test);
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@80fa3bf108ac91e4e95b0a92091922ed@"
"r04945022","2","0.41","107968","@62631c4dcf88327403d1f47487bb641f@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
//     Point2D test;
//     test = stack.pop();
//     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>=0){
//         ;
//     }else{
//         stack.push(test);
//     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@62631c4dcf88327403d1f47487bb641f@"
"r03522809","0","0.52","107936","@2ad01f34bd18cded2c8a72de826b26ff@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      sort(a);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);
        j=0;

//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}
@2ad01f34bd18cded2c8a72de826b26ff@"
"r03522826","0","0.38","105760","@b9d6678620a1783eead47fe3529e7176@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVector(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                if(p[j].distanceTo(p[i]) <= r)
                {
                    uf.union(j, i);
                    StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
                }
            }
        }
        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@b9d6678620a1783eead47fe3529e7176@"
"r03522826","0","0.5","106560","@d0131cc2b6729e09325fbb0b9fa9f573@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVector(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
        Insertion.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                if(p[j].distanceTo(p[i]) <= r)
                {
                    uf.union(j, i);
                    StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
                }
            }
        }
        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@d0131cc2b6729e09325fbb0b9fa9f573@"
"r04945022","0","0.51","107872","@a20591223e608ec4f6ffdf69835cf9d2@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<0){
         stack.push(test);
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@a20591223e608ec4f6ffdf69835cf9d2@"
"r03522826","0","0.38","105760","@2c614e2e1835895ccfa3c617056bcd07@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
        Insertion.sort(v, null);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                if(p[j].distanceTo(p[i]) <= r)
                {
                    uf.union(j, i);
                    StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
                }
            }
        }
        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@2c614e2e1835895ccfa3c617056bcd07@"
"r03522826","5","0.104","107888","@c03d3b864cc1aeba1eabb98cbdb801eb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                if(p[j].distanceTo(p[i]) <= r)
                {
                    uf.union(j, i);
                    StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
                }
            }
        }
        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@c03d3b864cc1aeba1eabb98cbdb801eb@"
"r04945022","2","0.49","107856","@29ac44827d40af0a857a98a3ddb98560@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>0){
         stack.push(test);
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@29ac44827d40af0a857a98a3ddb98560@"
"r04945022","2","0.5","106016","@47f49fbd3f18ee46cc5663dd205ff152@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     for(int i = 2; i < a.length; i++){
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>0&&stack.size()>1){
         stack.push(test);
     }
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@47f49fbd3f18ee46cc5663dd205ff152@"
"r03522809","0","0.52","104896","@7424966662ce9fc1147fa679c1ffea39@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);
        j=0;

//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

  


  
  public static void sort(Point2D[] a){
        int N =a.length;
        for (int i =0; i<N ;i++){
            for(int j =i;j>0;j--){
                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
                    exch(a,j,j-1);
            }
           assert isSorted(a, 0, i);
        }
        assert isSorted(a);
    }

    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    
    private static boolean less(Comparable v, Comparable w) {
        return (v.compareTo(w) < 0);
    }  
    
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    
   private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}
@7424966662ce9fc1147fa679c1ffea39@"
"r03522809","0","0.53","106048","@bf838aaa5fbaac2fc23f7b9ab9770707@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);    
          }
          if(intq4==N)break;
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);
        j=0;

//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}

@bf838aaa5fbaac2fc23f7b9ab9770707@"
"r04945022","0","0.48","107904","@4678b8595ace350a91380bdddcb7acf7@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     do{
     test = stack.pop();
     }while(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>0);
     stack.push(test);
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@4678b8595ace350a91380bdddcb7acf7@"
"r04945022","2","0.51","106016","@a17faf39bc9ebcea0dedd3e51fabb6ed@
import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
// Point2D[] xs = new Point2D[5];
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     do{
     test = stack.pop();
     }while(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<=0);
     stack.push(test);
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@a17faf39bc9ebcea0dedd3e51fabb6ed@"
"r03522809","0","0.52","108032","@683f36a3fc3ece9505ecc78d0177eae1@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Arrays.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }

      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);


//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}
@683f36a3fc3ece9505ecc78d0177eae1@"
"r03522809","0","0.52","107168","@b8c622b21d3a2e7659e0f7efba7c460e@import java.awt.Color;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);


//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}

@b8c622b21d3a2e7659e0f7efba7c460e@"
"r04945022","2","0.48","107936","@f3df1ad39a6bc9ec21e3b7a9bf20a402@import java.util.Stack;
import java.util.Arrays;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    Point2D[] x = Findconvexhull(s);
    int[] ref = new int[x.length];
    for(int i =0;i<x.length;i++){
        for(int j =0;j<s.length;j++){
            if(x[i].equals(s[j])){
                ref[i] = j;
                break;
            }
        }
    }
    Arrays.sort(ref);
    return ref;
}
 
 private static Point2D[] Findconvexhull(Point2D[] s){
     if(s.length<3){
         return null;
     }
     Point2D[] a = Relativepoint(s.clone());
     a = mergesort2D(a);
     Stack<Point2D> stack = new Stack();
     stack.push(a[0]);
     stack.push(a[1]);
     for(int i = 2; i < a.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, a[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(a[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<=0){
     do{
     test = stack.pop();
     }while(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<=0);
     stack.push(test);
     }else if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>0&&test!=stack.lastElement()){
         stack.push(test);
     }
     
     Point2D[] a2 = new Point2D[stack.size()];
     a2 = stack.toArray(a2);
     for (int i = 0; i < a2.length; ++i) {
            a2[i] = new Point2D(a2[i].x() + s[Findlowesty(s)].x(), a2[i].y() + s[Findlowesty(s)].y());
     }
     return a2;
 }
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 public static Point2D[] mergesort2D(Point2D[] arr) {

        int size = arr.length;
        if (size < 2) {
            return arr;
        }
        int i;
        Point2D[] arr1 = new Point2D[size / 2];
        Point2D[] arr2 = new Point2D[size - size / 2];
        for (i = 0; i < size / 2; ++i) {
            arr1[i] = new Point2D(arr[i].x(), arr[i].y());
        }
        for (; i < size; ++i) {
            arr2[i - size / 2] = new Point2D(arr[i].x(), arr[i].y());
        }
        arr1 = mergesort2D(arr1);
        arr2 = mergesort2D(arr2);
        int j = size - size / 2 - 1;
        i = size / 2 - 1;
        int k = size - 1;
        Point2D[] arr3 = new Point2D[size];
        while (i >= 0 && j >= 0) {
            if (arr1[i].theta() >= arr2[j].theta()) {
                arr3[k--] = arr1[i--];
            } else {
                arr3[k--] = arr2[j--];
            }
        }
        while (i >= 0) {
            arr3[k--] = arr1[i--];
        }
        while (j >= 0) {
            arr3[k--] = arr2[j--];
        }
        return arr3;
    }
 
 public static Point2D[] Relativepoint(Point2D[] a){
     int miniy = Findlowesty(a);
     Point2D[] a1 = new Point2D[a.length];
     for (int i =0; i< a.length;++i){
         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
     }
     return a1;
 }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@f3df1ad39a6bc9ec21e3b7a9bf20a402@"
"r03522809","0","0.48","107936","@2e9e368445f492181c351d21758d4b6b@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);


//      System.out.println("" "");
        k=0;
        for(i=0;i<N;i++){
//            System.out.println(b[i]); 
            for(j=1;j<convexsize;j++){
               int c = ans[j];
               if(b[i].compareTo(a[c])==0){
                   orians[k]=i;
//                System.out.println(i);
                   k++;
               }
            }
        }
      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(Color.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(Color.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(Color.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            System.out.println(convex[j]);
            StdDraw.setPenColor(Color.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }
        
        

//
//        
//        StdDraw.setPenColor(Color.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.text(a[0].x(), a[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(Color.BLACK);         
//        StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        StdDraw.text(a[i].x(), a[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(Color.GREEN);  
//        StdDraw.line(a[0].x(), a[0].y(),a[i].x(), a[i].y());
//        }
//
//        int [] convex=ConvexHullVertex(a);
//        convexsize=convex.length;
//        int[] cox=new int[convexsize];
//        j=0;
//        for (i=convexsize-1;i>0;i--){
//            System.out.println(convex[i]);
//            cox[j]=convex[i];
//            j++;
//        }
//
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(Color.BLUE);  
//            StdDraw.line(a[cox[j]].x(), a[cox[j]].y(),a[cox[j+1]].x(), a[cox[j+1]].y());
//            }
    }
    
}

@2e9e368445f492181c351d21758d4b6b@"
"b03611011","0","0","0","@6f56ef980b785362235361073e664930@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        min = point[0];
        for (Point2D point1 : point) {
            switch (point1.compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point1;
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.textLeft(point[i].x(), point[i].y() + 2, word);

        }
        if (N < 2) {
            return null;
        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;

    }

    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
//            int M = 0;
//            double L = 0;
//            int count = 0;
//            String data;
//            String[] data1;
//            Point2D min = new Point2D(1, 1);
//            while (count < 2) {
//                if (count == 0) {
//                    String fund = br.readLine();
//                    L = Double.parseDouble(fund);
//                    count++;
//                }
//                if (count == 1) {
//                    String fund = br.readLine();
//                    M = Integer.parseInt(fund);
//                    StdDraw.setCanvasSize(500, 500);
//                    StdDraw.setXscale(0, 1);
//                    StdDraw.setYscale(0, 1);
//                    StdDraw.setPenRadius(.005);
//                    count++;
//                }
//            }
//            Point2D[] points = new Point2D[M];
//            count = 0;
//            while ((data = br.readLine()) != null) {
//                String fund[] = data.split("" "");
//                double x = Double.parseDouble(fund[0]);
//                double y = Double.parseDouble(fund[1]);
//                points[count] = new Point2D(x, y);
//                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
//                count++;
//            }
//            UF c = new UF(M);
//            for (int i = 0; i < M; i++) {
//                for (int j = i; j < M; j++) {
//                    if (points[i].distanceSquaredTo(points[j]) <= L * L) {
//                        c.union(i, j);
//                        points[i].drawTo(points[j]);
//                    }
//                }
//            }
//            MyConvexHull t = new MyConvexHull();
//            int[] x;
//            x = t.ConvexHullVertex(points);
//            System.out.println(x);
//        }
    }
}

@6f56ef980b785362235361073e664930@"
"r03522809","0","0.53","107968","@69e5865c079275d970f8bb2e700e5f59@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      convexsize=ans.length;
      int[] orians=new int[convexsize];      
//       System.out.println(convexsize);
      
      Arrays.sort(ans);
//        System.out.println(convexsize); 
//        System.out.println("" "");
//        k=0;
        for(i=0;i<convexsize;i++){
            
//            System.out.println(ans[i]); 
//            for(j=1;j<convexsize;j++){
//               int c = ans[j];
//               if(b[i].compareTo(a[c])==0){
//                   orians[k]=i;
////                System.out.println(i);
//                   k++;
//               }
//            }
        }
      return  ans;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(StdDraw.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(StdDraw.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
//            System.out.println(convex[j]);
            StdDraw.setPenColor(StdDraw.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }

    }
    
}
@69e5865c079275d970f8bb2e700e5f59@"
"r03522809","0","0.52","108016","@a1e28da3490bb895194de4f4741409ec@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,j=0,k=0,decide=0;
      int N = a.length,size=0;
      int convexsize;
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){
      b[i]=a[i];
      }
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
//      System.out.println(ans[i]); 
      }


      int[] orians=new int[size];      

      
      Arrays.sort(ans);

        for(i=0;i<size;i++){
            System.out.println(ans[i]); 
        }
      return  ans;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(StdDraw.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(StdDraw.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
//            System.out.println(convex[j]);
            StdDraw.setPenColor(StdDraw.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }

    }
    
}
@a1e28da3490bb895194de4f4741409ec@"
"r03522809","5","0.104","107968","@41a2d655f1e085c528cd67becd7417cc@//import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i=0,decide=0;
      int N = a.length,size=0;
 
      String q1=""0"",q2=""0"",q3=""0"";
      Point2D [] b =new Point2D[N];
      int intq1=0,intq2=0,intq3=0,intq4=0;
      Stack convexhull = new Stack();
      
      for(i=0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];

      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);

      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
//          System.out.println(b[i]);
          for(int j=0;j<size;j++){
              if(b[i].compareTo(a[ans[j]])==0){orians[k]=i;k++;}
          }
      }
      
//        for(i=0;i<size;i++){
//            System.out.println(orians[i]); 
//        }
      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0,intt1=0,intt2=4,intt3=2,dd=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        System.out.println(a[i]);
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(StdDraw.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(StdDraw.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
//            System.out.println(convex[j]);
            StdDraw.setPenColor(StdDraw.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }

    }
    
}
@41a2d655f1e085c528cd67becd7417cc@"
"r03522809","0","0.104","107968","@0d9a14d33f38b171507f181a2e8648c1@* To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(StdDraw.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(StdDraw.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(StdDraw.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }

    }
    
}

@0d9a14d33f38b171507f181a2e8648c1@"
"r03522809","5","0.104","108208","@b1ad155429e2ddd47f7172d4368eec3e@
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here

        int N=10;
        Point2D[] a = new Point2D[N];
        Point2D[] c = new Point2D[N];        
        int i=0,j=0;
        int convexsize;
        for (i=0;i<N;i++){
        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
        c[i]=a[i];
        }
        

        
        int [] convex=ConvexHullVertex(a);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
        
        for (i=1;i<N;i++){    
        StdDraw.setPenColor(StdDraw.BLACK);         
        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
        StdDraw.setPenColor(StdDraw.GREEN);  
        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
        }  


        convexsize=convex.length;
        for (j=0;j<convexsize-1;j++){
            StdDraw.setPenColor(StdDraw.BLUE);  
            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
            }

    }
    
}

@b1ad155429e2ddd47f7172d4368eec3e@"
"b03611011","5","0.106","107872","@ab30030e8c84266a20e722d788470ae4@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        min = point[0];
        for (Point2D point1 : point) {
            switch (point1.compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point1;
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.textLeft(point[i].x(), point[i].y() + 2, word);

        }
        if (N < 2) {
            return null;
        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
//            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
//            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
//        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                    int fin =0;
            int M = 0;
            double L = 0;
            int count = 0;
            String data;
            Point2D min = new Point2D(1, 1);
            while (count < 2) {
                if (count == 0) {
                    String fund = br.readLine();
                    L = Double.parseDouble(fund);
                    count++;
                }
                if (count == 1) {
                    String fund = br.readLine();
                    M = Integer.parseInt(fund);
//                    StdDraw.setCanvasSize(500, 500);
//                    StdDraw.setXscale(0, 1);
//                    StdDraw.setYscale(0, 1);
//                    StdDraw.setPenRadius(.005);
                    count++;
                }
            }
            Point2D[] points = new Point2D[M];
            count = 0;
            while ((data = br.readLine()) != null) {
                String fund[] = data.split("" "");
                double x = Double.parseDouble(fund[0]);
                double y = Double.parseDouble(fund[1]);
                points[count] = new Point2D(x, y);
                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            UF c = new UF(M);
            for (int i = 0; i < M; i++) {
                for (int j = i; j < M; j++) {
                    if (points[i].distanceSquaredTo(points[j]) <= L * L) {
                        c.union(i, j);
//                        points[i].drawTo(points[j]);
                    }
                }
            }
            MyConvexHull t = new MyConvexHull();
            int[][] cal = new int[M][M];
            int[] where = new int[M];
            int w = 0;
            int j;
            int[] x;
            for (int i = 0; i < M; i++) {
                count = 0;
                for (j = 0; j < M; j++) {
                    if (c.find(j) == i) {
                        cal[i][count] = j;
                        count++;
                    }
                }
                if (count >= 1) {
                    where[w] = i;
                    w++;
                }
                Point2D[] cals = new Point2D[count];
                if (count > 0) {
                    for (int k = 0; k < count; k++) {
                        cals[k] = points[cal[i][k]];
                    }
                    x = t.ConvexHullVertex(cals);
                    if (x == null) {
                    } else {
                        fin=fin+x.length;
                    }
                }
                j = 0;

            }
            System.out.println(fin);
        }
    }
}

@ab30030e8c84266a20e722d788470ae4@"
"r04631006","0","0","0","@93677bcf0dbc9ae995d45d7f1824cad2@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        double mi = 0;
        double ang[] = new double[10];
        int order[] = new int[10];
        double ang_order[] = new double[10];
        for (int i = 0; i < 10; i++) {
            double x = StdRandom.uniform(0, 100);
            double y = StdRandom.uniform(0, 100);

            a[i] = new Point2D(x, y);
            a[i].draw();

            if (i == 0) {
                mi = a[0].y();
            } else if (i > 0 && y < mi) {
                zero = i;
                mi = y;
            }
        }

        for (int i = 0; i < 10; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);

        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 0;
        Point2D[] ch = new Point2D[10 + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 0; i < 10; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;
        }
        Arrays.sort(fir_order);
        return fir_order;
    }

    public static void main(String[] args) {

    }
}

@93677bcf0dbc9ae995d45d7f1824cad2@"
"r04228027","0","0.49","105760","@67b1a4c212d38b404a86c8a76afb656b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
// import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@67b1a4c212d38b404a86c8a76afb656b@"
"r04228027","0","0.49","105760","@8adb91e96e76542cb3a2b23803904c6f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@8adb91e96e76542cb3a2b23803904c6f@"
"r04631006","0","0.29","104976","@0d8d214c69c18d6d597d790d89eb63ed@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L=a.length;
        double mi = 0;
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);

        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 0;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 0; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;
        }
        Arrays.sort(fir_order);
        return fir_order;
    }

    public static void main(String[] args) {
 }
}
@0d8d214c69c18d6d597d790d89eb63ed@"
"r04631006","2","0.29","102304","@4b92f87b183a46e0c9b8a794e9cd0279@
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L = a.length;

        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);

        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 0;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 0; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;
        }
        int lorder[] = new int[m];
        for (int i = 0; i < m; i++) {
            lorder[i] = fir_order[i];
        }
        Arrays.sort(lorder);
        return lorder;
    }
    public static void main(String[] args) {
}
}
@4b92f87b183a46e0c9b8a794e9cd0279@"
"r04522627","0","0","0","@c81142b5af364607e8863a7e31e26c4b@import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Ted
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        
        Point2D[] b = a.clone();
        Arrays.sort(b, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
        b[0].draw();
//        StdDraw.text(b[0].x(), 0.03 + b[0].y(),String.valueOf(0));
//        StdDraw.setPenColor(StdDraw.BLACK);
        
        Arrays.sort(b, b[0].POLAR_ORDER);
        
        for(int i = 1; i < b.length ;i++)
        {
            b[i].draw();
//            StdDraw.text(b[i].x(), 0.03 + b[i].y(),String.valueOf(i));
        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(b[0]);
        _stack.push(b[1]);
        _stack.push(b[2]);
        int k = 3;
        int ccw = 0;
        while(k != b.length)
        {
            Point2D p3 = b[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }        
//         StdDraw.setPenColor(Color.yellow);
//         StdDraw.setPenRadius(.005);
         
        int[] id = new int[_stack.size()];
        int index = 0;
         
         Point2D d1 = _stack.pop();
         Point2D op = d1;
         int i = -1;
         while(!a[++i].equals(op))
         {
         }
         id[index++] = i;
       
         do
         {
             Point2D d2 = _stack.pop();
             i = -1;
             while(!a[++i].equals(d2))
             {
             }
             id[index++] = i;
            // StdDraw.line(d1.x(), d1.y(),d2.x(), d2.y());
             d1 = d2;
         }while(!(_stack.size() == 0));
         //StdDraw.line(d1.x(), d1.y(),op.x(), op.y());
         
         Arrays.sort(id);
       
        return id;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
//        int n = 10;
//        Point2D[] a = new Point2D[n];
//        StdDraw.setCanvasSize(800, 800);
//        StdDraw.setXscale(-0.2, 1.2);
//        StdDraw.setYscale(-0.2, 1.2);
//        StdDraw.setPenRadius(.01);
//         StdDraw.setPenColor(StdDraw.BLUE);
//        for(int i = 0; i < n ;i++)
//        {
//            a[i] = new  Point2D(StdRandom.uniform(),StdRandom.uniform());
//             StdDraw.text(a[i].x()+0.03 , 0.03 + a[i].y(),String.valueOf(i));
//        }
//        int[] k = ConvexHullVertex(a);
        
        
        
    }
    
}

@c81142b5af364607e8863a7e31e26c4b@"
"r04522616","0","0","0","@ce2c8056b5800d6b09f24036be5d62da@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import edu.princeton.cs.algs4.Point2D;
import  edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static String ConvexHullVertex(Point2D[] pointXY) {
        Arrays.sort(pointXY);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = pointXY.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(pointXY,pointXY[0].polarOrder());//根據角度重排點順序
        }        
        
        s.push(pointXY[0]); 
        A.push(0);
        s.push(pointXY[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, pointXY[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(pointXY[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        for(int j=0;j<n;j++){
            int temp = A.pop();
            B.push(temp);
        }
        String C = B.toString();
        return C;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@ce2c8056b5800d6b09f24036be5d62da@"
"r04522616","0","0","0","@c42e38a31845333ea519d7a9ff3bce56@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static String ConvexHullVertex(Point2D[] pointXY) {
        Arrays.sort(pointXY);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = pointXY.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(pointXY,pointXY[0].polarOrder());//根據角度重排點順序
        }        
        
        s.push(pointXY[0]); 
        A.push(0);
        s.push(pointXY[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, pointXY[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(pointXY[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        for(int j=0;j<n;j++){
            int temp = A.pop();
            B.push(temp);
        }
        String C = B.toString();
        return C;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@c42e38a31845333ea519d7a9ff3bce56@"
"r04522616","0","0","0","@27df0e5d817344d8954b642ae69fc958@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static String ConvexHullVertex(Point2D[] a) {
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        for(int j=0;j<n;j++){
            int temp = A.pop();
            B.push(temp);
        }
        String C = B.toString();
        return C;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@27df0e5d817344d8954b642ae69fc958@"
"r04522616","0","0","0","@a084e6ae56ba012d1b40e7b65db41494@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static String ConvexHullVertex(Point2D[] a) {
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        for(int j=0;j<n;j++){
            int temp = A.pop();
            B.push(temp);
        }
        String C = B.toString();
        return B;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@a084e6ae56ba012d1b40e7b65db41494@"
"r04522627","5","0.106","106304","@8010fb3e6272530d3ee5b8a10475bd7f@import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Ted
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        
        Point2D[] b = a.clone();
        Arrays.sort(b, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        b[0].draw();
//        StdDraw.text(b[0].x(), 0.03 + b[0].y(),String.valueOf(0));
//        StdDraw.setPenColor(StdDraw.BLACK);
        
        Arrays.sort(b, b[0].POLAR_ORDER);
        
        for(int i = 1; i < b.length ;i++)
        {
//            b[i].draw();
//            StdDraw.text(b[i].x(), 0.03 + b[i].y(),String.valueOf(i));
        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(b[0]);
        _stack.push(b[1]);
        _stack.push(b[2]);
        int k = 3;
        int ccw = 0;
        while(k != b.length)
        {
            Point2D p3 = b[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }        
//         StdDraw.setPenColor(Color.yellow);
//         StdDraw.setPenRadius(.005);
         
        int[] id = new int[_stack.size()];
        int index = 0;
         
         Point2D d1 = _stack.pop();
         Point2D op = d1;
         int i = -1;
         while(!a[++i].equals(op))
         {
         }
         id[index++] = i;
       
         do
         {
             Point2D d2 = _stack.pop();
             i = -1;
             while(!a[++i].equals(d2))
             {
             }
             id[index++] = i;
            // StdDraw.line(d1.x(), d1.y(),d2.x(), d2.y());
             d1 = d2;
         }while(!(_stack.size() == 0));
         //StdDraw.line(d1.x(), d1.y(),op.x(), op.y());
         
         Arrays.sort(id);
       
        return id;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
//        int n = 10;
//        Point2D[] a = new Point2D[n];
//        StdDraw.setCanvasSize(800, 800);
//        StdDraw.setXscale(-0.2, 1.2);
//        StdDraw.setYscale(-0.2, 1.2);
//        StdDraw.setPenRadius(.01);
//         StdDraw.setPenColor(StdDraw.BLUE);
//        for(int i = 0; i < n ;i++)
//        {
//            a[i] = new  Point2D(StdRandom.uniform(),StdRandom.uniform());
//             StdDraw.text(a[i].x()+0.03 , 0.03 + a[i].y(),String.valueOf(i));
//        }
//        int[] k = ConvexHullVertex(a);
        
        
        
    }
    
}

@8010fb3e6272530d3ee5b8a10475bd7f@"
"r04631006","3","0.4","106032","@88a613ba98d06293c49e6e94031e6300@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
        int lorder[] = new int[m];
        for (int i = 0; i < m; i++) {
            lorder[i] = fir_order[i];
        }
//        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) {
}
}
@88a613ba98d06293c49e6e94031e6300@"
"r04631006","3","0.4","105712","@d95cfaedd920a80ee582a80081307487@import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
        int lorder[] = new int[m];
        for (int i = 0; i < m; i++) {
            lorder[i] = fir_order[i];
        }
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) {
}
}
@d95cfaedd920a80ee582a80081307487@"
"r04945008","0","0.52","107888","@419697db2317b0856422c78862dd5fe7@import java.util.Arrays;
    
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] pts) {
        Stack<Point2D> hull = new Stack<Point2D>();
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];
        Arrays.sort(points);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);
        hull.push(points[0]);       // p[0] is first extreme point
        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) {vertex[0]=N-1; return vertex;}        // all points equal
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point
        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        
        int[] vertex = new int[hull.size()];
        Point2D[] temp = new Point2D[hull.size()];
        
        for (int i = 0; i < hull.size(); i++) {
            temp[i]=hull.pop();
        }
        
        int k=0;
        for(int i=0; i < N; i++)
            for (int j = 0; j < temp.length; j++) {
                if (pts[i].equals(temp[j])) {
                    vertex[k++]=i;
                }
            }
        Arrays.sort(vertex);
        return vertex;
    }
}
@419697db2317b0856422c78862dd5fe7@"
"r04945008","0","0.5","107888","@e0f38361bc1fa692dcdd55b5ffb287dc@import java.util.Arrays;
    
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] pts) {
        Stack<Point2D> hull = new Stack<Point2D>();
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];
        Arrays.sort(points);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);
        hull.push(points[0]);       // p[0] is first extreme point
        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) {vertex[0]=N-1; return vertex;}        // all points equal
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point
        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        
        int[] vertex = new int[hull.size()];
        Point2D[] temp = new Point2D[hull.size()];
        
        for (int i = 0; i < hull.size(); i++) {
            temp[i]=hull.pop();
        }
        
        int k=0;
        for(int i=0; i < N; i++)
            for (int j = 0; j < temp.length; j++) {
                if (pts[i].equals(temp[j])) {
                    vertex[k++]=i;
                }
            }
        Arrays.sort(vertex);
        return vertex;
    }
    public static void main(String[] args) {
        int N = StdIn.readInt();
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdIn.readInt();
            int y = StdIn.readInt();
            points[i] = new Point2D(x, y);
        }
    }
}
            

@e0f38361bc1fa692dcdd55b5ffb287dc@"
"r04921051","0","0.4","105712","@7f43e00b4f143a5bcc914d0f7c2a345a@import java.util.Comparator;
public class Card implements Comparable<Card> {

	private String face; // should be one of [A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K]
	private String suit; // should be one of [Spades, Hearts, Diamonds, Clubs]
	
    public static final Comparator<Card> SUIT_ORDER = new SuitOrder();

    // DO NOT MODIFY THIS
    public Card(String face, String suit){
        this.face = face;
        this.suit = suit;
    }
     
    // DO NOT MODIFY THIS   
    public String getFace(){
        return this.face;
    }
    
    // DO NOT MODIFY THIS    
    public String getSuit(){
        return this.suit;
    }   
    
    // TODO
    public int compareTo(Card that) {
        // complete this function so the Card can be sorted
        // (you must consider both face and suit)
        if(face2num(this)>face2num(that)) return -1;
        else if(face2num(this)<face2num(that)) return 1;
        else if(suit2num(this)>suit2num(that)) return -1;
        else if(suit2num(this)<suit2num(that)) return 1;
        else return 0;
    }  

    // TODO
    private static class SuitOrder implements Comparator<Card> {
        public int compare(Card c1, Card c2) {
            // complete this function so the Card can be sorted according to the suit
        if(face2num(c1)>face2num(c2)) return -1;			
        else if(face2num(c1)<face2num(c2)) return 1;
        else if(suit2num(c1)>suit2num(c2)) return -1;
        else if(suit2num(c1)<suit2num(c2)) return 1;
        else return 0;
        }
    }
	
    public static int face2num(Card c){
        switch(c.face){
            case(""A""):
                return 1;
            case(""J""):
                return 11;
            case(""Q""):
                return 12;
            case(""K""):
                return 13;
            default:
                return Integer.parseInt(c.face);
        }
    }
        
    public static int suit2num(Card c){
        switch(c.suit){
            case(""Spades""):
                return 4;
            case(""Hearts""):
                return 3;
            case(""Diamonds""):
                return 2;
            case(""Clubs""):
                return 1;
            default:
                return 0;
        }   
    } 
	
}


@7f43e00b4f143a5bcc914d0f7c2a345a@"
"r03525008","5","0.106","107968","@8ba20fd12574fc3e16667271861a3318@import java.util.*;

/**
 * Created by Yang Chi-Chang on 2016/4/11.
 */
public class MyConvexHull {

    public static void main(String[] args) {

        int num = 10;
        Point2D[] points = new Point2D[num];

        for(int i = 0; i < num ; i++) {
            points[i] = new Point2D(StdRandom.uniform(),StdRandom.uniform());
            System.out.println( i +  "" : "" + String.format(""(%.3f , %.3f)"" , points[i].x() , points[i].y()));
        }



        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int index[] = ConvexHullVertex(points);

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();

//        int count = 0;
//        int[] index = new int[convexhull.size()];
//        while (iterator.hasNext()) {
//            Point2D p = iterator.next();
//            index[count++] = array.indexOf(p);
//        }



        System.out.print(""["");
        String sp = """";
        for(int i : index){
            System.out.print( sp + i);
            sp = "","";
        }
        System.out.println(""]"");


        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(-0.1, 1.1);
        StdDraw.setYscale(-0.1, 1.1);

        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
        StdDraw.setPenRadius(.025);
        for(int i = 0 ; i < points.length ; i++){
            Point2D p = points[i];
            p.draw();
        }

        StdDraw.setPenColor(StdDraw.MAGENTA);
        for(int i : index){
            Point2D p = array.get(i);
            p.draw();
            StdDraw.text(p.x() + 0.015, p.y() + 0.015, i + """");
        }

    }


    public static int[] ConvexHullVertex(Point2D[] points) {


        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();

        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@8ba20fd12574fc3e16667271861a3318@"
"r04522616","0","0.5","109568","@d48b11a3000fc560cefea2fb5131b8b3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        int[] CHPoint=new int[n];
        for(int j=0;j<n;j++){
            int temp = A.pop();
            CHPoint[j]=temp;
            B.push(temp);
        }
        //String C = B.toString();
        return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@d48b11a3000fc560cefea2fb5131b8b3@"
"r04522616","3","0.32","108272","@8d290010fd888ff6ba3c105964f871e6@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=new Point2D[N];
        
        for(int i=0;i<N;i++)
        {
            b[i]=a[i];
        }
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        int n = A.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int k=0;
        for(int i=0;i<n;i++)
        {
            c[i]=s.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[k]=j;
                    k++;                    
                }
            }            
        }
        for(int i=0;i<n;i++)
        {
            Arrays.sort(CHPoint);
        }
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }
//        Stack<Integer> B = new Stack<Integer>();       
//        
//        for(int j=0;j<n;j++){
//            int temp = A.pop();
//            CHPoint[j]=temp;
//            B.push(temp);
//        }
        //String C = B.toString();
        return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@8d290010fd888ff6ba3c105964f871e6@"
"r03228006","0","0.51","107856","@cf19a7f03707a4caebc84e596d6f4dac@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int[]id = new int[a.length];
        for (int i = 0; i<a.length;i++){
            id[i]=i;
        }
        Point2D[] a0=a;
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p0 = a[0];
        Arrays.sort(a, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a.length);i++){
            int check=0;
            for(int k=i+1;k<(a.length);k++){
                if(Point2D.ccw(a[precv],a[i],a[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
            for(int j = 0; j<a0.length;j++){
              if(p1.equals(a0[j])){vindex[i] =j;}//如果找到與原本的a0相符，就記下a0的index
        }}
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
    }
    
   public static void main(String[] args)throws Exception {
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
//                    for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();}
                        //System.out.println(ccindex[k]);
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@cf19a7f03707a4caebc84e596d6f4dac@"
"r03228006","0","0.52","107360","@7fe85a1a42efec9ea49d9a41ef63cc0d@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int[]id = new int[a.length];
        for (int i = 0; i<a.length;i++){
            id[i]=i;
        }
        Point2D[] a0=a;
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p0 = a[0];
        Arrays.sort(a, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a.length);i++){
            int check=0;
            for(int k=i+1;k<(a.length);k++){
                if(Point2D.ccw(a[precv],a[i],a[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
            for(int j = 0; j<a0.length;j++){
              if(p1.equals(a0[j])){vindex[i] =j;}//如果找到與原本的a0相符，就記下a0的index
        }}
        //Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
    }
    
   public static void main(String[] args)throws Exception {
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
//                    for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();}
                        //System.out.println(ccindex[k]);
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@7fe85a1a42efec9ea49d9a41ef63cc0d@"
"b02611002","0","0","0","@fe9cad3564e3cf4b74f9476708134b58@import java.awt.*;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N, L;
    private static double radius = 0.01;

    public static int[] ConvexHullVertex(Point2D[] a) {

        for (Point2D p:a){System.out.println(""before: ""+p);}
        Arrays.sort(a,a[0].POLAR_ORDER);
        for (Point2D p:a){System.out.println(""after: ""+p);}
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return null;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);
        L = 512;

        // StdDraw setting
        StdDraw.setCanvasSize(L, L);
        StdDraw.setScale(0, L);
        StdDraw.setPenRadius(0.01);


        points = random2DPointArr(10);
        ConvexHullVertex(points);


        // draw line between points
        StdDraw.setPenColor(Color.green);
        StdDraw.setPenRadius();
        for (int i=1; i<points.length; i++)
            points[0].drawTo(points[i]);
        // draw red point
        StdDraw.setPenRadius(radius);
        StdDraw.setPenColor(Color.red);
        points[0].draw();
        // draw points
        StdDraw.setPenColor(Color.black);
        for (int i=1; i<points.length; i++)
            points[i].draw();
        // draw number
        StdDraw.setPenColor(Color.blue);
        for (int i=0; i<points.length; i++) {
            StdDraw.text(points[i].x(), points[i].y() + L*0.025, String.valueOf(i));
        }

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
            System.out.println(arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@fe9cad3564e3cf4b74f9476708134b58@"
"r04945008","5","0.104","106000","@a04c14ef79d976730db08009fc60527d@import java.util.Arrays;
    
public class MyConvexHull {private Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {
        Stack<Point2D> hull = new Stack<Point2D>();
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];
        Arrays.sort(points);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);
        hull.push(points[0]);       // p[0] is first extreme point
        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) {vertex[0]=N-1; return vertex;}        // all points equal
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point
        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        
        int[] vertex = new int[hull.size()];
        Point2D[] temp = new Point2D[hull.size()];
        int i=0;
        while (hull.size() > 0) {
            temp[i++]=hull.pop();
        }
        
        int k=0;
        for( i=0; i < temp.length; i++)
            for (int j = 0; j < N; j++) {
                if (pts[j] == temp[i]) {
                    vertex[k++]=j;
                }
            }
        Arrays.sort(vertex);
        return vertex;
    }
    public static void main(String[] args) {
        int N = 10;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
        }

        int[] A=ConvexHullVertex(points);
        for (int i = 0; i < A.length; i++) {
            System.out.printf(""%d\n"",A[i]);
            //StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
    }
}
            

@a04c14ef79d976730db08009fc60527d@"
"b03611041","0","0","0","@c71603f3345a40940e996723f405098c@import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");
        int dnum=num+1;
        for (int i = points.length - 1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < num; i++) {
//            System.out.println(v[i]);
//            v[i].draw();

            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@c71603f3345a40940e996723f405098c@"
"b03611041","3","0.5","107856","@d2f1c9002cef64140b14be30e3d9b259@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");
        int dnum=num+1;
        for (int i = points.length - 1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < num; i++) {
//            System.out.println(v[i]);
//            v[i].draw();

            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@d2f1c9002cef64140b14be30e3d9b259@"
"r03228006","0","0.5","107872","@1ddbfc3ab6656ca530b8a8f9202c1c2a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a0=a;
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p0 = a[0];
        Arrays.sort(a, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a.length);i++){
            int check=0;
            for(int k=i+1;k<(a.length);k++){
                if(Point2D.ccw(a[precv],a[i],a[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a0[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
    }
    
   public static void main(String[] args)throws Exception {
       //test
       Point2D [] test=new Point2D[10];
       for (int i=0;i<10;i++){
           double x = StdRandom.uniform();
           double y = StdRandom.uniform();
           test[i] = new Point2D(x, y);}
        int [] ccindex2 = ConvexHullVertex(test);
                    for (int k =0;k<ccindex2.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          System.out.println(ccindex2[k]);}
       
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(""input12.txt""))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

           /// System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@1ddbfc3ab6656ca530b8a8f9202c1c2a@"
"b01703032","5","0.102","107904","@7eacbb95aa18f946ec6d3476e9051f43@import java.util.*;


public class MyConvexHull {

    public static void main(String[] args) {


    }


    public static int[] ConvexHullVertex(Point2D[] points) {


        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@7eacbb95aa18f946ec6d3476e9051f43@"
"b03611041","0","0","0","@7ca0b763c7d699a093c009472161f314@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        if(points.length==2){
            int v2[]=new int[2];
            v2[0]=0;
            v2[1]=1;
            return v2;
        }else if(points.length==1){
            int v2[]=new int[1];
            v2[0]=0;
            return v2;
        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");
        int dnum=num+1;
        for (int i = points.length - 1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < num; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@7ca0b763c7d699a093c009472161f314@"
"b03611041","3","0.5","105488","@8741e2f7bd9527f5830cf46a56ff73c1@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        if(points.length==2){
            int v2[]=new int[2];
            v2[0]=0;
            v2[1]=1;
            return v2;
        }else if(points.length==1){
            int v2[]=new int[1];
            v2[0]=0;
            return v2;
        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");
        int dnum=num+1;
        for (int i = points.length - 1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < num; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@8741e2f7bd9527f5830cf46a56ff73c1@"
"r04921115","0","0","0","@5895335d6348141baed4d26f64fe149d@import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public int[] ConvexHullVertex(Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];

		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);
		
		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int i =0;
		int[] out = new int[inthull.size()];
		
		while(!inthull.isEmpty()){
			out[i++]=inthull.pop();
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
//			System.out.print(m[i]+"" "");
		}
	}
}

@5895335d6348141baed4d26f64fe149d@"
"r04921115","0","0.52","107520","@70a17df252f2616a3c1e3cde1a83c70e@import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];

		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);
		
		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int i =0;
		int[] out = new int[inthull.size()];
		
		while(!inthull.isEmpty()){
			out[i++]=inthull.pop();
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
//			System.out.print(m[i]+"" "");
		}
	}
}

@70a17df252f2616a3c1e3cde1a83c70e@"
"b03611041","3","0.39","107856","@393a8302f244ab0e7ed1bf03a299cfa2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        if(points.length==2){
            int v2[]=new int[2];
            v2[0]=0;
            v2[1]=1;
            return v2;
        }else if(points.length==1){
            int v2[]=new int[1];
            v2[0]=0;
            return v2;
        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 1,dnum=1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < num; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@393a8302f244ab0e7ed1bf03a299cfa2@"
"b03611041","3","0.4","104352","@20916e96a61fedaa92df3ba87c15639b@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        if(points.length==2){
            int v2[]=new int[2];
            v2[0]=0;
            v2[1]=1;
            return v2;
        }else if(points.length==1){
            int v2[]=new int[1];
            v2[0]=0;
            return v2;
        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 1,dnum=1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@20916e96a61fedaa92df3ba87c15639b@"
"r04631009","0","0.52","107520","@6309d08da5d3b171ccb3f9a2f0f147b2@
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Cyuan
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data = new Point2D[a.length];
        Point2D[] sortdata = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            double x = a[i].x();
            double y = a[i].y();
            data[i] = new Point2D(x, y);
            sortdata[i] = new Point2D(x, y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex = 0;
        double miny = sortdata[0].y();
        for (int i = 0; i < a.length; i++) {
            if (sortdata[i].y() < miny) {
                miny = sortdata[i].y();
                minindex = i;
            }
        }
        double maxx = sortdata[minindex].x();
        for (int i = 0; i < a.length; i++) {
            if (sortdata[i].y() == miny && sortdata[i].x() > maxx) {
                maxx = sortdata[i].x();
                minindex = i;
            }
        }
        Point2D swap = sortdata[minindex];
        sortdata[minindex] = sortdata[0];
        sortdata[0] = swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata, sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a.length; j++) {
                if (data[j].x() == sortdata[i].x() && data[j].y() == sortdata[i].y()) {
                    sortimformation[i] = j;
                }

            }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D temp1 = convexhull.pop();
            Point2D temp2 = convexhull.pop();
            while (sortdata[i].ccw(temp2, temp1, sortdata[i]) < 0) {
                temp1 = temp2;
                temp2 = convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        int counter = 0;
        int[] ans = new int[convexhull.size()];
        while (convexhull.size() != 0) {
            Point2D temp = convexhull.pop();
            for (int i = 0; i < a.length; i++) {
                if (sortdata[i].equals(temp)) {
                    ans[counter] = sortimformation[i];
                }
            }
            counter++;
        }
        Arrays.sort(ans);
        return (ans);
    }

    public static void main(String[] args) {
        int N = 10;
        Point2D[] data = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            data[i] = new Point2D(x, y);
        }
        int[] d = ConvexHullVertex(data);
        //---------------------------Show the ans-----------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.filledCircle(data[0].x(), data[0].y(), 0.01);
        //StdDraw.setPenColor(StdDraw.BLACK);
        //StdDraw.text(data[0].x(), data[0].y() + 0.02, String.valueOf(0));
        //for (int i = 1; i < N; i++) {
        //    StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
        //    StdDraw.text(data[i].x(), data[i].y() + 0.02, String.valueOf(i));
        //}
        //System.out.println("""");
        //for (int i = 0; i < d.length; i++) {
        //    System.out.println(d[i]);
        //}

    }
}

@6309d08da5d3b171ccb3f9a2f0f147b2@"
"b03611041","3","0.42","107824","@8250d53b55664d9ff733a11347fedd44@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
//        if(points.length==2){
//            int v2[]=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }else if(points.length==1){
//            int v2[]=new int[1];
//            v2[0]=0;
//            return v2;
//        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 1,dnum=1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@8250d53b55664d9ff733a11347fedd44@"
"r04631009","5","0.104","107920","@6c43820dd13753ef2061e233dd9892cc@
import java.util.Arrays;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Cyuan
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data = new Point2D[a.length];
        Point2D[] sortdata = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            double x = a[i].x();
            double y = a[i].y();
            data[i] = new Point2D(x, y);
            sortdata[i] = new Point2D(x, y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex = 0;
        double miny = sortdata[0].y();
        for (int i = 0; i < a.length; i++) {
            if (sortdata[i].y() < miny) {
                miny = sortdata[i].y();
                minindex = i;
            }
        }
        double maxx = sortdata[minindex].x();
        for (int i = 0; i < a.length; i++) {
            if (sortdata[i].y() == miny && sortdata[i].x() > maxx) {
                maxx = sortdata[i].x();
                minindex = i;
            }
        }
        Point2D swap = sortdata[minindex];
        sortdata[minindex] = sortdata[0];
        sortdata[0] = swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata, sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a.length; j++) {
                if (data[j].x() == sortdata[i].x() && data[j].y() == sortdata[i].y()) {
                    sortimformation[i] = j;
                }

            }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D temp1 = convexhull.pop();
            Point2D temp2 = convexhull.pop();
            while (sortdata[i].ccw(temp2, temp1, sortdata[i]) < 0) {
                temp1 = temp2;
                temp2 = convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        int counter = 0;
        int[] ans = new int[convexhull.size()];
        while (convexhull.size() != 0) {
            Point2D temp = convexhull.pop();
            for (int i = 0; i < a.length; i++) {
                if (sortdata[i].equals(temp)) {
                    ans[counter] = sortimformation[i];
                }
            }
            counter++;
        }
        Arrays.sort(ans);
        return (ans);
    }

    public static void main(String[] args) {
        int N = 10;
        Point2D[] data = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            data[i] = new Point2D(x, y);
        }
        int[] d = ConvexHullVertex(data);
        //---------------------------Show the ans-----------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.filledCircle(data[0].x(), data[0].y(), 0.01);
        //StdDraw.setPenColor(StdDraw.BLACK);
        //StdDraw.text(data[0].x(), data[0].y() + 0.02, String.valueOf(0));
        //for (int i = 1; i < N; i++) {
        //    StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
        //    StdDraw.text(data[i].x(), data[i].y() + 0.02, String.valueOf(i));
        //}
        //System.out.println("""");
        //for (int i = 0; i < d.length; i++) {
        //    System.out.println(d[i]);
        //}

    }
}

@6c43820dd13753ef2061e233dd9892cc@"
"b03611041","3","0.4","107824","@98241a2e5bd2a2530d50b6cb8c4a6ade@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
//        if(points.length==2){
//            int v2[]=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }else if(points.length==1){
//            int v2[]=new int[1];
//            v2[0]=0;
//            return v2;
//        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 2,dnum=1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);
//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@98241a2e5bd2a2530d50b6cb8c4a6ade@"
"r03228006","5","0.104","105920","@933dd6151e36c4a99438ed3980134ffb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a1= new Point2D[a.length];
        for(int i=0;i<a.length;i++){//如果直接a1=a，會連參照位置一起相等
        a1[i]=a[i];}
        Arrays.sort(a1, Point2D.Y_ORDER);
        Point2D p0 = a1[0];
        Arrays.sort(a1, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a1.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a1.length);i++){
            int check=0;
            for(int k=i+1;k<(a1.length);k++){
                if(Point2D.ccw(a1[precv],a1[i],a1[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a1[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
    }
    
   public static void main(String[] args)throws Exception {
       //test
       Point2D [] test=new Point2D[10];
       for (int i=0;i<10;i++){
           double x = StdRandom.uniform();
           double y = StdRandom.uniform();
           StdDraw.text(x,y,String.valueOf(i));
           test[i] = new Point2D(x, y);}
        int [] ccindex2 = ConvexHullVertex(test);
                    for (int k =0;k<ccindex2.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          System.out.println(ccindex2[k]);}
       //test end
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(""input12.txt""))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    //StdDraw.text(t0,t1,String.valueOf(ii));
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

           /// System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@933dd6151e36c4a99438ed3980134ffb@"
"b02611002","0","0","0","@def856b401a3161af6b99fb16a254e75@
import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
        for (Point2D p:a){System.out.println(""after: ""+p);}

        /* testing ccw */
        for(int i=0;i<a.length-2;i++) {
            System.out.println(i+"": ""+Point2D.ccw(a[i],a[i+1],a[i+2]));
        }

        /* Drawing */
        System.out.println(""Drawing..."");
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        /* routing */
        while (routing){
            if(now==a.length-1){ // now到8時停止
                routing=false;
            }
            if(Point2D.ccw(a[now],a[now+1],a[now+2])==1){
                now++;
                ans.push(now);
                continue;
            }else {
                now--;
                ans.pop();
                continue;
            }
        }

        System.out.println(""ans: ""+ans);

        /* 依序描點。最小者(point[0])為紅點 */
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        return null;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@def856b401a3161af6b99fb16a254e75@"
"b03611041","3","0.49","105952","@81c113752cbab211eb987e2dc1c2980b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
//        if(points.length==2){
//            int v2[]=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }else if(points.length==1){
//            int v2[]=new int[1];
//            v2[0]=0;
//            return v2;
//        }

        Point2D[] v = new Point2D[points.length];
        double originP[]=new double[points.length];
        for(int i=0;i<points.length;i++){
            originP[i]=points[i].x();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if (originP[k] == v[i].x()){
                    vertexes[i] = k;
//                    System.out.println(vertexes[i]);

                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@81c113752cbab211eb987e2dc1c2980b@"
"b03611041","5","0.098","105936","@fe852747dddc19521ab2a7666de93114@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
//        if(points.length==2){
//            int v2[]=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }else if(points.length==1){
//            int v2[]=new int[1];
//            v2[0]=0;
//            return v2;
//        }

        Point2D[] v = new Point2D[points.length];
        double originPx[]=new double[points.length];
        double originPy[]=new double[points.length];

        for(int i=0;i<points.length;i++){
            originPx[i]=points[i].x();
            originPy[i]=points[i].y();
        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originPx.length; k++) {
                if (originPx[k] == v[i].x() && originPy[k]==v[i].y()){
                    vertexes[i] = k;
//                    System.out.println(vertexes[i]);

                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@fe852747dddc19521ab2a7666de93114@"
"r04921115","5","0.106","107872","@85d93376fd314c54829abbe3b413d5ea@import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int[] out = new int[hull.size()];
		//System.out.println(""hullsize:""+hull.size());
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						//System.out.println(""j""+j);
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
			//System.out.print(m[i]+"" "");
		}
	}
}

@85d93376fd314c54829abbe3b413d5ea@"
"b03611041","5","0.102","106960","@9d3eb58cf999be90d26c2742686f6e76@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
            ConvexHullVertex(points);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
//        if(points.length==2){
//            int v2[]=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }else if(points.length==1){
//            int v2[]=new int[1];
//            v2[0]=0;
//            return v2;
//        }

        Point2D[] v = new Point2D[points.length];
//        double originPx[]=new double[points.length];
//        double originPy[]=new double[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);

//        for(int i=0;i<points.length;i++){
//            originPx[i]=points[i].x();
//            originPy[i]=points[i].y();
//        }
        Arrays.sort(points, new pointCmp());

//        for(int i=0;i<originP.length;i++){
//            System.out.println(originP[i]);
//        }
//        System.out.println(""\n"");

//        double miny=points[0].y();

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
//        System.out.println(num + ""\n"");

        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
//                if (originPx[k] == v[i].x() && originPy[k]==v[i].y()){
////                    System.out.println(vertexes[i]);
//
//                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@9d3eb58cf999be90d26c2742686f6e76@"
"r02b48003","0","0.52","106576","@1a284a854c4f217bf1b7154793df9024@import java.awt.Font;
import java.io.File;
import java.util.Arrays;
import java.util.Comparator;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class MyConvexHull {
    private static final double radius = 0.01; // point radius for plotting
    
    public static class MyUF extends WeightedQuickUnionUF {
        private final int count; // number of items
        
        public MyUF (int N) {
            /* execute WeightedQuickUnionUF constructor and 
               assign number of items*/
            super(N);
            count = N;
        } // end constructor
        
        public int[] getRoots() {
            /* The function gets all the roots */
            // initialization
            Stack<Integer> rootStack = new Stack<>(); // roots container
            
            // find roots and push to the container
            for (int node = 0; node < count; node++) {
                if (node == find(node)) { // if the root of a node is itself
                    rootStack.push(node);     // push to the container
                } // end if
            } // end loop
            
            // extract the roots from container and return
            int[] roots = stack2array(rootStack);
            return roots;
        } // end func getRoots
        
        public Stack<int[]> getCC() {
            /* get connected components */
            // initialization
            int[] roots = getRoots();           // get all the roots
            Stack<int[]> ccStack = new Stack<>(); // cc container
            
            // each root extract a connected component
            for (int root : roots){
                // loop initialization
                Stack<Integer> cc = new Stack<>();
                
                // element in connected component is connected to the root
                for (int node = 0; node < count; node++) {
                    if (root == find(node)) { cc.push(node); }
                } // end inner loop
                
                // collect each connected component
                ccStack.push(stack2array(cc));
            } // end outer loop
            
            return ccStack;
        } // end func getCC
        
        public int[] stack2array(Stack<Integer> stack){
            /* helper function:
               convert stack into array by popping all items into array */
            // initialization
            int[] arr = new int[stack.size()];
            
            // pop element and collect to an array
            for (int idx = 0; idx < arr.length; idx++) {
                arr[idx] = stack.pop();
            } // end loop
            
            return arr;
        } // end func stack2array
    } // end class myUF
    
    public static Point2D[] idx2points (Point2D[] points, int[] index) {
        /* helper function: 
           input an array of Point2D element and an array of index,
           return an array of Point2D where each element is matched the index 
           of the input array */
        // initialization
        int N = index.length;
        Point2D[] pts = new Point2D[N];
        
        // get the element based on the index array
        for (int i = 0; i < N; i++) {
            int idx = index[i];
            pts[i] = points[idx];
        } // end loop
        
        return pts;
    } // end func idx2point
    
    public static Stack<int[]> distUnionPoints (Point2D[] points, double dist) {
        /* union points and return stack of connected components */
        // initialization
        int N = points.length;
        MyUF uf; 
        
        // double for loop to compare each two points
        uf = new MyUF(N);
        for (int idx1 = 0; idx1 < N; idx1++) {
            for (int idx2 = idx1; idx2 < N; idx2++) {
                // union the points if the distance between points <= distance
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    uf.union(idx1, idx2);
                } // end if
            } // end inner loop
        } // end outer loop
        
        return uf.getCC();
    } // end func unionPoints
    
    /**
     * 
     * @param points
     * @return 
     */
    public static int[] ConvexHullVertex(Point2D[] points) {
	// check size
	int N = points.length;  // number of points
	if (N < 3) { return new int[0]; }

	// initialization
        Integer[] vex = new Integer[N]; // vertex: idx of points
	Point2D[] pts = new Point2D[N]; // all points
        
        for (int i = 0; i < N; i++) {
	    vex[i] = i;
	    pts[i] = new Point2D(points[i].x(),
				 points[i].y());
	} // end loop
        
        // initialize index
        Stack<Integer> convex = new Stack<Integer>(); // store index
	convex.push(0);
	convex.push(1);
	convex.push(2);
	
	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by Y axis
	sortByXYaxis(pts, vex);

	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by angle
	sortByAngle(pts, vex);
	
	// show points after sort
	// show(pts, vex);
        // plot(pts, vex);
	// plot(points);
	// plot(pts);
	
	// solve convex hull problem
	//*
	int idx = 2;
	while (true) {
	    
	    if (checkCCW(pts, convex)) {
		// update index
		idx += 1;
		idx %= N;
		
		// if index run through a cycle, break
		if (idx == 1) { break; }

		// push index into stack
		convex.push(idx);
	    } else {
		// skip a index by
		// pop two index & push current index
		convex.pop();
		convex.pop();
		convex.push(idx);
	    } // end if-else
	} // end loop

	// return answer
	int size = convex.size()-1;
        System.out.println(size);
        
	int[] ans = new int[size];
        for (int i = 0; i < size; i++) {
            //System.out.println(convex.pop());
            ans[i] = vex[convex.pop()];
	    //ans[i] = vertex[convex.pop()];
            //System.out.println(ans[i]);
            //System.out.println(vex[ans[i]]);
        } // end loop
        
	//plot(pts, ans1);
	//StdDraw.show(100);
	//StdDraw.clear();
	//plot(points, ans2);
	//*/
	return ans;
    } // end func ConvexHullVertex
    
    public static boolean checkCCW (Point2D[] points, Stack<Integer> index) {
        /* check whether the top 3 points form a counter clockwise angle */
	// get the top three index of the stack
	int idx3 = index.pop();
	int idx2 = index.pop();
	int idx1 = index.pop();

	// get three corresponding points
	Point2D p1 = points[idx1];
	Point2D p2 = points[idx2];
	Point2D p3 = points[idx3];

	// push back the index
	index.push(idx1);
	index.push(idx2);
	index.push(idx3);

	// return false if clockwise turn; return true otherwise
	//StdOut.println(idx1+"" ""+idx2+"" ""+idx3+"" ""+Point2D.ccw(p1, p2, p3));
	return Point2D.ccw(p1, p2, p3) != -1;
    } // end func checkCCW
    
    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by X and Y axis
     * @param points
     * @param vertex
     */
    public static void sortByXYaxis(Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        // first sort points by X axis
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.X_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
	// then sort points by Y axis
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.Y_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
    } // end class sortByYaxis

    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by angle to the reference point
     * The reference point is the first point in the array
     * @param points
     * @param vertex
     */
    public static void sortByAngle(Point2D[] points, Integer[] vertex) {
	// initialization
	int N = points.length;
        Point2D refPoint = points[0];
        Point2D[] pts = new Point2D[N];

	/* first sort points by radius in reversed order
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && more(Point2D.R_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop */
        
	// next shift points so that the reference point is at the origin
        double xi, yi, x0, y0;
	x0 = refPoint.x();
	y0 = refPoint.y();
	for (int i = 0; i < N; i++) {
	    xi = points[i].x();
	    yi = points[i].y();
	    //StdOut.println(xi + "" "" + yi + "" | "" + x0 + "" "" + y0);
	    pts[i] = new Point2D(xi - x0, yi - y0);
        } // end loop
        
        //System.out.println(""Inner:"");
        //show(pts, vertex);
	// then sort points by angle
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && lessAngle(pts[j], pts[j-1]);
                 //j > 0 && less(refPoint.polarOrder(), points[j], points[j-1]);
		 j--) {
                exch(pts, j, j-1);
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
    } // end func sortByAngle
    
    /**
     * @param v
     * @param w
     */
    private static boolean lessAngle (Point2D v, Point2D w) {
	return Double.compare(v.theta(), w.theta()) < 0;
    } // end func less
    
    /**
     * This method compare whether v < w
     * @param v The first object with comparable implemented
     * @param w The second object with comparable implemented
     * @return bool true if v is less than w
     */
    private static boolean less (Comparator c, Object v, Object w) {
	return c.compare(v, w) < 0;
    } // end func less

    /**
     * 
     * @param c
     * @param v
     * @param w
     * @return 
     */
    private static boolean more (Comparator c, Object v, Object w) {
	return c.compare(v, w) > 0;
    } // end func more

    /**
     * This method swap the position of a[idx01] and a[idx02]
     * @param a an array of elements with comparable implemented
     * @param idx01 the first index
     * @param idx02 the second index
     */
    private static void exch (Object[] a, int idx01, int idx02) {
	Object swap = a[idx01];
	a[idx01] = a[idx02];
	a[idx02] = swap;
    } // end func exch
    
    /**
     * 
     * @param points an array of elements with comparable implemented
     * @return
     */
    public static boolean isSortedXYaxis (Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].y() == points[idx+1].y()) {
                if (points[idx].x() > points[idx+1].x()) {
                    return false;
                } // end inner if
            } // end outer if
            
            if (points[idx].y() > points[idx+1].y()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedXYaxis
    
    /**
     * @param points
     * @return 
     */
    public static boolean isSortedAngle(Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].theta() > points[idx+1].theta()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedAngle
    
    /**
     * show the points with point ID
     * @param points
     * @param vertex
     */
    public static void show (Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        StdOut.println(""ID | X     | Y     | R     | Theta"");
	for (int i = 0; i < N; i++) {
	    StdOut.printf("" %d | %.3f | %.3f | %.3f | %.3f)\n"",
			  vertex[i],
			  points[i].x(),
			  points[i].y(),
                          points[i].r(),
			  points[i].theta());
	} // end loop
	StdOut.println(""------------"");
    } // end func show
    
    public static void plotSet () {
        // set scale
	StdDraw.setXscale(-1.2, 1.2);
	StdDraw.setYscale(-1.2, 1.2);
	
	// set coordinate
	StdDraw.setPenColor(StdDraw.GRAY);
        StdDraw.line(-1.1, 0, 1.1, 0);
	StdDraw.line(0, -1.1, 0, 1.1);
	
	// set Font
        Font font = new Font(""Consolas"", Font.BOLD, 15); 
	StdDraw.setFont(font);
    }
    /**
     * plot the points with point order
     * @param points
     */
    public static void plot (Point2D[] points) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop
    } // end func plot
    
    /**
     * plot the points with point ID
     * @param points
     * @param vertex
     */
    public static void plot (Point2D[] points, Integer[] vertex) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = vertex[i];
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// label the first point
	StdDraw.setPenColor(StdDraw.RED);
	StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint

    /**
     * 
     * @param points
     * @param ans 
     */
    public static void plotConvex (Point2D[] points, int[] ans) {
        plotSet();
	
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// plot lines
	StdOut.println("""");
	StdDraw.setPenColor(StdDraw.BLUE);
	for (int i = 0; i < ans.length; i++) {
	    int     v1 = ans[i];
	    int     v2 = ans[(i+1) % ans.length];
	    Point2D p1 = points[v1];
	    Point2D p2 = points[v2];
	    StdDraw.line(p1.x(), p1.y(), p2.x(), p2.y());
	    //StdOut.println(v1 + "" "" + v2);
	} // end loop

	// label the first point
	// StdDraw.setPenColor(StdDraw.RED);
	// StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint
    
    public static void main(String[] args) {
        Stack<Point2D> pointStack = new Stack<>();
        File file = new File(args[0]);
        In input = new In(file);
        String line;
        
        // read in the threshold distance
        line = input.readLine();
        Double dist = Double.parseDouble(line);
        
        // read in the number of points
        line = input.readLine();
        Integer N = Integer.parseInt(line);
        
        // check
        StdOut.println(""D: "" + dist + ""\nN: "" + N);
        while (!input.isEmpty()) {
            //double x = StdIn.readDouble();  
            //double y = StdIn.readDouble();           // Read pair to connect.
            //points.push(new Point2D(x, y));
            //StdOut.println(x + "" "" + y);       //   and print connection.
            line = input.readLine();
            String[] pos = line.split("" ""); // position
            Point2D point = new Point2D(
                    Double.parseDouble(pos[0]), 
                    Double.parseDouble(pos[1]));
            pointStack.push(point);
        } // end while loop 
        
        //*
        Point2D[] points = new Point2D[pointStack.size()];
        for (int idx = 0; idx < points.length; idx++) {
            points[idx] = pointStack.pop();
            //StdOut.printf(""%.3f, %.3f\n"", points[idx].x(), points[idx].y());
        } // end loop
        //*/
        //MyConvexHull.plot(points);
        int[] convex = MyConvexHull.ConvexHullVertex(points);
        MyConvexHull.plotConvex(points, convex);
    } // end func main
} // end class MyConvexHull

@1a284a854c4f217bf1b7154793df9024@"
"r02b48003","0","0.53","108672","@1a284a854c4f217bf1b7154793df9024@import java.awt.Font;
import java.io.File;
import java.util.Arrays;
import java.util.Comparator;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class MyConvexHull {
    private static final double radius = 0.01; // point radius for plotting
    
    public static class MyUF extends WeightedQuickUnionUF {
        private final int count; // number of items
        
        public MyUF (int N) {
            /* execute WeightedQuickUnionUF constructor and 
               assign number of items*/
            super(N);
            count = N;
        } // end constructor
        
        public int[] getRoots() {
            /* The function gets all the roots */
            // initialization
            Stack<Integer> rootStack = new Stack<>(); // roots container
            
            // find roots and push to the container
            for (int node = 0; node < count; node++) {
                if (node == find(node)) { // if the root of a node is itself
                    rootStack.push(node);     // push to the container
                } // end if
            } // end loop
            
            // extract the roots from container and return
            int[] roots = stack2array(rootStack);
            return roots;
        } // end func getRoots
        
        public Stack<int[]> getCC() {
            /* get connected components */
            // initialization
            int[] roots = getRoots();           // get all the roots
            Stack<int[]> ccStack = new Stack<>(); // cc container
            
            // each root extract a connected component
            for (int root : roots){
                // loop initialization
                Stack<Integer> cc = new Stack<>();
                
                // element in connected component is connected to the root
                for (int node = 0; node < count; node++) {
                    if (root == find(node)) { cc.push(node); }
                } // end inner loop
                
                // collect each connected component
                ccStack.push(stack2array(cc));
            } // end outer loop
            
            return ccStack;
        } // end func getCC
        
        public int[] stack2array(Stack<Integer> stack){
            /* helper function:
               convert stack into array by popping all items into array */
            // initialization
            int[] arr = new int[stack.size()];
            
            // pop element and collect to an array
            for (int idx = 0; idx < arr.length; idx++) {
                arr[idx] = stack.pop();
            } // end loop
            
            return arr;
        } // end func stack2array
    } // end class myUF
    
    public static Point2D[] idx2points (Point2D[] points, int[] index) {
        /* helper function: 
           input an array of Point2D element and an array of index,
           return an array of Point2D where each element is matched the index 
           of the input array */
        // initialization
        int N = index.length;
        Point2D[] pts = new Point2D[N];
        
        // get the element based on the index array
        for (int i = 0; i < N; i++) {
            int idx = index[i];
            pts[i] = points[idx];
        } // end loop
        
        return pts;
    } // end func idx2point
    
    public static Stack<int[]> distUnionPoints (Point2D[] points, double dist) {
        /* union points and return stack of connected components */
        // initialization
        int N = points.length;
        MyUF uf; 
        
        // double for loop to compare each two points
        uf = new MyUF(N);
        for (int idx1 = 0; idx1 < N; idx1++) {
            for (int idx2 = idx1; idx2 < N; idx2++) {
                // union the points if the distance between points <= distance
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    uf.union(idx1, idx2);
                } // end if
            } // end inner loop
        } // end outer loop
        
        return uf.getCC();
    } // end func unionPoints
    
    /**
     * 
     * @param points
     * @return 
     */
    public static int[] ConvexHullVertex(Point2D[] points) {
	// check size
	int N = points.length;  // number of points
	if (N < 3) { return new int[0]; }

	// initialization
        Integer[] vex = new Integer[N]; // vertex: idx of points
	Point2D[] pts = new Point2D[N]; // all points
        
        for (int i = 0; i < N; i++) {
	    vex[i] = i;
	    pts[i] = new Point2D(points[i].x(),
				 points[i].y());
	} // end loop
        
        // initialize index
        Stack<Integer> convex = new Stack<Integer>(); // store index
	convex.push(0);
	convex.push(1);
	convex.push(2);
	
	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by Y axis
	sortByXYaxis(pts, vex);

	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by angle
	sortByAngle(pts, vex);
	
	// show points after sort
	// show(pts, vex);
        // plot(pts, vex);
	// plot(points);
	// plot(pts);
	
	// solve convex hull problem
	//*
	int idx = 2;
	while (true) {
	    
	    if (checkCCW(pts, convex)) {
		// update index
		idx += 1;
		idx %= N;
		
		// if index run through a cycle, break
		if (idx == 1) { break; }

		// push index into stack
		convex.push(idx);
	    } else {
		// skip a index by
		// pop two index & push current index
		convex.pop();
		convex.pop();
		convex.push(idx);
	    } // end if-else
	} // end loop

	// return answer
	int size = convex.size()-1;
        System.out.println(size);
        
	int[] ans = new int[size];
        for (int i = 0; i < size; i++) {
            //System.out.println(convex.pop());
            ans[i] = vex[convex.pop()];
	    //ans[i] = vertex[convex.pop()];
            //System.out.println(ans[i]);
            //System.out.println(vex[ans[i]]);
        } // end loop
        
	//plot(pts, ans1);
	//StdDraw.show(100);
	//StdDraw.clear();
	//plot(points, ans2);
	//*/
	return ans;
    } // end func ConvexHullVertex
    
    public static boolean checkCCW (Point2D[] points, Stack<Integer> index) {
        /* check whether the top 3 points form a counter clockwise angle */
	// get the top three index of the stack
	int idx3 = index.pop();
	int idx2 = index.pop();
	int idx1 = index.pop();

	// get three corresponding points
	Point2D p1 = points[idx1];
	Point2D p2 = points[idx2];
	Point2D p3 = points[idx3];

	// push back the index
	index.push(idx1);
	index.push(idx2);
	index.push(idx3);

	// return false if clockwise turn; return true otherwise
	//StdOut.println(idx1+"" ""+idx2+"" ""+idx3+"" ""+Point2D.ccw(p1, p2, p3));
	return Point2D.ccw(p1, p2, p3) != -1;
    } // end func checkCCW
    
    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by X and Y axis
     * @param points
     * @param vertex
     */
    public static void sortByXYaxis(Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        // first sort points by X axis
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.X_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
	// then sort points by Y axis
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.Y_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
    } // end class sortByYaxis

    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by angle to the reference point
     * The reference point is the first point in the array
     * @param points
     * @param vertex
     */
    public static void sortByAngle(Point2D[] points, Integer[] vertex) {
	// initialization
	int N = points.length;
        Point2D refPoint = points[0];
        Point2D[] pts = new Point2D[N];

	/* first sort points by radius in reversed order
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && more(Point2D.R_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop */
        
	// next shift points so that the reference point is at the origin
        double xi, yi, x0, y0;
	x0 = refPoint.x();
	y0 = refPoint.y();
	for (int i = 0; i < N; i++) {
	    xi = points[i].x();
	    yi = points[i].y();
	    //StdOut.println(xi + "" "" + yi + "" | "" + x0 + "" "" + y0);
	    pts[i] = new Point2D(xi - x0, yi - y0);
        } // end loop
        
        //System.out.println(""Inner:"");
        //show(pts, vertex);
	// then sort points by angle
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && lessAngle(pts[j], pts[j-1]);
                 //j > 0 && less(refPoint.polarOrder(), points[j], points[j-1]);
		 j--) {
                exch(pts, j, j-1);
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
    } // end func sortByAngle
    
    /**
     * @param v
     * @param w
     */
    private static boolean lessAngle (Point2D v, Point2D w) {
	return Double.compare(v.theta(), w.theta()) < 0;
    } // end func less
    
    /**
     * This method compare whether v < w
     * @param v The first object with comparable implemented
     * @param w The second object with comparable implemented
     * @return bool true if v is less than w
     */
    private static boolean less (Comparator c, Object v, Object w) {
	return c.compare(v, w) < 0;
    } // end func less

    /**
     * 
     * @param c
     * @param v
     * @param w
     * @return 
     */
    private static boolean more (Comparator c, Object v, Object w) {
	return c.compare(v, w) > 0;
    } // end func more

    /**
     * This method swap the position of a[idx01] and a[idx02]
     * @param a an array of elements with comparable implemented
     * @param idx01 the first index
     * @param idx02 the second index
     */
    private static void exch (Object[] a, int idx01, int idx02) {
	Object swap = a[idx01];
	a[idx01] = a[idx02];
	a[idx02] = swap;
    } // end func exch
    
    /**
     * 
     * @param points an array of elements with comparable implemented
     * @return
     */
    public static boolean isSortedXYaxis (Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].y() == points[idx+1].y()) {
                if (points[idx].x() > points[idx+1].x()) {
                    return false;
                } // end inner if
            } // end outer if
            
            if (points[idx].y() > points[idx+1].y()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedXYaxis
    
    /**
     * @param points
     * @return 
     */
    public static boolean isSortedAngle(Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].theta() > points[idx+1].theta()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedAngle
    
    /**
     * show the points with point ID
     * @param points
     * @param vertex
     */
    public static void show (Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        StdOut.println(""ID | X     | Y     | R     | Theta"");
	for (int i = 0; i < N; i++) {
	    StdOut.printf("" %d | %.3f | %.3f | %.3f | %.3f)\n"",
			  vertex[i],
			  points[i].x(),
			  points[i].y(),
                          points[i].r(),
			  points[i].theta());
	} // end loop
	StdOut.println(""------------"");
    } // end func show
    
    public static void plotSet () {
        // set scale
	StdDraw.setXscale(-1.2, 1.2);
	StdDraw.setYscale(-1.2, 1.2);
	
	// set coordinate
	StdDraw.setPenColor(StdDraw.GRAY);
        StdDraw.line(-1.1, 0, 1.1, 0);
	StdDraw.line(0, -1.1, 0, 1.1);
	
	// set Font
        Font font = new Font(""Consolas"", Font.BOLD, 15); 
	StdDraw.setFont(font);
    }
    /**
     * plot the points with point order
     * @param points
     */
    public static void plot (Point2D[] points) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop
    } // end func plot
    
    /**
     * plot the points with point ID
     * @param points
     * @param vertex
     */
    public static void plot (Point2D[] points, Integer[] vertex) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = vertex[i];
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// label the first point
	StdDraw.setPenColor(StdDraw.RED);
	StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint

    /**
     * 
     * @param points
     * @param ans 
     */
    public static void plotConvex (Point2D[] points, int[] ans) {
        plotSet();
	
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// plot lines
	StdOut.println("""");
	StdDraw.setPenColor(StdDraw.BLUE);
	for (int i = 0; i < ans.length; i++) {
	    int     v1 = ans[i];
	    int     v2 = ans[(i+1) % ans.length];
	    Point2D p1 = points[v1];
	    Point2D p2 = points[v2];
	    StdDraw.line(p1.x(), p1.y(), p2.x(), p2.y());
	    //StdOut.println(v1 + "" "" + v2);
	} // end loop

	// label the first point
	// StdDraw.setPenColor(StdDraw.RED);
	// StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint
    
    public static void main(String[] args) {
        Stack<Point2D> pointStack = new Stack<>();
        File file = new File(args[0]);
        In input = new In(file);
        String line;
        
        // read in the threshold distance
        line = input.readLine();
        Double dist = Double.parseDouble(line);
        
        // read in the number of points
        line = input.readLine();
        Integer N = Integer.parseInt(line);
        
        // check
        StdOut.println(""D: "" + dist + ""\nN: "" + N);
        while (!input.isEmpty()) {
            //double x = StdIn.readDouble();  
            //double y = StdIn.readDouble();           // Read pair to connect.
            //points.push(new Point2D(x, y));
            //StdOut.println(x + "" "" + y);       //   and print connection.
            line = input.readLine();
            String[] pos = line.split("" ""); // position
            Point2D point = new Point2D(
                    Double.parseDouble(pos[0]), 
                    Double.parseDouble(pos[1]));
            pointStack.push(point);
        } // end while loop 
        
        //*
        Point2D[] points = new Point2D[pointStack.size()];
        for (int idx = 0; idx < points.length; idx++) {
            points[idx] = pointStack.pop();
            //StdOut.printf(""%.3f, %.3f\n"", points[idx].x(), points[idx].y());
        } // end loop
        //*/
        //MyConvexHull.plot(points);
        int[] convex = MyConvexHull.ConvexHullVertex(points);
        MyConvexHull.plotConvex(points, convex);
    } // end func main
} // end class MyConvexHull

@1a284a854c4f217bf1b7154793df9024@"
"r02b48003","5","0.104","106016","@5a352566a1c734c306539bc31a35912a@import java.awt.Font;
import java.io.File;
import java.util.Arrays;
import java.util.Comparator;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class MyConvexHull {
    private static final double radius = 0.01; // point radius for plotting
    
    public static class MyUF extends WeightedQuickUnionUF {
        private final int count; // number of items
        
        public MyUF (int N) {
            /* execute WeightedQuickUnionUF constructor and 
               assign number of items*/
            super(N);
            count = N;
        } // end constructor
        
        public int[] getRoots() {
            /* The function gets all the roots */
            // initialization
            Stack<Integer> rootStack = new Stack<>(); // roots container
            
            // find roots and push to the container
            for (int node = 0; node < count; node++) {
                if (node == find(node)) { // if the root of a node is itself
                    rootStack.push(node);     // push to the container
                } // end if
            } // end loop
            
            // extract the roots from container and return
            int[] roots = stack2array(rootStack);
            return roots;
        } // end func getRoots
        
        public Stack<int[]> getCC() {
            /* get connected components */
            // initialization
            int[] roots = getRoots();           // get all the roots
            Stack<int[]> ccStack = new Stack<>(); // cc container
            
            // each root extract a connected component
            for (int root : roots){
                // loop initialization
                Stack<Integer> cc = new Stack<>();
                
                // element in connected component is connected to the root
                for (int node = 0; node < count; node++) {
                    if (root == find(node)) { cc.push(node); }
                } // end inner loop
                
                // collect each connected component
                ccStack.push(stack2array(cc));
            } // end outer loop
            
            return ccStack;
        } // end func getCC
        
        public int[] stack2array(Stack<Integer> stack){
            /* helper function:
               convert stack into array by popping all items into array */
            // initialization
            int[] arr = new int[stack.size()];
            
            // pop element and collect to an array
            for (int idx = 0; idx < arr.length; idx++) {
                arr[idx] = stack.pop();
            } // end loop
            
            return arr;
        } // end func stack2array
    } // end class myUF
    
    public static Point2D[] idx2points (Point2D[] points, int[] index) {
        /* helper function: 
           input an array of Point2D element and an array of index,
           return an array of Point2D where each element is matched the index 
           of the input array */
        // initialization
        int N = index.length;
        Point2D[] pts = new Point2D[N];
        
        // get the element based on the index array
        for (int i = 0; i < N; i++) {
            int idx = index[i];
            pts[i] = points[idx];
        } // end loop
        
        return pts;
    } // end func idx2point
    
    public static Stack<int[]> distUnionPoints (Point2D[] points, double dist) {
        /* union points and return stack of connected components */
        // initialization
        int N = points.length;
        MyUF uf; 
        
        // double for loop to compare each two points
        uf = new MyUF(N);
        for (int idx1 = 0; idx1 < N; idx1++) {
            for (int idx2 = idx1; idx2 < N; idx2++) {
                // union the points if the distance between points <= distance
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    uf.union(idx1, idx2);
                } // end if
            } // end inner loop
        } // end outer loop
        
        return uf.getCC();
    } // end func unionPoints
    
    /**
     * 
     * @param points
     * @return 
     */
    public static int[] ConvexHullVertex(Point2D[] points) {
	// check size
	int N = points.length;  // number of points
	if (N < 3) { return new int[0]; }

	// initialization
        Integer[] vex = new Integer[N]; // vertex: idx of points
	Point2D[] pts = new Point2D[N]; // all points
        
        for (int i = 0; i < N; i++) {
	    vex[i] = i;
	    pts[i] = new Point2D(points[i].x(),
				 points[i].y());
	} // end loop
        
        // initialize index
        Stack<Integer> convex = new Stack<Integer>(); // store index
	convex.push(0);
	convex.push(1);
	convex.push(2);
	
	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by Y axis
	sortByXYaxis(pts, vex);

	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by angle
	sortByAngle(pts, vex);
	
	// show points after sort
	// show(pts, vex);
        // plot(pts, vex);
	// plot(points);
	// plot(pts);
	
	// solve convex hull problem
	//*
	int idx = 2;
	while (true) {
	    
	    if (checkCCW(pts, convex)) {
		// update index
		idx += 1;
		idx %= N;
		
		// if index run through a cycle, break
		if (idx == 1) { break; }

		// push index into stack
		convex.push(idx);
	    } else {
		// skip a index by
		// pop two index & push current index
		convex.pop();
		convex.pop();
		convex.push(idx);
	    } // end if-else
	} // end loop

	// return answer
	int size = convex.size()-1;
        
	int[] ans = new int[size];
        for (int i = 0; i < size; i++) {
            ans[i] = vex[convex.pop()];
        } // end loop
        
	//plot(pts, ans1);
	//StdDraw.show(100);
	//StdDraw.clear();
	//plot(points, ans2);
	//*/
	return ans;
    } // end func ConvexHullVertex
    
    public static boolean checkCCW (Point2D[] points, Stack<Integer> index) {
        /* check whether the top 3 points form a counter clockwise angle */
	// get the top three index of the stack
	int idx3 = index.pop();
	int idx2 = index.pop();
	int idx1 = index.pop();

	// get three corresponding points
	Point2D p1 = points[idx1];
	Point2D p2 = points[idx2];
	Point2D p3 = points[idx3];

	// push back the index
	index.push(idx1);
	index.push(idx2);
	index.push(idx3);

	// return false if clockwise turn; return true otherwise
	//StdOut.println(idx1+"" ""+idx2+"" ""+idx3+"" ""+Point2D.ccw(p1, p2, p3));
	return Point2D.ccw(p1, p2, p3) != -1;
    } // end func checkCCW
    
    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by X and Y axis
     * @param points
     * @param vertex
     */
    public static void sortByXYaxis(Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        // first sort points by X axis
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.X_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
	// then sort points by Y axis
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.Y_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
    } // end class sortByYaxis

    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by angle to the reference point
     * The reference point is the first point in the array
     * @param points
     * @param vertex
     */
    public static void sortByAngle(Point2D[] points, Integer[] vertex) {
	// initialization
	int N = points.length;
        Point2D refPoint = points[0];
        Point2D[] pts = new Point2D[N];

	/* first sort points by radius in reversed order
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && more(Point2D.R_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop */
        
	// next shift points so that the reference point is at the origin
        double xi, yi, x0, y0;
	x0 = refPoint.x();
	y0 = refPoint.y();
	for (int i = 0; i < N; i++) {
	    xi = points[i].x();
	    yi = points[i].y();
	    //StdOut.println(xi + "" "" + yi + "" | "" + x0 + "" "" + y0);
	    pts[i] = new Point2D(xi - x0, yi - y0);
        } // end loop
        
        //System.out.println(""Inner:"");
        //show(pts, vertex);
	// then sort points by angle
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && lessAngle(pts[j], pts[j-1]);
                 //j > 0 && less(refPoint.polarOrder(), points[j], points[j-1]);
		 j--) {
                exch(pts, j, j-1);
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
    } // end func sortByAngle
    
    /**
     * @param v
     * @param w
     */
    private static boolean lessAngle (Point2D v, Point2D w) {
	return Double.compare(v.theta(), w.theta()) < 0;
    } // end func less
    
    /**
     * This method compare whether v < w
     * @param v The first object with comparable implemented
     * @param w The second object with comparable implemented
     * @return bool true if v is less than w
     */
    private static boolean less (Comparator c, Object v, Object w) {
	return c.compare(v, w) < 0;
    } // end func less

    /**
     * 
     * @param c
     * @param v
     * @param w
     * @return 
     */
    private static boolean more (Comparator c, Object v, Object w) {
	return c.compare(v, w) > 0;
    } // end func more

    /**
     * This method swap the position of a[idx01] and a[idx02]
     * @param a an array of elements with comparable implemented
     * @param idx01 the first index
     * @param idx02 the second index
     */
    private static void exch (Object[] a, int idx01, int idx02) {
	Object swap = a[idx01];
	a[idx01] = a[idx02];
	a[idx02] = swap;
    } // end func exch
    
    /**
     * 
     * @param points an array of elements with comparable implemented
     * @return
     */
    public static boolean isSortedXYaxis (Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].y() == points[idx+1].y()) {
                if (points[idx].x() > points[idx+1].x()) {
                    return false;
                } // end inner if
            } // end outer if
            
            if (points[idx].y() > points[idx+1].y()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedXYaxis
    
    /**
     * @param points
     * @return 
     */
    public static boolean isSortedAngle(Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].theta() > points[idx+1].theta()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedAngle
    
    /**
     * show the points with point ID
     * @param points
     * @param vertex
     */
    public static void show (Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        StdOut.println(""ID | X     | Y     | R     | Theta"");
	for (int i = 0; i < N; i++) {
	    StdOut.printf("" %d | %.3f | %.3f | %.3f | %.3f)\n"",
			  vertex[i],
			  points[i].x(),
			  points[i].y(),
                          points[i].r(),
			  points[i].theta());
	} // end loop
	StdOut.println(""------------"");
    } // end func show
    
    public static void plotSet () {
        // set scale
	StdDraw.setXscale(-1.2, 1.2);
	StdDraw.setYscale(-1.2, 1.2);
	
	// set coordinate
	StdDraw.setPenColor(StdDraw.GRAY);
        StdDraw.line(-1.1, 0, 1.1, 0);
	StdDraw.line(0, -1.1, 0, 1.1);
	
	// set Font
        Font font = new Font(""Consolas"", Font.BOLD, 15); 
	StdDraw.setFont(font);
    }
    /**
     * plot the points with point order
     * @param points
     */
    public static void plot (Point2D[] points) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop
    } // end func plot
    
    /**
     * plot the points with point ID
     * @param points
     * @param vertex
     */
    public static void plot (Point2D[] points, Integer[] vertex) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = vertex[i];
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// label the first point
	StdDraw.setPenColor(StdDraw.RED);
	StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint

    /**
     * 
     * @param points
     * @param ans 
     */
    public static void plotConvex (Point2D[] points, int[] ans) {
        plotSet();
	
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// plot lines
	StdOut.println("""");
	StdDraw.setPenColor(StdDraw.BLUE);
	for (int i = 0; i < ans.length; i++) {
	    int     v1 = ans[i];
	    int     v2 = ans[(i+1) % ans.length];
	    Point2D p1 = points[v1];
	    Point2D p2 = points[v2];
	    StdDraw.line(p1.x(), p1.y(), p2.x(), p2.y());
	    //StdOut.println(v1 + "" "" + v2);
	} // end loop

	// label the first point
	// StdDraw.setPenColor(StdDraw.RED);
	// StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint
    
    public static void main(String[] args) {
        Stack<Point2D> pointStack = new Stack<>();
        File file = new File(args[0]);
        In input = new In(file);
        String line;
        
        // read in the threshold distance
        line = input.readLine();
        Double dist = Double.parseDouble(line);
        
        // read in the number of points
        line = input.readLine();
        Integer N = Integer.parseInt(line);
        
        // check
        StdOut.println(""D: "" + dist + ""\nN: "" + N);
        while (!input.isEmpty()) {
            //double x = StdIn.readDouble();  
            //double y = StdIn.readDouble();           // Read pair to connect.
            //points.push(new Point2D(x, y));
            //StdOut.println(x + "" "" + y);       //   and print connection.
            line = input.readLine();
            String[] pos = line.split("" ""); // position
            Point2D point = new Point2D(
                    Double.parseDouble(pos[0]), 
                    Double.parseDouble(pos[1]));
            pointStack.push(point);
        } // end while loop 
        
        //*
        Point2D[] points = new Point2D[pointStack.size()];
        for (int idx = 0; idx < points.length; idx++) {
            points[idx] = pointStack.pop();
            //StdOut.printf(""%.3f, %.3f\n"", points[idx].x(), points[idx].y());
        } // end loop
        //*/
        //MyConvexHull.plot(points);
        int[] convex = MyConvexHull.ConvexHullVertex(points);
        //MyConvexHull.plotConvex(points, convex);
        System.out.println(Arrays.toString(convex));
    } // end func main
} // end class MyConvexHull

@5a352566a1c734c306539bc31a35912a@"
"r04631026","0","0.63","112336","@431e63b74e625d213987aaa5e9016801@import static java.lang.Math.atan;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {
    Stack<Point2D> hull;
    
    // Point2D[] setRedPoints(Point2D[] p) { 設定 Y 值最小的點，並與首項交換 } (第一次)
    public static Point2D[] setRedPointAndSort(Point2D[] p) {
        // 標記 Y 值最小的點為紅色
        Point2D redPoint = p[0];
        int index = 0;
        for (int i = 1; i < p.length; i++) {
            if (redPoint.y() > p[i].y()) {
                redPoint = p[i];
                index = i;
            }
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        redPoint.draw();
        
        // 將 array 首項與紅點互換
        p[index] = p[0];
        p[0] = redPoint;
        
        // 計算紅點到其它點的角度
        double[] degree = new double[p.length];
        for (int i = 0; i < p.length; i++) {
            degree[i] = atan((p[i].x()-redPoint.x())/(p[i].y()-redPoint.y()));
        }
        
        // 把紅點到其它點角度由小至大排序
        Point2D tempPoint = new Point2D(0, 0);
        double tempDegree = 0;
        for (int i = 1; i < p.length; i++) {
           for (int k = i+1; k < p.length; k++) {
              if (degree[i] < degree[k]) {
                  tempPoint = p[i];
                  p[i] = p[k];
                  p[k] = tempPoint;  

                  tempDegree = degree[i];
                  degree[i] = degree[k];
                  degree[k] = tempDegree; 
               }
           }
        }
        
    return p;
    }
    
    // int ccw(Point2D a, Point2D b, Point2D c) { 判斷向量ab與向量bc角度是否為 counter-clockwise }
    public static int ccw(Point2D a, Point2D b, Point2D c) {
        double area = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        
        if (area < 0)  
            return -1; // clockwise
        else if (area > 0) 
            return +1; // counter-clockwise
        else 
            return 0; // collinear
}
}
@431e63b74e625d213987aaa5e9016801@"
"r04631026","0","0.63","112096","@d385f2d57043eaf601e86ae65960515d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Yue
 */

import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import static java.lang.Math.atan;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {
    Stack<Point2D> hull;
    
    // Point2D[] setRedPoints(Point2D[] p) { 設定 Y 值最小的點，並與首項交換 } (第一次)
    public static Point2D[] setRedPointAndSort(Point2D[] p) {
        // 標記 Y 值最小的點為紅色
        Point2D redPoint = p[0];
        int index = 0;
        for (int i = 1; i < p.length; i++) {
            if (redPoint.y() > p[i].y()) {
                redPoint = p[i];
                index = i;
            }
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        redPoint.draw();
        
        // 將 array 首項與紅點互換
        p[index] = p[0];
        p[0] = redPoint;
        
        // 計算紅點到其它點的角度
        double[] degree = new double[p.length];
        for (int i = 0; i < p.length; i++) {
            degree[i] = atan((p[i].x()-redPoint.x())/(p[i].y()-redPoint.y()));
        }
        
        // 把紅點到其它點角度由小至大排序
        Point2D tempPoint = new Point2D(0, 0);
        double tempDegree = 0;
        for (int i = 1; i < p.length; i++) {
           for (int k = i+1; k < p.length; k++) {
              if (degree[i] < degree[k]) {
                  tempPoint = p[i];
                  p[i] = p[k];
                  p[k] = tempPoint;  

                  tempDegree = degree[i];
                  degree[i] = degree[k];
                  degree[k] = tempDegree; 
               }
           }
        }
        
    return p;
    }
    
    // int ccw(Point2D a, Point2D b, Point2D c) { 判斷向量ab與向量bc角度是否為 counter-clockwise }
    public static int ccw(Point2D a, Point2D b, Point2D c) {
        double area = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        
        if (area < 0)  
            return -1; // clockwise
        else if (area > 0) 
            return +1; // counter-clockwise
        else 
            return 0; // collinear
}
    
    
    // int[] ConvexHullVertex(Point2D[] p) { 函式回傳點集合中形成 convex hull 點的 index }
    public static int[] ConvexHullVertex(Point2D[] a) { 
        if (a.length > 2) {
            Stack<Point2D> hull = new Stack<Point2D>();
        
            hull.push(a[0]);
            hull.push(a[1]);
        
           for (int i = 2; i < a.length; i++) {
                Point2D top = hull.pop();
           while (Point2D.ccw(hull.peek(), top, a[i]) <= 0)
                top = hull.pop();
           hull.push(top);
           hull.push(a[i]);
           }
        
           // 判斷點集合中形成 convex hull 點的 index
           int[] p = new int[hull.size()];
           int j = 0;
           for (Point2D q : hull) {
                p[hull.size()- j - 1] = Arrays.asList(a).indexOf(q);
                j++;
           }
        
//        for (int i = 0; i < p.length; i++) {
//            StdOut.print(""/"" + p[i]);
//        }
//        StdOut.println();
        
        // 回傳ConvexHullVertex的index set，編號請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return p;
        }
        else {
            int[] p = null;
        return p;
        }
    }
    
    public static void main(String[] args) {
        // 讀取文字檔
        In in = new In(args[0]);
        
        // 讀取點個數 N
        int N = in.readInt();
        
        // 初始化視窗大小、畫筆粗細
//        StdDraw.setCanvasSize(500, 500);
//        StdDraw.setPenRadius(.01);
        
        
        // 讀入點座標並在平面上畫出
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(in.readDouble(), in.readDouble());
//            points[i].draw();
        }
        
        // 設定 Y 值最小的點，並排序
        points = setRedPointAndSort(points);
        
        // 設定筆的粗細、顏色，並標記 Y 值最小的點號碼為 0
        HashMap<Integer, Point2D> map = new HashMap<Integer, Point2D> (); // 號碼索引的 HashMap
        HashMap<Integer, Point2D>  tempMap = new HashMap<Integer, Point2D> (); // 移除 vertex 用的HashMap
        map.put(0, points[0]); // 號碼索引的 HashMap
        tempMap.put(0, points[0]); // 移除 vertex 用的HashMap
//        StdDraw.setPenRadius (.001);
//        StdDraw.setPenColor (StdDraw.BLACK);
//        StdDraw.text(points[0].x(), points[0].y()+0.02, Integer.toString(0));
        // 標記其它點的號碼
        for (int i = 1; i < N; i++) {
            map.put(i, points[i]); // 號碼索引的 HashMap
            tempMap.put(i, points[i]); // 移除 vertex 用的HashMap
//            StdDraw.text(points[i].x(), points[i].y()+0.02, Integer.toString(i));
        }
        
        
        int m;
        while (tempMap.size() >= 3) {
            int[] indexOfVertex = ConvexHullVertex(points);
            
            // 輸出形成 convex hull 點的 vertex
            for (int i = 0; i < indexOfVertex.length; i++) {
                for (Integer key : map.keySet()) {
                    if (points[indexOfVertex[i]] == map.get(key)) {
                        tempMap.remove(key);
                        StdOut.print(key + "" "");
                    }
                }
            }
            StdOut.println();
            
            // 點集合拿掉 vertex
            points = new Point2D[tempMap.size()];
            m = 0;
            for (Integer key : map.keySet()) {
                if (tempMap.containsKey(key)) {
                    points[m] = (Point2D) tempMap.get(key);
                    m++;
                }
            }
            
            if (tempMap.size() >= 3) {
                points = setRedPointAndSort(points);
            }
        }
    }
}

@d385f2d57043eaf601e86ae65960515d@"
"r04631026","0","0.41","107984","@42eb395c52e312d7a39b7cbba1413900@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Yue
 */


import static java.lang.Math.atan;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {
    Stack<Point2D> hull;
    
    // Point2D[] setRedPoints(Point2D[] p) { 設定 Y 值最小的點，並與首項交換 } (第一次)
    public static Point2D[] setRedPointAndSort(Point2D[] p) {
        // 標記 Y 值最小的點為紅色
        Point2D redPoint = p[0];
        int index = 0;
        for (int i = 1; i < p.length; i++) {
            if (redPoint.y() > p[i].y()) {
                redPoint = p[i];
                index = i;
            }
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        redPoint.draw();
        
        // 將 array 首項與紅點互換
        p[index] = p[0];
        p[0] = redPoint;
        
        // 計算紅點到其它點的角度
        double[] degree = new double[p.length];
        for (int i = 0; i < p.length; i++) {
            degree[i] = atan((p[i].x()-redPoint.x())/(p[i].y()-redPoint.y()));
        }
        
        // 把紅點到其它點角度由小至大排序
        Point2D tempPoint = new Point2D(0, 0);
        double tempDegree = 0;
        for (int i = 1; i < p.length; i++) {
           for (int k = i+1; k < p.length; k++) {
              if (degree[i] < degree[k]) {
                  tempPoint = p[i];
                  p[i] = p[k];
                  p[k] = tempPoint;  

                  tempDegree = degree[i];
                  degree[i] = degree[k];
                  degree[k] = tempDegree; 
               }
           }
        }
        
    return p;
    }
    
    // int ccw(Point2D a, Point2D b, Point2D c) { 判斷向量ab與向量bc角度是否為 counter-clockwise }
    public static int ccw(Point2D a, Point2D b, Point2D c) {
        double area = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        
        if (area < 0)  
            return -1; // clockwise
        else if (area > 0) 
            return +1; // counter-clockwise
        else 
            return 0; // collinear
}
    
    
    // int[] ConvexHullVertex(Point2D[] p) { 函式回傳點集合中形成 convex hull 點的 index }
    public static int[] ConvexHullVertex(Point2D[] a) { 
        if (a.length > 2) {
            Stack<Point2D> hull = new Stack<Point2D>();
        
            hull.push(a[0]);
            hull.push(a[1]);
        
           for (int i = 2; i < a.length; i++) {
                Point2D top = hull.pop();
           while (Point2D.ccw(hull.peek(), top, a[i]) <= 0)
                top = hull.pop();
           hull.push(top);
           hull.push(a[i]);
           }
        
           // 判斷點集合中形成 convex hull 點的 index
           int[] p = new int[hull.size()];
           int j = 0;
           for (Point2D q : hull) {
                p[hull.size()- j - 1] = Arrays.asList(a).indexOf(q);
                j++;
           }
        
//        for (int i = 0; i < p.length; i++) {
//            StdOut.print(""/"" + p[i]);
//        }
//        StdOut.println();
        
        // 回傳ConvexHullVertex的index set，編號請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return p;
        }
        else {
            int[] p = null;
        return p;
        }
    }
    
    public static void main(String[] args) {
        // 讀取文字檔
        In in = new In(args[0]);
        
        // 讀取點個數 N
        int N = in.readInt();
        
        // 初始化視窗大小、畫筆粗細
//        StdDraw.setCanvasSize(500, 500);
//        StdDraw.setPenRadius(.01);
        
        
        // 讀入點座標並在平面上畫出
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(in.readDouble(), in.readDouble());
//            points[i].draw();
        }
        
        // 設定 Y 值最小的點，並排序
        points = setRedPointAndSort(points);
        
        // 設定筆的粗細、顏色，並標記 Y 值最小的點號碼為 0
        HashMap<Integer, Point2D> map = new HashMap<Integer, Point2D> (); // 號碼索引的 HashMap
        HashMap<Integer, Point2D>  tempMap = new HashMap<Integer, Point2D> (); // 移除 vertex 用的HashMap
        map.put(0, points[0]); // 號碼索引的 HashMap
        tempMap.put(0, points[0]); // 移除 vertex 用的HashMap
//        StdDraw.setPenRadius (.001);
//        StdDraw.setPenColor (StdDraw.BLACK);
//        StdDraw.text(points[0].x(), points[0].y()+0.02, Integer.toString(0));
        // 標記其它點的號碼
        for (int i = 1; i < N; i++) {
            map.put(i, points[i]); // 號碼索引的 HashMap
            tempMap.put(i, points[i]); // 移除 vertex 用的HashMap
//            StdDraw.text(points[i].x(), points[i].y()+0.02, Integer.toString(i));
        }
        
        
        int m;
        while (tempMap.size() >= 3) {
            int[] indexOfVertex = ConvexHullVertex(points);
            
            // 輸出形成 convex hull 點的 vertex
            for (int i = 0; i < indexOfVertex.length; i++) {
                for (Integer key : map.keySet()) {
                    if (points[indexOfVertex[i]] == map.get(key)) {
                        tempMap.remove(key);
                        StdOut.print(key + "" "");
                    }
                }
            }
            StdOut.println();
            
            // 點集合拿掉 vertex
            points = new Point2D[tempMap.size()];
            m = 0;
            for (Integer key : map.keySet()) {
                if (tempMap.containsKey(key)) {
                    points[m] = (Point2D) tempMap.get(key);
                    m++;
                }
            }
            
            if (tempMap.size() >= 3) {
                points = setRedPointAndSort(points);
            }
        }
    }
}

@42eb395c52e312d7a39b7cbba1413900@"
"b02611002","0","0.48","105552","@37d65746b7218055db9be689075ffc15@

import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class Submit {
    private static Point2D[] points;
    private static int N;

    public static String ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


        /* Drawing */
//        System.out.println(""Drawing..."");
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

        String returnVal = """";
        for(Integer i : ans){
            returnVal+=String.valueOf(i);
//            System.out.print("",""+i);
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@37d65746b7218055db9be689075ffc15@"
"b02611002","0","0.1","108256","@d704c171c79e07a746714360bd3a684f@

import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static String ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


        /* Drawing */
//        System.out.println(""Drawing..."");
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

        String returnVal = """";
        for(Integer i : ans){
            returnVal+=String.valueOf(i);
//            System.out.print("",""+i);
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@d704c171c79e07a746714360bd3a684f@"
"b02611012","0","0.1","108256","@6df33b7511f258c68eea00e6a22912d2@

import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public int[] ConvexHullVertex(Point2D a[]) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
        int N = 10;
        edu.princeton.cs.algs4.StdDraw.setCanvasSize(400, 400);
        edu.princeton.cs.algs4.StdDraw.setXscale(0, 100);
        edu.princeton.cs.algs4.StdDraw.setYscale(0, 100);
        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = edu.princeton.cs.algs4.StdRandom.uniform(100);
            int y = edu.princeton.cs.algs4.StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }
        int min = 0;
        for (int j = 1; j < N; j++) {
            if (points[min].compareTo(points[j]) == +1) {
                min = j;
            }
        }
        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.RED);
        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
        points[min].draw();
        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.BLUE);
        Arrays.sort(points, points[min].polarOrder());
        for (int i = 0; i < N; i++) {
            points[min].drawTo(points[i]);
            edu.princeton.cs.algs4.StdDraw.show(100);
        }

    }


}

@6df33b7511f258c68eea00e6a22912d2@"
"b02611012","0","0.63","110880","@43a3d14982936d367739e37cdb1d5047@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public int[] ConvexHullVertex(Point2D a[]) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
//        int N = 10;
//        edu.princeton.cs.algs4.StdDraw.setCanvasSize(400, 400);
//        edu.princeton.cs.algs4.StdDraw.setXscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setYscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            int y = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//        int min = 0;
//        for (int j = 1; j < N; j++) {
//            if (points[min].compareTo(points[j]) == +1) {
//                min = j;
//            }
//        }
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.RED);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        points[min].draw();
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.BLUE);
//        Arrays.sort(points, points[min].polarOrder());
//        for (int i = 0; i < N; i++) {
//            points[min].drawTo(points[i]);
//            edu.princeton.cs.algs4.StdDraw.show(100);
//        }

    }


}

@43a3d14982936d367739e37cdb1d5047@"
"b02611012","0","0","0","@507db499551ce4b3db1051d67ebea265@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D a[]) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
//        int N = 10;
//        edu.princeton.cs.algs4.StdDraw.setCanvasSize(400, 400);
//        edu.princeton.cs.algs4.StdDraw.setXscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setYscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            int y = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//        int min = 0;
//        for (int j = 1; j < N; j++) {
//            if (points[min].compareTo(points[j]) == +1) {
//                min = j;
//            }
//        }
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.RED);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        points[min].draw();
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.BLUE);
//        Arrays.sort(points, points[min].polarOrder());
//        for (int i = 0; i < N; i++) {
//            points[min].drawTo(points[i]);
//            edu.princeton.cs.algs4.StdDraw.show(100);
//        }

    }


}

@507db499551ce4b3db1051d67ebea265@"
"b02611012","0","0.48","105552","@39d860b3e1e10bb4179d21316eca0c22@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D a[]) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].polarOrder());
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
//        int N = 10;
//        edu.princeton.cs.algs4.StdDraw.setCanvasSize(400, 400);
//        edu.princeton.cs.algs4.StdDraw.setXscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setYscale(0, 100);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            int y = edu.princeton.cs.algs4.StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//        int min = 0;
//        for (int j = 1; j < N; j++) {
//            if (points[min].compareTo(points[j]) == +1) {
//                min = j;
//            }
//        }
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.RED);
//        edu.princeton.cs.algs4.StdDraw.setPenRadius(.005);
//        points[min].draw();
//        edu.princeton.cs.algs4.StdDraw.setPenColor(edu.princeton.cs.algs4.StdDraw.BLUE);
//        
//        for (int i = 0; i < N; i++) {
//            points[min].drawTo(points[i]);
//            edu.princeton.cs.algs4.StdDraw.show(100);
//        }

    }


}

@39d860b3e1e10bb4179d21316eca0c22@"
"b02611002","0","0.48","105552","@8ada7d5705f1d2107c63e368b762952a@
import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}
/

        /* Drawing */
//        System.out.println(""Drawing..."");
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[100];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
            System.out.print("",""+i);
            j++;
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@8ada7d5705f1d2107c63e368b762952a@"
"b02611002","0","0","0","@a86b0437692618994fa1c7d68f55936e@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


        /* Drawing */
//        System.out.println(""Drawing..."");
        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }        StdDraw.setPenColor(StdDraw.RED);
        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[100];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
            System.out.print("",""+i);
            j++;
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@a86b0437692618994fa1c7d68f55936e@"
"b02611002","0","0.56","107632","@8c42f510a0aed7528b2059adb2c431d8@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


//        /* Drawing */
////        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[100];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
            System.out.print("",""+i);
            j++;
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@8c42f510a0aed7528b2059adb2c431d8@"
"b02611002","0","0.55","107840","@31fbea40655c98d390a5bcfc14c60445@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


//        /* Drawing */
////        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[100];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }
//        System.out.println(""returnVal: ""+returnVal);

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@31fbea40655c98d390a5bcfc14c60445@"
"b02611002","0","0.5","107264","@dfe8b8fc15bc7a85c0dc7ee76d26f5ed@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
//        int now = 0;
//        int[] ans = new int[points.length-1];
        Stack<Integer> ans = new Stack<>();

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        for (int i=0;i<N;i++) {
            points[i] = random2DPoint();
            /* 將y座標最小者與points[0]對調 */
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}


//        /* Drawing */
////        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
////            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[ans.size()];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

//        /* 依序描點。最小者(point[0])為紅點 */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//                StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }

    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }

    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@dfe8b8fc15bc7a85c0dc7ee76d26f5ed@"
"b02611002","0","0.53","103952","@7ba2673935f5c305c69f939be789aba3@
import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;
        
//        for (Point2D p:a){System.out.println(""before: ""+p);}
        
        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}
        
        /* Drawing */
//        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[100];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

        //輸出returnVal
//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@7ba2673935f5c305c69f939be789aba3@"
"b02611012","0","0.55","107840","@fd6658eb9d3ee7e1dc19dfb0ce0c2060@

import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param a
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].polarOrder());
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
            System.out.printf(ans[m]+"""");
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
        

    }


}

@fd6658eb9d3ee7e1dc19dfb0ce0c2060@"
"b02611002","0","0.51","103824","@4fb0e40642404acbbfb671afa313f04e@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;

//        for (Point2D p:a){System.out.println(""before: ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}

        /* Drawing */
//        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[ans.size()];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

        //輸出returnVal
//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@4fb0e40642404acbbfb671afa313f04e@"
"r04525016","5","0.102","107872","@160fd554950c8d729efa3edb5e5ae1eb@import java.util.ArrayList;
import java.util.Comparator;

/**
 * Created by cavitation on 2016/4/15.
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point2Ds) {
        ArrayList<Point2D> PG = new ArrayList<>();
        for (int i = 0; i < point2Ds.length; i++) {
            PG.add(point2Ds[i]);
        }


        int minIndex = getMin(point2Ds);
        Point2D min = point2Ds[minIndex];

        Comparator<Point2D> comparator = min.ATAN2_ORDER;
        sort(point2Ds, comparator);

        Stack<Point2D> data = new Stack<Point2D>();
        data.push(point2Ds[0]);
        data.push(point2Ds[1]);

        for (int i = 2; i < point2Ds.length; i++) {
            Point2D b = data.pop();
            Point2D c = data.pop();
            Point2D a = point2Ds[i];

            while (Point2D.ccw(c, b, a) != 1) {
                b = c;
                c = data.pop();
            }
            data.push(c);
            data.push(b);
            data.push(a);
        }


        int[] index = new int[data.size()];
        int count = 0;
        while (!data.isEmpty()) {
            Point2D p = data.pop();
            int i = PG.indexOf(p);
            index[count++] = i;
        }


        int[] index2 = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            index2[i] = index[index.length - 1 - i];
        }


        return index2;
    }


    public static int getMin(Point2D[] a) {
        double min = a[0].y();
        int minIndex = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i].y() < min) {
                min = a[i].y();
                minIndex = i;
            }
        }
        return minIndex;
    }

    public static void sort(Point2D[] array, Comparator<Point2D> c) {
        sort2(array, 0, array.length - 1, c);
    }

    public static void sort2(Point2D[] array, int start, int end, Comparator<Point2D> c) {

        boolean goOn = true;
        int i = start + 1;
        int n = end;

        if (start >= end) return;

        while (goOn) {
            while (c.compare(array[start], array[i]) != -1) {
                if (i == end) break;
                i++;
            }

            while (c.compare(array[start], array[n]) != 1) {
                if (n == start) break;
                n--;
            }


            if (i < n) {
                Point2D temp = array[i];
                array[i] = array[n];
                array[n] = temp;
                goOn = true;
            } else {
                Point2D temp = array[n];
                array[n] = array[start];
                array[start] = temp;
                goOn = false;
            }

        }
        sort2(array, start, n - 1, c);
        sort2(array, n + 1, end, c);
    }
    
}

@160fd554950c8d729efa3edb5e5ae1eb@"
"b02611002","0","0.5","105968","@2fdc7b9e0478d435de980f0b4b0e626f@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;

//        for (Point2D p:a){System.out.println(""before: ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}

//        /* Drawing */
//        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[ans.size()];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

        //輸出returnVal
//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@2fdc7b9e0478d435de980f0b4b0e626f@"
"b02611012","0","0.51","103824","@dbc86e60e3f968b0f243bd24f89a4b30@

import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param a
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].polarOrder());
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
            System.out.printf(ans[m]+"""");
        }
        sort(ans);
        return ans;
    }

    public static void main(String[] args) {
        // TODO code application logic here
        

    }


}
@dbc86e60e3f968b0f243bd24f89a4b30@"
"b02611002","0","0.51","105936","@25fa9af54534b3f420b63e05f2f5d390@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;

//        for (Point2D p:a){System.out.println(""before: ""+p);}

//        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}

//        /* Drawing */
//        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

//        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

//        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[ans.size()];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

        //輸出returnVal
//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        ConvexHullVertex(points);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@25fa9af54534b3f420b63e05f2f5d390@"
"b02611002","0","0.5","104736","@3623d87553685ccfe56fc6ab7cc98a9b@import java.awt.geom.*;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        boolean routing = true;

//        for (Point2D p:a){System.out.println(""before: ""+p);}

//        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""after: ""+p);}

//        /* Drawing */
//        System.out.println(""Drawing..."");
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            System.out.println(""drawing: ""+points[i]);
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }

//        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);

//        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }

        ans.pop();
        ans.pop();

//        String returnVal = """";
        int[] returnVal = new int[ans.size()];
        int j = 0;
        for(Integer i : ans){
//            returnVal+=String.valueOf(i);
            returnVal[j]=i;
//            System.out.print("",""+i);
            j++;
        }

        //輸出returnVal
//        for(Integer k:returnVal){
//            System.out.println(k);
//        }

        return returnVal;
    }

    public static void main(String[] args) {
        
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@3623d87553685ccfe56fc6ab7cc98a9b@"
"b02611002","2","0.5","107536","@b82972d9976b12f76d2ae64011cbdf1a@import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        int[] vertexArr = ConvexHullVertex(points);
        for (Integer i:vertexArr){System.out.println(i);}

//        /* Drawing */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }


        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@b82972d9976b12f76d2ae64011cbdf1a@"
"b02611002","0","0.132","112608","@6eca04c22117216746dba8af4f85b4ac@import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    private static Point2D[] points;
    private static int N;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<N;i++) {
            if(points[i].y()<points[0].y()){
                Point2D temp = points[0];
                points[0] = points[i];
                points[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }

    public static void main(String[] args) {
        N = 10;//Integer.valueOf(args[0]);


        points = random2DPointArr(10);
        int[] vertexArr = ConvexHullVertex(points);
        for (Integer i:vertexArr){System.out.println(i);}

//        /* Drawing */
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i=0;i<N;i++){
//            if(i>0){StdDraw.setPenColor(StdDraw.BLUE);}
//            StdDraw.filledCircle(points[i].x(),points[i].y(),0.01);
//            StdDraw.text(points[i].x(),points[i].y()+0.01,String.valueOf(i));
//        }


        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D [] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}

back return to list
@6eca04c22117216746dba8af4f85b4ac@"
"r04631013","0","0.31","105792","@6f92532e32d07d4a16f5448907f5682d@public class MyConvexHull {

//    public static void main(String[] args) throws Exception {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = 6;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);

            int intx = (int) x;
            x = x * 0.001;
            y = y * 0.001;
            array_y[i] = y;

            a[i] = new Point2D(x, y);
            if (y < yy) {
                yy = y;
                xx = x;
            }
            System.out.printf(""%3.3f "", x);
            System.out.printf(""%3.3f\n"", y);
            StdDraw.filledCircle(x, y, 0.01);
        }

        //sort y value
        Arrays.sort(array_y);
        for (int i = 0; i < N; i++) {
            System.out.printf(""%3.3f\n "", array_y[i]);
        }
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        System.out.printf(""%3.3f\n "", miniy.x());
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
            System.out.printf(""%3.3f\n "", theta[i]);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }

        System.out.printf(""%3.3f\n "", yy);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);
        System.out.printf(""%3.3f\n "", a[0].theta());
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", theta_int[i]);
        }
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", sort_number[i]);
        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<Integer>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
//            System.out.printf(""%d\n "", num_size);
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);
            return con_hull;

        }
        return null;

    }
}
@6f92532e32d07d4a16f5448907f5682d@"
"r04631013","0","0","0","@5778196aaad45404ff0dd36552f87580@import java.util.Arrays;
public class MyConvexHull {

//    public static void main(String[] args) throws Exception {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = 6;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);

            int intx = (int) x;
            x = x * 0.001;
            y = y * 0.001;
            array_y[i] = y;

            a[i] = new Point2D(x, y);
            if (y < yy) {
                yy = y;
                xx = x;
            }
            System.out.printf(""%3.3f "", x);
            System.out.printf(""%3.3f\n"", y);
            StdDraw.filledCircle(x, y, 0.01);
        }

        //sort y value
        Arrays.sort(array_y);
        for (int i = 0; i < N; i++) {
            System.out.printf(""%3.3f\n "", array_y[i]);
        }
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        System.out.printf(""%3.3f\n "", miniy.x());
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
            System.out.printf(""%3.3f\n "", theta[i]);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }

        System.out.printf(""%3.3f\n "", yy);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);
        System.out.printf(""%3.3f\n "", a[0].theta());
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", theta_int[i]);
        }
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", sort_number[i]);
        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<Integer>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
//            System.out.printf(""%d\n "", num_size);
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);
            return con_hull;

        }
        return null;

    }
}
@5778196aaad45404ff0dd36552f87580@"
"r04631013","0","0","0","@b00212fb199375d93bcd588ce3d239fd@import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import java.util.Arrays;
import edu.princeton.cs.algs4.QuickUnionUF;
import edu.princeton.cs.algs4.Stack;
public class MyConvexHull {

//    public static void main(String[] args) throws Exception {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = 6;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);

            int intx = (int) x;
            x = x * 0.001;
            y = y * 0.001;
            array_y[i] = y;

            a[i] = new Point2D(x, y);
            if (y < yy) {
                yy = y;
                xx = x;
            }
            System.out.printf(""%3.3f "", x);
            System.out.printf(""%3.3f\n"", y);
            StdDraw.filledCircle(x, y, 0.01);
        }

        //sort y value
        Arrays.sort(array_y);
        for (int i = 0; i < N; i++) {
            System.out.printf(""%3.3f\n "", array_y[i]);
        }
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        System.out.printf(""%3.3f\n "", miniy.x());
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
            System.out.printf(""%3.3f\n "", theta[i]);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }

        System.out.printf(""%3.3f\n "", yy);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);
        System.out.printf(""%3.3f\n "", a[0].theta());
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", theta_int[i]);
        }
        for (int i = 0; i < N; i++) {
            System.out.printf(""%d\n "", sort_number[i]);
        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<Integer>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
//            System.out.printf(""%d\n "", num_size);
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);
            return con_hull;

        }
        return null;

    }
}

@b00212fb199375d93bcd588ce3d239fd@"
"r04631013","0","0","0","@3508a819fef91afc6b3fe26cd2f67a9a@import java.util.Arrays;

public class MyConvexHull {

    private static int[] con_hull;

//    public static void main(String[] args) throws Exception {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = 6;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);

            x = x * 0.001;
            y = y * 0.001;
            array_y[i] = y;

            a[i] = new Point2D(x, y);
            if (y < yy) {
                yy = y;
                xx = x;
            }
//            System.out.printf(""%3.3f "", x);
//            System.out.printf(""%3.3f\n"", y);
//            StdDraw.filledCircle(x, y, 0.01);
        }

        //sort y value
        Arrays.sort(array_y);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%3.3f\n "", array_y[i]);
//        }
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
//        System.out.printf(""%3.3f\n "", miniy.x());
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
//            System.out.printf(""%3.3f\n "", theta[i]);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }

//        System.out.printf(""%3.3f\n "", yy);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);
//        System.out.printf(""%3.3f\n "", a[0].theta());
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", theta_int[i]);
//        }
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", sort_number[i]);
//        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
//            System.out.printf(""%d\n "", num_size);
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);

        }
        return con_hull;
    }
}

@3508a819fef91afc6b3fe26cd2f67a9a@"
"b03106003","0","0.52","107840","@7d774126244ae6c6b55a88d19e6bb4af@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            return 1;
        }
        else{
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        Arrays.sort(mypoint, new CompareAngle(mypoint[start]));
        
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            r[i] = answer[i].index;
        }
        
        

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        int pr[] = ConvexHullVertex(point);
        for(int i = 1 ; i< pr.length ; i++){
                System.out.print(pr[i] + "" "");
        }

    }
}

@7d774126244ae6c6b55a88d19e6bb4af@"
"b03106003","0","0.52","107632","@622caafca75cb5619ae51ef091c5a4bc@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            return 1;
        }
        else{
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        Arrays.sort(mypoint, new CompareAngle(mypoint[start]));
        
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            r[i] = answer[i].index;
        }
        
        

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        int pr[] = ConvexHullVertex(point);
        for(int i = 1 ; i< pr.length ; i++){
                System.out.print(pr[i] + "" "");
        }

    }
}
@622caafca75cb5619ae51ef091c5a4bc@"
"f02631008","0","0","0","@dfd9ebaf67ef6c65242cc31601431125@
import java.io.*;
import java.util.Scanner;
import java.io.IOException;
import java.util.Arrays;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        _parent[j] = i;
        _rank[j]++;
    }
    public MyConvexHull(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }
    
    
    public static double angle(double x1, double y1, double x2, double y2)
    {
        double dx=x2-x1,dy=y2-y1, PI=(double)Math.PI;
        double angle=0.0;
        
        if(dx==0)
           if(dy==0)angle=0;
           else if(dy>0)angle=PI/2;
           else angle=PI*3/2;
        else if(dy==0)
           if(dx>0)angle=0;
           else angle=PI;
        else if(dx<0)angle=Math.atan(dy/dx)+PI;
        else if(dy<0)angle=Math.atan(dy/dx)+(2*PI);
        else angle=Math.atan(dy/dx);

        return (double)angle*180/PI;
    }
    
    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
//        int[] index = { 1, 2, 3, 4, 5, 6 };
        
        int minAng = 360;
        int lastAng = 0;
        int NxtPt = 0;
        int NxtPt0 = 0;
        int EndPtFlag = 0;
        int ifflag = 0;
        int CX = 0;
        int []index = new int[a.length];
        Point2D[] pts = new Point2D[a.length];
        for(int i = 0; i < a.length; i++){
            pts[i] = a[i];
        }
        
        int ArrNum = a.length;
        
        int minPtsNum = 0; 
        double lastptsy = 1;
        for(int i = 0; i < ArrNum; i++){
            if(pts[i].y() < lastptsy){
               minPtsNum = i; 
            }
            lastptsy = pts[i].y();
        }
        
//        for(int i = 0; i < ArrNum; i++){
        ifflag = 0;
        lastAng = 0;
        NxtPt = 0;
        NxtPt0 = 0;
        if(ifflag == 0){
            NxtPt = minPtsNum;
            while(EndPtFlag == 0){
                double [] AngleArr = new double[ArrNum];
                int [] AngleArrI = new int[ArrNum]; 
                minAng = 360;
//                        System.out.println(NxtPt);
                index[CX] = NxtPt;
                for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
                        AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
                        AngleArrI[j] = (int)AngleArr[j];
                        if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
                            minAng = AngleArrI[j]-lastAng;
                            NxtPt0 = j;
                        }
//                            }
                }
                NxtPt = NxtPt0;
                lastAng = minAng;
//                        System.out.println(NxtPt);
                CX++;

                if(NxtPt == minPtsNum){
                    EndPtFlag = 1;
//                    break;
                }
            }
            ifflag = 1;
        }
        EndPtFlag=0;
//            }
                
        int []index2 = new int[CX];
        for(int i = 0; i < CX; i++){
            index2[i] = index[i];
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return index2;
    }
    
     
    public static void main(String[] args) {
        /*File file = new File(args[0]);
        try{
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            double MinDis = Double.parseDouble(line_1);
//            System.out.println(MinDis);
            
            String line_2 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_2);
//            System.out.println(ArrNum);
            
            int Ai = 0;
            Point2D[] pts = new Point2D[ArrNum];
            
            while (File_in.hasNextLine())
            {
                String line_3 = File_in.nextLine();
                String[] GivePoint = line_3.split("" "");
                double Px = Double.parseDouble(GivePoint[0]);
                double Py = Double.parseDouble(GivePoint[1]);
                
                pts[Ai] = new Point2D(Px ,Py);
                Ai++;
            }
//            System.out.println(pts[3].x());
//            System.out.println(Points[3][1]);
            double Distance = 0.0;
            MyConvexHull uf = new MyConvexHull(ArrNum);
            //Distance = Math.sqrt(Math.pow(Points[0][0]-Points[1][0],2)+Math.pow(Points[0][1]-Points[1][1],2));
//            System.out.println(Distance);
                      
            
            for(int i = 0; i < ArrNum; i++){
                for(int j = 0; j < ArrNum; j++){
                    if(i != j ){
//                        StdDraw.setPenRadius(0.01);
//                        StdDraw.setPenColor(StdDraw.BLACK);
//                        StdDraw.point(pts[i].x(), pts[i].y());
//                        StdDraw.point(pts[j].x(), pts[j].y());
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.text(pts[i].x()+0.02, pts[i].y(),  Integer.toString(i));
                        
                        Distance = Math.sqrt(Math.pow(pts[i].x()-pts[j].x(),2)+Math.pow(pts[i].y()-pts[j].y(),2));

                        if(Distance <= MinDis){
                            //System.out.println(Distance);
//                            StdDraw.setPenRadius(0.001);
//                            StdDraw.setPenColor(StdDraw.GREEN);
//                            StdDraw.line(pts[i].x(), pts[i].y(), pts[j].x(), pts[j].y());
                            
                            if(pts[i].y() < pts[j].y()){
                                uf.union(i,j);
                            }
                            else{
                                uf.union(j,i);
                            }
                        }
                    }
                }
            }
//            System.out.println(uf);
            

            
            
            int[] RedArr = new int[ArrNum];
            for(int i = 0; i < ArrNum; i++){
                RedArr[i] = -1;
            }
            
            int RedFlag = 0;
            for(int i = 0; i < ArrNum; i++){
                int ParCount = 0;
                for(int j = 0; j < ArrNum; j++){
                    if(uf._parent[j] == i){
                        ParCount++;  
                        if(ParCount >= 3){
                            if(RedFlag == 0){
                                RedArr[i] = i;
                                RedFlag = 1;
                            }
                            uf._rank[i] = ParCount;
//                            StdDraw.setPenColor(StdDraw.RED);
//                            StdDraw.point(pts[i].x(), pts[i].y());
//                            System.out.println(i);
                        }
                    }
                }
                RedFlag = 0;
            }
//            System.out.println(uf);
//            System.out.println(RedArr[3]);
            
//            int CCnum = 0;
//            for(int i = 0; i < ArrNum; i++){
//                if(RedArr[i] != -1){
//                    CCnum++;
//                }
//            }
//            System.out.println(CCnum);
            
            
            
            int ArrSiz = 0;
            int[] NewArr = new int[ArrNum];
            
            
            for(int i = 0; i < ArrNum-6; i++){
                int Pt2count = 0;
                if(RedArr[i] != -1){
                    Point2D[] pts2 = new Point2D[uf._rank[i]];
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            pts2[Pt2count] = pts[j];
                            Pt2count++;
                        }
                    }
//                    System.out.println(ConvexHullVertex(pts2));
                    NewArr = ConvexHullVertex(pts2);
                    
//                    System.out.println(NumArr[j]);
                }
            }
            
            for(int i = 0; i < NewArr.length; i++){
                System.out.println(NewArr[i]);
            }
            
            
//            System.out.println(uf);
//            double [] AngleArr = new double[ArrNum];
//            int [] AngleArrI = new int[ArrNum]; 
//            int minAng = 360;
//            int lastAng = 0;
//            int NxtPt = 0;
//            int NxtPt0 = 0;
//            int EndPtFlag = 0;
//            int ifflag = 0;
//            int CX = 0;
            
//            for(int i = 0; i < ArrNum; i++){
//                ifflag = 0;
//                lastAng = 0;
//                NxtPt = 0;
//                NxtPt0 = 0;
//                if(RedArr[i] != -1 && ifflag == 0){
//                    NxtPt = RedArr[i];
//                    while(EndPtFlag == 0){
//                        double [] AngleArr = new double[ArrNum];
//                        int [] AngleArrI = new int[ArrNum]; 
//                        minAng = 360;
////                        System.out.println(NxtPt);
//                        for(int j = 0; j < ArrNum; j++){
//                            if(uf._parent[j] == RedArr[i]){
//                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
//                                AngleArrI[j] = (int)AngleArr[j];
//                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
//                                    minAng = AngleArrI[j]-lastAng;
//                                    NxtPt0 = j;
//                                }
//                            }
//                        }
//                        NxtPt = NxtPt0;
//                        lastAng = minAng;
////                        System.out.println(NxtPt);
//                        CX++;
//                        
//                        if(NxtPt == RedArr[i]){
//                            EndPtFlag = 1;
//                            break;
//                        }
//                    }
//                    ifflag = 1;
//                }
//                EndPtFlag=0;
//            }

            
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }*/
        // TODO code application logic here
    }
    
}

@dfd9ebaf67ef6c65242cc31601431125@"
"b02611002","5","0.104","105952","@824b6fb9ac45005dfe7354f4dfe95739@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;


/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
//    public static int N;
//    public static double d;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
        int n = a.length;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<n;i++) {
            if(a[i].y()<a[0].y()){
                Point2D temp = a[0];
                a[0] = a[i];
                a[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }


    public static void main(String[] args) throws Exception {


        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            /* 讀檔，幾十個點讀入points */
            double d = Double.valueOf(br.readLine());  //d
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Point2D[] points = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                points[count] =  new Point2D(x,y);;
                count++;
            }

            for (Point2D p:points){System.out.println(""p(brfore): ""+p);} //print(x,y)(before)

            /* points重新排序，並輸出vertex */
//            System.out.println(ConvexHullVertex(points));

//            for (Point2D p:points){System.out.println(""p(after): ""+p);} //print(x,y)(after)

        /* Drawing */
            StdDraw.setPenColor(StdDraw.RED);
            for (int i = 0; i < N; i++) {
                if (i > 0) {
                    StdDraw.setPenColor(StdDraw.BLUE);
                }
                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
            }

//        /* random 2Dpoints testing */
//            N = 10;
//            points = random2DPointArr(10);
//            int[] vertexArr = ConvexHullVertex(points);
//            for (Integer i : vertexArr) {
//                System.out.println(i);
//            }
//
//        /* Drawing */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

            // 1. read in the file containing N 2-dimentional points
            // 2. create an edge for each pair of points with a distance <= d
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D[] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@824b6fb9ac45005dfe7354f4dfe95739@"
"b03106003","0","0.41","107904","@3b37cc6607ad92a4071859a1a55a6c3f@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 1;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        int pr[] = ConvexHullVertex(point);
        for(int i = 1 ; i< pr.length ; i++){
                System.out.print(pr[i]+ "" "");
                System.out.print(point[pr[i]] + "" "");
                
        }

    }
}

@3b37cc6607ad92a4071859a1a55a6c3f@"
"b03106003","0","0.52","103808","@abb66d54a518f430715dfb5050f28fa7@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        int pr[] = ConvexHullVertex(point);
        for(int i = 1 ; i< pr.length ; i++){
                System.out.print(pr[i]+ "" "");
                System.out.print(point[pr[i]] + "" "");
                
        }

    }
}

@abb66d54a518f430715dfb5050f28fa7@"
"b03106003","5","0.104","107936","@5d8f9f4f35ba61e273c08674eeb407d6@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            //System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        for(int i = 0; i<m ;i++){
            //System.out.println(r[i]);
        }

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        int pr[] = ConvexHullVertex(point);
        for(int i = 0 ; i< pr.length ; i++){
                //System.out.print(pr[i]+ "" "");
                //System.out.print(point[pr[i]] + "" "");
                
        }

    }
}

@5d8f9f4f35ba61e273c08674eeb407d6@"
"r04631013","0","0","0","@1c5b3ebd46657676e5147d4b59a6a00e@import java.util.Arrays;
public class MyConvexHull {

    private static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

       
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);

        }
        return con_hull;
    }
}
@1c5b3ebd46657676e5147d4b59a6a00e@"
"r04945009","5","0.104","105936","@0e245a2c9dccccca621671c03edd982c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author hung-wei
 */
public class MyConvexHull {
    
    public static Point2D[] Go(Point2D[] points, Stack S) {
        int N = S.size();
        Point2D[] GO = new Point2D[N];
        for (int i = 0; i < N; i++) {
            GO[i] = points[(int)S.pop()];
        }
        return GO;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int length = 0;
        for (Point2D i : a) {
            length++;
        }
        //copy the origin array
        Point2D[] Origin = new Point2D[length];
        System.arraycopy(a, 0, Origin, 0, length);
        
        //find the y minimun
        Arrays.sort(a, Point2D.Y_ORDER);
        
        //Sort points by polar angle
        Arrays.sort(a, a[0].POLAR_ORDER);
        //Consider points in order; discard unless it create a ccw turn.
        Stack Vertice = new Stack();
        Vertice.push(0); Vertice.push(1); Vertice.push(2);
        int A,B;
        for (int i = 3; i<length; i++) {
            B = (int)Vertice.pop(); A = (int)Vertice.pop();
            if (Point2D.ccw(a[A],a[B],a[i]) == 1) {
                Vertice.push(A); Vertice.push(B); 
                Vertice.push(i);
            }
            else if (Point2D.ccw(a[A],a[B],a[i]) == -1) {
                Vertice.push(A);
                i--;
            }        
        }
        
        int[] ans = new int[Vertice.size()];
        int f;
        int VerSize = Vertice.size();
        for (int i = 0; i<VerSize; i++) {
            f = (int)Vertice.pop();
            for (int j = 0; j<length; j++) {
                if (a[f].equals(Origin[j]))
                    ans[i] = j;
            }
        }
        Arrays.sort(ans);
        return ans;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            
            Point2D[] points = new Point2D[N];
            
            for (int i = 0; i < N; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[i] = new Point2D(x, y);
//                points[i].draw();
            }
            
            QuickFindUF CC = new QuickFindUF(N);
            for (int i = 0; i < N-1; i++) {
                for (int j = i; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= d)
                        CC.union(i, j);
                }
            }
            
            int[] Array = new int[N];
            for (int i = 0; i < N; i++) {
                Array[i] = CC.find(i);
            }
            
            int[] CopyArray = new int[N];
            System.arraycopy(Array, 0, CopyArray, 0, N);
            Arrays.sort(CopyArray);
            
            int ans = 0;
            Stack S = new Stack();
            for (int i = 0; i < N; i++) {
                if(Array[i] == CopyArray[0]) {
                    S.push(i);
                }
            }
            
            ans += ConvexHullVertex(Go(points, S)).length;
//            S = null;
            
            for (int k = 0; k < N-1; k++) {
                if(CopyArray[k+1] != CopyArray[k]) {
                    for (int i = 0; i < N; i++) {
                        if(Array[i] == CopyArray[k+1]) {
                            S.push(i);
                        }
                    }
                    if (S.size() >= 3)
                        ans += ConvexHullVertex(Go(points, S)).length;
                }
            }
            
            System.out.println(ans);
            
        }
        
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it


            
    

    } 
}

@0e245a2c9dccccca621671c03edd982c@"
"r04631013","0","0.104","105936","@8649a35b5347ff611520057a8026231e@import java.util.Arrays;
public class MyConvexHull {

    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

       
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);

        }
        return con_hull;
    }
}

back return to list
@8649a35b5347ff611520057a8026231e@"
"r04631013","0","0.1","107728","@3ebeddb0d6eea31a32eaa67073d06ef8@import java.util.Arrays;
public class MyConvexHull {

    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

       
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);

        }
        return con_hull;
    }
}

back return to list
@3ebeddb0d6eea31a32eaa67073d06ef8@"
"r04631013","0","0.09","104448","@9e070dbcd6cf80004c448260110b27ba@import java.util.Arrays;
public class MyConvexHull {

    private static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;

        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

       
        Arrays.sort(array_y);
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();
        if (sort_number.length >= 3) {
            need.push(sort_number[0]);

            int aa = sort_number[0];
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
            need.push(sort_number[N - 1]);
            int num_size = need.size();
            int con_hull[] = new int[num_size];
            for (int i = 0; i < num_size; i++) {
                con_hull[i] = need.pop();
            }
            Arrays.sort(con_hull);

        }
        return con_hull;
    }
}

back return to list
@9e070dbcd6cf80004c448260110b27ba@"
"r04631013","0","0.49","107696","@64b1007893c0f2856075aa52165e8089@
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.StdDraw;
import java.util.Arrays;
import edu.princeton.cs.algs4.QuickUnionUF;
import edu.princeton.cs.algs4.Stack;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
        for (int i = 0; i < N; i++) {
//            System.out.printf(""%3.3f "", a[i].x());
//            System.out.printf(""%3.3f\n"", a[i].y());
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);
        int qqq[] = new int[1];
        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform(1000);
//            double y = StdRandom.uniform(1000);
//
//            x = x * 0.001;
//            y = y * 0.001;
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
        for (int i = 0; i < num_size; i++) {
            System.out.printf(""%d\n "", con_hull[i]);
        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);
//        System.out.printf(""%d\n "", ans[0]);

    }

}
@64b1007893c0f2856075aa52165e8089@"
"r04631013","0","0","0","@2dfc24254a998cff7788d2d683a8eab2@import java.util.Arrays;
public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
        for (int i = 0; i < N; i++) {
//            System.out.printf(""%3.3f "", a[i].x());
//            System.out.printf(""%3.3f\n"", a[i].y());
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);
        int qqq[] = new int[1];
        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform(1000);
//            double y = StdRandom.uniform(1000);
//
//            x = x * 0.001;
//            y = y * 0.001;
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
        for (int i = 0; i < num_size; i++) {
            System.out.printf(""%d\n "", con_hull[i]);
        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);
//        System.out.printf(""%d\n "", ans[0]);

    }

}
@2dfc24254a998cff7788d2d683a8eab2@"
"r04631013","3","0.52","106352","@8b22f438f14df66b96f015a37e70d9d6@import java.util.Arrays;
public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
//        for (int i = 0; i < N; i++) {
////            System.out.printf(""%3.3f "", a[i].x());
////            System.out.printf(""%3.3f\n"", a[i].y());
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);
        int qqq[] = new int[1];
        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform(1000);
//            double y = StdRandom.uniform(1000);
//
//            x = x * 0.001;
//            y = y * 0.001;
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
//        for (int i = 0; i < num_size; i++) {
//            System.out.printf(""%d\n "", con_hull[i]);
//        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);
//        System.out.printf(""%d\n "", ans[0]);

    }

}
@8b22f438f14df66b96f015a37e70d9d6@"
"r04631013","3","0.5","107904","@2a2db19e13bd9ab75e4b6c21cca10b43@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (theta[i] * 1000);
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}
@2a2db19e13bd9ab75e4b6c21cca10b43@"
"b02611012","0","0","0","@16313cbe2fbf42d8df965c398516146c@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int ans[] = null;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m++] = i;
            System.out.printf(ans[m]+"""");
        }
        sort(ans);
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        int N = 10;
        StdDraw.setXscale(0, 100);
        StdDraw.setYscale(0, 100);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            int x = StdRandom.uniform(100);
            int y = StdRandom.uniform(100);
            points[i] = new Point2D(x, y);
            points[i].draw();
        }

        
    }
    
}

@16313cbe2fbf42d8df965c398516146c@"
"b02611012","0","0.52","107424","@509afcf25cf052bb1f0ad432fc00a763@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        sort(ans);
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        
        
    }
    
}

@509afcf25cf052bb1f0ad432fc00a763@"
"b02611012","0","0.52","107888","@32b243c5f91c794c68cfe2a0e0ae329d@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        sort(ans);
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        
        
    }
    
}

@32b243c5f91c794c68cfe2a0e0ae329d@"
"b02611012","0","0.52","107424","@62bd6164d650fd4d29847fcefbe07624@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        
    
}

@62bd6164d650fd4d29847fcefbe07624@"
"b02611012","0","0.49","106560","@2070e9e11600f929dddffab6bb480e09@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                min = j;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        

        
    }
    
}

@2070e9e11600f929dddffab6bb480e09@"
"r04921044","2","0.8","117744","@991b46807faa444c1ca162f0cdc8de9d@
import java.util.ArrayList;
import java.util.Stack;
import java.util.Collections;

public class MyConvexHull {

    private class PointWrapper {
        public PointWrapper(Point2D p, int i) {
            point = p;
            index = i;
        }

        public void description() {
            System.out.println(""index: "" + index + "", theta: "" + theta);
        }

        public double angleTo(Point2D that) {
            double dx = that.x() - point.x();
            double dy = that.y() - point.y();
            return Math.atan2(dy, dx);
        }

        public Point2D point;
        public int index;
        public double theta;
    }

    public static int[] ConvexHullVertex(Point2D[] list) {
        ArrayList<PointWrapper> points = new ArrayList<> ();
        for (int i=0; i<list.length; ++i) {
            MyConvexHull fuckingJAVAsyntax = new MyConvexHull();
            MyConvexHull.PointWrapper point = fuckingJAVAsyntax.new PointWrapper(list[i], i);
            points.add(point);
        }

        // find min
        PointWrapper minYPoint = points.get(0);
        for (int i=0; i<points.size(); ++i) {
            double pointY = points.get(i).point.y();
            if (pointY < minYPoint.point.y()) {
                minYPoint = points.get(i);
            }
        }

        // compute theta
        for (int i=0; i<points.size(); ++i) {
            points.get(i).theta = minYPoint.angleTo(points.get(i).point);
        }

        // sort with theta
        Collections.sort(points, (o1, o2) -> Double.valueOf(o1.theta).compareTo(Double.valueOf(o2.theta)));

        // get convex hull indices
        Stack<Integer> resultPoint = new Stack<> ();
        resultPoint.push(points.get(0).index);
        resultPoint.push(points.get(1).index);
        Point2D lineStartPoint = points.get(0).point;
        Point2D lineEndPoint = points.get(1).point;
        for (int i=2; i<points.size(); ++i) {
            PointWrapper pointWrapper = points.get(i);
            int ccw = Point2D.ccw(lineStartPoint, lineEndPoint, pointWrapper.point);
            if (ccw == 1) { // counter-clock-wise
                lineStartPoint = lineEndPoint;
                lineEndPoint = pointWrapper.point;
                resultPoint.push(pointWrapper.index);
            }
            else if (ccw == -1) { // clock-wise
                lineEndPoint = pointWrapper.point;
                resultPoint.pop();
                resultPoint.push(pointWrapper.index);
            }
        }

        // return original indices
        int result[] = new int[resultPoint.size()];
        int i = 0;
        for(Integer index : resultPoint) {
            result[i++] = index;
        }
        return result;
    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        Point2D[] points = {
            new Point2D(1.f, 1.f),
            new Point2D(-1.f, 3.f),
            new Point2D(0.f, 0.f),
            new Point2D(1.f, 3.f),
            new Point2D(-1.f, 1.f)
        };

        MyConvexHull.ConvexHullVertex(points);
    }
}

@991b46807faa444c1ca162f0cdc8de9d@"
"b02611012","0","0.53","105264","@f3849bda924458ad8c40bb2046bae971@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
        for (int i = 0; i < m; i++) {
            System.out.printf("""" + b[i]);
        }
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        

        
    }
    
}

@f3849bda924458ad8c40bb2046bae971@"
"b02611012","0","0.53","105584","@96e1078f4dd9b5bc14f4724f1bd12ae8@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
//        for (int i = 0; i < m; i++) {
//            System.out.printf("""" + b[i]);
//        }
        return ans;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        

        
    }
    
}

@96e1078f4dd9b5bc14f4724f1bd12ae8@"
"b02611012","0","0.49","107776","@f3027fffebf8afdd53cd17022ee5917d@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
//        for (int i = 0; i < m; i++) {
//            System.out.printf("""" + b[i]);
//        }
        return b;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        
        
    }
    
}

@f3027fffebf8afdd53cd17022ee5917d@"
"b02611012","0","0.51","107088","@6f608e831bed8c906076dcb1cbf0c034@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[min].POLAR_ORDER);
        int m = 0;      // m 為凸包頂點數目
        int[] ans = new int[a.length] ;
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(a[ans[m - 2]], a[ans[m - 1]], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            ans[m] = i;
            m++;
            
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
//        for (int i = 0; i < m; i++) {
//            System.out.printf("""" + b[i]);
//        }
        return b;
    }
    public static void main(String[] args) {
        // TODO code application logic here
//        int N = 10;
//        StdDraw.setXscale(0, 100);
//        StdDraw.setYscale(0, 100);
//        StdDraw.setPenRadius(.005);
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            int x = StdRandom.uniform(100);
//            int y = StdRandom.uniform(100);
//            points[i] = new Point2D(x, y);
//            points[i].draw();
//        }
//        MyConvexHull.ConvexHullVertex(points);

        
    }
    
}

@6f608e831bed8c906076dcb1cbf0c034@"
"r04631013","3","0.5","107936","@e28003d14b84980defb21b703513f988@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N >= 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
       }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}
@e28003d14b84980defb21b703513f988@"
"r04631013","0","0.48","107776","@397764d4ed2c42757a54982d9b721338@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N >= 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1 && != 0) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
       }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}
@397764d4ed2c42757a54982d9b721338@"
"b02611026","0","0.104","107568","@364eeb6b95da5ad9e78fe9e023decf0b@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static class Point2D {

        public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();

        private final double x;
        private final double y;

        public Point2D(double x, double y) {
            this.x = x;
            this.y = y;
        }

        public static int ccw(Point2D a, Point2D b, Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        private class PolarOrder implements Comparator<Point2D> {

            public int compare(Point2D q1, Point2D q2) {
                double dy1 = q1.y - y;
                double dy2 = q2.y - y;

                int state = 0;

                if (dy1 == 0 && dy2 == 0) {
                } else if (dy1 >= 0 && dy2 < 0) {
                    state = -1;
                } else if (dy2 <= 0 && dy1 < 0) {
                    state = +1;
                } else {
                    state = -ccw(Point2D.this, q1, q2);
                }
                return state;
            }
        }

    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        int length = a.length;
        Point2D[] newindex = new Point2D[length];
        Point2D[] sortedindex = new Point2D[length];
        int[] convex_index = new int[length];

        //copy
        for (int i = 0; i < length; i++) {
            double newindex_x = a[i].x;
            double newindex_y = a[i].y;
            newindex[i] = new Point2D(newindex_x, newindex_y);
        }

        //find the min_y and its index is min_index
        double min_y = newindex[0].y;
        int min_index = 0;
        for (int i = 0; i < length; i++) {
            if (newindex[i].y < min_y) {
                min_y = newindex[i].y;
                min_index = i;
            }
        }

        sortedindex[0] = newindex[0];
        newindex[0] = newindex[min_index];
        newindex[min_index] = sortedindex[0];

//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(newindex[0].x, newindex[0].y, 0.01);

        Arrays.sort(newindex, newindex[0].POLAR_ORDER);
//        for (int i = 0; i < length; i++) {
//            System.out.print(i + "":"");
//            System.out.println(newindex[i].x + newindex[i].y);
//            StdDraw.text(newindex[i].x, newindex[i].y + 0.03, Integer.toString(i));
//        }

        int j = 0;
        int first = 0;
        int middle = 1;
        int last = 2;
        int state = 0;
        while (true) {
//            System.out.print(""first middle last進入判斷"");
//            System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.println("" "" + last);
//                System.out.println("" -------- "");
            if (last > 9) {
                break;
            }
            int clockwise = Point2D.ccw(newindex[first], newindex[middle], newindex[last]);
            if (clockwise == -1) {          //clockwise                
                middle = first;
                first = convex_index[j-1];
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter順時針應變："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" -1"");
            } else if (clockwise == 1) {    //counter-clockwise                
                convex_index[j] = first;
                convex_index[j + 1] = middle;
                convex_index[j + 2] = last;

                first = middle;
                middle = last;
                last = last + 1;

                state++; 
//                System.out.print(""convex_index：逆時針應變  "");
//                System.out.print(j + ""： "");
//                System.out.print(convex_index[j]);
//                //System.out.print(j+1 + ""： "");        
//                System.out.print("" "" + convex_index[j+1]);
//                //System.out.print(j+2 + ""： "");
//                System.out.println("" "" + convex_index[j+2]);
//                System.out.print(""first middle last / conter"");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 1"");
                
               
                
            } else if (clockwise == 0) {     //collinear
                middle = first;
                first = first - 1;
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 0"");
            }
            if (state >= 1) {
                j++;
            } else {
                j--;
            }

        }
        //convex_index[9] = 0;
//        System.out.println(""   "");
////        
//        System.out.println("" "");
//        for (int i = 0; i < j+2; i++) {
//            System.out.println(convex_index[i]);
//        }
//        System.out.println(""-------------------------------"");
        int[] ans = new int[j+2];
        for(int i = 0 ; i < j+2 ; i++){
            for(int k = 0 ; k < 10 ; k++){
                if(newindex[convex_index[i]].x == a[k].x && newindex[convex_index[i]].y == a[k].y)
                    ans[i] = k;
            }
        }
        for (int i = 0; i < j+2; i++) {
            System.out.print(ans[i] + "" "");
        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return ans;
    }

    public static void main(String[] args) {
        StdDraw.setCanvasSize(500, 500);
        //StdDraw.clear(StdDraw.WHITE);
        int N = 10;
        Point2D[] A = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a, b);
            StdDraw.filledCircle(A[i].x, A[i].y, 0.01);
            StdDraw.text(a, b - 0.03, Integer.toString(i));
        }

        for (int i = 0; i < N; i++) {
            System.out.println(A[i].x + A[i].y);
        }
        System.out.println("" "");
        int[] ans = ConvexHullVertex(A);
        //System.out.println(ans[0] + 1);
        //ans[0] = ConvexHullVertex(A);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    }
}

@364eeb6b95da5ad9e78fe9e023decf0b@"
"r04921044","2","0.76","117360","@aa9236516e0e0c811a572720695d209b@
import java.util.ArrayList;
import java.util.Collections;

public class MyConvexHull {

    private class PointWrapper {
        public PointWrapper(Point2D p, int i) {
            point = p;
            index = i;
        }

        public void description() {
            System.out.println(""index: "" + index + "", theta: "" + theta);
        }

        public double angleTo(Point2D that) {
            double dx = that.x() - point.x();
            double dy = that.y() - point.y();
            return Math.atan2(dy, dx);
        }

        public Point2D point;
        public int index;
        public double theta;
    }

    public static int[] ConvexHullVertex(Point2D[] list) {
        ArrayList<PointWrapper> points = new ArrayList<> ();
        for (int i=0; i<list.length; ++i) {
            MyConvexHull fuckingJAVAsyntax = new MyConvexHull();
            MyConvexHull.PointWrapper point = fuckingJAVAsyntax.new PointWrapper(list[i], i);
            points.add(point);
        }

        // find min
        PointWrapper minYPoint = points.get(0);
        for (int i=0; i<points.size(); ++i) {
            double pointY = points.get(i).point.y();
            if (pointY < minYPoint.point.y()) {
                minYPoint = points.get(i);
            }
        }

        // compute theta
        for (int i=0; i<points.size(); ++i) {
            points.get(i).theta = minYPoint.angleTo(points.get(i).point);
        }

        // sort with theta
        Collections.sort(points, (o1, o2) -> Double.valueOf(o1.theta).compareTo(Double.valueOf(o2.theta)));

        // get convex hull indices
        ArrayList<PointWrapper> resultPoint = new ArrayList<> ();
        resultPoint.add(points.get(0));
        resultPoint.add(points.get(1));
        Point2D lineStartPoint = points.get(0).point;
        Point2D lineEndPoint = points.get(1).point;
        for (int i=2; i<points.size(); ++i) {
            PointWrapper pointWrapper = points.get(i);
            int ccw = Point2D.ccw(lineStartPoint, lineEndPoint, pointWrapper.point);

            while (ccw == -1) { // clock-wise
                resultPoint.remove(resultPoint.size() - 1);
                lineEndPoint = lineStartPoint;
                lineStartPoint = resultPoint.get(resultPoint.size() - 1).point;

                ccw = Point2D.ccw(lineStartPoint, lineEndPoint, pointWrapper.point);
            }

            lineStartPoint = lineEndPoint;
            lineEndPoint = pointWrapper.point;
            resultPoint.add(pointWrapper);
        }

        // return original indices
        int result[] = new int[resultPoint.size()];
        int i = 0;
        for(PointWrapper wrapper : resultPoint) {
            result[i++] = wrapper.index;
        }
        return result;
    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        Point2D[] points = {
            new Point2D(0.200, 0.250),
            new Point2D(0.147, 0.387),
            new Point2D(0.300, 0.300),
            new Point2D(0.333, 0.213),
            new Point2D(0.353, 0.412),
            new Point2D(0.700, 0.890),
            new Point2D(0.879, 0.700),
            new Point2D(0.867, 0.888),
            new Point2D(0.980, 0.120),
            new Point2D(0.111, 0.932)
        };

        int result[] = MyConvexHull.ConvexHullVertex(points);

        for (int i : result) {
            System.out.println(i);
        }

        // StdDraw.init();
        for (Point2D point : points) {
            StdDraw.point(point.x(), point.y());
        }
    }
}

@aa9236516e0e0c811a572720695d209b@"
"r04921044","5","0.154","117424","@173918e40caa387eb5e7c3424d714ebc@
import java.util.ArrayList;
import java.util.Collections;

public class MyConvexHull {

    private class PointWrapper {
        public PointWrapper(Point2D p, int i) {
            point = p;
            index = i;
        }

        public void description() {
            System.out.println(""index: "" + index + "", theta: "" + theta);
        }

        public double angleTo(Point2D that) {
            double dx = that.x() - point.x();
            double dy = that.y() - point.y();
            return Math.atan2(dy, dx);
        }

        public Point2D point;
        public int index;
        public double theta;
    }

    public static int[] ConvexHullVertex(Point2D[] list) {
        ArrayList<PointWrapper> points = new ArrayList<> ();
        for (int i=0; i<list.length; ++i) {
            MyConvexHull fuckingJAVAsyntax = new MyConvexHull();
            MyConvexHull.PointWrapper point = fuckingJAVAsyntax.new PointWrapper(list[i], i);
            points.add(point);
        }

        // find min
        PointWrapper minYPoint = points.get(0);
        for (int i=0; i<points.size(); ++i) {
            double pointY = points.get(i).point.y();
            if (pointY < minYPoint.point.y()) {
                minYPoint = points.get(i);
            }
        }

        // compute theta
        for (int i=0; i<points.size(); ++i) {
            points.get(i).theta = minYPoint.angleTo(points.get(i).point);
        }

        // sort with theta
        Collections.sort(points, (o1, o2) -> Double.valueOf(o1.theta).compareTo(Double.valueOf(o2.theta)));

        // get convex hull indices
        ArrayList<PointWrapper> resultPoint = new ArrayList<> ();
        resultPoint.add(points.get(0));
        resultPoint.add(points.get(1));
        Point2D lineStartPoint = points.get(0).point;
        Point2D lineEndPoint = points.get(1).point;
        for (int i=2; i<points.size(); ++i) {
            PointWrapper pointWrapper = points.get(i);

            while (Point2D.ccw(lineStartPoint, lineEndPoint, pointWrapper.point) == -1) { // clock-wise
                resultPoint.remove(resultPoint.size() - 1);
                lineEndPoint = lineStartPoint;
                lineStartPoint = resultPoint.get(resultPoint.size() - 2).point;
            }

            lineStartPoint = lineEndPoint;
            lineEndPoint = pointWrapper.point;
            resultPoint.add(pointWrapper);
        }

        // return original indices
        int result[] = new int[resultPoint.size()];
        int i = 0;
        for(PointWrapper wrapper : resultPoint) {
            result[i++] = wrapper.index;
        }
        return result;
    }

    public static void main(String[] args) {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        Point2D[] points = {
            new Point2D(0.200, 0.250),
            new Point2D(0.147, 0.387),
            new Point2D(0.300, 0.300),
            new Point2D(0.333, 0.213),
            new Point2D(0.353, 0.412),
            new Point2D(0.700, 0.890),
            new Point2D(0.879, 0.700),
            new Point2D(0.867, 0.888),
            new Point2D(0.980, 0.120),
            new Point2D(0.111, 0.932)
        };

        int result[] = MyConvexHull.ConvexHullVertex(points);

        for (int i : result) {
            System.out.println(i);
        }

        // StdDraw.init();
        for (Point2D point : points) {
            StdDraw.point(point.x(), point.y());
        }
    }
}

@173918e40caa387eb5e7c3424d714ebc@"
"b02611026","1","0.29","106928","@7275f04cddea05b1e2c76df4790f1f1e@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

//    public static class Point2D {
//
//        public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();
//
//        private final double x;
//        private final double y;
//
//        public Point2D(double x, double y) {
//            this.x = x;
//            this.y = y;
//        }
//
//        public static int ccw(Point2D a, Point2D b, Point2D c) {
//            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
//            if (area2 < 0) {
//                return -1;
//            } else if (area2 > 0) {
//                return +1;
//            } else {
//                return 0;
//            }
//        }
//
//        private class PolarOrder implements Comparator<Point2D> {
//
//            public int compare(Point2D q1, Point2D q2) {
//                double dy1 = q1.y - y;
//                double dy2 = q2.y - y;
//
//                int state = 0;
//
//                if (dy1 == 0 && dy2 == 0) {
//                } else if (dy1 >= 0 && dy2 < 0) {
//                    state = -1;
//                } else if (dy2 <= 0 && dy1 < 0) {
//                    state = +1;
//                } else {
//                    state = -ccw(Point2D.this, q1, q2);
//                }
//                return state;
//            }
//        }
//        
//
//    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        int length = a.length;
        Point2D[] newindex = new Point2D[length];
        Point2D[] sortedindex = new Point2D[length];
        int[] convex_index = new int[length];

        //copy
        for (int i = 0; i < length; i++) {
            double newindex_x = a[i].x();
            double newindex_y = a[i].y();
            newindex[i] = new Point2D(newindex_x, newindex_y);
        }

        //find the min_y and its index is min_index
        double min_y = newindex[0].y();
        int min_index = 0;
        for (int i = 0; i < length; i++) {
            if (newindex[i].y() < min_y) {
                min_y = newindex[i].y();
                min_index = i;
            }
        }

        sortedindex[0] = newindex[0];
        newindex[0] = newindex[min_index];
        newindex[min_index] = sortedindex[0];

//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(newindex[0].x, newindex[0].y, 0.01);

        Arrays.sort(newindex, newindex[0].POLAR_ORDER);
//        for (int i = 0; i < length; i++) {
//            System.out.print(i + "":"");
//            System.out.println(newindex[i].x + newindex[i].y);
//            StdDraw.text(newindex[i].x, newindex[i].y + 0.03, Integer.toString(i));
//        }

        int j = 0;
        int first = 0;
        int middle = 1;
        int last = 2;
        int state = 0;
        while (true) {
//            System.out.print(""first middle last進入判斷"");
//            System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.println("" "" + last);
//                System.out.println("" -------- "");
            if (last > 9) {
                break;
            }
            int clockwise = Point2D.ccw(newindex[first], newindex[middle], newindex[last]);
            if (clockwise == -1) {          //clockwise                
                middle = first;
                first = convex_index[j-1];
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter順時針應變："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" -1"");
            } else if (clockwise == 1) {    //counter-clockwise                
                convex_index[j] = first;
                convex_index[j + 1] = middle;
                convex_index[j + 2] = last;

                first = middle;
                middle = last;
                last = last + 1;

                state++; 
//                System.out.print(""convex_index：逆時針應變  "");
//                System.out.print(j + ""： "");
//                System.out.print(convex_index[j]);
//                //System.out.print(j+1 + ""： "");        
//                System.out.print("" "" + convex_index[j+1]);
//                //System.out.print(j+2 + ""： "");
//                System.out.println("" "" + convex_index[j+2]);
//                System.out.print(""first middle last / conter"");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 1"");
                
               
                
            } else if (clockwise == 0) {     //collinear
                middle = first;
                first = first - 1;
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 0"");
            }
            if (state >= 1) {
                j++;
            } else {
                j--;
            }

        }
        //convex_index[9] = 0;
//        System.out.println(""   "");
////        
//        System.out.println("" "");
//        for (int i = 0; i < j+2; i++) {
//            System.out.println(convex_index[i]);
//        }
//        System.out.println(""-------------------------------"");
        int[] ans = new int[j+2];
        for(int i = 0 ; i < j+2 ; i++){
            for(int k = 0 ; k < 10 ; k++){
                if(newindex[convex_index[i]].x() == a[k].x() && newindex[convex_index[i]].y() == a[k].y())
                    ans[i] = k;
            }
        }
//        for (int i = 0; i < j+2; i++) {
//            System.out.print(ans[i] + "" "");
//        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return ans;
    }

    public static void main(String[] args) {
//        StdDraw.setCanvasSize(500, 500);
        //StdDraw.clear(StdDraw.WHITE);
        int N = 10;
        Point2D[] A = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a, b);
//            StdDraw.filledCircle(A[i].x(), A[i].y(), 0.01);
//            StdDraw.text(a, b - 0.03, Integer.toString(i));
        }

//        for (int i = 0; i < N; i++) {
//            System.out.println(A[i].x() + A[i].y());
//        }
//        System.out.println("" "");
        int[] ans = ConvexHullVertex(A);
        //System.out.println(ans[0] + 1);
        //ans[0] = ConvexHullVertex(A);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    }
}

@7275f04cddea05b1e2c76df4790f1f1e@"
"b02611026","5","0.1","107344","@4e845416e05fc628f31eeb6247dea824@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

//    public static class Point2D {
//
//        public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();
//
//        private final double x;
//        private final double y;
//
//        public Point2D(double x, double y) {
//            this.x = x;
//            this.y = y;
//        }
//
//        public static int ccw(Point2D a, Point2D b, Point2D c) {
//            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
//            if (area2 < 0) {
//                return -1;
//            } else if (area2 > 0) {
//                return +1;
//            } else {
//                return 0;
//            }
//        }
//
//        private class PolarOrder implements Comparator<Point2D> {
//
//            public int compare(Point2D q1, Point2D q2) {
//                double dy1 = q1.y - y;
//                double dy2 = q2.y - y;
//
//                int state = 0;
//
//                if (dy1 == 0 && dy2 == 0) {
//                } else if (dy1 >= 0 && dy2 < 0) {
//                    state = -1;
//                } else if (dy2 <= 0 && dy1 < 0) {
//                    state = +1;
//                } else {
//                    state = -ccw(Point2D.this, q1, q2);
//                }
//                return state;
//            }
//        }
//        
//
//    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        int length = a.length;
        Point2D[] newindex = new Point2D[length];
        Point2D[] sortedindex = new Point2D[length];
        int[] convex_index = new int[length];

        //copy
        for (int i = 0; i < length; i++) {
            double newindex_x = a[i].x();
            double newindex_y = a[i].y();
            newindex[i] = new Point2D(newindex_x, newindex_y);
        }

        //find the min_y and its index is min_index
        double min_y = newindex[0].y();
        int min_index = 0;
        for (int i = 0; i < length; i++) {
            if (newindex[i].y() < min_y) {
                min_y = newindex[i].y();
                min_index = i;
            }
        }

        sortedindex[0] = newindex[0];
        newindex[0] = newindex[min_index];
        newindex[min_index] = sortedindex[0];

//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(newindex[0].x, newindex[0].y, 0.01);

        Arrays.sort(newindex, newindex[0].POLAR_ORDER);
//        for (int i = 0; i < length; i++) {
//            System.out.print(i + "":"");
//            System.out.println(newindex[i].x + newindex[i].y);
//            StdDraw.text(newindex[i].x, newindex[i].y + 0.03, Integer.toString(i));
//        }

        int j = 0;
        int first = 0;
        int middle = 1;
        int last = 2;
        int state = 0;
        while (true) {
//            System.out.print(""first middle last進入判斷"");
//            System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.println("" "" + last);
//                System.out.println("" -------- "");
            if (last > (length - 1)) {
                break;
            }
            int clockwise = Point2D.ccw(newindex[first], newindex[middle], newindex[last]);
            if (clockwise == -1) {          //clockwise                
                middle = first;
                first = convex_index[j-1];
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter順時針應變："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" -1"");
            } else if (clockwise == 1) {    //counter-clockwise                
                convex_index[j] = first;
                convex_index[j + 1] = middle;
                convex_index[j + 2] = last;

                first = middle;
                middle = last;
                last = last + 1;

                state++; 
//                System.out.print(""convex_index：逆時針應變  "");
//                System.out.print(j + ""： "");
//                System.out.print(convex_index[j]);
//                //System.out.print(j+1 + ""： "");        
//                System.out.print("" "" + convex_index[j+1]);
//                //System.out.print(j+2 + ""： "");
//                System.out.println("" "" + convex_index[j+2]);
//                System.out.print(""first middle last / conter"");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 1"");
                
               
                
            } else if (clockwise == 0) {     //collinear
                middle = first;
                first = first - 1;
                last = last;
                state = 0;
                
//                System.out.print(""first middle last / conter："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 0"");
            }
            if (state >= 1) {
                j++;
            } else {
                j--;
            }

        }
        //convex_index[9] = 0;
//        System.out.println(""   "");
////        
//        System.out.println("" "");
//        for (int i = 0; i < j+2; i++) {
//            System.out.println(convex_index[i]);
//        }
//        System.out.println(""-------------------------------"");
        int[] ans = new int[j+2];
        for(int i = 0 ; i < j+2 ; i++){
            for(int k = 0 ; k < length ; k++){
                if(newindex[convex_index[i]].x() == a[k].x() && newindex[convex_index[i]].y() == a[k].y())
                    ans[i] = k;
            }
        }
//        for (int i = 0; i < j+2; i++) {
//            System.out.print(ans[i] + "" "");
//        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return ans;
    }

    public static void main(String[] args) {
//        StdDraw.setCanvasSize(500, 500);
        //StdDraw.clear(StdDraw.WHITE);
        int N = 10;
        Point2D[] A = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double a = StdRandom.uniform();
            double b = StdRandom.uniform();
            A[i] = new Point2D(a, b);
//            StdDraw.filledCircle(A[i].x(), A[i].y(), 0.01);
//            StdDraw.text(a, b - 0.03, Integer.toString(i));
        }

//        for (int i = 0; i < N; i++) {
//            System.out.println(A[i].x() + A[i].y());
//        }
//        System.out.println("" "");
        int[] ans = ConvexHullVertex(A);
        //System.out.println(ans[0] + 1);
        //ans[0] = ConvexHullVertex(A);

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    }
}

@4e845416e05fc628f31eeb6247dea824@"
"b02611012","0","0.5","105936","@9932d88671278cf37d00276a793afd20@
import java.util.Arrays;
import static java.util.Arrays.sort;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D[] a) {
        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);
        
        
       
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            
            an[m] = a[i];
            ans[m] = i;
            m++;
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        sort(b);
        
        
        
        return b;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        

        
    }
    
}

@9932d88671278cf37d00276a793afd20@"
"r04631006","3","0.4","103552","@cdeac1a64936774bd66c55457cfd4b40@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];
// find the min y of points 
        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }
// find the angle of points to p   
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }
//find the numder of points befor sort 
        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }
//find convexhull
        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) != 1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
//find the orginal of convexhull       
        int lorder[] = new int[m];
        for (int i = 0; i < m; i++) {
            lorder[i] = fir_order[i];
        }
//        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {
}
}
@cdeac1a64936774bd66c55457cfd4b40@"
"b02611012","5","0.098","107840","@0ae538a44c78d186caac99daef582c7f@
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }

        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0,0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);
        
        
        Stack<Integer> vals = new Stack<Integer>();
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點
            
            an[m] = a[i];
            ans[m] = i;
            m++;
        }
        
        int[] b = new int[m] ;
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
         for (int i = 0; i < m; i++) {
            b[i] = map.get(a[ans[i]]);
        }
        sort(b);
        
        
        
        
        return b;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        }
    
}

@0ae538a44c78d186caac99daef582c7f@"
"r03525006","0","0","0","@1244b758c2165ce40cd8502c11ab073a@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;


        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a, p.ATAN2_ORDER);

        int[] sortIndex = new int[10];
        int[] isConvex = new int[9];
        for (int i = 1; i < 10; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < 10; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = 10;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == 8)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
//                System.out.println(j+"" /j"");
//                System.out.println(index+"" /index"");
            }

//            System.out.println(ccwArray[0]+""/""+ccwArray[1]+""/""+ccwArray[2]);

            int temp = Point2D.ccw(a[ccwArray[0]], a[ccwArray[1]], a[ccwArray[2]]);
            if (temp == 1) {
                index++;
//                System.out.println(""ha"");
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
//                    System.out.println(""hi"");
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        StdDraw.setPenColor(StdDraw.GREEN);
        for (int i = 0; i < 9; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                a[isConvex[i]].draw();
                ansCount--;
            }
        }
        return ans;
    }


    public static void main(String[] args) {


    }

}

@1244b758c2165ce40cd8502c11ab073a@"
"r04631027","3","0.29","110032","@6e914021c64e21c9280d7731f875c646@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         Point2D[] b = new Point2D[a.length] ;
         for(int i = 0 ; i < a.length ; i++){
             b[i] = a[i];
         }
         int[] c = new int [a.length] ;
         int count = 0 ;
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         for(int i = 0 ; i < a.length ; i++){
             if (orig.x()==b[i].x()&&orig.y()==b[i].y()){
                 c[0] =i ;
                 //System.out.println(i) ;
                 break ;
             }
         }
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         for(int i = 0 ; i < a.length ; i++){
             if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[1] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
                 
             }
         }
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  for(int i = 0 ; i < a.length ; i++){
                  if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[convexhullvertex] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
             }
         }
                  convexhullvertex ++ ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2+""here"") ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y() ;
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         //System.out.println(temp2.x()+"",""+temp2.y());
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         for(int l = 0 ; l < a.length ; l++){
                     if (temp2.x()==b[l].x()&&temp2.y()==b[l].y()){
                 c[convexhullvertex] =l ;
                 //System.out.println(l+""+""+convexhullvertex) ;
                 break ;
             }
         }
                         convexhullvertex ++;
                         
              break;       
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         int[] gg = new int[convexhullvertex] ;
         for(int i = 0 ; i < convexhullvertex ; i++){
             gg[i]=c[i] ;
         }
         for(int i = 0 ; i < convexhullvertex ; i++){
             //System.out.print(gg[i]);
         }
         return gg ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        ConvexHullVertex(points) ;
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    //final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        //  System.out.print(final_number) ;
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        }
        catch(IOException e){
            System.out.println(""error!"");
        }
        // TODO code application logic here
    }
    
}

@6e914021c64e21c9280d7731f875c646@"
"r04631027","3","0.3","106128","@8146974beb5b569b9575c67f2937c03f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         Point2D[] b = new Point2D[a.length] ;
         for(int i = 0 ; i < a.length ; i++){
             b[i] = a[i];
         }
         int[] c = new int [a.length] ;
         int count = 0 ;
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
       //  System.out.println(a[i].x());
       //  System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         for(int i = 0 ; i < a.length ; i++){
             if (orig.x()==b[i].x()&&orig.y()==b[i].y()){
                 c[0] =i ;
                 //System.out.println(i) ;
                 break ;
             }
         }
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         for(int i = 0 ; i < a.length ; i++){
             if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[1] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
                 
             }
         }
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  for(int i = 0 ; i < a.length ; i++){
                  if (temp2.x()==b[i].x()&&temp2.y()==b[i].y()){
                 c[convexhullvertex] =i ;
                 //System.out.println(i+""+""+convexhullvertex) ;
                 break ;
             }
         }
                  convexhullvertex ++ ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2+""here"") ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y() ;
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         //System.out.println(temp2.x()+"",""+temp2.y());
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         for(int l = 0 ; l < a.length ; l++){
                     if (temp2.x()==b[l].x()&&temp2.y()==b[l].y()){
                 c[convexhullvertex] =l ;
                 //System.out.println(l+""+""+convexhullvertex) ;
                 break ;
             }
         }
                         convexhullvertex ++;
                         
              break;       
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         int[] gg = new int[convexhullvertex] ;
         for(int i = 0 ; i < convexhullvertex ; i++){
             gg[i]=c[i] ;
         }
         for(int i = 0 ; i < convexhullvertex ; i++){
             //System.out.print(gg[i]);
         }
         return gg ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        ConvexHullVertex(points) ;
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    //final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        //  System.out.print(final_number) ;
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        }
        catch(IOException e){
            System.out.println(""error!"");
        }
        // TODO code application logic here
    }
    
}

@8146974beb5b569b9575c67f2937c03f@"
"r03525006","0","0","0","@3e9c7ff2a57afd7f1a405d74dad1f2a3@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;


        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
//                System.out.println(j+"" /j"");
//                System.out.println(index+"" /index"");
            }

//            System.out.println(ccwArray[0]+""/""+ccwArray[1]+""/""+ccwArray[2]);

            int temp = Point2D.ccw(a[ccwArray[0]], a[ccwArray[1]], a[ccwArray[2]]);
            if (temp == 1) {
                index++;
//                System.out.println(""ha"");
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
//                    System.out.println(""hi"");
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        StdDraw.setPenColor(StdDraw.GREEN);
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                a[isConvex[i]].draw();
                ansCount--;
            }
        }
        return ans;
    }


    public static void main(String[] args) {


    }

}

@3e9c7ff2a57afd7f1a405d74dad1f2a3@"
"r04228027","0","0.098","107840","@67b1a4c212d38b404a86c8a76afb656b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
// import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@67b1a4c212d38b404a86c8a76afb656b@"
"r04921074","0","0","0","@7e1b29b71ef4c1d9394def7e08075950@
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class MyConvexHull {
     public static int[] ConvexHullVertex(Point2D[] a) {
         
         int N = a.length;
         int min = 0;
         Double[] degree = new Double [N];
         Double minX = a[0].x();
         Double minY = a[0].y();
         Stack<Integer> cnxpoint = new Stack<Integer>(); 
         //************************* find min ********************************\\
         int[] orderlist = new int[N+1];
         for(int i=0; i<N; i++){
             orderlist[i]=i;
             if(a[i].y()<minY){
                 minX = a[i].x();
                 minY = a[i].y();
                 min = i;
             }             
         }
         int temp;  Double tempX,tempY;
        //************************** degree stuff*****************************\\
         for(int i=0; i<N; i++){
               degree[i]=Math.toDegrees(Math.atan2(a[i].y()-minY,a[i].x()-minX));
         }
        //***********************  sorting  **********************************\\
        
        for(int i=1; i<a.length; i++){
            Double tempD = degree[i];
            int    tempO = orderlist[i];
            int j=0;
                for( j=i-1; j>=0 && tempD < degree[j]; j--){
                    orderlist[j+1] = orderlist[j];
                    degree[j+1]    = degree [j];
                }               
            degree[j+1] = tempD;
            orderlist[j+1] = tempO;
        }
        orderlist[N]=orderlist[0];
        //*********************** ccw link ***********************************\\
         
           int CNXcount = 0;
           while(CNXcount<=N){ 
                   // System.out.println(convexpoint.size());
                    if(cnxpoint.size()<3){ cnxpoint.push(orderlist[CNXcount]); CNXcount++;}
                    if(cnxpoint.size()>=3){
                        
                        int p3=cnxpoint.pop();
                        int p2=cnxpoint.pop();
                        int p1=cnxpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           cnxpoint.push(p1); 
                           cnxpoint.push(p2);
                           cnxpoint.push(p3);
                           
                           cnxpoint.push(orderlist[CNXcount]);
                           CNXcount++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           cnxpoint.push(p1);
                           cnxpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = cnxpoint.size()-2;
            int convexsize =  cnxpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = cnxpoint.pop();
            
            while(cnxpoint.size()!=0){
                index[counter] = cnxpoint.pop();
                counter--;
            }
        //************************ show dots**********************************\\
        for(int i=0; i<N; i++){
             //  System.out.print(a[i].x()+""\t"");
             //  System.out.print(a[i].y()+""\t"");
               System.out.println(degree[i]);
         }
        for(int i=0; i<N+1; i++){
               System.out.print(orderlist[i]);
         }        
        //----------------------------data------------------------------------\\
                
         for(int i=0; i<N; i++){
            if(i==min){
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(a[i].x(),a[i].y());                
            }
            else{
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.point(a[i].x(),a[i].y());
            }
        }
        //--------------------------------------------------------------------\\
        return index;
      }
    
/*   public static void main(String[] args) throws IOException{
       
       Scanner scanner = new Scanner(System.in); 
       System.out.println(""How many random dot you want?"");
       int N = scanner.nextInt();
       System.out.printf(""Processing......""+""\n    creating %d dot\n"",N);
       
              
       Point2D[] dotdata = new Point2D [N]; //create dot data [dot order][two axis num// x: ,y: //]
       Point2D[] b = new Point2D [N];
       
       
       for(int i=0; i<N; i++){
           
                dotdata[i] =new Point2D(StdRandom.random(),StdRandom.random());
                System.out.println(dotdata[i].x()+""\t""+dotdata[i].y());
                           
       }
      // ConvexHullVertex(dotdata);
             


    }*/
    
}

@7e1b29b71ef4c1d9394def7e08075950@"
"r04631013","3","0.51","107920","@026cd0240db6f37aa652a8401754bc41@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

           array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.001;
                a[i] = new Point2D(x_, y_);

            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N >= 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
       }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}
@026cd0240db6f37aa652a8401754bc41@"
"r04945022","0","0.098","107840","@ea1f12449e3be44be011be92a8c15d88@
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    quickSort(s, first.atan2Order());
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)>0){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           break;
       }
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@ea1f12449e3be44be011be92a8c15d88@"
"r04921074","5","0.102","107600","@c62be2c54b80047391d400889d82fd15@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class MyConvexHull {
     public static int[] ConvexHullVertex(Point2D[] a) {
         
         int N = a.length;
         int min = 0;
         Double[] degree = new Double [N];
         Double minX = a[0].x();
         Double minY = a[0].y();
         Stack<Integer> cnxpoint = new Stack<Integer>(); 
         //************************* find min ********************************\\
         int[] orderlist = new int[N+1];
         for(int i=0; i<N; i++){
             orderlist[i]=i;
             if(a[i].y()<minY){
                 minX = a[i].x();
                 minY = a[i].y();
                 min = i;
             }             
         }
         int temp;  Double tempX,tempY;
        //************************** degree stuff*****************************\\
         for(int i=0; i<N; i++){
               degree[i]=Math.toDegrees(Math.atan2(a[i].y()-minY,a[i].x()-minX));
         }
        //***********************  sorting  **********************************\\
        
        for(int i=1; i<a.length; i++){
            Double tempD = degree[i];
            int    tempO = orderlist[i];
            int j=0;
                for( j=i-1; j>=0 && tempD < degree[j]; j--){
                    orderlist[j+1] = orderlist[j];
                    degree[j+1]    = degree [j];
                }               
            degree[j+1] = tempD;
            orderlist[j+1] = tempO;
        }
        orderlist[N]=orderlist[0];
        //*********************** ccw link ***********************************\\
         
           int CNXcount = 0;
           while(CNXcount<=N){ 
                   // System.out.println(convexpoint.size());
                    if(cnxpoint.size()<3){ cnxpoint.push(orderlist[CNXcount]); CNXcount++;}
                    if(cnxpoint.size()>=3){
                        
                        int p3=cnxpoint.pop();
                        int p2=cnxpoint.pop();
                        int p1=cnxpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           cnxpoint.push(p1); 
                           cnxpoint.push(p2);
                           cnxpoint.push(p3);
                           
                           cnxpoint.push(orderlist[CNXcount]);
                           CNXcount++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           cnxpoint.push(p1);
                           cnxpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = cnxpoint.size()-2;
            int convexsize =  cnxpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = cnxpoint.pop();
            
            while(cnxpoint.size()!=0){
                index[counter] = cnxpoint.pop();
                counter--;
            }
        //************************ show dots**********************************\\
  /*      for(int i=0; i<N; i++){
             //  System.out.print(a[i].x()+""\t"");
             //  System.out.print(a[i].y()+""\t"");
               System.out.println(degree[i]);
         }
        for(int i=0; i<N+1; i++){
               System.out.print(orderlist[i]);
         }        
        //----------------------------data------------------------------------\\
                
         for(int i=0; i<N; i++){
            if(i==min){
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(a[i].x(),a[i].y());                
            }
            else{
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.point(a[i].x(),a[i].y());
            }
        }*/
        //--------------------------------------------------------------------\\
        return index;
      }
    
  /* public static void main(String[] args) throws IOException{
       
       Scanner scanner = new Scanner(System.in); 
       System.out.println(""How many random dot you want?"");
       int N = scanner.nextInt();
       System.out.printf(""Processing......""+""\n    creating %d dot\n"",N);
       
              
       Point2D[] dotdata = new Point2D [N]; //create dot data [dot order][two axis num// x: ,y: //]
       Point2D[] b = new Point2D [N];
       
       
       for(int i=0; i<N; i++){
           
                dotdata[i] =new Point2D(StdRandom.random(),StdRandom.random());
                System.out.println(dotdata[i].x()+""\t""+dotdata[i].y());
                           
       }
      // ConvexHullVertex(dotdata);
             


    }*/
    
    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
//                double x = Double.valueOf(buf2[0]);
//                double y = Double.valueOf(buf2[1]);
                //===============================
                double x = StdRandom.uniform(0.01,0.99);
                double y = StdRandom.uniform(0.01,0.99);
                //===============================
                points[count] = new Point2D(x, y);
                count++;
                //===============================
                StdDraw.setPenRadius(0.01);
                StdDraw.setPenColor(StdDraw.BLUE);
                StdDraw.point(x,y);
                //===============================
            }
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.GREEN);
            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                         StdDraw.setPenRadius(0.001);
                         StdDraw.setPenColor(StdDraw.BLUE);
                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=leadcccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}

@c62be2c54b80047391d400889d82fd15@"
"r04921074","5","0.102","107936","@3d1873ecf0f4e03e76e9d22513beae3e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class MyConvexHull {
     public static int[] ConvexHullVertex(Point2D[] a) {
         
         int N = a.length;
         int min = 0;
         Double[] degree = new Double [N];
         Double minX = a[0].x();
         Double minY = a[0].y();
         Stack<Integer> cnxpoint = new Stack<Integer>(); 
         //************************* find min ********************************\\
         int[] orderlist = new int[N+1];
         for(int i=0; i<N; i++){
             orderlist[i]=i;
             if(a[i].y()<minY){
                 minX = a[i].x();
                 minY = a[i].y();
                 min = i;
             }             
         }
         int temp;  Double tempX,tempY;
        //************************** degree stuff*****************************\\
         for(int i=0; i<N; i++){
               degree[i]=Math.toDegrees(Math.atan2(a[i].y()-minY,a[i].x()-minX));
         }
        //***********************  sorting  **********************************\\
        
        for(int i=1; i<a.length; i++){
            Double tempD = degree[i];
            int    tempO = orderlist[i];
            int j=0;
                for( j=i-1; j>=0 && tempD < degree[j]; j--){
                    orderlist[j+1] = orderlist[j];
                    degree[j+1]    = degree [j];
                }               
            degree[j+1] = tempD;
            orderlist[j+1] = tempO;
        }
        orderlist[N]=orderlist[0];
        //*********************** ccw link ***********************************\\
         
           int CNXcount = 0;
           while(CNXcount<=N){ 
                   // System.out.println(convexpoint.size());
                    if(cnxpoint.size()<3){ cnxpoint.push(orderlist[CNXcount]); CNXcount++;}
                    if(cnxpoint.size()>=3){
                        
                        int p3=cnxpoint.pop();
                        int p2=cnxpoint.pop();
                        int p1=cnxpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           cnxpoint.push(p1); 
                           cnxpoint.push(p2);
                           cnxpoint.push(p3);
                           
                           cnxpoint.push(orderlist[CNXcount]);
                           CNXcount++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           cnxpoint.push(p1);
                           cnxpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = cnxpoint.size()-2;
            int convexsize =  cnxpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = cnxpoint.pop();
            
            while(cnxpoint.size()!=0){
                index[counter] = cnxpoint.pop();
                counter--;
            }
        //************************ show dots**********************************\\
  /*      for(int i=0; i<N; i++){
             //  System.out.print(a[i].x()+""\t"");
             //  System.out.print(a[i].y()+""\t"");
               System.out.println(degree[i]);
         }
        for(int i=0; i<N+1; i++){
               System.out.print(orderlist[i]);
         }        
        //----------------------------data------------------------------------\\
                
         for(int i=0; i<N; i++){
            if(i==min){
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(a[i].x(),a[i].y());                
            }
            else{
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.point(a[i].x(),a[i].y());
            }
        }*/
        //--------------------------------------------------------------------\\
        return index;
      }
    
   public static void main(String[] args) throws IOException{
       
       Scanner scanner = new Scanner(System.in); 
       System.out.println(""How many random dot you want?"");
       int N = scanner.nextInt();
       System.out.printf(""Processing......""+""\n    creating %d dot\n"",N);
       
              
       Point2D[] dotdata = new Point2D [N]; //create dot data [dot order][two axis num// x: ,y: //]
       Point2D[] b = new Point2D [N];
       
       
       for(int i=0; i<N; i++){
           
                dotdata[i] =new Point2D(StdRandom.random(),StdRandom.random());
                System.out.println(dotdata[i].x()+""\t""+dotdata[i].y());
                           
       }
      // ConvexHullVertex(dotdata);
    }
}
    
  
@3d1873ecf0f4e03e76e9d22513beae3e@"
"b01705003","0","0.102","107936","@d6f0e8324110adadbc41149141b8927a@public class MyConvexHull {
    public static void main(String[] args) {
        System.out.println(""7"");
    }
}
@d6f0e8324110adadbc41149141b8927a@"
"r03525006","0","0","0","@2b3b3e2356bdd915a43b6e8c37360078@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        double rand1,rand2;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++) {
            rand1 = StdRandom.uniform();
            rand2 = StdRandom.uniform();
//            System.out.println((int)(rand1*1000)/1000.0 + "" / "" + (int)(rand2*1000)/1000.0);
            a[i] = new Point2D(rand1,rand2);
            a2[i] = new Point2D(rand1,rand2);
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
//                System.out.println(j+"" /j"");
//                System.out.println(index+"" /index"");
            }

//            System.out.println(ccwArray[0]+""/""+ccwArray[1]+""/""+ccwArray[2]);

            int temp = Point2D.ccw(a2[ccwArray[0]], a2[ccwArray[1]], a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
//                System.out.println(""ha"");
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
//                    System.out.println(""hi"");
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        StdDraw.setPenColor(StdDraw.GREEN);
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                a2[isConvex[i]].draw();
                ansCount--;
            }
        }
        return ans;
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

        }
    }
}

@2b3b3e2356bdd915a43b6e8c37360078@"
"b01705003","0","0.102","107936","@59ba7f00e7247d16e7aa75b1cd69b6cc@
public class MyConvexHull {

    public static void main(String[] args) {
        System.out.println(""7"");
    }

}
@59ba7f00e7247d16e7aa75b1cd69b6cc@"
"b01705003","0","0.102","107600","@07a07083fb4c247b03c98d0d3ee27e75@public class ConvexHullVertex{
    public static void main(String[] args) {
        System.out.println(""12"");
    }
}

@07a07083fb4c247b03c98d0d3ee27e75@"
"b01705003","0","0.102","107600","@59ba7f00e7247d16e7aa75b1cd69b6cc@
public class MyConvexHull {

    public static void main(String[] args) {
        System.out.println(""7"");
    }

}
@59ba7f00e7247d16e7aa75b1cd69b6cc@"
"r04631023","0","0.42","107904","@6aa1f073a222449339e9dbe40f7858ba@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
            System.out.println(angle[i]) ;
        }
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int x = convexHull.pop() ;
            StdDraw.filledCircle(a[x].x(), a[x].y(), 0.01) ;
        }
        */
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}
@6aa1f073a222449339e9dbe40f7858ba@"
"r03525006","0","0","0","@de7fc50594af6e2d08eb06dfbcd9de6c@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        double rand1,rand2;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]], a2[ccwArray[1]], a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                a2[isConvex[i]].draw();
                ansCount--;
            }
        }
        return ans;
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

        }
    }
}

@de7fc50594af6e2d08eb06dfbcd9de6c@"
"r04631006","2","0.49","107824","@3f013d54112a1840933d528d36e427fc@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];
// find the min y of points 
        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zeroaa = i;
                mmaa = a[i].y();
            }
            if (a[i].x() < mmbb) {
                zerobb = i;
                mmbb = a[i].x();
            }
        }
        if (a[zerobb].y() == a[zeroaa].y()) {
            if (a[zerobb].x() >= a[zeroaa].y()) {
                zero = zeroaa;
            } else {
                zero = zerobb;
            }
        }

// find the angle of points to p   
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }
//find the numder of points befor sort 
        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }
//find convexhull
        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) != 1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
//find the orginal of convexhull       
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }
 public static void main(String[] args) throws Exception {
}
}
@3f013d54112a1840933d528d36e427fc@"
"r04631023","4","0.41","107616","@f996c5da2c18af33e297cf65e8fe91fb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int x = convexHull.pop() ;
            StdDraw.filledCircle(a[x].x(), a[x].y(), 0.01) ;
        }
        */
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}

@f996c5da2c18af33e297cf65e8fe91fb@"
"r04945022","0","0.21","107888","@e198d02ccd71bcf20d7c053b93f2457a@
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)>0){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(f[i].y() < f[miniy].y()){
             miniy = i;
         }
         else if(f[i].y()==f[miniy].y() && f[i].x()<f[miniy].x()){
             miniy = i;
         }
     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           break;
       }
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@e198d02ccd71bcf20d7c053b93f2457a@"
"r04631006","2","0.49","107888","@54a909a74121bcec9a72a37c03bfea23@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];
// find the min y of points 
        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zeroaa = i;
                mmaa = a[i].y();
            }
            if (a[i].x() < mmbb) {
                zerobb = i;
                mmbb = a[i].x();
            }
        }
        if (a[zerobb].y() == a[zeroaa].y()) {
            if (a[zerobb].x() >= a[zeroaa].y()) {
                zero = zeroaa;
            } else {
                zero = zerobb;
            }
        }

// find the angle of points to p   
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }
//find the numder of points befor sort 
        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }
//find convexhull
        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
//find the orginal of convexhull       
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {
}
}
@54a909a74121bcec9a72a37c03bfea23@"
"r04631006","4","0.5","104480","@71083067b4aa6e20eb20717597d8bf33@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }


  
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
     
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {
}
}
@71083067b4aa6e20eb20717597d8bf33@"
"r04945022","0","0.38","107696","@46cb93ed07adf7e9e40db793c5cf1e41@import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)!=1){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }
     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
       }
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@46cb93ed07adf7e9e40db793c5cf1e41@"
"r03525006","0","0","0","@7e1dac4574e5efeedf35133392bcbd35@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                a2[isConvex[i]].draw();
                ansCount--;
            }
        }
        return ans;
    }
}

@7e1dac4574e5efeedf35133392bcbd35@"
"r04945022","0","0.21","105088","@3c38a8c97f8425fde27aa5cc7466524d@import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)!=1){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }

     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           if(left>=right) break;
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           
       }
       
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@3c38a8c97f8425fde27aa5cc7466524d@"
"r04631013","3","0.51","106016","@25c6b70ca51f4362ee7cad025fb28f14@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

           array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);

            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N >= 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
       }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}

@25c6b70ca51f4362ee7cad025fb28f14@"
"r04522616","0","0.66","111008","@dbb8048cb877e0eac034613bc1b24bd8@
import com.sun.corba.se.impl.io.ValueHandlerImpl;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=a.clone();
        
        
        Arrays.sort(a);//找出y最小的點為point[0]
        
        //Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序(POLAR_ORDER)
        }        
        
        s.push(a[0]); 
        //A.push(0);
        s.push(a[1]); 
        //A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            //int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                //temp = A.pop();
            }
            s.push(top); 
            //A.push(temp);
            s.push(a[i]); 
            //A.push(i);
        }
        
        int n = s.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int k=0;
        for(int i=0;i<n;i++)
        {
            c[i]=s.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[k]=j;
                    k++;                    
                }
            }            
        }
        
        Arrays.sort(CHPoint);
        
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }

        return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);                
            }
            //MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
            //Stack<Point2D> label = new Stack<Point2D>();
            int[] label=new int[numOfPoint];
            for(int i=0;i<numOfPoint;i++)
            {
                label[i]=-1;
            }
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
                    {
                        wQUF.union(i, j);//一小群CC                             
                    }                    
                }             
                
            }
            int k=0;
            int groupCount=0;
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(wQUF.connected(i, j))
                    {
                        if(label[i]==-1&&label[j]==-1)
                        {
                            label[i]=k;
                            label[j]=k;
                            k++;
                            groupCount++;
                        }
                        else if(label[i]!=-1&&label[j]==-1)
                        {
                            label[j]=label[i];
                        }
                        else if(label[i]==-1&&label[j]!=-1)
                        {
                            label[i]=label[j];
                        }
                        
                    }
                    
                }
            }
            
            int pointCount=0;
            int L=0;
            //int count=0;
            while(L<=groupCount)
            {
                int numOfGroupPoint=0;
                for(int j=0;j<numOfPoint;j++)
                {
                    if(label[j]==L)
                    {
                        numOfGroupPoint++;
                    }
                }
                Point2D[] pointXYa=new Point2D[numOfGroupPoint];
                int cnt = 0;
                for(int i=0;i<numOfPoint;i++)
                {
                    
                    if(label[i]==L)
                    {
                        pointXYa[cnt]=pointXY[i];
                        cnt++;
                        
                    }                  
                }
                if(pointXYa.length>=3)
                {
                    pointCount+=MyConvexHull.ConvexHullVertex(pointXYa);
                }
                L++;
            }
            System.out.printf(String.valueOf(pointCount));
           
            
           
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@dbb8048cb877e0eac034613bc1b24bd8@"
"r04945022","0","0.64","110976","@9b3c06da651d3ec12d5233d0309ce012@import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Stack;


/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    quickSort(s, first.atan2Order());
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)!=1){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }

     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           if(left>=right) break;
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           
       }
       
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
    
}

@9b3c06da651d3ec12d5233d0309ce012@"
"r04522616","3","0.33","109680","@0ba65172ba96747d1028d69aaef9c450@
import com.sun.corba.se.impl.io.ValueHandlerImpl;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=a.clone();
        
        
        Arrays.sort(a);//找出y最小的點為point[0]
        
        //Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序(POLAR_ORDER)
        }        
        
        s.push(a[0]); 
        //A.push(0);
        s.push(a[1]); 
        //A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            //int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                //temp = A.pop();
            }
            s.push(top); 
            //A.push(temp);
            s.push(a[i]); 
            //A.push(i);
        }
        
        int n = s.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int k=0;
        for(int i=0;i<n;i++)
        {
            c[i]=s.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[k]=j;
                    k++;                    
                }
            }            
        }
        
        Arrays.sort(CHPoint);
        
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }

        return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);                
            }
            //MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
            //Stack<Point2D> label = new Stack<Point2D>();
            int[] label=new int[numOfPoint];
            for(int i=0;i<numOfPoint;i++)
            {
                label[i]=-1;
            }
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
                    {
                        wQUF.union(i, j);//一小群CC                             
                    }                    
                }             
                
            }
            int k=0;
            int groupCount=0;
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(wQUF.connected(i, j))
                    {
                        if(label[i]==-1&&label[j]==-1)
                        {
                            label[i]=k;
                            label[j]=k;
                            k++;
                            groupCount++;
                        }
                        else if(label[i]!=-1&&label[j]==-1)
                        {
                            label[j]=label[i];
                        }
                        else if(label[i]==-1&&label[j]!=-1)
                        {
                            label[i]=label[j];
                        }
                        
                    }
                    
                }
            }
            
            int pointCount=0;
            int L=0;
            //int count=0;
            while(L<=groupCount)
            {
                int numOfGroupPoint=0;
                for(int j=0;j<numOfPoint;j++)
                {
                    if(label[j]==L)
                    {
                        numOfGroupPoint++;
                    }
                }
                Point2D[] pointXYa=new Point2D[numOfGroupPoint];
                int cnt = 0;
                for(int i=0;i<numOfPoint;i++)
                {
                    
                    if(label[i]==L)
                    {
                        pointXYa[cnt]=pointXY[i];
                        cnt++;
                        
                    }                  
                }
                if(pointXYa.length>=3)
                {
                    //pointCount+=MyConvexHull.ConvexHullVertex(pointXYa);
                }
                L++;
            }
            System.out.printf(String.valueOf(pointCount));
           
            
           
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@0ba65172ba96747d1028d69aaef9c450@"
"r04631013","3","0.5","106064","@90e9be45811fb72f7f34596563d5dd1f@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

           array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);

            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
       }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}
@90e9be45811fb72f7f34596563d5dd1f@"
"r04631013","3","0.51","107600","@0df5edddea78d942d5e50a81a398be5d@import java.util.Arrays;
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

        double xx = 1;
        double yy = 1;


        int qqq[] = new int[1];
        double array_y[] = new double[N]; 
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {

           array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);

            }
        }

   
        Arrays.sort(array_y);
        
        Point2D miniy = new Point2D(xx, yy);
        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }
        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }
        Arrays.sort(theta_int);
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
     
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
        int bb = sort_number[1];
        for (int i = 0; i < N - 2; i++) {

            int cc = sort_number[i + 2];
            while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                bb = need.pop();
                aa = need.peek();

            }
            need.push(bb);
            aa = bb;
            bb = cc;
        }
          need.push(sort_number[N - 1]);
       }
       
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);

        return con_hull;
    }

    public static void main(String[] args) throws Exception {
        int N = 10;
        Point2D[] a = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(1000);
            double y = StdRandom.uniform(1000);
            x = x * 0.001;
            y = y * 0.001;
            a[i] = new Point2D(x, y);
        }
        int ans[] = ConvexHullVertex(a);

    }

}

@0df5edddea78d942d5e50a81a398be5d@"
"r04631025","0","0.46","105392","@869af9ec1950f1a267c3a70355330484@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import edu.princeton.cs.algs4.Point2D;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        int[] answer=new int[10]; 
        for(int i=0;i<10;i++) 
            answer[i]=0;
        return answer;

    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=0;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@869af9ec1950f1a267c3a70355330484@"
"r03525006","2","0.52","107888","@377ce1631203389a705e44064a1c3501@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        return ans;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@377ce1631203389a705e44064a1c3501@"
"r04522616","3","0.32","109664","@874a41ee1267359de3e845f6df721c75@
import com.sun.corba.se.impl.io.ValueHandlerImpl;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=a.clone();
        
        
        Arrays.sort(a);//找出y最小的點為point[0]
        
        //Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序(POLAR_ORDER)
        }        
        
//        s.push(a[0]); 
//        //A.push(0);
//        s.push(a[1]); 
//        //A.push(1);
//        
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            //int temp = A.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                //temp = A.pop();
//            }
//            
//            s.push(top); 
//            //A.push(temp);
//            s.push(a[i]); 
//            //A.push(i);
//        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(a[0]);
        _stack.push(a[1]);
        _stack.push(a[2]);
        int k = 3;
        int ccw = 0;
        while(k != a.length)
        {
            Point2D p3 = a[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }
        
        
        
        int n = _stack.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int p=0;
        for(int i=0;i<n;i++)
        {
            c[i]=_stack.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[p]=j;
                    p++;                    
                }
            }            
        }
        
        Arrays.sort(CHPoint);
        
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }

        return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);                
            }
            //MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
            //Stack<Point2D> label = new Stack<Point2D>();
            int[] label=new int[numOfPoint];
            for(int i=0;i<numOfPoint;i++)
            {
                label[i]=-1;
            }
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
                    {
                        wQUF.union(i, j);//一小群CC                             
                    }                    
                }             
                
            }
            int k=0;
            int groupCount=0;
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(wQUF.connected(i, j))
                    {
                        if(label[i]==-1&&label[j]==-1)
                        {
                            label[i]=k;
                            label[j]=k;
                            k++;
                            groupCount++;
                        }
                        else if(label[i]!=-1&&label[j]==-1)
                        {
                            label[j]=label[i];
                        }
                        else if(label[i]==-1&&label[j]!=-1)
                        {
                            label[i]=label[j];
                        }
                        
                    }
                    
                }
            }
            
            int pointCount=0;
            int L=0;
            //int count=0;
            while(L<=groupCount)
            {
                int numOfGroupPoint=0;
                for(int j=0;j<numOfPoint;j++)
                {
                    if(label[j]==L)
                    {
                        numOfGroupPoint++;
                    }
                }
                Point2D[] pointXYa=new Point2D[numOfGroupPoint];
                int cnt = 0;
                for(int i=0;i<numOfPoint;i++)
                {
                    
                    if(label[i]==L)
                    {
                        pointXYa[cnt]=pointXY[i];
                        cnt++;
                        
                    }                  
                }
                if(pointXYa.length>=3)
                {
                    //pointCount+=MyConvexHull.ConvexHullVertex(pointXYa);
                }
                L++;
            }
            System.out.printf(String.valueOf(pointCount));
           
            
           
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@874a41ee1267359de3e845f6df721c75@"
"r04522616","5","0.106","106000","@e99ce5b9179c46d4f4203abc1c255fbe@import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Ted
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//        StdDraw.setPenRadius(0.01);
        Point2D[] b = a.clone();
        Arrays.sort(b, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        b[0].draw();
//        StdDraw.text(b[0].x(), 0.03 + b[0].y(),String.valueOf(0));
//        StdDraw.setPenColor(StdDraw.BLACK);
        
        Arrays.sort(b, b[0].POLAR_ORDER);
        
        for(int i = 1; i < b.length ;i++)
        {
//            b[i].draw();
//            StdDraw.text(b[i].x(), 0.03 + b[i].y(),String.valueOf(i));
        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(b[0]);
        _stack.push(b[1]);
        _stack.push(b[2]);
        int k = 3;
        int ccw = 0;
        while(k != b.length)
        {
            Point2D p3 = b[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }        
//         StdDraw.setPenColor(Color.yellow);
//         StdDraw.setPenRadius(.005);
         
        int[] id = new int[_stack.size()];
        int index = 0;
         
         Point2D d1 = _stack.pop();
         Point2D op = d1;
         int i = -1;
         while(!a[++i].equals(op))
         {
         }
         id[index++] = i;
       
         do
         {
             Point2D d2 = _stack.pop();
             i = -1;
             while(!a[++i].equals(d2))
             {
             }
             id[index++] = i;
//             StdDraw.line(d1.x(), d1.y(),d2.x(), d2.y());
             d1 = d2;
         }while(!(_stack.size() == 0));
//         StdDraw.line(d1.x(), d1.y(),op.x(), op.y());
         
         Arrays.sort(id);
       
        return id;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
         try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
             
            double distance = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            
            Point2D[] a = new Point2D[n];
            UF uf = new UF(n);
            int[][] ccIndex = new int[n][];
            for(int i = 0 ;i < n ;i++)
            {
                ccIndex[i] = new int[1];
                ccIndex[i][0] = -1;
            }
            
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.2, 1.2);
//            StdDraw.setYscale(-0.2, 1.2);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i = 0; i < n ;i++)
            {
                String datastream = br.readLine();
                String[] data = datastream.split("" "");
                a[i] = new  Point2D(Double.parseDouble(data[0]),Double.parseDouble(data[1]));
//                StdDraw.text(a[i].x()+0.03 , 0.03 + a[i].y(),String.valueOf(i));
            }
//            StdDraw.setPenRadius(.001);
//            StdDraw.setPenColor(StdDraw.GRAY);
            for(int i=0; i < n ;i++)
            {
                for(int j = i+1; j < n;j++)
                {
                    if(a[i].distanceTo(a[j])  <= distance)
                    {
//                        StdDraw.line(a[i].x(), a[i].y(), a[j].x(), a[j].y());
                        uf.union(i, j);
                    }
                }
            }
            
            int ncc = 0;
            int[] cc_pointnum = new int[uf.count()];
            for(int i = 0;i<uf.count();i++)
            {
                cc_pointnum[i] = 0;
            }
            while( ncc != uf.count())
            {
                for(int i = 0; i < n;i++)
                {
                    if(ccIndex[i][0] == -1)
                    {
                        ccIndex[i][0] = ncc++;
                        for(int j = 0; j < n;j++)
                        {
                             if(uf.connected(i, j))
                             {
                                ccIndex[j][0] =  ccIndex[i][0];
                                cc_pointnum[ncc-1]++;
                             }
                        }
                    }
                }
            }
            
            
            int totalnum = 0;
            for(int i = 0;i < uf.count();i++)
            {
                if(cc_pointnum[i] >= 3)
                {
                    Point2D[] temp = new Point2D[cc_pointnum[i]];
                    int k = 0;
                    for(int j = 0;j < n;j++)
                    {
                        if(ccIndex[j][0] == i)
                        {
                            temp[k++] = a[j];
                        }
                    }
                    totalnum += ConvexHullVertex(temp).length;
                }
            }
           
            System.out.printf(String.valueOf(totalnum));
        }
        
    }
    
}

@e99ce5b9179c46d4f4203abc1c255fbe@"
"r04228027","0","0.49","107616","@7ea907bae371052d93a52ab25acd3104@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@7ea907bae371052d93a52ab25acd3104@"
"r04228027","0","0.49","107616","@d305ca73c82cce509c52fc892454b954@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
// import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Custom_Point2D[] points = new Custom_Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Custom_Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@d305ca73c82cce509c52fc892454b954@"
"r04228027","0","0.1","108016","@6c0a1e0e0092f8420b6d19c093892e1e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@6c0a1e0e0092f8420b6d19c093892e1e@"
"r04228027","0","0.1","108016","@37c63aa8ff81f8c90bdee9a4b615a786@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        @Override
        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@37c63aa8ff81f8c90bdee9a4b615a786@"
"r03849033","0","0.21","105984","@ab2d96e19ae8602d76009383e0244f1f@

import java.util.Arrays;
import java.util.Comparator;





public class MyConvexHull {

    public static void main(String[] args) {
         Point2D[] a = new Point2D[10];
         Point2D[] A = a;
         int N = a.length;
         for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(10);
            double y = StdRandom.uniform(10);
            a[i] = new Point2D(x, y);
        }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
    }
}

@ab2d96e19ae8602d76009383e0244f1f@"
"r03849033","0","0.2","103072","@63a7fb4176db49ceb0186bbc0cf10046@

import java.util.Arrays;
import java.util.Comparator;





public class MyConvexHull {

    public static void main(String[] args) {
         Point2D[] A = a;
         int N = a.length;
         for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(10);
            double y = StdRandom.uniform(10);
            a[i] = new Point2D(x, y);
        }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
    }
}

@63a7fb4176db49ceb0186bbc0cf10046@"
"r03849033","0","0.2","103072","@449246b318155cb811e33ee31235791f@

public class MyConvexHull {

    public static void main(String[] args) {
         Point2D[] A = a;
         int N = a.length;
         for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(10);
            double y = StdRandom.uniform(10);
            a[i] = new Point2D(x, y);
        }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
    }
}

@449246b318155cb811e33ee31235791f@"
"r04631041","5","0.102","107856","@87509bbda44982a5870dc2ee51eb45b2@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
//                //===============================
                points[count] = new Point2D(x, y);
                count++;
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
//                System.out.println(""input size: ""+point1s.length);
                int index[] =  ConvexHullVertex(point1s);
                
//                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
//                //===================================
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}

@87509bbda44982a5870dc2ee51eb45b2@"
"r03849033","0","0.2","103072","@25fc340d353179c48e9da90cebbced89@

import java.util.Arrays;
import java.util.Comparator;





public class MyConvexHull {

    public String[] ConvexHullVertex (Point2D[] a) {
         Point2D[] A = a;
         int N = a.length;
         for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(10);
            double y = StdRandom.uniform(10);
            a[i] = new Point2D(x, y);
        }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
         return(ConvexHullVertex);
    }
    
    
    public static void main(String[] args) {

    }
}

@25fc340d353179c48e9da90cebbced89@"
"r03849033","0","0.2","103072","@565e4200ed377d566cc21508e2576da4@




public class MyConvexHull {

    public String[] ConvexHullVertex (Point2D[] a) {
         Point2D[] A = a;
         int N = a.length;
         for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform(10);
            double y = StdRandom.uniform(10);
            a[i] = new Point2D(x, y);
        }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
         return(ConvexHullVertex);
    }
    
    
    public static void main(String[] args) {

    }
}

@565e4200ed377d566cc21508e2576da4@"
"r04228027","0","0.48","107136","@db7157a7406bd214a57e2b0453d1ad15@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        @Override
        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Custom_Point2D[] points = new Custom_Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Custom_Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]),i);
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i=0; i<points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@db7157a7406bd214a57e2b0453d1ad15@"
"r04228027","0","0.09","101744","@bab4ffbc0cd7bcc163ff61d25bacf89e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import Point2D;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        @Override
        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Custom_Point2D[] points = new Custom_Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Custom_Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]),i);
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i=0; i<points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@bab4ffbc0cd7bcc163ff61d25bacf89e@"
"r03522831","5","0.106","104944","@b552c25b0905cb1e4279299b7e5a096c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@b552c25b0905cb1e4279299b7e5a096c@"
"r04228027","0","0.106","104944","@bab4ffbc0cd7bcc163ff61d25bacf89e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import Point2D;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        @Override
        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Custom_Point2D[] points = new Custom_Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Custom_Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]),i);
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i=0; i<points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@bab4ffbc0cd7bcc163ff61d25bacf89e@"
"r04228027","0","0.51","107872","@1230f962e16289d6cc16b921a1441016@ * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.util.Point2D;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        @Override
        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Custom_Point2D[] points = new Custom_Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Custom_Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]),i);
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i=0; i<points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@1230f962e16289d6cc16b921a1441016@"
"r03849033","0","0.106","104944","@d8773bfce4748912742bcc6b0f03e7c0@

import java.util.Arrays;
import java.util.Comparator;





public class MyConvexHull {

    public String[] ConvexHullVertex (String[][] a) {
         int N = a.length;
         Point2D[] a1 = new Point2D[N];
         for (int i = 0; i < N; i++) {
            double x = Double.parseDouble(a[i][0]);
            double y = Double.parseDouble(a[i][1]);
            a1[i] = new Point2D(x, y);
        }
         Point2D[] A = a1;
         Arrays.sort(a);
         Point2D p = new Point2D(a1[0].x(), a1[0].y());
         Arrays.sort(a1, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a1[Integer.parseInt(v[num-2])];
             Point2D b = a1[Integer.parseInt(v[num-1])];
             Point2D c = a1[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         String[] ConvexHullVertex = new String[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a1[Integer.parseInt(v[j])])==0){
                    ConvexHullVertex[x]="""" + i;
                    x++;
                    break;
                }
             }
         }
         return(ConvexHullVertex);
    }
    
    
    public static void main(String[] args) {

    }
}

@d8773bfce4748912742bcc6b0f03e7c0@"
"r04631036","0","0","0","@4b529be80750a63aa1bcd031bf6b2eb1@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        for (int i = 0; i < N; i++) {
            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);
        if(points[0].y()==points[1].y())
            hull.push(points[1]);
        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        StdDraw.setPenColor(Color.red);
        for(int i=0;i<N;i++)
        {
            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < points.length; j++) {
                if (check == pts[j].y()) {
                    //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                    ans[i] = j;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
         StdDraw.setPenColor(Color.black);
        for (int i = 0; i < ans.length-1; i++) {
             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
        }
        for(int i=0;i<ans.length;i++)
        {
            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
        }
        //StdDraw.setPenColor(StdDraw.GREEN);
        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
        for (int i = 0; i < ans.length; i++) {
             System.out.printf(""\nindex= %d"", ans[i]);
        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
        Point2D[] a = new Point2D[10];
        a[0] = new Point2D(0.200, 0.250);
        a[1] = new Point2D(0.147, 0.387);
        a[2] = new Point2D(0.300, 0.300);
        a[3] = new Point2D(0.333, 0.213);
        a[4] = new Point2D(0.353, 0.412);
        a[5] = new Point2D(0.700, 0.890);
        a[6] = new Point2D(0.879, 0.700);
        a[7] = new Point2D(0.867, 0.888);
        a[8] = new Point2D(0.980, 0.120);
        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
        MyConvexHull cv = new MyConvexHull();
        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@4b529be80750a63aa1bcd031bf6b2eb1@"
"r03849033","0","0.49","107168","@fd24cff022867f75d7366169fe793b35@

import java.util.Arrays;


public class MyConvexHull {

     public static int[] ConvexHullVertex(Point2D[] a) {
         int N = a.length;
         Point2D[] A = a;
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         String[] v = new String[N];
         v[0]="""" + 0;
         v[1]="""" + 1;     
         int num = 2;
         for (int i = 2; i < N; i++) {
             Point2D aa = a[Integer.parseInt(v[num-2])];
             Point2D b = a[Integer.parseInt(v[num-1])];
             Point2D c = a[i];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());
             if(ccw > 0){
                 v[num]="""" + i;
                 num++;
             }
         }
         int[] Vertex = new int[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (A[i].distanceTo(a[Integer.parseInt(v[j])])==0){
                    Vertex[x]=i;
                    x++;
                    break;
                }
             }
         }
         return(Vertex);
    }
    
    
    public static void main(String[] args) {

    }
}

@fd24cff022867f75d7366169fe793b35@"
"r04631036","0","0","0","@92fcc98cf60c73d989fb9fa354f7bd24@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
        for (int i = 0; i < N; i++) {
            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        StdDraw.setPenColor(Color.red);
        for(int i=0;i<N;i++)
        {
            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < pts.length; j++) {
                if (check == pts[j].y()) {
                    //System.out.printf(""value=%f  index= %d\n"",pts[i].y(),j);

                    ans[i] = j;
                    pts[j] = new Point2D(0,0);
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
         StdDraw.setPenColor(Color.black);
        for (int i = 0; i < ans.length-1; i++) {
             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
        }
        for(int i=0;i<ans.length;i++)
        {
            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
        }
        //StdDraw.setPenColor(StdDraw.GREEN);
        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
        for (int i = 0; i < ans.length; i++) {
             System.out.printf(""\nindex= %d"", ans[i]);
        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
        Point2D[] a = new Point2D[10];
        a[0] = new Point2D(0.200, 0.250);
        a[1] = new Point2D(0.147, 0.387);
        a[2] = new Point2D(0.300, 0.300);
        a[3] = new Point2D(0.333, 0.213);
        a[4] = new Point2D(0.353, 0.412);
        a[5] = new Point2D(0.700, 0.890);
        a[6] = new Point2D(0.879, 0.700);
        a[7] = new Point2D(0.867, 0.888);
        a[8] = new Point2D(0.980, 0.120);
        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
        MyConvexHull cv = new MyConvexHull();
        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@92fcc98cf60c73d989fb9fa354f7bd24@"
"r04631023","4","0.51","107904","@564ddd826a41b88754efa811c56df6f4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        Stack<Double> Diff = new Stack<Double>();
        Stack<Integer> DiffLoc = new Stack<Integer>();
        
        for (int i = 0; i < a.length ; i++){
            if (i == 0){
                if (angleSort[i] == angleSort[i+1]) {
                Diff.push(angleSort[i]);
                DiffLoc.push(i);
                }
            }else if(i != a.length-1){
                if (angleSort[i] != angleSort[i-1] && angleSort[i] == angleSort[i+1]){
                    Diff.push(angleSort[i]);
                    DiffLoc.push(i);
                }
            }
        }
        
        
        for (int i = Diff.size(); i > 0; i--){
            double checkangle = Diff.pop() ;
            int newLoc = DiffLoc.pop() ;
            int[] angleLoc = new int[a.length] ;
            int[] indexDisSort = new int[a.length] ;
            double[] angleDis = new double[a.length] ;
            double[] angleDisSort = new double[a.length] ;
            int count = 0 ;
            for (int j = 0; j < a.length ; j++){
                if (angle[j] == checkangle){
                    angleLoc[count] = j ;
                    count++ ;
                }
            }
            
            for (int j = 0; j < count ; j++){
                angleDis[angleLoc[j]] = Distance(a[index], a[angleLoc[j]]) ;
            }
            angleDisSort = angleDis ;
            /*
            for (int k = 0; k < count; k++){
                System.out.println(angleDisSort[k]) ;
            }
            */
            Arrays.sort(angleDisSort);
            /*
            for (int k = 0; k < count; k++){
                System.out.println(angleDisSort[k]) ;
            }
            */
            for (int j = 0; j < count ; j++){
            indexDisSort[j] = Arrays.binarySearch(angleDisSort, angleDis[j])+ newLoc ;
            indexNum[indexDisSort[j]] = angleLoc[j] ;
            }
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            if (convexHull.size() < 2){
                break ;
            }
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int x = convexHull.pop() ;
            StdDraw.filledCircle(a[x].x(), a[x].y(), 0.01) ;
        }
        */
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}

@564ddd826a41b88754efa811c56df6f4@"
"r03525006","2","0.5","103712","@065c8996be2ae0616597bcbbf4fc7c9c@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = 10;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@065c8996be2ae0616597bcbbf4fc7c9c@"
"r04631036","3","0.51","106784","@8f0b3bff43d79336aeae33bc2810cc25@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
//        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

//        StdDraw.setPenColor(Color.red);
//        for(int i=0;i<N;i++)
//        {
//            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
//        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < pts.length; j++) {
                if (check == pts[j].y()) {
                    //System.out.printf(""value=%f  index= %d\n"",pts[i].y(),j);

                    ans[i] = j;
                    pts[j] = new Point2D(0,0);
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
//         StdDraw.setPenColor(Color.black);
//        for (int i = 0; i < ans.length-1; i++) {
//             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
//        }
//        for(int i=0;i<ans.length;i++)
//        {
//            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
//        }
        //StdDraw.setPenColor(StdDraw.GREEN);
//        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
//        for (int i = 0; i < ans.length; i++) {
//             System.out.printf(""\nindex= %d"", ans[i]);
//        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
//        MyConvexHull cv = new MyConvexHull();
//        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@8f0b3bff43d79336aeae33bc2810cc25@"
"r03525006","2","0.52","107888","@065c8996be2ae0616597bcbbf4fc7c9c@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = 10;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@065c8996be2ae0616597bcbbf4fc7c9c@"
"r04631036","0","0.51","107472","@e21602f73b758b6179e770f71075c7a6@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
//        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

//        StdDraw.setPenColor(Color.red);
//        for(int i=0;i<N;i++)
//        {
//            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
//        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < pts.length; j++) {
                if (check == pts[j].y()) {
//                    System.out.printf(""value=%f  index= %d\n"",pts[i].y(),j);
                    pts[j] = new Point2D(-1,-1);
                    ans[i] = j;
                    break;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
//         StdDraw.setPenColor(Color.black);
//        for (int i = 0; i < ans.length-1; i++) {
//             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
//        }
//        for(int i=0;i<ans.length;i++)
//        {
//            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
//        }
//        //StdDraw.setPenColor(StdDraw.GREEN);
//        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
        for (int i = 0; i < ans.length; i++) {
             System.out.printf(""\nindex= %d"", ans[i]);
        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
//        MyConvexHull cv = new MyConvexHull();
//        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@e21602f73b758b6179e770f71075c7a6@"
"r04631036","5","0.1","104016","@17f805c891600d07f4ad0ded6629b5eb@
/**
 * ****************************************************************************
 * Compilation: javac GrahamaScan.java Execution: java GrahamScan < input.txt
 * Dependencies: Point2D.java
 *
 * Create points from standard input and compute the convex hull using Graham
 * scan algorithm.
 *
 * May be floating-point issues if x- and y-coordinates are not integers.
 *
 *****************************************************************************
 */
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;

/**
 * The <tt>GrahamScan</tt> data type provides methods for computing the convex
 * hull of a set of <em>N</em> points in the plane.
 * <p>
 * The implementation uses the Graham-Scan convex hull algorithm. It runs in
 * O(<em>N</em> log <em>N</em>) time in the worst case and uses O(<em>N</em>)
 * extra memory.
 * <p>
 * For additional documentation, see
 * <a href=""http://algs4.cs.princeton.edu/99scientific"">Section 9.9</a> of
 * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
//        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

//        StdDraw.setPenColor(Color.red);
//        for(int i=0;i<N;i++)
//        {
//            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
//        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < pts.length; j++) {
                if (check == pts[j].y()) {
//                    System.out.printf(""value=%f  index= %d\n"",pts[i].y(),j);
                    pts[j] = new Point2D(-1,-1);
                    ans[i] = j;
                    break;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
//         StdDraw.setPenColor(Color.black);
//        for (int i = 0; i < ans.length-1; i++) {
//             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
//        }
//        for(int i=0;i<ans.length;i++)
//        {
//            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
//        }
//        //StdDraw.setPenColor(StdDraw.GREEN);
//        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
//        for (int i = 0; i < ans.length; i++) {
//             System.out.printf(""\nindex= %d"", ans[i]);
//        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
//        MyConvexHull cv = new MyConvexHull();
//        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@17f805c891600d07f4ad0ded6629b5eb@"
"r03525006","2","0.52","106000","@f2d84472b8a9c082750b07a28bb8d2e5@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = 10;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ans;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@f2d84472b8a9c082750b07a28bb8d2e5@"
"r04631023","4","0.5","107904","@4e525ee88cab7d34c92cfcbbfe7a9cdc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        Stack<Double> Diff = new Stack<Double>();
        Stack<Integer> DiffLoc = new Stack<Integer>();
        
        for (int i = 0; i < a.length ; i++){
            if (i == 0){
                if (angleSort[i] == angleSort[i+1]) {
                Diff.push(angleSort[i]);
                DiffLoc.push(i);
                }
            }else if(i != a.length-1){
                if (angleSort[i] != angleSort[i-1] && angleSort[i] == angleSort[i+1]){
                    Diff.push(angleSort[i]);
                    DiffLoc.push(i);
                }
            }
        }
        
        
        for (int i = Diff.size(); i > 0; i--){
            double checkangle = Diff.pop() ;
            int newLoc = DiffLoc.pop() ;
            int[] angleLoc = new int[a.length] ;
            int[] indexDisSort = new int[a.length] ;
            double[] angleDis = new double[a.length] ;
            double[] angleDisSort = new double[a.length] ;
            int count = 0 ;
            for (int j = 0; j < a.length ; j++){
                if (angle[j] == checkangle){
                    angleLoc[count] = j ;
                    count++ ;
                }
            }
            
            for (int j = 0; j < count ; j++){
                angleDis[angleLoc[j]] = Distance(a[index], a[angleLoc[j]]) ;
            }
            angleDisSort = angleDis ;
            Arrays.sort(angleDisSort);
            for (int j = 0; j < count ; j++){
            indexDisSort[j] = Arrays.binarySearch(angleDisSort, angleDis[j])+ newLoc ;
            indexNum[indexDisSort[j]] = angleLoc[j] ;
            }
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            if (convexHull.size() < 2){
                break ;
            }
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int q = convexHull.pop() ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.filledCircle(a[q].x(), a[q].y(), 0.01) ;
        }
        */
        Arrays.sort(answer) ;
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}

@4e525ee88cab7d34c92cfcbbfe7a9cdc@"
"r04945022","0","0.21","104576","@03b23b5c441e25c6c327a200caf61b54@
import java.util.*;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)!=1){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    Arrays.sort(ref);
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }

     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           if(left>=right) break;
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           
       }
       
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@03b23b5c441e25c6c327a200caf61b54@"
"r03525006","2","0.5","106000","@fae1d53df43ba940b723e20a7ebfa529@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@fae1d53df43ba940b723e20a7ebfa529@"
"r03525006","2","0.5","105984","@fae1d53df43ba940b723e20a7ebfa529@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[1] == N-2)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@fae1d53df43ba940b723e20a7ebfa529@"
"r04631023","4","0.53","107856","@ac0435e75c024a12da1ef71bbf51a545@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        Stack<Double> Diff = new Stack<Double>();
        Stack<Integer> DiffLoc = new Stack<Integer>();
        
        for (int i = 0; i < a.length ; i++){
            if (i == 0){
                if (angleSort[i] == angleSort[i+1]) {
                Diff.push(angleSort[i]);
                DiffLoc.push(i);
                }
            }else if(i != a.length-1){
                if (angleSort[i] != angleSort[i-1] && angleSort[i] == angleSort[i+1]){
                    Diff.push(angleSort[i]);
                    DiffLoc.push(i);
                }
            }
        }
        
        
        for (int i = Diff.size(); i > 0; i--){
            double checkangle = Diff.pop() ;
            int newLoc = DiffLoc.pop() ;
            int[] angleLoc = new int[a.length] ;
            int[] indexDisSort = new int[a.length] ;
            double[] angleDis = new double[a.length] ;
            double[] angleDisSort = new double[a.length] ;
            int count = 0 ;
            for (int j = 0; j < a.length ; j++){
                if (angle[j] == checkangle){
                    angleLoc[count] = j ;
                    count++ ;
                }
            }
            
            for (int j = 0; j < count ; j++){
                angleDis[j] = Distance(a[index], a[angleLoc[j]]) ;
            }
            angleDisSort = angleDis ;
            /*
            for (int k = 0; k < count; k++){
                System.out.println(angleDisSort[k]) ;
            }
            */
            Arrays.sort(angleDisSort);
            /*
            for (int k = 0; k < count; k++){
                System.out.println(angleDisSort[k]) ;
            }
            */
            for (int j = 0; j < count ; j++){
            indexDisSort[j] = Arrays.binarySearch(angleDisSort, angleDis[j])+ newLoc ;
            indexNum[indexDisSort[j]] = angleLoc[j] ;
            //System.out.println(indexDisSort[j]) ;
            }
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            if (convexHull.size() < 2){
                break ;
            }
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int q = convexHull.pop() ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.filledCircle(a[q].x(), a[q].y(), 0.01) ;
        }
        */
        Arrays.sort(answer) ;
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}

@ac0435e75c024a12da1ef71bbf51a545@"
"r04921012","5","0.106","106016","@29c25dad3e770f989983123f858b188c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Insertion;
//import edu.princeton.cs.algs4.Merge;
//import edu.princeton.cs.algs4.Point2D;
//import java.io.IOException;
import java.util.Arrays;
//import java.util.Iterator;
//import java.util.Stack;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author 余軒
 */
//利用StdRandom產生N個2D points((用Point2D的array來儲存))
//再搭配StdDraw把這個N個點畫出來

public class MyConvexHull {
    
  //  private static int N = 16;
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        
         int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
       return index;
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    
//    public static void main(String[] args) throws IOException {
//        // TODO code application logic here
//
//    int N = 30;
//
//        StdDraw.setCanvasSize(600, 600);
//        StdDraw.setXscale(-100, 700);
//        StdDraw.setYscale(-100, 700);
//        StdDraw.setPenRadius(.02);
//
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//
//            int x = StdRandom.uniform(600);
//            int y = StdRandom.uniform(600);
//            points[i] = new Point2D(x, y);
//            StdDraw.point(points[i].x(), points[i].y());
//
//        }
//        Merge.sort(points);
//
//        Arrays.sort(points, points[0].polarOrder());
//        for (int i = 0; i < N; ++i) {
//            StdDraw.text(points[i].x(), points[i].y() + 12, String.valueOf(i));
//        }
//
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        points[0].draw();
//        
//        Stack<Point2D> vals = new Stack<Point2D>();
//        
// 
//        int k1;
//        for (k1 = 1; k1 < N; k1++)
//            if (!points[0].equals(points[k1])) break;
//        if (k1 == N) return;        // all points equal
//        vals.push(points[0]);
//        vals.push(points[k1]);
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int k2;
//        for (k2 = k1 + 1; k2 < N; k2++)
//            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
//        vals.push(points[k2]);    // points[k2-1] is second extreme point
//
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = k2; i < N; i++) {
//            Point2D top = vals.pop();
//            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
//                top = vals.pop();
//            }
//            vals.push(top);
//            vals.push(points[i]);
//        }
//        System.out.println(vals.size());
//        
//        StdDraw.setPenColor(StdDraw.GREEN);
//        int number = vals.size();
//        Point2D[] vertex = new Point2D[number];
//        for(int u = 0;u<number;u++){
//            vertex[u] = vals.pop();
//           StdDraw.point(vertex[u].x(), vertex[u].y());
//        }
//        
//        
//        
//        /*
//        System.out.println(vals.size());
//        Iterator<Point2D> c = vals.iterator();
//        while(c.hasNext()){
//            Point2D f = c.next();
//            System.out.println(f);
//        }
//        */
//        
//        
//    }
//    }
}

@29c25dad3e770f989983123f858b188c@"
"r04945022","0","0.098","106176","@6bb69a127e9f96f7f778283594f718ab@import java.util.*;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> stack = new Stack();
     stack.push(s[0]);
     stack.push(s[1]);
     for(int i = 2; i < s.length; i++){
         Point2D q;
         do {
             q =stack.pop(); 
         } while(Point2D.ccw(stack.lastElement(), q, s[i])<=0&&stack.size()>1);
         stack.push(q);
         stack.push(s[i]);
     }
     Point2D test;
     test = stack.pop();
     if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<=0){
     do{
     test = stack.pop();
     }while(Point2D.ccw(stack.lastElement(), test, stack.firstElement())<=0);
     stack.push(test);
     }else if(Point2D.ccw(stack.lastElement(), test, stack.firstElement())>0&&test!=stack.lastElement()){
         stack.push(test);
     }
     
          
//    Stack<Point2D> convex = new Stack<Point2D>();
//    convex.push(s[0]);
//    convex.push(s[1]);
//    for(int i=2;i<s.length;i++){
//        Point2D b =convex.pop();
//        Point2D a = convex.pop();
//        Point2D c =s[i];
//        while(Point2D.ccw(a, b, c)!=1){
//            b = a;
//            a = convex.pop();
//        }
//        convex.push(a);
//        convex.push(b);
//        convex.push(c);
//    }
//        Stack<Point2D> oppo = new Stack<Point2D>();
//        while(!convex.isEmpty()){
//            oppo.push(convex.pop());
//        }
//        convex = oppo;
        Iterator<Point2D> it = stack.iterator();
        int count = 0;
        int[] ref = new int[stack.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    Arrays.sort(ref);
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }

     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
//        System.out.println();
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           if(left>=right) break;
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           
       }
       
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@6bb69a127e9f96f7f778283594f718ab@"
"r04631035","0","0.098","106176","@0412b873345dbbefb4da3201d1e3c9e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import edu.princeton.cs.algs4.Point2D;
import java.util.*;
import java.math.*;
import java.awt.Color;

/**
 *
 * @author cypan
 */
public class MyConvexHull {

    public double ConvexHullVertex(Point2D[] a) {

//        double i = StdRandom.uniform(0, 1);
//        System.out.println(i);
        
        Point2D.ccw(a[0], a[1], a[2]);
        
        return 0;
    }



    private static void insertionSort_Point(double[][] arr, int col) {

        for (int i = 1; i < arr.length; i++) {
            int col1 = 0;
            int col2 = 0;
            if (col == 0) {
                col1 = 1;
                col2 = 2;
            } else if (col == 1) {
                col1 = 0;
                col2 = 2;
            } else if (col == 2) {
                col1 = 0;
                col2 = 1;
            }
            double valueToSort = arr[i][col];
            double valueNoSort = arr[i][col1];
            double valueNoSort1 = arr[i][col2];
            int j = i;
            while (j > 0 && arr[j - 1][col] > valueToSort) {
                arr[j][col] = arr[j - 1][col];
                arr[j][col1] = arr[j - 1][col1];
                arr[j][col2] = arr[j - 1][col2];
                j--;
            }
            arr[j][col] = valueToSort;
            arr[j][col1] = valueNoSort; //綁定
            arr[j][col2] = valueNoSort1; //綁定

        }
    }

    private static void insertionSort(double[] arr) {
        for (int i = 1; i < arr.length; i++) {
            double valueToSort = arr[i];
            int j = i;
            while (j > 0 && arr[j - 1] > valueToSort) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = valueToSort;
        }
    }

    public static void printArray(double[][] B, int col) {
        System.out.println(Arrays.toString(B));
    }

    public static void populateArray(int[] B) {
        for (int i = 0; i < B.length; i++) {
            B[i] = (int) (Math.random() * 100);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        int num = StdRandom.uniform(5, 10);
        double[][] Point2D = new double[num][3];

        System.out.println(num);

        for (int i = 0; i < num; i++) {
            double y = StdRandom.uniform(0, 1000);
            double angle = StdRandom.uniform(0, 1000);
            Point2D[i][0] = y / 1000;
            Point2D[i][1] = angle / 1000;
            StdDraw.circle(Point2D[i][0], Point2D[i][1], 0.01);
//            System.out.println(Point2D[i][0]);
//            System.out.println(Point2D[i][1]);
        }

        insertionSort_Point(Point2D, 1); //找y軸最低
        StdDraw.setPenColor(new Color(255, 0, 0));   // red
        StdDraw.circle(Point2D[0][0], Point2D[0][1], 0.01);

        Point2D[0][2] = 0;
        for (int i = 1; i < Point2D.length; i++) {

            double deg = (double) Math.toDegrees(Math.atan2(Point2D[i][0] - Point2D[0][0], Point2D[i][1] - Point2D[0][1]));
            if (deg > 0) {
                Point2D[i][2] = deg;
            } else if (deg < 0) {
                deg = 180 + deg;
                Point2D[i][2] = deg;
            }
        }

        insertionSort_Point(Point2D, 2);

        System.out.println(Point2D[0][2]);
        System.out.println(Point2D[1][2]);
        System.out.println(Point2D[2][2]);
        System.out.println(Point2D[3][2]);
        System.out.println(Point2D[4][2]);

    }

}

@0412b873345dbbefb4da3201d1e3c9e3@"
"r04631035","0","0.098","106176","@7441fbe52c1367bee954c7ce1fc0f293@ㄒ/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
import java.math.*;
import java.awt.Color;

/**
 *
 * @author cypan
 */
public class MyConvexHull {

    public double ConvexHullVertex(Point2D[] a) {

//        double i = StdRandom.uniform(0, 1);
//        System.out.println(i);
        
        Point2D.ccw(a[0], a[1], a[2]);
        
        return 0;
    }



    private static void insertionSort_Point(double[][] arr, int col) {

        for (int i = 1; i < arr.length; i++) {
            int col1 = 0;
            int col2 = 0;
            if (col == 0) {
                col1 = 1;
                col2 = 2;
            } else if (col == 1) {
                col1 = 0;
                col2 = 2;
            } else if (col == 2) {
                col1 = 0;
                col2 = 1;
            }
            double valueToSort = arr[i][col];
            double valueNoSort = arr[i][col1];
            double valueNoSort1 = arr[i][col2];
            int j = i;
            while (j > 0 && arr[j - 1][col] > valueToSort) {
                arr[j][col] = arr[j - 1][col];
                arr[j][col1] = arr[j - 1][col1];
                arr[j][col2] = arr[j - 1][col2];
                j--;
            }
            arr[j][col] = valueToSort;
            arr[j][col1] = valueNoSort; //綁定
            arr[j][col2] = valueNoSort1; //綁定

        }
    }

    private static void insertionSort(double[] arr) {
        for (int i = 1; i < arr.length; i++) {
            double valueToSort = arr[i];
            int j = i;
            while (j > 0 && arr[j - 1] > valueToSort) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = valueToSort;
        }
    }

    public static void printArray(double[][] B, int col) {
        System.out.println(Arrays.toString(B));
    }

    public static void populateArray(int[] B) {
        for (int i = 0; i < B.length; i++) {
            B[i] = (int) (Math.random() * 100);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        int num = StdRandom.uniform(5, 10);
        double[][] Point2D = new double[num][3];

        System.out.println(num);

        for (int i = 0; i < num; i++) {
            double y = StdRandom.uniform(0, 1000);
            double angle = StdRandom.uniform(0, 1000);
            Point2D[i][0] = y / 1000;
            Point2D[i][1] = angle / 1000;
            StdDraw.circle(Point2D[i][0], Point2D[i][1], 0.01);
//            System.out.println(Point2D[i][0]);
//            System.out.println(Point2D[i][1]);
        }

        insertionSort_Point(Point2D, 1); //找y軸最低
        StdDraw.setPenColor(new Color(255, 0, 0));   // red
        StdDraw.circle(Point2D[0][0], Point2D[0][1], 0.01);

        Point2D[0][2] = 0;
        for (int i = 1; i < Point2D.length; i++) {

            double deg = (double) Math.toDegrees(Math.atan2(Point2D[i][0] - Point2D[0][0], Point2D[i][1] - Point2D[0][1]));
            if (deg > 0) {
                Point2D[i][2] = deg;
            } else if (deg < 0) {
                deg = 180 + deg;
                Point2D[i][2] = deg;
            }
        }

        insertionSort_Point(Point2D, 2);

        System.out.println(Point2D[0][2]);
        System.out.println(Point2D[1][2]);
        System.out.println(Point2D[2][2]);
        System.out.println(Point2D[3][2]);
        System.out.println(Point2D[4][2]);

    }

}

@7441fbe52c1367bee954c7ce1fc0f293@"
"r04631023","5","0.108","107616","@f546b848aaa6dafcb0a2858d923757d2@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        Stack<Double> Diff = new Stack<Double>();
        Stack<Integer> DiffLoc = new Stack<Integer>();
        
        for (int i = 0; i < a.length ; i++){
            if (i == 0){
                if (angleSort[i] == angleSort[i+1]) {
                Diff.push(angleSort[i]);
                DiffLoc.push(i);
                }
            }else if(i != a.length-1){
                if (angleSort[i] != angleSort[i-1] && angleSort[i] == angleSort[i+1]){
                    Diff.push(angleSort[i]);
                    DiffLoc.push(i);
                }
            }
        }
        
        
        for (int i = Diff.size(); i > 0; i--){
            double checkangle = Diff.pop() ;
            int newLoc = DiffLoc.pop() ;
            int[] angleLoc = new int[a.length] ;
            int[] indexDisSort = new int[a.length] ;
            double[] angleDis = new double[a.length] ;
            
            int count = 0 ;
            for (int j = 0; j < a.length ; j++){
                if (angle[j] == checkangle){
                    angleLoc[count] = j ;
                    count++ ;
                }
            }
            
            for (int j = 0; j < count ; j++){
                angleDis[j] = Distance(a[index], a[angleLoc[j]]) ;
            }
            double[] angleDisSort = new double[count] ;
            for (int j = 0; j < count ; j++){
                angleDisSort[j] = angleDis[j] ;
            }
            Arrays.sort(angleDisSort);
            for (int j = 0; j < count ; j++){
            indexDisSort[j] = Arrays.binarySearch(angleDisSort, angleDis[j])+ newLoc ;
            indexNum[indexDisSort[j]] = angleLoc[j] ;
            
            }
        }        
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }else if(Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 0){
                convexHull.push(first);
                convexHull.push(indexNum[count]);
                count++ ;
            }else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int q = convexHull.pop() ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.filledCircle(a[q].x(), a[q].y(), 0.01) ;
        }
        */
        Arrays.sort(answer) ;
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}

@f546b848aaa6dafcb0a2858d923757d2@"
"r04945022","3","0.51","107792","@7aeaeed9c43fd0cdcdccab3c159fa1a4@
import java.util.*;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
private static Stack<Point2D> chh = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        chh.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == N) {
//            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        chh.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = chh.pop();
            while (Point2D.ccw(chh.peek(), top, points[i]) <= 0) {
                top = chh.pop();
            }
            chh.push(top);
            chh.push(points[i]);

        }
        ans = new int[chh.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = chh.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < points.length; j++) {
                if (check == pts[j].y()) {
                    //System.out.printf(""value=%f  index= %d\n"",back[i].y(),j);
                    ans[i] = j;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
        Arrays.sort(ans);
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : chh) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
       
//            //StdOut.println(p);
//        }
    }

}

@7aeaeed9c43fd0cdcdccab3c159fa1a4@"
"r03525006","2","0.52","107872","@8f42ac0e25d876dcd2d6ab28341cc130@import java.util.Arrays;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }
}

@8f42ac0e25d876dcd2d6ab28341cc130@"
"r04631026","5","0.106","105264","@746d33a512af594cac035dcd7e0240cb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@746d33a512af594cac035dcd7e0240cb@"
"r03631015","5","0.104","104128","@746d33a512af594cac035dcd7e0240cb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@746d33a512af594cac035dcd7e0240cb@"
"r04631031","5","0.106","107936","@746d33a512af594cac035dcd7e0240cb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@746d33a512af594cac035dcd7e0240cb@"
"d04631001","0","0.12","100272","@bc1d2fa9e2d87a7c933e224f18bcf6a3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] graph = new Point2D[a.length];
        graph=a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();
            
            if (i == 0) {
                min_y = graph[0].y();
            }
            else if (i > 0 && graph[i].y() < min_y){
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");
        
        double angle[] = new double[5];
        double angle_ord[] = new double[5];
        
        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x()- graph[k].x();
            double dist_y = graph[i].y()- graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i]= angle[i];
        }
        //System.out.printf(""%s\n"", "" "");
        
        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++){
            angle[i] = Math.floor(angle[i]*1000000)/1000000;
            angle_ord[i] = Math.floor(angle_ord[i]*1000000)/1000000;
        }
        for (int i = 0; i<graph.length;i++){
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[5];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i]=graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[5];
        //graph_ccw[0]=1;
        for (int i = 1; i<graph.length-1; i++){
            graph_ccw[i] = Point2D.ccw(new_graph[i-1], new_graph[i], new_graph[i+1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[4], new_graph[0], new_graph[1]);
        graph_ccw[4] = Point2D.ccw(new_graph[3], new_graph[4], new_graph[0]);
        for (int i = 0; i<graph.length; i++){
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[5];
        int ori_ch[] = new int[5];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i=0;i<graph.length;i++){
            if (ori_ch[i]==-1){
                ori_ch[i]=0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j]==1){
                fin_ch[n]=j;
                n++;
            }
        }
        
        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}
        
        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
            //System.out.print(graph[i] + ""\n"");
        //}
    }
}

@bc1d2fa9e2d87a7c933e224f18bcf6a3@"
"r03525006","2","0.5","104976","@9834ed0745de03d51ae2a1c6780e8097@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@9834ed0745de03d51ae2a1c6780e8097@"
"r04631046","5","0.106","106048","@746d33a512af594cac035dcd7e0240cb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@746d33a512af594cac035dcd7e0240cb@"
"d04631001","0","0.51","106016","@84c10d6d9c444a9561ad856e5f2de4ac@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
}

@84c10d6d9c444a9561ad856e5f2de4ac@"
"d04631001","0","0.5","107632","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.53","106480","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.5","103616","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.5","105184","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.51","107664","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.5","106800","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.51","107872","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.48","106000","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"d04631001","0","0.51","106000","@eeaac901a06ce4bb0e06d3f733080aa9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@eeaac901a06ce4bb0e06d3f733080aa9@"
"r03525006","0","0","0","@d585571f1fd0b76b67fa8ab5fbb7d7fa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N-1) {
                isConvex[N-1] = -1;
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@d585571f1fd0b76b67fa8ab5fbb7d7fa@"
"r04631025","5","0.106","107792","@9f100ac44cacd2ca439f9057303a78a9@
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Stack;
public class MyConvexHull {

    private static Stack<Point2D> hull = new Stack<Point2D>();
    Stack h = new Stack();

    /**
     * Computes the convex hull of the specified array of points.
     *
     * @param pts the array of points
     * @throws NullPointerException if <tt>points</tt> is <tt>null</tt> or if
     * any entry in <tt>points[]</tt> is <tt>null</tt>
     */
    public static int[] ConvexHullVertex(Point2D[] pts) {

        // defensive copy
        int N = pts.length;
        int[] ans;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            points[i] = pts[i];
        }
//        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.005);
//            //System.out.printf(""%f  ,   %f\n"", point[i].x(), point[i].y());
//        }
        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

//        StdDraw.setPenColor(Color.red);
//        for(int i=0;i<N;i++)
//        {
//            StdDraw.text(points[i].x(), points[i].y()-0.03, String.valueOf(i));
//        }
        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!points[0].equals(points[k1])) {
                break;
            }
        }
//        if (k1 == 8) {
////            return;        // all points equal
//        }
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) {
                break;
            }
        }
        hull.push(points[k2 - 1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);

        }
        ans = new int[hull.size()];
//        System.out.printf(""hull size=%d\n"", hull.size());
        for (int i = 0; i < ans.length; i++) {
            double check = 0;
            check = hull.pop().y();
            //System.out.printf(""check=%f\n"", check);
            for (int j = 0; j < pts.length; j++) {
                if (check == pts[j].y()) {
//                    System.out.printf(""value=%f  index= %d\n"",pts[i].y(),j);
                    pts[j] = new Point2D(-1,-1);
                    ans[i] = j;
                    break;
                }
            }

//                System.out.printf(""index= %d\n"",ans[i]);
        }
//         StdDraw.setPenColor(Color.black);
//        for (int i = 0; i < ans.length-1; i++) {
//             StdDraw.line(pts[ans[i]].x(), pts[ans[i]].y(), pts[ans[i+1]].x(), pts[ans[i+1]].y());
//        }
//        for(int i=0;i<ans.length;i++)
//        {
//            StdDraw.text(pts[ans[i]].x(), pts[ans[i]].y()+0.03, Integer.toString(ans[i]) );
//        }
//        //StdDraw.setPenColor(StdDraw.GREEN);
//        StdDraw.line(pts[ans[0]].x(), pts[ans[0]].y(), pts[ans[ans.length-1]].x(), pts[ans[ans.length-1]].y());
        Arrays.sort(ans);
//        for (int i = 0; i < ans.length; i++) {
//             System.out.printf(""\nindex= %d"", ans[i]);
//        }
        return ans;
        //assert isConvex();
    }

    /**
     * Returns the extreme points on the convex hull in counterclockwise order.
     *
     * @return the extreme points on the convex hull in counterclockwise order
     */
    public Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) {
            s.push(p);
        }
        return s;
    }

    /**
     * Unit tests the <tt>ClosestPair</tt> data type. Reads in an integer
     * <tt>N</tt> and <tt>N</tt> points (specified by their <em>x</em>- and
     * <em>y</em>-coordinates) from standard input; computes their convex hull;
     * and prints out the points on the convex hull to standard output.
     */
    public static void main(String[] args) {
//        Point2D[] a = new Point2D[10];
//        a[0] = new Point2D(0.200, 0.250);
//        a[1] = new Point2D(0.147, 0.387);
//        a[2] = new Point2D(0.300, 0.300);
//        a[3] = new Point2D(0.333, 0.213);
//        a[4] = new Point2D(0.353, 0.412);
//        a[5] = new Point2D(0.700, 0.890);
//        a[6] = new Point2D(0.879, 0.700);
//        a[7] = new Point2D(0.867, 0.888);
//        a[8] = new Point2D(0.980, 0.120);
//        a[9] = new Point2D(0.111, 0.120);
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x, y);
//        }
//        MyConvexHull cv = new MyConvexHull();
//        cv.ConvexHullVertex(a);
//        for (Point2D p : graham.hull()) {
//            //StdOut.println(p);
//        }
    }

}

@9f100ac44cacd2ca439f9057303a78a9@"
"r03525006","0","0","0","@685ad154678c79bc99be2a1ba1df3998@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        isConvex[N-1] = N;
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N-1) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N-1) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@685ad154678c79bc99be2a1ba1df3998@"
"r03525006","3","0.47","107680","@d2f7d36708b481f39bd13289c458a351@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N];
        isConvex[N-1] = N;
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@d2f7d36708b481f39bd13289c458a351@"
"r03525006","3","0.52","104336","@a2e1420699837171487a07e4c5c41e92@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N];
        isConvex[N-1] = N;
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ans;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@a2e1420699837171487a07e4c5c41e92@"
"r03849033","5","0.1","107792","@9dc1a3ecd547a46f68cbae77e989e659@

import java.util.Arrays;


public class MyConvexHull {

     public static int[] ConvexHullVertex(Point2D[] a) {
         int N = a.length;
 
         Point2D[] temp = new Point2D[N];
         for (int i = 0; i < N; i++) {
          temp[i]= a[i];
         }
         Arrays.sort(a);
         Point2D p = new Point2D(a[0].x(), a[0].y());
         Arrays.sort(a, p.POLAR_ORDER);
         int[] v = new int[N];
         v[0]=0;
         v[1]=1;     
         int num = 2;
         for (int k = 2; k < N; k++) {
             Point2D aa = a[v[num-2]];
             Point2D b = a[v[num-1]];
             Point2D c = a[k];
             double ccw = (b.x()-aa.x())*(c.y()-aa.y()) - (b.y()-aa.y())*(c.x()-aa.x());  

             if(ccw > 0){

                 v[num]=k;
                 num++;
             } else  {
                 num--;
                 k--;
                 }
         }
         int[] Vertex = new int[num];
         int x = 0;        
         for(int i = 0; i < N; i++) {  
             for(int j = 0; j < num; j++) {
                if (temp[i].distanceTo(a[v[j]])==0){
                    Vertex[x]=i;
                    x++;
                    break;
                }
             }
         }  
         return(Vertex);
    }
    
    
    public static void main(String[] args) {
      
 
    }
}

@9dc1a3ecd547a46f68cbae77e989e659@"
"r04631035","0","0.45","105280","@8d4f1bec8d4d35fa012ed7952ef3b3b9@ public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put((a[i].x() * 100 + a[i].y()), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }
                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get((a[storge.get(count)].x() * 100) + a[storge.get(count)].y());
                    }
                    return output;
          }
@8d4f1bec8d4d35fa012ed7952ef3b3b9@"
"r04631035","0","0.45","105328","@cce64a99ff83f53f5fb798fa643aad1e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.*;
import java.math.*;
import java.awt.Color;

/**
 *
 * @author cypan
 */
public class MyConvexHull {

     public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put((a[i].x() * 100 + a[i].y()), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }
                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get((a[storge.get(count)].x() * 100) + a[storge.get(count)].y());
                    }
                    return output;
          }



    private static void insertionSort_Point(double[][] arr, int col) {

        for (int i = 1; i < arr.length; i++) {
            int col1 = 0;
            int col2 = 0;
            if (col == 0) {
                col1 = 1;
                col2 = 2;
            } else if (col == 1) {
                col1 = 0;
                col2 = 2;
            } else if (col == 2) {
                col1 = 0;
                col2 = 1;
            }
            double valueToSort = arr[i][col];
            double valueNoSort = arr[i][col1];
            double valueNoSort1 = arr[i][col2];
            int j = i;
            while (j > 0 && arr[j - 1][col] > valueToSort) {
                arr[j][col] = arr[j - 1][col];
                arr[j][col1] = arr[j - 1][col1];
                arr[j][col2] = arr[j - 1][col2];
                j--;
            }
            arr[j][col] = valueToSort;
            arr[j][col1] = valueNoSort; //綁定
            arr[j][col2] = valueNoSort1; //綁定

        }
    }

    private static void insertionSort(Point2D[] arr) {
        for (int i = 1; i < arr.length; i++) {
            double valueNoSort = arr[i].x();
            double valueToSort = arr[i].y();
            int j = i;
            while (j > 0 && arr[j - 1].y() > valueToSort) {
                arr[j] = new Point2D(arr[j - 1].x(),arr[j - 1].y());
                j--;
            }
            
            arr[j]= new Point2D(valueNoSort,valueToSort);
            
        }
    }

    public static void printArray(double[][] B, int col) {
        System.out.println(Arrays.toString(B));
    }

    public static void populateArray(int[] B) {
        for (int i = 0; i < B.length; i++) {
            B[i] = (int) (Math.random() * 100);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        int num = StdRandom.uniform(5, 10);
        //double[][] Point2D = new double[num][3];
        Point2D[] A = new Point2D[num];
        int[] f = ConvexHullVertex(A);
        
        System.out.println(A);

        
        for (int i = 0; i < num; i++) {
           
            double x = StdRandom.uniform(0, 1000);
            double y = StdRandom.uniform(0, 1000);
            A[i]=new Point2D(x/1000 ,y/1000);
            StdDraw.circle(A[i].x(), A[i].y(), 0.01);
        }
        MergeX.sort(A, Point2D.Y_ORDER); //哪來的
        //insertionSort(A); //找y軸最低
        StdDraw.setPenColor(new Color(255, 0, 0));   // red
        StdDraw.circle(A[0].x(), A[0].y(), 0.01);
        
        System.out.println(A[0].x());
        System.out.println(A[0].y());
        System.out.println(A[1].x());
        System.out.println(A[1].y());
        System.out.println(A[2].x());
        System.out.println(A[2].y());
        
        MergeX.sort(A, A[0].polarOrder());
        
        for (int i = 1; i < A.length; i++) {
            
            Comparator<Point2D> a = A[i].polarOrder();
            
//            System.out.println();
//            double deg = (double) Math.toDegrees(Math.atan2(A[i].x() - A[0].x(), A[i].y() - A[0].y()));
//            if (deg > 0) {
//                Point2D[i][2] = deg;
//                
//                
//            } else if (deg < 0) {
//                deg = 180 + deg;
//                Point2D[i][2] = deg;
//            }
        }

//        insertionSort_Point(Point2D, 2);

//        System.out.println(Point2D[0][2]);
//        System.out.println(Point2D[1][2]);
//        System.out.println(Point2D[2][2]);
//        System.out.println(Point2D[3][2]);
//        System.out.println(Point2D[4][2]);

    }

}

@cce64a99ff83f53f5fb798fa643aad1e@"
"r04631035","5","0.102","106016","@4f149a3735453b2d53b5f589a8efd545@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
import java.math.*;
import java.awt.Color;

/**
 *
 * @author cypan
 */
public class MyConvexHull {

     public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put((a[i].x() * 100 + a[i].y()), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(), a[0].y());
                    MergeX.sort(a, p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }
                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get((a[storge.get(count)].x() * 100) + a[storge.get(count)].y());
                    }
                    return output;
          }



    private static void insertionSort_Point(double[][] arr, int col) {

        for (int i = 1; i < arr.length; i++) {
            int col1 = 0;
            int col2 = 0;
            if (col == 0) {
                col1 = 1;
                col2 = 2;
            } else if (col == 1) {
                col1 = 0;
                col2 = 2;
            } else if (col == 2) {
                col1 = 0;
                col2 = 1;
            }
            double valueToSort = arr[i][col];
            double valueNoSort = arr[i][col1];
            double valueNoSort1 = arr[i][col2];
            int j = i;
            while (j > 0 && arr[j - 1][col] > valueToSort) {
                arr[j][col] = arr[j - 1][col];
                arr[j][col1] = arr[j - 1][col1];
                arr[j][col2] = arr[j - 1][col2];
                j--;
            }
            arr[j][col] = valueToSort;
            arr[j][col1] = valueNoSort; //綁定
            arr[j][col2] = valueNoSort1; //綁定

        }
    }

    private static void insertionSort(Point2D[] arr) {
        for (int i = 1; i < arr.length; i++) {
            double valueNoSort = arr[i].x();
            double valueToSort = arr[i].y();
            int j = i;
            while (j > 0 && arr[j - 1].y() > valueToSort) {
                arr[j] = new Point2D(arr[j - 1].x(),arr[j - 1].y());
                j--;
            }
            
            arr[j]= new Point2D(valueNoSort,valueToSort);
            
        }
    }

    public static void printArray(double[][] B, int col) {
        System.out.println(Arrays.toString(B));
    }

    public static void populateArray(int[] B) {
        for (int i = 0; i < B.length; i++) {
            B[i] = (int) (Math.random() * 100);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        int num = StdRandom.uniform(5, 10);
        //double[][] Point2D = new double[num][3];
        Point2D[] A = new Point2D[num];
        int[] f = ConvexHullVertex(A);
        
        System.out.println(A);

        
        for (int i = 0; i < num; i++) {
           
            double x = StdRandom.uniform(0, 1000);
            double y = StdRandom.uniform(0, 1000);
            A[i]=new Point2D(x/1000 ,y/1000);
            StdDraw.circle(A[i].x(), A[i].y(), 0.01);
        }
        MergeX.sort(A, Point2D.Y_ORDER); //哪來的
        //insertionSort(A); //找y軸最低
        StdDraw.setPenColor(new Color(255, 0, 0));   // red
        StdDraw.circle(A[0].x(), A[0].y(), 0.01);
        
        System.out.println(A[0].x());
        System.out.println(A[0].y());
        System.out.println(A[1].x());
        System.out.println(A[1].y());
        System.out.println(A[2].x());
        System.out.println(A[2].y());
        
        //MergeX.sort(A, A[0].polarOrder());
        
        for (int i = 1; i < A.length; i++) {
            
      //      Comparator<Point2D> a = A[i].polarOrder();
            
//            System.out.println();
//            double deg = (double) Math.toDegrees(Math.atan2(A[i].x() - A[0].x(), A[i].y() - A[0].y()));
//            if (deg > 0) {
//                Point2D[i][2] = deg;
//                
//                
//            } else if (deg < 0) {
//                deg = 180 + deg;
//                Point2D[i][2] = deg;
//            }
        }

//        insertionSort_Point(Point2D, 2);

//        System.out.println(Point2D[0][2]);
//        System.out.println(Point2D[1][2]);
//        System.out.println(Point2D[2][2]);
//        System.out.println(Point2D[3][2]);
//        System.out.println(Point2D[4][2]);

    }

}

@4f149a3735453b2d53b5f589a8efd545@"
"r03525006","0","0","0","@95e89122c3394d82d463888baa449098@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N+1];
        for (int i = 0; i < N+1; i++)
            isConvex[i] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }
        int[] newisConvex = new int[N-1];
        for (int i = 0; i < isConvex.length-2; i++) {
            newisConvex[i] = isConvex[i+1];
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (newisConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[newisConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@95e89122c3394d82d463888baa449098@"
"r03525006","3","0.5","106048","@ddf4dd2b574f02abf5dfdb9f452166c5@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N+1];
        for (int i = 0; i < N+1; i++)
            isConvex[i] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1]] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }
        int[] newisConvex = new int[N-1];
        for (int i = 0; i < isConvex.length-2; i++) {
            newisConvex[i] = isConvex[i+1];
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (newisConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[newisConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@ddf4dd2b574f02abf5dfdb9f452166c5@"
