"r04945025","9","1.89","231952","@ecef0bfda8ba748a3f56c5940cdc0a56@
import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.ArrayList;

public class CriticalDis {

    static BreadthFirstDirectedPaths check;
    static Pair min;
    static Point2D[] points;

    
    static class Pair implements Comparable<Pair>{
        
        double distance = 0;
        Point2D pointa;
        Point2D pointb;
        int a;
        int b;
        public Pair(int a,int b){
            this.distance = points[a].distance(points[b]);
            this.pointa = points[a];
            this.pointb = points[b];
            this.a = a;
            this.b = b;
        }
        public int compareTo(Pair that) {
            if (this.distance>that.distance)return +1;
            else if (this.distance<that.distance)return -1;
            else return 0;
        }
    }
    public static void main(String[] args) {
        In in = new In(args[0]); // open the input file 
        int N = in.readInt();
        points = new Point2D[N];
        int source = 0;
        int target = 0;
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D.Double(0, 0);
            points[i].setLocation(in.readDouble(), in.readDouble());
            if ((points[i].getX() + points[i].getY()) < (points[source].getX() + points[source].getY())) {
                source = i;
            }
            if ((points[i].getX() + points[i].getY()) > (points[target].getX() + points[target].getY())) {
                target = i;
            }
        }
//        StdDraw.setPenColor(Color.yellow);
//        StdDraw.filledCircle(points[source].getX(), points[source].getY(), 0.01);
//        StdDraw.filledCircle(points[target].getX(), points[target].getY(), 0.01);
//        StdDraw.setPenColor(Color.black);

        Digraph g = new Digraph(N);
        MinPQ<Pair> mpq = new MinPQ<Pair>(N * N / 2);
        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].getX(), points[i].getY(), 0.005);
//            StdDraw.text(points[i].getX()+0.03, points[i].getY()+0.03, Integer.toString(i));
            for (int j = i + 1; j < N; j++) {
                if (points[j].getX() > points[i].getX() && points[j].getY() > points[i].getY()) {
                    mpq.insert(new Pair(i,j));
                } else if (points[i].getX() > points[j].getX() && points[i].getY() > points[j].getY()) {
                    mpq.insert(new Pair(j,i));
                }
            }
        }

        Digraph g2 = new Digraph(N);
        do {
            
            min = mpq.delMin();
            g2.addEdge(min.a, min.b);
//            StdDraw.line(points[min.a].getX(), points[min.a].getY(), points[min.b].getX(), points[min.b].getY());

            check = new BreadthFirstDirectedPaths(g2, source);
        } while (!check.hasPathTo(target));

        
//        System.out.printf(""%1.3f\n"", min);
        
        DepthFirstDirectedPaths bfs = new DepthFirstDirectedPaths(g2, source);
        double dis = 0;
        ArrayList<Integer> al = new ArrayList<Integer>();
        
        for(int point:bfs.pathTo(target)){
            al.add(point);
//            StdOut.print(point+"" "");
            
        }
        for(int i = 0;i<al.size()-1;i++){
            int a = al.get(i);
            dis=dis+points[al.get(i)].distance(points[al.get(i+1)]);
//            StdDraw.setPenColor(Color.yellow);
//            StdDraw.line(points[al.get(i)].getX(), points[al.get(i)].getY(), points[al.get(i+1)].getX(), points[al.get(i+1)].getY());
//            StdOut.print(dis+"" "");
        }
        System.out.printf(""%.3f\n"", dis);
    }
}

@ecef0bfda8ba748a3f56c5940cdc0a56@"
"r04945025","9","1.74","239696","@ecef0bfda8ba748a3f56c5940cdc0a56@
import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.ArrayList;

public class CriticalDis {

    static BreadthFirstDirectedPaths check;
    static Pair min;
    static Point2D[] points;

    
    static class Pair implements Comparable<Pair>{
        
        double distance = 0;
        Point2D pointa;
        Point2D pointb;
        int a;
        int b;
        public Pair(int a,int b){
            this.distance = points[a].distance(points[b]);
            this.pointa = points[a];
            this.pointb = points[b];
            this.a = a;
            this.b = b;
        }
        public int compareTo(Pair that) {
            if (this.distance>that.distance)return +1;
            else if (this.distance<that.distance)return -1;
            else return 0;
        }
    }
    public static void main(String[] args) {
        In in = new In(args[0]); // open the input file 
        int N = in.readInt();
        points = new Point2D[N];
        int source = 0;
        int target = 0;
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D.Double(0, 0);
            points[i].setLocation(in.readDouble(), in.readDouble());
            if ((points[i].getX() + points[i].getY()) < (points[source].getX() + points[source].getY())) {
                source = i;
            }
            if ((points[i].getX() + points[i].getY()) > (points[target].getX() + points[target].getY())) {
                target = i;
            }
        }
//        StdDraw.setPenColor(Color.yellow);
//        StdDraw.filledCircle(points[source].getX(), points[source].getY(), 0.01);
//        StdDraw.filledCircle(points[target].getX(), points[target].getY(), 0.01);
//        StdDraw.setPenColor(Color.black);

        Digraph g = new Digraph(N);
        MinPQ<Pair> mpq = new MinPQ<Pair>(N * N / 2);
        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].getX(), points[i].getY(), 0.005);
//            StdDraw.text(points[i].getX()+0.03, points[i].getY()+0.03, Integer.toString(i));
            for (int j = i + 1; j < N; j++) {
                if (points[j].getX() > points[i].getX() && points[j].getY() > points[i].getY()) {
                    mpq.insert(new Pair(i,j));
                } else if (points[i].getX() > points[j].getX() && points[i].getY() > points[j].getY()) {
                    mpq.insert(new Pair(j,i));
                }
            }
        }

        Digraph g2 = new Digraph(N);
        do {
            
            min = mpq.delMin();
            g2.addEdge(min.a, min.b);
//            StdDraw.line(points[min.a].getX(), points[min.a].getY(), points[min.b].getX(), points[min.b].getY());

            check = new BreadthFirstDirectedPaths(g2, source);
        } while (!check.hasPathTo(target));

        
//        System.out.printf(""%1.3f\n"", min);
        
        DepthFirstDirectedPaths bfs = new DepthFirstDirectedPaths(g2, source);
        double dis = 0;
        ArrayList<Integer> al = new ArrayList<Integer>();
        
        for(int point:bfs.pathTo(target)){
            al.add(point);
//            StdOut.print(point+"" "");
            
        }
        for(int i = 0;i<al.size()-1;i++){
            int a = al.get(i);
            dis=dis+points[al.get(i)].distance(points[al.get(i+1)]);
//            StdDraw.setPenColor(Color.yellow);
//            StdDraw.line(points[al.get(i)].getX(), points[al.get(i)].getY(), points[al.get(i+1)].getX(), points[al.get(i+1)].getY());
//            StdOut.print(dis+"" "");
        }
        System.out.printf(""%.3f\n"", dis);
    }
}

@ecef0bfda8ba748a3f56c5940cdc0a56@"
"r04945025","9","1.9","245472","@1f0e9a2b0647e937e373879cf14a3957@
import java.util.ArrayList;

public class CriticalDis {

    static BreadthFirstDirectedPaths check;
    static Pair min;
    static Point2D[] points;

    
    static class Pair implements Comparable<Pair>{
        
        double distance = 0;
        Point2D pointa;
        Point2D pointb;
        int a;
        int b;
        public Pair(int a,int b){
            this.distance = points[a].distanceTo(points[b]);
            this.pointa = points[a];
            this.pointb = points[b];
            this.a = a;
            this.b = b;
        }
        public int compareTo(Pair that) {
            if (this.distance>that.distance)return +1;
            else if (this.distance<that.distance)return -1;
            else return 0;
        }
    }
    public static void main(String[] args) {
        In in = new In(args[0]); // open the input file 
        int N = in.readInt();
        points = new Point2D[N];
        int source = 0;
        int target = 0;
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(0, 0);
            points[i]=new Point2D(in.readDouble(), in.readDouble());
            if ((points[i].x() + points[i].y()) < (points[source].x() + points[source].y())) {
                source = i;
            }
            if ((points[i].x() + points[i].y()) > (points[target].x() + points[target].y())) {
                target = i;
            }
        }
//        StdDraw.setPenColor(Color.yellow);
//        StdDraw.filledCircle(points[source].getX(), points[source].getY(), 0.01);
//        StdDraw.filledCircle(points[target].getX(), points[target].getY(), 0.01);
//        StdDraw.setPenColor(Color.black);

        Digraph g = new Digraph(N);
        MinPQ<Pair> mpq = new MinPQ<Pair>(N * N / 2);
        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(points[i].getX(), points[i].getY(), 0.005);
//            StdDraw.text(points[i].getX()+0.03, points[i].getY()+0.03, Integer.toString(i));
            for (int j = i + 1; j < N; j++) {
                if (points[j].x() > points[i].x() && points[j].y() > points[i].y()) {
                    mpq.insert(new Pair(i,j));
                } else if (points[i].x() > points[j].x() && points[i].y() > points[j].y()) {
                    mpq.insert(new Pair(j,i));
                }
            }
        }

        Digraph g2 = new Digraph(N);
        do {
            
            min = mpq.delMin();
            g2.addEdge(min.a, min.b);
//            StdDraw.line(points[min.a].getX(), points[min.a].getY(), points[min.b].getX(), points[min.b].getY());

            check = new BreadthFirstDirectedPaths(g2, source);
        } while (!check.hasPathTo(target));

        
//        System.out.printf(""%1.3f\n"", min);
        
        DepthFirstDirectedPaths bfs = new DepthFirstDirectedPaths(g2, source);
        double dis = 0;
        ArrayList<Integer> al = new ArrayList<Integer>();
        
        for(int point:bfs.pathTo(target)){
            al.add(point);
//            StdOut.print(point+"" "");
            
        }
        for(int i = 0;i<al.size()-1;i++){
            int a = al.get(i);
            dis=dis+points[al.get(i)].distanceTo(points[al.get(i+1)]);
//            StdDraw.setPenColor(Color.yellow);
//            StdDraw.line(points[al.get(i)].getX(), points[al.get(i)].getY(), points[al.get(i+1)].getX(), points[al.get(i+1)].getY());
//            StdOut.print(dis+"" "");
        }
        System.out.printf(""%.3f\n"", dis);
    }
}

@1f0e9a2b0647e937e373879cf14a3957@"
"r04945025","10","0.154","204352","@42c3dcde26ef7866d6fd8d83f135a6f1@import java.io.File;
import java.util.Scanner;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;

class Pair implements Comparable<Pair>{
    public Node a, b;
    public boolean s, t;
    public double distance;
    
    public Pair(Node a, Node b, boolean s, boolean t){
        this.a = a;
        this.b = b;
        this.s = s;
        this.t = t;
        this.distance = a.point.distanceTo(b.point);
    }
    
    public int compareTo(Pair that){
        if(this.distance > that.distance) return 1;
        else if(this.distance < that.distance) return -1;
        return 0;
    }
}

class Node{
    public int tmp = 0;
    public Point2D point;
    public ArrayList<Node> next;
    
    public Node(Point2D point){
        this.point = point;
        next = new ArrayList<Node>();
    }
    
    public void addEdge(Node that){
        this.next.add(that);
        this.tmp++;
        that.tmp++;
    }
    
    public boolean search(Node target, boolean flag){
        for(int i = 0; i < next.size(); i++){
            if(next.get(i).point == target.point){
                flag = true;
                break;
            }
            flag = next.get(i).search(target, false);
            if(flag == true)
                break;
        }
        return flag;
    }
}

class Connect{
    public int num;
    public int[] size;
    public int[] index;
    public HashMap<Node, Integer> nodes;

    public Connect(int num){
        this.num = num;
        this.size = new int[num];
        this.index = new int[num];
        this.nodes = new HashMap<Node, Integer>();
        for(int i = 0; i < num; i++){
            size[i] = 1;
            index[i] = i;
        }
    }

    public void setNode(int i, Node node){
        this.nodes.put(node, i);
    }
    
    public int root(int i){
        while(i != this.index[i]){
            i = this.index[i];
        }
        return i;
    }
    
    public boolean connected(Node a, Node b){
        int i = this.root(nodes.get(a));
        int j = this.root(nodes.get(b));
        return this.root(i) == this.root(j);
    }
    
    public void union(Node a, Node b){
        int i = this.root(nodes.get(a));
        int j = this.root(nodes.get(b));
        if(i != j){
            if(this.size[i] <  this.size[j]){
                this.size[j] += this.size[i];
                this.index[i] = j;
            }
            else{
                this.size[i] += this.size[j];
                this.index[j] = i;
            }
        }
    }
}

public class CriticalDis {

    public static int number, k;
    public static Node[] points;
    public static Connect connect;
    public static Node source, target;
    public static ArrayList<Pair> pairs = new ArrayList<Pair>();
    
    public static void main(String[] argv) throws Exception{
        double startTime = System.currentTimeMillis();
        
        String[] tmp;
        File file = new File(argv[0]);
        Scanner scanner = new Scanner(file);
        number = Integer.parseInt(scanner.nextLine());

        points = new Node[number];
        connect = new Connect(number);
        
        double min = 2.0;
        double max = 0.0;
        int sidx = 0;
        int tidx = 0;
        
        for(int i = 0; i < number; i++){
            tmp = scanner.nextLine().split("" "");
            double x = Double.parseDouble(tmp[0]);
            double y = Double.parseDouble(tmp[1]);
            Point2D point = new Point2D(x, y);
            Node node = new Node(point);
            if(x + y <= min){
                min = x + y;
                source = node;
                sidx = i;
            }
            if(x + y >= max){
                max = x + y;
                target = node;
                tidx = i;
            }
            //System.out.printf(""(%3.3f, %3.3f)\n"", x, y);
            points[i] = node;
            /*StdDraw.setPenColor(StdDraw.GRAY);
            StdDraw.filledCircle(point.x(), point.y(), 0.005);*/
            connect.setNode(i, node);
        }
        
        for(int i = 0; i < number - 1; i++){
            for(int j = i + 1; j < number; j++){
                Pair pair = null;
                boolean s = false;
                boolean t = false;
                Node a = points[i];
                Node b = points[j];
                
                if(a.point == source.point || b.point == source.point)
                    s = true;
                if(a.point == target.point || b.point == target.point)
                    t = true;
                if(a.point.x() < b.point.x() && a.point.y() < b.point.y())
                    pair = new Pair(a, b, s, t);
                else if(a.point.x() > b.point.x() && a.point.y() > b.point.y())
                    pair = new Pair(b, a, s, t);
                if(pair != null)
                    pairs.add(pair);
            }
        }
        
        double estimatedTime = System.currentTimeMillis() - startTime;
        // System.out.printf(""%3.3f\n"", estimatedTime / 1000);
        
        Collections.sort(pairs);
        double count = 0;
        boolean s = false;
        boolean t = false;
        double baseline = pairs.get(pairs.size()-1).distance;
        
        for(int i = 0; i < pairs.size(); i++){
            Node a = pairs.get(i).a;
            Node b = pairs.get(i).b;
            count += pairs.get(i).distance;
            Point2D pa = pairs.get(i).a.point;
            Point2D pb = pairs.get(i).b.point;
            
            if(!(pa.x() < pb.x() && pa.y() < pb.y())){
                System.out.println(""Error"");
            }
            
            /*StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.filledCircle(pairs.get(i).a.point.x(), pairs.get(i).a.point.y(), 0.005);
            StdDraw.filledCircle(pairs.get(i).b.point.x(), pairs.get(i).b.point.y(), 0.005);
            StdDraw.setPenColor(StdDraw.GREEN);
            StdDraw.line(pa.x(), pa.y(), pb.x(), pb.y());
            StdDraw.setPenColor(StdDraw.BLUE);*/
            //StdDraw.text((pa.x() + pb.x()) / 2, (pa.y() + pb.y()) / 2, String.valueOf(i + 1));
            
            a.addEdge(b);
            connect.union(a, b);
            
            if(pairs.get(i).s == true && s == false)
                s = true;
            if(pairs.get(i).t == true && t == false)
                t = true;
            
            boolean flag = false;
            if(count >= baseline && s == true && t == true){
                if(flag == true || connect.connected(source, target)){
                    flag = true;
                    if(source.search(target, false)){
                        System.out.printf(""%1.3f\n"", pairs.get(i).distance);
                        break;
                    }
                }
            }
        }
        
        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(source.point.x(), source.point.y(), 0.005);
        StdDraw.setPenColor(StdDraw.MAGENTA);
        StdDraw.filledCircle(target.point.x(), target.point.y(), 0.005);
        StdDraw.setPenColor(StdDraw.GREEN);*/
        
        estimatedTime = System.currentTimeMillis() - startTime;
        //System.out.printf(""%3.3f\n"", estimatedTime / 1000);
    }
}


@42c3dcde26ef7866d6fd8d83f135a6f1@"
"r04447001","10","0.121","216768","@e1cbe51cfa4cf0d1014ce9fb901c9828@import java.io.BufferedReader;
import java.io.FileReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class CriticalDis {
    
        public static class Event implements Comparable<Event> {

        public double distance;         // time that event is scheduled to occur
        int a, b;       // particles involved in event, possibly null

        // create a new event to occur at time t involving a and b
        public Event(double d, int a, int b) {
            this.distance = d;
            this.a = a;
            this.b = b;
        }

        // compare times when two events will occur
        public int compareTo(Event that) {
            if (this.distance < that.distance) {
                return -1;
            } else if (this.distance > that.distance) {
                return +1;
            } else {
                return 0;
            }
        }
    }//use priority queue to sort the distance
        
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String init = br.readLine();
            int total_number = Integer.parseInt(init);
            Point2D[] total_p = new Point2D[total_number];
            int current = 0;
            for (String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split(""\\s+"");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                total_p[current++] = new Point2D(x, y);
            }
            int source_N = 0;
            int target_N = 0;
            for(int i = 0; i < total_number; i++){
                if((total_p[i].x()+total_p[i].y()) < (total_p[source_N].x()+total_p[source_N].y())) {source_N = i;}
                if((total_p[i].x()+total_p[i].y()) > (total_p[target_N].x()+total_p[target_N].y())) {target_N = i;}
            }
            MinPQ<CriticalDis.Event> pq= new MinPQ<CriticalDis.Event>();
            for(int i = 0; i < total_number; i++){
                for(int j = 1; j <  total_number; j++){
                    if((total_p[i].x() < total_p[j].x()) && (total_p[i].y() < total_p[j].y())){
                    pq.insert(new CriticalDis.Event(total_p[i].distanceTo(total_p[j]), i, j));
                    }
                }
            }
            Digraph graph = new Digraph(total_number);
            double dist = 2.0;
            while(pq.size() > 0){
                CriticalDis.Event currentEvent = pq.delMin();
                if(currentEvent.distance > dist){break;}
                graph.addEdge(currentEvent.a, currentEvent.b);
                DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(graph, source_N);
                if(dfs.hasPathTo(target_N)){
                    double newDist = total_p[currentEvent.a].distanceTo(total_p[currentEvent.b]);
                    if(newDist < dist) dist = newDist;
                    /*Queue<Integer> q = new Queue<Integer>();
                    double newDist = 2.0;
                    for(int s:dfs.pathTo(target_N)){
                        q.enqueue(s);
                        System.out.println(s);
                    }
                    while (q.size() > 1) {
                        int first = q.dequeue();
                        int second = q.peek();
                        System.out.println(first+"" ""+second+"" ""+total_p[first].distanceTo(total_p[second]));
                        if(total_p[first].distanceTo(total_p[second]) < newDist ){
                            newDist = total_p[first].distanceTo(total_p[second]);
                            if(newDist < dist){
                                dist = newDist;
                            }
                        }*/
                    }
                }
            System.out.printf(""%1.3f\n"", dist);
            }
            }
        }

@e1cbe51cfa4cf0d1014ce9fb901c9828@"
"r04546032","8","0.98","111920","@b9f9819b1cf143cdc020f1d271ea8c6b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Graph graph ;
    private static DepthFirstPaths dfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Graph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            dfs = new DepthFirstPaths(graph,start);
            // create all path
            double d = 0;
            List<Double> distance = new ArrayList<Double>();
            for(int i = 0; i < AllPoint.length ;i++)
            {
                for(int j = 0; j < AllPoint.length ;j++)
                {
                    if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()))
                    {
                        //graph.addEdge(i, j);
                        distance.add(AllPoint[i].distanceTo(AllPoint[j]));
                    }
                }               
            }
            double dis [] = new double[distance.size()];
            for(int a = 0; a < distance.size();a++)
            {
                dis[a] = distance.get(a);
            }
            Arrays.sort(dis);
            int count = 0;
            boolean flag = false;
            while(flag==false)
            {
              graph = new Graph(Totalpoints);
              d = dis[count];  
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DepthFirstPaths(graph,start);
              flag = dfs.hasPathTo(end);
              count++;
            }
//            List<Integer> sources = new ArrayList<Integer>();
//
//             for (int x : bfs.pathTo(end)) 
//             {
//                 sources.add(x);
//             }
//             double d = 0;
//            for(int a = 0; a < sources.size()-1;a++)
//            {
//                d+=AllPoint[sources.get(a)].distanceTo(AllPoint[sources.get(a+1)]);
//            }
            
                   
            System.out.printf(""%1.3f\n"", dis[count-2]);
    }  
}

@b9f9819b1cf143cdc020f1d271ea8c6b@"
"r04546032","8","0.99","115168","@099fe00a4b089c2bbe2c3bd290ecedd7@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Graph graph ;
    private static DepthFirstPaths dfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Graph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            dfs = new DepthFirstPaths(graph,start);
            // create all path
            double d = 0;
            List<Double> distance = new ArrayList<Double>();
            for(int i = 0; i < AllPoint.length ;i++)
            {
                for(int j = 0; j < AllPoint.length ;j++)
                {
                    if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()))
                    {
                        //graph.addEdge(i, j);
                        distance.add(AllPoint[i].distanceTo(AllPoint[j]));
                    }
                }               
            }
            double dis [] = new double[distance.size()];
            for(int a = 0; a < distance.size();a++)
            {
                dis[a] = distance.get(a);
            }
            Arrays.sort(dis);
            int count = 0;
            double last = 0;
            boolean flag = false;
            while(flag == false)
            {
              graph = new Graph(Totalpoints);
              d = dis[++count];  
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DepthFirstPaths(graph,start);
              flag = dfs.hasPathTo(end);

          
            }
//            List<Integer> sources = new ArrayList<Integer>();
//
//             for (int x : bfs.pathTo(end)) 
//             {
//                 sources.add(x);
//             }
//             double d = 0;
//            for(int a = 0; a < sources.size()-1;a++)
//            {
//                d+=AllPoint[sources.get(a)].distanceTo(AllPoint[sources.get(a+1)]);
//            }
            
                   
            System.out.printf(""%1.3f\n"", dis[count-1]);
    }  
}

@099fe00a4b089c2bbe2c3bd290ecedd7@"
"r04228002","0","0.4","110752","@dbf3492e5ab7a336fbc2a1d32b7cc3af@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 *
 * @author Lenovo
 */
public class FindNeighbors {
    public Node root;
    private MaxPQ<Pair> MPQ;
    
    public void init(Point2D[] points){
        root = new Node(points[0],null,null,1);
        for (int i=1;i<points.length;i++){
            put(points[i]);
        }
        return;
    }
    
    public Point2D[] query(Point2D point, int k){
        MPQ = new MaxPQ<Pair>(k);
        root = search(point,root,k);
        Point2D[] result = new Point2D[k];
        for (int i=0;i<k;i++){
            Point2D p = MPQ.delMax().neighbor;
            result[k-1-i]=p;
        }
        return result;
    // the points should be sorted accordingly to their distances to the query, from small to large
    }
////////////////////////////////////////////////////////////////////////////////   
    private class Node{
        private Point2D loc;
        private Node left;
        private Node right;
        private Integer dir;
        public Node(Point2D p, Node l, Node r, Integer d){
            this.loc=p;
            this.left=l;
            this.right=r;
            this.dir=d;
            
        }
    }  
////////////////////////////////////////////////////////////////////////////////
    private static class Pair implements Comparable<Pair>{
        public Point2D neighbor;
        public double dis;
        public Pair(Point2D p, double dis){
            this.neighbor = p;
            this.dis = dis;
        }
        public int compareTo(Pair that){
            if (this.dis > that.dis){return 1;}
            else if (this.dis < that.dis){return -1;}
            else{return 0;}
        }
        
        public Point2D getNeighbor(){
            return this.neighbor;
        }
        public double getDis(){
            return this.dis;
        } 
    }

////////////////////////////////////////////////////////////////////////////////

    public void put(Point2D LOC){
        root = put(root,LOC,1);
    }
    private Node put(Node n,Point2D point,Integer dir){
        
        if (n==null) {
            return new Node(point,null,null,dir);
        }
        Integer cmp;
        if (dir==1){
            cmp=compare(point.x(),n.loc.x());
            dir=0;
        }
        else {
            cmp=compare(point.y(),n.loc.y());
            dir=1;
        }
        
        if (cmp <= 0){
            n.left=put(n.left, point, dir);
        }
        else if (cmp > 0){
            n.right=put(n.right, point, dir);
        }
        return n;
    }
    
    private Integer compare(double a,double b){
        if (a<b){return -1;}
        else if (a>b){ return 1;}
        else{return 0;}
    }
    
    public Node search(Point2D point, Node n, Integer k){
        if (n==null) return null;
        
        Integer cmp;
        if (MPQ.size()==k){
            Pair MaxPair = MPQ.max();
            double distance;
            if (n.dir == 1){
                cmp = compare(point.x(),n.loc.x());
                if (cmp > 0){distance = point.x()-n.loc.x();}
                else {distance = n.loc.x()-point.x();}
            }
            else{
                cmp = compare(point.y(),n.loc.y());
                if (cmp > 0){distance = point.y()-n.loc.y();}
                else {distance = n.loc.y()-point.y();}       
            }
            if (distance > MaxPair.dis){return n;}
            else {
                distance = point.distanceTo(n.loc);
                if (distance < MaxPair.dis){
                    MPQ.delMax();
                    MPQ.insert(new Pair(n.loc,distance));
                }
                if (cmp > 0){
                    n.right=search(point,n.right,k);
                    n.left=search(point,n.left,k);
                }
                else{
                    n.left=search(point,n.left,k);
                    n.right=search(point,n.right,k);
                }
            }
        }

        else{
            Pair pair = new Pair(n.loc,point.distanceTo(n.loc));
            MPQ.insert(pair);
            if (n.dir==1){
                cmp = compare(point.x(),n.loc.x());
            }
            else{
                cmp = compare(point.y(),n.loc.y());
            }
            if (cmp > 0){
                n.right=search(point,n.right,k);
                n.left=search(point,n.left,k);
            }
            else{
                n.left=search(point,n.left,k);
                n.right=search(point,n.right,k);
            }
        }
        return n;
    }
////////////////////////////////////////////////////////////////////////////////
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        // TODO code application logic here
        ArrayList<Point2D> PA = new ArrayList<Point2D>();
        Point2D Target;
        Integer k;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String temp_target = br.readLine();
            String[] temp_target_list=temp_target.split("" "");
            Target = new Point2D(Double.parseDouble(temp_target_list[0]),Double.parseDouble(temp_target_list[1]));
            
            String nei = br.readLine();
            //String[] temp_nei=nei.split("" "");
            k = Integer.parseInt(nei);
            
            String temp;
            while((temp = br.readLine())!=null){
                String[] split_temp=temp.split("" "");
                Point2D p = new Point2D(Double.parseDouble(split_temp[0]),Double.parseDouble(split_temp[1]));
                PA.add(p);
            }
        }
        
        Point2D[] PList = PA.toArray(new Point2D[PA.size()]);
        
        FindNeighbors find = new FindNeighbors();
        find.init(PList);
        /*
        Node root = find.root;
        Node L1 = root.right;
        Node L1L = L1.right.right;
        System.out.println(L1L.loc.x());
        System.out.println(L1L.loc.y());
        */     
        
        
        Point2D[] result = find.query(Target,k);
        
        for (int i=0;i<k;i++){
            System.out.println(result[i].x());
            System.out.println(result[i].y());
            System.out.println(""stop"");
        }
                
                
    }
    
}

@dbf3492e5ab7a336fbc2a1d32b7cc3af@"
"r04546032","8","0.98","115840","@099fe00a4b089c2bbe2c3bd290ecedd7@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Graph graph ;
    private static DepthFirstPaths dfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Graph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            dfs = new DepthFirstPaths(graph,start);
            // create all path
            double d = 0;
            List<Double> distance = new ArrayList<Double>();
            for(int i = 0; i < AllPoint.length ;i++)
            {
                for(int j = 0; j < AllPoint.length ;j++)
                {
                    if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()))
                    {
                        //graph.addEdge(i, j);
                        distance.add(AllPoint[i].distanceTo(AllPoint[j]));
                    }
                }               
            }
            double dis [] = new double[distance.size()];
            for(int a = 0; a < distance.size();a++)
            {
                dis[a] = distance.get(a);
            }
            Arrays.sort(dis);
            int count = 0;
            double last = 0;
            boolean flag = false;
            while(flag == false)
            {
              graph = new Graph(Totalpoints);
              d = dis[++count];  
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DepthFirstPaths(graph,start);
              flag = dfs.hasPathTo(end);

          
            }
//            List<Integer> sources = new ArrayList<Integer>();
//
//             for (int x : bfs.pathTo(end)) 
//             {
//                 sources.add(x);
//             }
//             double d = 0;
//            for(int a = 0; a < sources.size()-1;a++)
//            {
//                d+=AllPoint[sources.get(a)].distanceTo(AllPoint[sources.get(a+1)]);
//            }
            
                   
            System.out.printf(""%1.3f\n"", dis[count-1]);
    }  
}

@099fe00a4b089c2bbe2c3bd290ecedd7@"
"r04546032","8","1.01","118416","@63699af3d92c87cbfcdad23642b0ac20@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Graph graph ;
    private static DepthFirstPaths dfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Graph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            dfs = new DepthFirstPaths(graph,start);
            // create all path
            double d = 0;
            List<Double> distance = new ArrayList<Double>();
            for(int i = 0; i < AllPoint.length ;i++)
            {
                for(int j = 0; j < AllPoint.length ;j++)
                {
                    if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()))
                    {
                        //graph.addEdge(i, j);
                        distance.add(AllPoint[i].distanceTo(AllPoint[j]));
                    }
                }               
            }
            double dis [] = new double[distance.size()];
            for(int a = 0; a < distance.size();a++)
            {
                dis[a] = distance.get(a);
            }
            Arrays.sort(dis);
            int count = 0;
            double last = 0;
            boolean flag = false;
            while(flag == false)
            {
              last = d;
              graph = new Graph(Totalpoints);
              d = dis[++count];  
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DepthFirstPaths(graph,start);
              flag = dfs.hasPathTo(end);

          
            }

            
                   
            System.out.printf(""%1.3f\n"", last);
    }  
}

@63699af3d92c87cbfcdad23642b0ac20@"
"r04921094","0","0","0","@598d441688077baa278ca946d2438bbe@// author: ymy

//import edu.princeton.cs.algs4.*;
import java.util.HashSet;
import java.util.Arrays;

class CirtialDis {

	private Point2D[] points;
	private MinPQ<Distance> disPQ;						// all the points dis between two points
	private int source = 0, destination = 0;
	private int pointNum;
	private boolean[] mark;
	private double d = 0;
	
	public CirtialDis(Point2D[] points_){
		points = points_;
		Arrays.sort(points);
		pointNum = points.length;
		mark = new boolean[pointNum];
		disPQ = new MinPQ<Distance>();

		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for(int i = 0; i < pointNum; i++){
			double sum = points[i].x() + points[i].y();
			if(sum < min){
				min = sum;
				source = i;
			}
			if(sum > max){
				max = sum;
				destination = i;
			}
		}

		for(int i = source+1; i < pointNum; i++){
			if(points[i].x() > points[source].x()){
				disPQ.insert(new Distance(points[source], source, points[i], i));
			}
			mark[source] = true;
		}
		
		// for(int i = 0; i < pointNum; i++){
		// 	for(int j = i + 1; j < pointNum; j++){
		// 		pointsDis[disFlag++] = points[i].distanceTo(points[j]);
		// 	}
		// }
		// Arrays.sort(pointsDis);
	}
	
	public double findDis(){
		while(!disPQ.isEmpty()){
			Distance dis = disPQ.delMin();
			if(dis.distance > d){
				d = dis.distance;
			}
			int index = dis.largerIndex;

			if(index == destination){
				break;
			}

			if(mark[index] == false){
				mark[index] = true;
				for(int i = dis.largerIndex + 1; i < pointNum; i++){
					if(points[i].x() > points[index].x()){
						disPQ.insert(new Distance(points[index], index, points[i], i));
					}
				}
			}
		}
		return d;
	}
	private class Distance implements Comparable<Distance>{
		public Point2D smaller;
		public Point2D larger;
		public double distance;
		public int smallerIndex;
		public int largerIndex;

		public Distance(Point2D smaller_, int smallerIndex_, Point2D larger_, int largerIndex_){
			smaller = smaller_;
			larger = larger_;
			smallerIndex = smallerIndex_;
			largerIndex = largerIndex_;
			distance = smaller.distanceTo(larger);
		}

		public int compareTo(Distance that){
			if(this.distance < that.distance) return -1;
            if(this.distance > that.distance) return +1;
            else return 0;
		}
	}
	
	public static void main(String [] args){
		int lineNum;
		Point2D[] points;
		
		In in = new In(args[0]);
		lineNum = Integer.parseInt(in.readLine());
		points = new Point2D[lineNum];
		
		for(int i = 0; i<lineNum; i++){
			String[] xy;
			xy = in.readLine().split("" "");
			points[i] = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
		}
		
		CirtialDis cirtialDis = new CirtialDis(points);
		System.out.printf(""%1.3f\n"", cirtialDis.findDis());
	}
}
@598d441688077baa278ca946d2438bbe@"
"r04921094","0","0","0","@598d441688077baa278ca946d2438bbe@// author: ymy

//import edu.princeton.cs.algs4.*;
import java.util.HashSet;
import java.util.Arrays;

class CirtialDis {

	private Point2D[] points;
	private MinPQ<Distance> disPQ;						// all the points dis between two points
	private int source = 0, destination = 0;
	private int pointNum;
	private boolean[] mark;
	private double d = 0;
	
	public CirtialDis(Point2D[] points_){
		points = points_;
		Arrays.sort(points);
		pointNum = points.length;
		mark = new boolean[pointNum];
		disPQ = new MinPQ<Distance>();

		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for(int i = 0; i < pointNum; i++){
			double sum = points[i].x() + points[i].y();
			if(sum < min){
				min = sum;
				source = i;
			}
			if(sum > max){
				max = sum;
				destination = i;
			}
		}

		for(int i = source+1; i < pointNum; i++){
			if(points[i].x() > points[source].x()){
				disPQ.insert(new Distance(points[source], source, points[i], i));
			}
			mark[source] = true;
		}
		
		// for(int i = 0; i < pointNum; i++){
		// 	for(int j = i + 1; j < pointNum; j++){
		// 		pointsDis[disFlag++] = points[i].distanceTo(points[j]);
		// 	}
		// }
		// Arrays.sort(pointsDis);
	}
	
	public double findDis(){
		while(!disPQ.isEmpty()){
			Distance dis = disPQ.delMin();
			if(dis.distance > d){
				d = dis.distance;
			}
			int index = dis.largerIndex;

			if(index == destination){
				break;
			}

			if(mark[index] == false){
				mark[index] = true;
				for(int i = dis.largerIndex + 1; i < pointNum; i++){
					if(points[i].x() > points[index].x()){
						disPQ.insert(new Distance(points[index], index, points[i], i));
					}
				}
			}
		}
		return d;
	}
	private class Distance implements Comparable<Distance>{
		public Point2D smaller;
		public Point2D larger;
		public double distance;
		public int smallerIndex;
		public int largerIndex;

		public Distance(Point2D smaller_, int smallerIndex_, Point2D larger_, int largerIndex_){
			smaller = smaller_;
			larger = larger_;
			smallerIndex = smallerIndex_;
			largerIndex = largerIndex_;
			distance = smaller.distanceTo(larger);
		}

		public int compareTo(Distance that){
			if(this.distance < that.distance) return -1;
            if(this.distance > that.distance) return +1;
            else return 0;
		}
	}
	
	public static void main(String [] args){
		int lineNum;
		Point2D[] points;
		
		In in = new In(args[0]);
		lineNum = Integer.parseInt(in.readLine());
		points = new Point2D[lineNum];
		
		for(int i = 0; i<lineNum; i++){
			String[] xy;
			xy = in.readLine().split("" "");
			points[i] = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
		}
		
		CirtialDis cirtialDis = new CirtialDis(points);
		System.out.printf(""%1.3f\n"", cirtialDis.findDis());
	}
}
@598d441688077baa278ca946d2438bbe@"
"r04921094","0","0","0","@6df56f904d2c5ba16c3b27ce0794bee0@// author: ymy

//import edu.princeton.cs.algs4.*;
import java.util.HashSet;
import java.util.Arrays;

class CritialDis {

	private Point2D[] points;
	private MinPQ<Distance> disPQ;						// all the points dis between two points
	private int source = 0, destination = 0;
	private int pointNum;
	private boolean[] mark;
	private double d = 0;
	
	public CritialDis(Point2D[] points_){
		points = points_;
		Arrays.sort(points);
		pointNum = points.length;
		mark = new boolean[pointNum];
		disPQ = new MinPQ<Distance>();

		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for(int i = 0; i < pointNum; i++){
			double sum = points[i].x() + points[i].y();
			if(sum < min){
				min = sum;
				source = i;
			}
			if(sum > max){
				max = sum;
				destination = i;
			}
		}

		for(int i = source+1; i < pointNum; i++){
			if(points[i].x() > points[source].x()){
				disPQ.insert(new Distance(points[source], source, points[i], i));
			}
			mark[source] = true;
		}
		
		// for(int i = 0; i < pointNum; i++){
		// 	for(int j = i + 1; j < pointNum; j++){
		// 		pointsDis[disFlag++] = points[i].distanceTo(points[j]);
		// 	}
		// }
		// Arrays.sort(pointsDis);
	}
	
	public double findDis(){
		while(!disPQ.isEmpty()){
			Distance dis = disPQ.delMin();
			if(dis.distance > d){
				d = dis.distance;
			}
			int index = dis.largerIndex;

			if(index == destination){
				break;
			}

			if(mark[index] == false){
				mark[index] = true;
				for(int i = dis.largerIndex + 1; i < pointNum; i++){
					if(points[i].x() > points[index].x()){
						disPQ.insert(new Distance(points[index], index, points[i], i));
					}
				}
			}
		}
		return d;
	}
	private class Distance implements Comparable<Distance>{
		public Point2D smaller;
		public Point2D larger;
		public double distance;
		public int smallerIndex;
		public int largerIndex;

		public Distance(Point2D smaller_, int smallerIndex_, Point2D larger_, int largerIndex_){
			smaller = smaller_;
			larger = larger_;
			smallerIndex = smallerIndex_;
			largerIndex = largerIndex_;
			distance = smaller.distanceTo(larger);
		}

		public int compareTo(Distance that){
			if(this.distance < that.distance) return -1;
            if(this.distance > that.distance) return +1;
            else return 0;
		}
	}
	
	public static void main(String [] args){
		int lineNum;
		Point2D[] points;
		
		In in = new In(args[0]);
		lineNum = Integer.parseInt(in.readLine());
		points = new Point2D[lineNum];
		
		for(int i = 0; i<lineNum; i++){
			String[] xy;
			xy = in.readLine().split("" "");
			points[i] = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
		}
		
		CritialDis critialDis = new CritialDis(points);
		System.out.printf(""%1.3f\n"", critialDis.findDis());
	}
}
@6df56f904d2c5ba16c3b27ce0794bee0@"
"r04921094","10","0.136","153424","@2f84dfe8af57b26f41835aa4c30949ee@// author: ymy

//import edu.princeton.cs.algs4.*;
import java.util.HashSet;
import java.util.Arrays;

class CriticalDis {

	private Point2D[] points;
	private MinPQ<Distance> disPQ;						// all the points dis between two points
	private int source = 0, destination = 0;
	private int pointNum;
	private boolean[] mark;
	private double d = 0;
	
	public CriticalDis(Point2D[] points_){
		points = points_;
		Arrays.sort(points);
		pointNum = points.length;
		mark = new boolean[pointNum];
		disPQ = new MinPQ<Distance>();

		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for(int i = 0; i < pointNum; i++){
			double sum = points[i].x() + points[i].y();
			if(sum < min){
				min = sum;
				source = i;
			}
			if(sum > max){
				max = sum;
				destination = i;
			}
		}

		for(int i = source+1; i < pointNum; i++){
			if(points[i].x() > points[source].x()){
				disPQ.insert(new Distance(points[source], source, points[i], i));
			}
			mark[source] = true;
		}
		
		// for(int i = 0; i < pointNum; i++){
		// 	for(int j = i + 1; j < pointNum; j++){
		// 		pointsDis[disFlag++] = points[i].distanceTo(points[j]);
		// 	}
		// }
		// Arrays.sort(pointsDis);
	}
	
	public double findDis(){
		while(!disPQ.isEmpty()){
			Distance dis = disPQ.delMin();
			if(dis.distance > d){
				d = dis.distance;
			}
			int index = dis.largerIndex;

			if(index == destination){
				break;
			}

			if(mark[index] == false){
				mark[index] = true;
				for(int i = dis.largerIndex + 1; i < pointNum; i++){
					if(points[i].x() > points[index].x()){
						disPQ.insert(new Distance(points[index], index, points[i], i));
					}
				}
			}
		}
		return d;
	}
	private class Distance implements Comparable<Distance>{
		public Point2D smaller;
		public Point2D larger;
		public double distance;
		public int smallerIndex;
		public int largerIndex;

		public Distance(Point2D smaller_, int smallerIndex_, Point2D larger_, int largerIndex_){
			smaller = smaller_;
			larger = larger_;
			smallerIndex = smallerIndex_;
			largerIndex = largerIndex_;
			distance = smaller.distanceTo(larger);
		}

		public int compareTo(Distance that){
			if(this.distance < that.distance) return -1;
            if(this.distance > that.distance) return +1;
            else return 0;
		}
	}
	
	public static void main(String [] args){
		int lineNum;
		Point2D[] points;
		
		In in = new In(args[0]);
		lineNum = Integer.parseInt(in.readLine());
		points = new Point2D[lineNum];
		
		for(int i = 0; i<lineNum; i++){
			String[] xy;
			xy = in.readLine().split("" "");
			points[i] = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
		}
		
		CriticalDis criticalDis = new CriticalDis(points);
		System.out.printf(""%1.3f\n"", criticalDis.findDis());
	}
}
@2f84dfe8af57b26f41835aa4c30949ee@"
"r03525008","9","1.35","120304","@169f2c7da252c51408b94d4184978935@import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by Yang, Chi-Chang on 2016/6/6.
 */
public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int v = in.readInt();
        Point2D[] points = new Point2D[v];
        for (int i = 0 ; i < v ; i++){
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<Double> dists = new ArrayList<Double>();
        for (int i = 0; i < points.length; i++) {
            for (int j = i+1; j < points.length; j++) {
                dists.add(points[i].distanceTo(points[j]));
            }
        }
        Double[] distances = dists.toArray(new Double[dists.size()]);
        Arrays.sort(distances);

        Digraph digraph = new Digraph(v);


        for (double d:distances){
            for (int i = 0; i < points.length; i++) {
                Point2D p1 = points[i];
                for (int j = 0; j < points.length; j++) {
                    Point2D p2 = points[j];
                    if (p1.x() < p2.x() && p1.y() < p2.y()) {
                        if (p1.distanceTo(p2) <= d) {
                            digraph.addEdge(i,j);
                        }
                    }
                }
            }
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",d));
                break;
            }
        }

    }
}

@169f2c7da252c51408b94d4184978935@"
"r04921051","10","0.172","212592","@db980b1d4ce3e8f7db428972df8ed9f8@import java.util.*;

public class CriticalDis {

   public static void main(String[] args){
        
 
            In in = new In(args[0]);
            
            String data = in.readLine();            
            int n = Integer.parseInt(data);
            
            Digraph g = new Digraph(n);
            
            String[] in_str = new String[n];
            Point2D[] points = new Point2D[n];
            
            for(int i = 0; i < n; i++){
                in_str = in.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(in_str[0]),Double.parseDouble(in_str[1]));
            }
            
            List<dist> p;
            p = new ArrayList<>();
            
            for(int v = 0; v < n; v++){
                for(int w = 0; w < n; w++){
                    if(v != w){
                        if((points[v].x() < points[w].x()) && (points[v].y() < points[w].y()))
                            p.add(new dist(points[v].distanceTo(points[w]),v,w));
                    }
                }
            }
            
            dist[] d = p.toArray(new dist[p.size()]);
            Arrays.sort(d);
            
            int s = 0;
            int t = 0;
            
            double s_temp = Double.MAX_VALUE;
            double t_temp = Double.MIN_VALUE;
            
            for(int i = 0; i < n; i++){
                if(points[i].x() + points[i].y() < s_temp){
                    s_temp = points[i].x() + points[i].y();
                    s = i;
                }
                if(points[i].x() + points[i].y() > t_temp){
                    t_temp = points[i].x() + points[i].y();
                    t = i;
                }        
            }
            
            
            
            
            
            for(int i = 0; i < d.length; i++){
                g.addEdge(d[i].geti(), d[i].getj()); 
                DirectedDFS dfs = new DirectedDFS(g,s);
                if(dfs.marked(t)){
                    System.out.printf(""%1.3f\n"", d[i].getd());
                    break;
                }                            
            }
            
            
            
            
            
            

            

 
        
    
    

        
    }  
   
    public static class dist implements Comparable<dist>{
        private final double d;
        private final int i;
        private final int j;
        
        public dist(double d, int i, int j){
            this.d = d;
            this.i = i;
            this.j = j;
        }
        
        public double getd(){
            return d;
        }
        
        public int geti(){
            return i;
        }

        public int getj(){
            return j;
        }        
        
        public void print(){
            System.out.printf(""( %d , %d ) d = %1.3f\n"",i,j,d);
        }
        
        @Override
        public int compareTo(dist that) {
        if (this.d < that.d) return -1;
        if (this.d > that.d) return +1;
        return 0;
         }


    }
    
}

@db980b1d4ce3e8f7db428972df8ed9f8@"
"r03525008","9","1.27","116960","@80db26e149eb1704ff45ab461dc933e0@import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by Yang, Chi-Chang on 2016/6/6.
 */
public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int v = in.readInt();
        Point2D[] points = new Point2D[v];
        for (int i = 0 ; i < v ; i++){
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<DistanceEvent> distanceArray = new ArrayList<DistanceEvent>();
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points.length; j++) {
                distanceArray.add(new DistanceEvent(points[i].distanceTo(points[j]),i,j));
            }
        }
        DistanceEvent[] distanceEvents = distanceArray.toArray(new DistanceEvent[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (DistanceEvent distanceEvent:distanceEvents){
            Point2D p1 = points[distanceEvent.i];
            Point2D p2 = points[distanceEvent.j];
            if (p1.x() < p2.x() && p1.y() < p2.y()) {
                digraph.addEdge(distanceEvent.i,distanceEvent.j);
            }

            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }

    }

    static class DistanceEvent implements Comparable<DistanceEvent>{
        double d;
        int i;
        int j;
        public DistanceEvent(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(DistanceEvent o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}

@80db26e149eb1704ff45ab461dc933e0@"
"r03525008","10","0.188","236256","@06b9c3881b218e55d662b68ef74724f2@import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by Yang, Chi-Chang on 2016/6/6.
 */
public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int v = in.readInt();
        Point2D[] points = new Point2D[v];
        for (int i = 0 ; i < v ; i++){
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<DistanceEvent> distanceArray = new ArrayList<DistanceEvent>();
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points.length; j++) {
                if (points[i].x() < points[j].x() && points[i].y() < points[j].y()) {
                    distanceArray.add(new DistanceEvent(points[i].distanceTo(points[j]), i, j));
                }
            }
        }
        DistanceEvent[] distanceEvents = distanceArray.toArray(new DistanceEvent[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (DistanceEvent distanceEvent:distanceEvents){
//            Point2D p1 = points[distanceEvent.i];
//            Point2D p2 = points[distanceEvent.j];
//            if (p1.x() < p2.x() && p1.y() < p2.y()) {
                digraph.addEdge(distanceEvent.i,distanceEvent.j);
//            }

            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }

    }

    static class DistanceEvent implements Comparable<DistanceEvent>{
        double d;
        int i;
        int j;
        public DistanceEvent(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(DistanceEvent o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}

@06b9c3881b218e55d662b68ef74724f2@"
"r04921044","10","0.112","133264","@c3182c1ffca1913c317dff3db7ef4a80@
//import edu.princeton.cs.algs4.*;
import java.util.*;

import java.io.FileReader;
import java.io.BufferedReader;

public class CriticalDis {

    private class Edge implements Comparable<Edge> {
        public Point2D origin;
        public Point2D destination;
        public double length;

        public Edge(Point2D O, Point2D D, double L) {
            origin = O;
            destination = D;
            length = L;
        }

        public int compareTo(Edge that) {
            if (this.length > that.length) {
                return 1;
            }
            else if (this.length < that.length) {
                return -1;
            }
            return 0;
        }
    }

    ArrayList<Point2D> points;

    public CriticalDis(ArrayList<Point2D> thePoints) {
        points = thePoints;
    }

    public double solve() {
        Collections.sort(points, new Comparator<Point2D> () {
            @Override
            public int compare(Point2D p1, Point2D p2) {
                double result = (p1.x() + p1.y()) - (p2.x() + p2.y());
                if (result > 0) {
                    return 1;
                }
                else if (result < 0) {
                    return -1;
                }
                return 0;
            }
        });

        Set<Point2D> pointSet = new HashSet<> ();
        MinPQ<Edge> edges = new MinPQ<> ();

        Point2D targetPoint = points.get(0);
        int indexOfPoint = 0;

        // add point and update minPQ
        pointSet.add(targetPoint);
        for (int i=indexOfPoint+1; i<points.size(); ++i) {
            Point2D destination = points.get(i);
            if (targetPoint.x() < destination.x() && targetPoint.y() < destination.y()) {
                double length = targetPoint.distanceTo(destination);
                edges.insert(new Edge(targetPoint, destination, length));
            }
        }

        double min = 0;

        Edge candidate;
        do {
            candidate = edges.delMin();
            if (candidate.length > min) {
                min =  candidate.length;
            }
            if (!pointSet.contains(candidate.destination)) {
                targetPoint = candidate.destination;
                indexOfPoint = points.indexOf(targetPoint);

                pointSet.add(targetPoint);
                for (int i=indexOfPoint+1; i<points.size(); ++i) {
                    Point2D destination = points.get(i);
                    if (targetPoint.x() < destination.x() && targetPoint.y() < destination.y()) {
                        double length = targetPoint.distanceTo(destination);
                        edges.insert(new Edge(targetPoint, destination, length));
                    }
                }
            }
        } while (!candidate.destination.equals(points.get(points.size()-1)));

        return min;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));

        String nString = buffer.readLine();
        int N = Integer.parseInt(nString);

        ArrayList<Point2D> points = new ArrayList<> ();
        for (int i=0; i<N; ++i) {
            String[] coord = buffer.readLine().split("" "");
            double x = Double.parseDouble(coord[0]);
            double y = Double.parseDouble(coord[1]);
            Point2D newPoint = new Point2D(x, y);
            points.add(newPoint);
        }

        CriticalDis solver = new CriticalDis(points);
        System.out.printf(""%1.3f\n"", solver.solve());
    }
}
@c3182c1ffca1913c317dff3db7ef4a80@"
"r04942099","6","1.63","253360","@33c23098ae23365c4a7925ff820699d4@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;

public class CriticalDis {

    public static class Pair implements Comparable<Pair> {

        private Point2D a;
        private Point2D b;
        private double distance;
        private int a1, b1;

        public Pair(Point2D a, Point2D b, int a1, int b1) {
            this.a = a;
            this.b = b;
            this.a1 = a1;
            this.b1 = b1;
            this.distance = a.distanceTo(b);
        }

        public Point2D getA() {
            return this.a;
        }

        public Point2D getB() {
            return this.b;
        }

        public int getIndexA() {
            return this.a1;
        }

        public int getIndexB() {
            return this.b1;
        }

        public int compareTo(Pair that) {
            if (this.distance > that.distance) {
                return 1;
            } else if (this.distance < that.distance) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int size = Integer.parseInt(br.readLine());
            Point2D[] wei = new Point2D[size];
            String[] temp = new String[2];
            int s = 0; //source
            int t = 0; //target
            double s_size = 2;
            double t_size = 0;
            double x = 0;
            double y = 0;
            for (int i = 0; i < size; i++) {
                temp = br.readLine().split("" "");
                x = Double.parseDouble(temp[0]);
                y = Double.parseDouble(temp[1]);
                if (x + y > t_size) {
                    t_size = x + y;
                    t = i;
                }
                if (x + y < s_size) {
                    s_size = x + y;
                    s = i;
                }
                wei[i] = new Point2D(x, y);
                //System.out.println(wei[i]);
            }

            MinPQ<Pair> yuru = new MinPQ<Pair>(size * (size - 1) / 2);

            for (int i = 0; i < size; i++) {
                for (int j = i + 1; j < size; j++) {
                    yuru.insert(new Pair(wei[i], wei[j], i, j));
                }
            }
            Digraph dg = new Digraph(size);
            DirectedDFS chi = null;
            int flag = 0;
            Pair cheng;
            while (flag == 0) {
                cheng = yuru.delMin();
                if (cheng.getA().x() > cheng.getB().x()) {
                    if (cheng.getA().y() > cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexB(), cheng.getIndexA());
                    }

                } else if (cheng.getA().x() < cheng.getB().x()) {
                    if (cheng.getA().y() < cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexA(), cheng.getIndexB());
                    }
                }
                chi = new DirectedDFS(dg, s);
                if (chi.marked(t)) {
                    break;
                }
            }
            BreadthFirstDirectedPaths feng = new BreadthFirstDirectedPaths(dg, s);

            //double distance = 0;
            double j = 2;
            int current = s;
            

            for (int u : feng.pathTo(t)) {
                //distance = distance + wei[s].distanceTo(wei[u]);
                j = wei[s].distanceTo(wei[u]);
             
                s = u;
            }

            System.out.printf(""%1.3f\n"", j);

        }
    }
}

@33c23098ae23365c4a7925ff820699d4@"
"r04942099","6","1.75","256080","@594bdd587cc34801091401da56d142a6@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;

public class CriticalDis {

    public static class Pair implements Comparable<Pair> {

        private Point2D a;
        private Point2D b;
        private double distance;
        private int a1, b1;

        public Pair(Point2D a, Point2D b, int a1, int b1) {
            this.a = a;
            this.b = b;
            this.a1 = a1;
            this.b1 = b1;
            this.distance = a.distanceTo(b);
        }

        public Point2D getA() {
            return this.a;
        }

        public Point2D getB() {
            return this.b;
        }

        public int getIndexA() {
            return this.a1;
        }

        public int getIndexB() {
            return this.b1;
        }

        public int compareTo(Pair that) {
            if (this.distance > that.distance) {
                return 1;
            } else if (this.distance < that.distance) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int size = Integer.parseInt(br.readLine());
            Point2D[] wei = new Point2D[size];
            String[] temp = new String[2];
            int s = 0; //source
            int t = 0; //target
            double s_size = 2;
            double t_size = 0;
            double x = 0;
            double y = 0;
            for (int i = 0; i < size; i++) {
                temp = br.readLine().split("" "");
                x = Double.parseDouble(temp[0]);
                y = Double.parseDouble(temp[1]);
                if (x + y > t_size) {
                    t_size = x + y;
                    t = i;
                }
                if (x + y < s_size) {
                    s_size = x + y;
                    s = i;
                }
                wei[i] = new Point2D(x, y);
                //System.out.println(wei[i]);
            }

            MinPQ<Pair> yuru = new MinPQ<Pair>(size * (size - 1) / 2);

            for (int i = 0; i < size; i++) {
                for (int j = i + 1; j < size; j++) {
                    yuru.insert(new Pair(wei[i], wei[j], i, j));
                }
            }
            Digraph dg = new Digraph(size);
            DirectedDFS chi = null;
            int flag = 0;
            Pair cheng;
            while (flag == 0) {
                cheng = yuru.delMin();
                if (cheng.getA().x() > cheng.getB().x()) {
                    if (cheng.getA().y() > cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexB(), cheng.getIndexA());
                    }

                } else if (cheng.getA().x() < cheng.getB().x()) {
                    if (cheng.getA().y() < cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexA(), cheng.getIndexB());
                    }
                }
                chi = new DirectedDFS(dg, s);
                if (chi.marked(t)) {
                    break;
                }
            }
            BreadthFirstDirectedPaths feng = new BreadthFirstDirectedPaths(dg, s);

            //double distance = 0;
            double j = 2;
            int current = s;
            int counter = 0;

            for (int u : feng.pathTo(t)) {
                //distance = distance + wei[s].distanceTo(wei[u]);
                j = wei[s].distanceTo(wei[u]);
                if(counter>0){
                    if(wei[s].distanceTo(wei[u])>j){
                        j = wei[s].distanceTo(wei[u]);
                    }
                }
                s = u;
                counter++;
            }

            System.out.printf(""%1.3f\n"", j);

        }
    }
}

@594bdd587cc34801091401da56d142a6@"
"r04942099","1","1.8","253776","@539a85c6048aa3d59338773701269d29@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;

public class CriticalDis {

    public static class Pair implements Comparable<Pair> {

        private Point2D a;
        private Point2D b;
        private double distance;
        private int a1, b1;

        public Pair(Point2D a, Point2D b, int a1, int b1) {
            this.a = a;
            this.b = b;
            this.a1 = a1;
            this.b1 = b1;
            this.distance = a.distanceTo(b);
        }

        public Point2D getA() {
            return this.a;
        }

        public Point2D getB() {
            return this.b;
        }

        public int getIndexA() {
            return this.a1;
        }

        public int getIndexB() {
            return this.b1;
        }

        public int compareTo(Pair that) {
            if (this.distance > that.distance) {
                return 1;
            } else if (this.distance < that.distance) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int size = Integer.parseInt(br.readLine());
            Point2D[] wei = new Point2D[size];
            String[] temp = new String[2];
            int s = 0; //source
            int t = 0; //target
            double s_size = 2;
            double t_size = 0;
            double x = 0;
            double y = 0;
            for (int i = 0; i < size; i++) {
                temp = br.readLine().split("" "");
                x = Double.parseDouble(temp[0]);
                y = Double.parseDouble(temp[1]);
                if (x + y > t_size) {
                    t_size = x + y;
                    t = i;
                }
                if (x + y < s_size) {
                    s_size = x + y;
                    s = i;
                }
                wei[i] = new Point2D(x, y);
                //System.out.println(wei[i]);
            }

            MinPQ<Pair> yuru = new MinPQ<Pair>(size * (size - 1) / 2);

            for (int i = 0; i < size; i++) {
                for (int j = i + 1; j < size; j++) {
                    yuru.insert(new Pair(wei[i], wei[j], i, j));
                }
            }
            Digraph dg = new Digraph(size);
            DirectedDFS chi = null;
            int flag = 0;
            Pair cheng;
            while (flag == 0) {
                cheng = yuru.delMin();
                if (cheng.getA().x() > cheng.getB().x()) {
                    if (cheng.getA().y() > cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexB(), cheng.getIndexA());
                    }

                } else if (cheng.getA().x() < cheng.getB().x()) {
                    if (cheng.getA().y() < cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexA(), cheng.getIndexB());
                    }
                }
                chi = new DirectedDFS(dg, s);
                if (chi.marked(t)) {
                    break;
                }
            }
            BreadthFirstDirectedPaths feng = new BreadthFirstDirectedPaths(dg, s);

            //double distance = 0;
            double j = 2;
            int current = s;
            int counter = 0;
            double m=0;

            for (int u : feng.pathTo(t)) {
                //distance = distance + wei[s].distanceTo(wei[u]);
                m = wei[s].distanceTo(wei[u]);
               // System.out.println(m);
                if(counter>0){
                    if(wei[s].distanceTo(wei[u])<j){
                        j = wei[s].distanceTo(wei[u]);
                    }
                }
                s = u;
                counter++;
            }

            System.out.printf(""%1.3f\n"", j);

        }
    }
}

@539a85c6048aa3d59338773701269d29@"
"r04942099","10","0.164","256240","@9f18c1340b64eb31449bac02d5dd8adf@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;

public class CriticalDis {

    public static class Pair implements Comparable<Pair> {

        private Point2D a;
        private Point2D b;
        private double distance;
        private int a1, b1;

        public Pair(Point2D a, Point2D b, int a1, int b1) {
            this.a = a;
            this.b = b;
            this.a1 = a1;
            this.b1 = b1;
            this.distance = a.distanceTo(b);
        }

        public Point2D getA() {
            return this.a;
        }

        public Point2D getB() {
            return this.b;
        }

        public int getIndexA() {
            return this.a1;
        }

        public int getIndexB() {
            return this.b1;
        }

        public int compareTo(Pair that) {
            if (this.distance > that.distance) {
                return 1;
            } else if (this.distance < that.distance) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int size = Integer.parseInt(br.readLine());
            Point2D[] wei = new Point2D[size];
            String[] temp = new String[2];
            int s = 0; //source
            int t = 0; //target
            double s_size = 2;
            double t_size = 0;
            double x = 0;
            double y = 0;
            for (int i = 0; i < size; i++) {
                temp = br.readLine().split("" "");
                x = Double.parseDouble(temp[0]);
                y = Double.parseDouble(temp[1]);
                if (x + y > t_size) {
                    t_size = x + y;
                    t = i;
                }
                if (x + y < s_size) {
                    s_size = x + y;
                    s = i;
                }
                wei[i] = new Point2D(x, y);
                //System.out.println(wei[i]);
            }

            MinPQ<Pair> yuru = new MinPQ<Pair>(size * (size - 1) / 2);

            for (int i = 0; i < size; i++) {
                for (int j = i + 1; j < size; j++) {
                    yuru.insert(new Pair(wei[i], wei[j], i, j));
                }
            }
            Digraph dg = new Digraph(size);
            DirectedDFS chi = null;
            int flag = 0;
            double ans = 0;
            Pair cheng;
            while (flag == 0) {
                cheng = yuru.delMin();
                if (cheng.getA().x() > cheng.getB().x()) {
                    if (cheng.getA().y() > cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexB(), cheng.getIndexA());
                        
                    }

                } else if (cheng.getA().x() < cheng.getB().x()) {
                    if (cheng.getA().y() < cheng.getB().y()) {
                        dg.addEdge(cheng.getIndexA(), cheng.getIndexB());
                        
                    }
                }
                chi = new DirectedDFS(dg, s);
                if (chi.marked(t)) {
                    ans = wei[cheng.getIndexA()].distanceTo(wei[cheng.getIndexB()]);
                    break;
                }
            }
            BreadthFirstDirectedPaths feng = new BreadthFirstDirectedPaths(dg, s);

            //double distance = 0;
  /*          double j = 2;
            int current = s;
            int counter = 0;
            double m=0;*/
/*
            for (int u : feng.pathTo(t)) {
                //distance = distance + wei[s].distanceTo(wei[u]);
                m = wei[s].distanceTo(wei[u]);
               // System.out.println(m);
                if(counter>0){
                    if(wei[s].distanceTo(wei[u])<j){
                        j = wei[s].distanceTo(wei[u]);
                    }
                }
                s = u;
                counter++;
                System.out.println(u);
            }
*/
            System.out.printf(""%1.3f\n"", ans);

        }
    }
}

@9f18c1340b64eb31449bac02d5dd8adf@"
"r04546032","8","0.97","114688","@b8d89cdbdd41c0babdc1e9683e2295e9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Graph graph ;
    private static DepthFirstPaths dfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Graph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            dfs = new DepthFirstPaths(graph,start);
            // create all path
            double d = 0;
            List<Double> distance = new ArrayList<Double>();
            for(int i = 0; i < AllPoint.length ;i++)
            {
                for(int j = 0; j < AllPoint.length ;j++)
                {
                    if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()))
                    {
                        //graph.addEdge(i, j);
                        distance.add(AllPoint[i].distanceTo(AllPoint[j]));
                    }
                }               
            }
            double dis [] = new double[distance.size()];
            for(int a = 0; a < distance.size();a++)
            {
                dis[a] = distance.get(a);
            }
            Arrays.sort(dis);
            int count = 0;
            double last = 0;
            boolean flag = false;
            if(Totalpoints == 2)
            {
                System.out.printf(""%1.3f\n"", AllPoint[0].distanceTo(AllPoint[1]));
            }
            else
            {
            while(flag == false)
            {
              last = d;
              graph = new Graph(Totalpoints);
              d = dis[++count];  
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DepthFirstPaths(graph,start);
              flag = dfs.hasPathTo(end);

          
            }

            
                   
            System.out.printf(""%1.3f\n"", last);
            }
    }  
}

@b8d89cdbdd41c0babdc1e9683e2295e9@"
"b01b01039","9","0.99","109504","@1d58fa1f81b5ccc0f1d662dc0270f017@import java.util.Arrays;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Random;

public class CriticalDis{
	private MinPQ<Double> pq;
	private My_Point2D[] PointArray;
	private int N;
	private Digraph DG;
	private Double[][] DistTable;
	private DepthFirstPaths DFS;
	
	CriticalDis(Point2D[] ps){
		N 			= ps.length;
		for(int i = 0; i < N; i++){
			PointArray[i] = new My_Point2D(ps[i], i);
		}
		DG 			= new Digraph(N);
		DistTable 	= new Double[N][N];
		pq 			= new MinPQ<Double>();
	}
	
	CriticalDis(My_Point2D[] m_ps){
		N 			= m_ps.length;
		PointArray 	= m_ps;
		DG 			= new Digraph(N);
		DistTable 	= new Double[N][N];
		pq 			= new MinPQ<Double>();
	}
	
	private void DG_construction(){
		SortByDiagonal();
		//DrawPoints();
		for(int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				if(PointArray[i].x() < PointArray[j].x() && PointArray[i].y() < PointArray[j].y() ){
					//DrawEdge(i, j, 0);
					DG.addEdge(i, j); //addEdge(tail vertex, head vertex)
					DistTable[i][j] = PointArray[i].distanceTo(PointArray[j]);
					pq.insert(DistTable[i][j]);
				}
			}
		}
	}
	
	private Double CriticalDisFinf(){
		Double c_dist = pq.delMin();
		DFS = new DepthFirstPaths(DG, 0, c_dist);
		while(!DFS.hasPathTo(N-1)){
			c_dist = pq.delMin();
			//System.out.println(""Now dist :"" + c_dist);
			DFS = new DepthFirstPaths(DG, 0, c_dist);
		}
		return c_dist;
	}
	
	private void SortByIdx(){
		Arrays.sort(PointArray, PointArray[0].INDEX_ORDER);
	}
	
	private void SortByDiagonal(){
		Arrays.sort(PointArray, PointArray[0].DIAGONAL_ORDER);
	}
	
	public void DrawPoints(){
		StdDraw.setPenRadius(.01);
		StdDraw.setPenColor(StdDraw.RED);
		PointArray[0].draw();
		PointArray[N-1].draw();
		StdDraw.setPenColor(StdDraw.BLACK);
		for(int i = 0; i < N; i++){
			String s = String.valueOf(i);
			StdDraw.text(PointArray[i].x()+0.05, PointArray[i].y(), s);
		}
	}
	
	private void DrawEdge(int i, int j, int col){
		StdDraw.setPenRadius(.001);
		if		(col == 0)StdDraw.setPenColor(StdDraw.GRAY);
		else if	(col == 1)StdDraw.setPenColor(StdDraw.RED);
		else			  StdDraw.setPenColor(StdDraw.BLUE);
		PointArray[i].drawTo(PointArray[j]);
	}
	
	public static void SetConvas(){
		StdDraw.setCanvasSize(600, 600);
		StdDraw.setXscale(-0.05, 1.05);
		StdDraw.setYscale(-0.05, 1.05);
		StdDraw.setPenRadius(.005);
	}
	
	
	public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
			int N      = Integer.parseInt(br.readLine());
			My_Point2D[] PointArray = new My_Point2D[N];
			
			//SetConvas();
           
			for(int i = 0; i < N; i++) {
				String[] line = br.readLine().split("" "");
				//StdDraw.setPenColor(StdDraw.BLACK);
				double x = Double.parseDouble(line[0]);
				double y = Double.parseDouble(line[1]);
				My_Point2D p = new My_Point2D(x, y, i);
				PointArray[i] = p;
				//p.draw();
				//StdDraw.setPenColor(StdDraw.BLUE);
				//String s = String.valueOf(i);
				//StdDraw.text(PointArray[i].x()+0.05, PointArray[i].y(), s);
			}
			
			CriticalDis CDis = new CriticalDis(PointArray);
			CDis.DG_construction();
			System.out.printf(""%1.3f\n"", CDis.CriticalDisFinf());
			//System.out.println(""Done!"");
		}	
	}
	
	private class DepthFirstPaths {
		private boolean[] marked;    // marked[v] = is there an s-v path?
		private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
		private final int s;         // source vertex
		private Double c_dist;

		public DepthFirstPaths(Digraph G, int s, Double c_dist) {
			this.s = s;
			this.c_dist = c_dist;
			edgeTo = new int[G.V()];
			marked = new boolean[G.V()];
			dfs(G, s);
		}

		private void dfs(Digraph G, int v) {
			marked[v] = true;
			for (int w : G.adj(v)) {
				if (!marked[w] && DistTable[v][w] <= c_dist) {
					edgeTo[w] = v;
					//DrawEdge(w, v, 1);
					dfs(G, w);
				}
			}
		}
		
		public boolean hasPathTo(int v) {
			return marked[v];
		}
	
		public Iterable<Integer> pathTo(int v) {
			if (!hasPathTo(v)) return null;
			Stack<Integer> path = new Stack<Integer>();
			for (int x = v; x != s; x = edgeTo[x])
				path.push(x);
			path.push(s);
			return path;
		}
	}
}



class My_Point2D extends Point2D{
	
	private int idx;
	
	My_Point2D(double x, double y, int idx){
		super(x, y);
		this.idx = idx;
	}
	
	My_Point2D(Point2D p, int idx){
		super(p.x(), p.y());
		this.idx = idx;
	}
	
	public static final Comparator<My_Point2D> DIAGONAL_ORDER = new DIAGONALOrder();
	
	public static final Comparator<My_Point2D> INDEX_ORDER = new INDEXOrder();
		
	private static class DIAGONALOrder implements Comparator<My_Point2D> {
		public int compare(My_Point2D p, My_Point2D q) {
		if (p.x() + p.y() < q.x() + q.y()) return -1;
		if (p.x() + p.y() < q.x() + q.y()) return +1;
			return 0;
		}
	}
	
	private static class INDEXOrder implements Comparator<My_Point2D> {
		public int compare(My_Point2D p, My_Point2D q) {
		if (p.idx < q.idx) return -1;
		if (p.idx > q.idx) return +1;
		return 0;
		}
	}
}

@1d58fa1f81b5ccc0f1d662dc0270f017@"
"b01b01039","10","0.179","244400","@95b7846bc23283b7beab0401a5b65d9c@import java.util.Arrays;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Random;

public class CriticalDis{
	private MinPQ<Double> pq;
	private My_Point2D[] PointArray;
	private int N;
	private Digraph DG;
	private Double[][] DistTable;
	private DepthFirstPaths DFS;
	
	CriticalDis(Point2D[] ps){
		N 			= ps.length;
		for(int i = 0; i < N; i++){
			PointArray[i] = new My_Point2D(ps[i], i);
		}
		DG 			= new Digraph(N);
		DistTable 	= new Double[N][N];
		pq 			= new MinPQ<Double>();
	}
	
	CriticalDis(My_Point2D[] m_ps){
		N 			= m_ps.length;
		PointArray 	= m_ps;
		DG 			= new Digraph(N);
		DistTable 	= new Double[N][N];
		pq 			= new MinPQ<Double>();
	}
	
	private void DG_construction(){
		SortByDiagonal();
		//DrawPoints();
		for(int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				if(PointArray[i].x() < PointArray[j].x() && PointArray[i].y() < PointArray[j].y() ){
					//DrawEdge(i, j, 0);
					DG.addEdge(i, j); //addEdge(tail vertex, head vertex)
					DistTable[i][j] = PointArray[i].distanceTo(PointArray[j]);
					pq.insert(DistTable[i][j]);
				}
			}
		}
	}
	
	private Double CriticalDisFinf(){
		Double c_dist = pq.delMin();
		DFS = new DepthFirstPaths(DG, 0, c_dist);
		while(!DFS.hasPathTo(N-1)){
			c_dist = pq.delMin();
			//System.out.println(""Now dist :"" + c_dist);
			DFS = new DepthFirstPaths(DG, 0, c_dist);
		}
		/*Integer from = 0;
		for(Integer to : DFS.pathTo(N-1)){
			PointArray[from].drawTo(PointArray[to]);
			from = to;
		}*/
		return c_dist;
	}
	
	private void SortByIdx(){
		Arrays.sort(PointArray, PointArray[0].INDEX_ORDER);
	}
	
	private void SortByDiagonal(){
		Arrays.sort(PointArray, PointArray[0].DIAGONAL_ORDER);
	}
	
	public void DrawPoints(){
		StdDraw.setPenRadius(.01);
		StdDraw.setPenColor(StdDraw.RED);
		PointArray[0].draw();
		PointArray[N-1].draw();
		StdDraw.setPenColor(StdDraw.BLACK);
		/*for(int i = 0; i < N; i++){
			String s = String.valueOf(i);
			StdDraw.text(PointArray[i].x()+0.05, PointArray[i].y(), s);
		}*/
	}
	
	private void DrawEdge(int i, int j, int col){
		StdDraw.setPenRadius(.001);
		if		(col == 0)StdDraw.setPenColor(StdDraw.GRAY);
		else if	(col == 1)StdDraw.setPenColor(StdDraw.RED);
		else			  StdDraw.setPenColor(StdDraw.BLUE);
		PointArray[i].drawTo(PointArray[j]);
	}
	
	public static void SetConvas(){
		StdDraw.setCanvasSize(600, 600);
		StdDraw.setXscale(-0.05, 1.05);
		StdDraw.setYscale(-0.05, 1.05);
		StdDraw.setPenRadius(.005);
	}
	
	
	public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
			int N      = Integer.parseInt(br.readLine());
			My_Point2D[] PointArray = new My_Point2D[N];
			
			//SetConvas();
           
			for(int i = 0; i < N; i++) {
				String[] line = br.readLine().split("" "");
				//StdDraw.setPenColor(StdDraw.BLACK);
				double x = Double.parseDouble(line[0]);
				double y = Double.parseDouble(line[1]);
				My_Point2D p = new My_Point2D(x, y, i);
				PointArray[i] = p;
				//p.draw();
				//StdDraw.setPenColor(StdDraw.BLUE);
				//String s = String.valueOf(i);
				//StdDraw.text(PointArray[i].x()+0.05, PointArray[i].y(), s);
			}
			
			CriticalDis CDis = new CriticalDis(PointArray);
			CDis.DG_construction();
			System.out.printf(""%1.3f\n"", CDis.CriticalDisFinf());
			//System.out.println(""Done!"");
		}	
	}
	
	private class DepthFirstPaths {
		private boolean[] marked;    // marked[v] = is there an s-v path?
		private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
		private final int s;         // source vertex
		private Double c_dist;

		public DepthFirstPaths(Digraph G, int s, Double c_dist) {
			this.s = s;
			this.c_dist = c_dist;
			edgeTo = new int[G.V()];
			marked = new boolean[G.V()];
			dfs(G, s);
		}

		private void dfs(Digraph G, int v) {
			marked[v] = true;
			for (int w : G.adj(v)) {
				if (!marked[w] && DistTable[v][w] <= c_dist) {
					edgeTo[w] = v;
					//DrawEdge(w, v, 1);
					dfs(G, w);
				}
			}
		}
		
		public boolean hasPathTo(int v) {
			return marked[v];
		}
	
		public Iterable<Integer> pathTo(int v) {
			if (!hasPathTo(v)) return null;
			Stack<Integer> path = new Stack<Integer>();
			for (int x = v; x != s; x = edgeTo[x])
				path.push(x);
			path.push(s);
			return path;
		}
	}
}



class My_Point2D extends Point2D{
	
	private int idx;
	
	My_Point2D(double x, double y, int idx){
		super(x, y);
		this.idx = idx;
	}
	
	My_Point2D(Point2D p, int idx){
		super(p.x(), p.y());
		this.idx = idx;
	}
	
	public static final Comparator<My_Point2D> DIAGONAL_ORDER = new DIAGONALOrder();
	
	public static final Comparator<My_Point2D> INDEX_ORDER = new INDEXOrder();
		
	private static class DIAGONALOrder implements Comparator<My_Point2D> {
		public int compare(My_Point2D p, My_Point2D q) {
		if (p.x() + p.y() < q.x() + q.y()) return -1;
		if (p.x() + p.y() > q.x() + q.y()) return +1;
			return 0;
		}
	}
	
	private static class INDEXOrder implements Comparator<My_Point2D> {
		public int compare(My_Point2D p, My_Point2D q) {
		if (p.idx < q.idx) return -1;
		if (p.idx > q.idx) return +1;
		return 0;
		}
	}
}

@95b7846bc23283b7beab0401a5b65d9c@"
"r04525016","9","1.09","118864","@dde1b25d2b2e68045ff244d14ccdf721@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 * Created by user on 2016/6/7.
 */
public class CriticalDis {


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());
            ArrayList<Point2D> points = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                String[] temp = br.readLine().split(""\\s"");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                points.add(new Point2D(x, y));
            }

            //search the smallest point
            int source = 0;
            int target = 0;

            Point2D o = new Point2D(0, 0);
            double sTemp = points.get(0).x() + points.get(0).y();
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum < sTemp) {
                    sTemp = sum;
                    source = i;
                }
            }

            //search the biggest point
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum > sTemp) {
                    sTemp = sum;
                    target = i;
                }
            }


            ArrayList<Double> distance = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    distance.add(points.get(i).distanceTo(points.get(j)));
                }
            }

            while (!distance.isEmpty()) {
                double d = distance.get(0);
                for (int i = 1; i < distance.size(); i++) {
                    if (distance.get(i) < d) {
                        d = distance.get(i);
                    }
                }
//                System.out.println(d);

//            double d = 0.3571473074759942;
                Digraph digraph = new Digraph(num);
                for (int i = 0; i < num; i++) {
                    for (int j = 0; j < num; j++) {
                        if (points.get(i).x() < points.get(j).x() &&
                                points.get(i).y() < points.get(j).y() &&
                                points.get(i).distanceTo(points.get(j)) <= d) {

                            digraph.addEdge(i, j);

                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(digraph, source);


                if (!dfs.marked(target)) {
                    distance.remove(d);
                } else {
                    System.out.println(String.format(""%1.3f"", d));
                    break;
                }


            }


        }


    }
}

@dde1b25d2b2e68045ff244d14ccdf721@"
"r03723070","4","1.29","165840","@d32ab4ef827f86c12102c31e75d11a2b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph G = new Graph(N);
            smallest_distance = pq.delMin();
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = i+1;j<N;j++){
                        if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                }
            }
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) break;
        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@d32ab4ef827f86c12102c31e75d11a2b@"
"r03723070","1","6.09","208624","@8d7be713b5cbdb79a4fb65d7da0711c8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //add the edge
                /*for(int i=0; i<N;i++){
                    for(int j = i+1;j<N;j++){
                        if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                }
            }*/
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) break;
        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@8d7be713b5cbdb79a4fb65d7da0711c8@"
"r03723070","4","1.32","171216","@ef150801bc6d518c6f15f956b1b976a3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                //if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                //}
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = i+1;j<N;j++){
                        if(vert[i].x()<=vert[j].x() && vert[j].y()<=vert[j].y()){
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                }
            }
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) break;
        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@ef150801bc6d518c6f15f956b1b976a3@"
"r04525016","9","1.06","122864","@c8588e46c80b13f952a9879135c6dcaa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 * Created by user on 2016/6/7.
 */
public class CriticalDis {


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());
            ArrayList<Point2D> points = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                String[] temp = br.readLine().split(""\\s"");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                points.add(new Point2D(x, y));
            }

            //search the smallest point
            int source = 0;
            int target = 0;

            Point2D o = new Point2D(0, 0);
            double sTemp = points.get(0).x() + points.get(0).y();
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum < sTemp) {
                    sTemp = sum;
                    source = i;
                }
            }

            //search the biggest point
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum > sTemp) {
                    sTemp = sum;
                    target = i;
                }
            }


            ArrayList<Double> distance = new ArrayList<>();
            ArrayList<Integer> indexV = new ArrayList<>();
            ArrayList<Integer> indexW = new ArrayList<>();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    distance.add(points.get(i).distanceTo(points.get(j)));
                    indexV.add(i);
                    indexW.add(j);
                }
            }


            Digraph digraph = new Digraph(num);


            while (!distance.isEmpty()) {
                double d = distance.get(0);
                int index = 0;
                for (int i = 1; i < distance.size(); i++) {
                    if (distance.get(i) < d) {
                        d = distance.get(i);
                        index = i;
                    }

                }


                int v = indexV.get(index);
                int w = indexW.get(index);
                if (points.get(v).x() < points.get(w).x() &&
                        points.get(v).y() < points.get(w).y()) {
                    digraph.addEdge(v, w);
                }

//                Digraph digraph = new Digraph(num);
//                for (int i = 0; i < num; i++) {
//                    for (int j = 0; j < num; j++) {
//                        if (points.get(i).x() < points.get(j).x() &&
//                                points.get(i).y() < points.get(j).y() &&
//                                points.get(i).distanceTo(points.get(j)) <= d) {
//
//                            digraph.addEdge(i, j);
//                        }
//                    }
//                }

                DirectedDFS dfs = new DirectedDFS(digraph, source);

                if (!dfs.marked(target)) {
                    distance.remove(d);
                    indexV.remove(index);
                    indexW.remove(index);
                } else {
                    System.out.println(String.format(""%1.3f"", d));
                    break;
                }


            }


        }


    }
}

@c8588e46c80b13f952a9879135c6dcaa@"
"r03723070","3","1.24","138208","@7e7c280c17f254623ca394160b2a4fee@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                if(vert[i].x()<=vert[j].x() && vert[i].y()<=vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = i+1;j<N;j++){
                        if(vert[i].x()<=vert[j].x() && vert[i].y()<=vert[j].y()){
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                }
            }
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) break;
        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@7e7c280c17f254623ca394160b2a4fee@"
"r04525016","9","0.85","127760","@9a530637d7fbbc4f7620d42f7207f3be@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 * Created by user on 2016/6/7.
 */
public class CriticalDis {


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());
            ArrayList<Point2D> points = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                String[] temp = br.readLine().split(""\\s"");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                points.add(new Point2D(x, y));
            }

            //search the smallest point
            int source = 0;
            int target = 0;

            double sTemp = points.get(0).x() + points.get(0).y();
            double tTemp = points.get(0).x() + points.get(0).y();
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum < sTemp) {
                    sTemp = sum;
                    source = i;
                }
                else if (sum > tTemp){
                    tTemp = sum;
                    target = i;
                }
            }

          

            ArrayList<Double> distance = new ArrayList<>();
            ArrayList<Integer> indexV = new ArrayList<>();
            ArrayList<Integer> indexW = new ArrayList<>();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    distance.add(points.get(i).distanceTo(points.get(j)));
                    indexV.add(i);
                    indexW.add(j);
                }
            }


            Digraph digraph = new Digraph(num);


            while (!distance.isEmpty()) {
                double d = distance.get(0);
                int index = 0;
                for (int i = 1; i < distance.size(); i++) {
                    if (distance.get(i) < d) {
                        d = distance.get(i);
                        index = i;
                    }

                }


                int v = indexV.get(index);
                int w = indexW.get(index);
                if (points.get(v).x() < points.get(w).x() &&
                        points.get(v).y() < points.get(w).y()) {
                    digraph.addEdge(v, w);
                }

//                Digraph digraph = new Digraph(num);
//                for (int i = 0; i < num; i++) {
//                    for (int j = 0; j < num; j++) {
//                        if (points.get(i).x() < points.get(j).x() &&
//                                points.get(i).y() < points.get(j).y() &&
//                                points.get(i).distanceTo(points.get(j)) <= d) {
//
//                            digraph.addEdge(i, j);
//                        }
//                    }
//                }

                DirectedDFS dfs = new DirectedDFS(digraph, source);

                if (!dfs.marked(target)) {
                    distance.remove(d);
                    indexV.remove(index);
                    indexW.remove(index);
                } else {
                    System.out.println(String.format(""%1.3f"", d));
                    break;
                }


            }


        }


    }
}

@9a530637d7fbbc4f7620d42f7207f3be@"
"r04525016","10","0.423","255904","@7e60f4191ba28c9a58c575f74cad5729@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 * Created by user on 2016/6/7.
 */
public class CriticalDis {


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());
            ArrayList<Point2D> points = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                String[] temp = br.readLine().split(""\\s"");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                points.add(new Point2D(x, y));
            }

            //search the smallest point
            int source = 0;
            int target = 0;

            double sTemp = points.get(0).x() + points.get(0).y();
            double tTemp = points.get(0).x() + points.get(0).y();
            for (int i = 1; i < num; i++) {
                double sum = points.get(i).x() + points.get(i).y();
                if (sum < sTemp) {
                    sTemp = sum;
                    source = i;
                } else if (sum > tTemp) {
                    tTemp = sum;
                    target = i;
                }
            }


            ArrayList<Double> distance = new ArrayList<>();
            ArrayList<Integer> indexV = new ArrayList<>();
            ArrayList<Integer> indexW = new ArrayList<>();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (points.get(i).x() < points.get(j).x() &&
                            points.get(i).y() < points.get(j).y()) {
                        distance.add(points.get(i).distanceTo(points.get(j)));
                        indexV.add(i);
                        indexW.add(j);
                    }
                }
            }


            Digraph digraph = new Digraph(num);


            while (!distance.isEmpty()) {
                double d = distance.get(0);
                int index = 0;
                for (int i = 1; i < distance.size(); i++) {
                    if (distance.get(i) < d) {
                        d = distance.get(i);
                        index = i;
                    }

                }


                int v = indexV.get(index);
                int w = indexW.get(index);

                digraph.addEdge(v, w);

//                Digraph digraph = new Digraph(num);
//                for (int i = 0; i < num; i++) {
//                    for (int j = 0; j < num; j++) {
//                        if (points.get(i).x() < points.get(j).x() &&
//                                points.get(i).y() < points.get(j).y() &&
//                                points.get(i).distanceTo(points.get(j)) <= d) {
//
//                            digraph.addEdge(i, j);
//                        }
//                    }
//                }

                DirectedDFS dfs = new DirectedDFS(digraph, source);

                if (!dfs.marked(target)) {
                    distance.remove(d);
                    indexV.remove(index);
                    indexW.remove(index);
                } else {
                    System.out.println(String.format(""%1.3f"", d));
                    break;
                }


            }


        }


    }
}

@7e60f4191ba28c9a58c575f74cad5729@"
"r03723070","0","1.34","149408","@2db3e3aa9c14d267a854776dae5f6970@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //System.out.printf(""%f\n"",smallest_distance);
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = i+1;j<N;j++){
                        if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                            //System.out.printf(""%f\n"",smallest_distance);
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <smallest_distance){
                                G.addEdge(i, j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                        
                }
            }
            System.out.printf(""%f\n"",smallest_distance);
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) {
                //StdOut.println(""T is ""+T);
                //StdOut.println(""S is ""+S);
                System.out.printf(""%f\n"",smallest_distance);
                break;
            }

        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@2db3e3aa9c14d267a854776dae5f6970@"
"r03723070","9","11.66","178944","@1a58fdc2ff42386579f47ef3a9122b61@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            //StdOut.println(i);
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                //StdOut.println(""x+y is ""+(x+y));
                //StdOut.println(""x is ""+x+""y is ""+y);
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                //StdOut.println(""M x+y is ""+(x+y));
                //StdOut.println(""M x is ""+x+""y is ""+y);
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i+1;j<N;j++){
                if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //System.out.printf(""%f\n"",smallest_distance);
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = 0;j<N;j++){
                        if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                            //StdOut.println("" i is ""+i+""j is ""+j);
                            //System.out.printf(""%f\n"",smallest_distance);
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                               // StdOut.println("" i is ""+i+""j is ""+j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                        
                }
            }
            //System.out.printf(""%f\n"",smallest_distance);
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) {
                //StdOut.println(""T is ""+T);
                //StdOut.println(""S is ""+S);
                //System.out.printf(""%f\n"",smallest_distance);
                break;
            }

        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@1a58fdc2ff42386579f47ef3a9122b61@"
"r03723070","8","1.24","120240","@7b16619a35dc83e3b69c351cb172ccd9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            //StdOut.println(i);
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<=S_min) {
                //StdOut.println(""x+y is ""+(x+y));
                //StdOut.println(""x is ""+x+""y is ""+y);
                S_min = x+y;
                S = i;
            }
            if(x+y>=T_max) {
                //StdOut.println(""M x+y is ""+(x+y));
                //StdOut.println(""M x is ""+x+""y is ""+y);
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = 0;j<N;j++){
                if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Graph  G = new Graph (N);
            smallest_distance = pq.delMin();
            //System.out.printf(""%f\n"",smallest_distance);
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = 0;j<N;j++){
                        if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                            //StdOut.println("" i is ""+i+""j is ""+j);
                            //System.out.printf(""%f\n"",smallest_distance);
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                               // StdOut.println("" i is ""+i+""j is ""+j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                        
                }
            }
            //System.out.printf(""%f\n"",smallest_distance);
            CC cc = new CC(G);
            if(cc.connected(S, T) == true) {
                //StdOut.println(""T is ""+T);
                //StdOut.println(""S is ""+S);
                //System.out.printf(""%f\n"",smallest_distance);
                break;
            }

        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@7b16619a35dc83e3b69c351cb172ccd9@"
"r03723070","10","1.199","178032","@5dec830c23835e99e167ffe2942559e9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
        public static void main(String[] args) {
        In in = new In(args[0]);
        String[] s = in.readAllLines();
        int N = Integer.parseInt(s[0]);
        //StdOut.println(N);
        double T_max = 0;
        int T = 0;
        double S_min = 2;
        int S = 0;
        Point2D[] vert = new Point2D[N];//store all
        for(int i = 0; i<N;i++){
            //StdOut.println(i);
            String[] inData = s[i+1].split("" "");
            Double x = Double.parseDouble(inData[0]);
            Double y = Double.parseDouble(inData[1]);
            vert[i] = new Point2D(x,y);
            if(x+y<S_min) {
                //StdOut.println(""x+y is ""+(x+y));
                //StdOut.println(""x is ""+x+""y is ""+y);
                S_min = x+y;
                S = i;
            }
            if(x+y>T_max) {
                //StdOut.println(""M x+y is ""+(x+y));
                //StdOut.println(""M x is ""+x+""y is ""+y);
                T_max = x+y;
                T = i;
            }
        }
        //StdOut.println(""T is ""+T);
        //StdOut.println(""S is ""+S);
        //store all the distance
        MinPQ<Double> pq = new MinPQ<Double>();//store the distance, this is for searching the min distance
        for(int i=0; i<N;i++){
            for(int j = i;j<N;j++){
                if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                    // in this condition, add edge
                    pq.insert(vert[i].distanceTo(vert[j]));
                    //StdOut.println(vert[i].distanceSquaredTo(vert[j]));
                }
            }
        }
        double smallest_distance = 0;
        while(!pq.isEmpty()){
            Digraph   G = new Digraph  (N);
            smallest_distance = pq.delMin();
            //System.out.printf(""%f\n"",smallest_distance);
            //add the edge
                for(int i=0; i<N;i++){
                    for(int j = 0;j<N;j++){
                        if(vert[i].x()<vert[j].x() && vert[i].y()<vert[j].y()){
                            //StdOut.println("" i is ""+i+""j is ""+j);
                            //System.out.printf(""%f\n"",smallest_distance);
                            // in this condition, add edge
                            if(vert[i].distanceTo(vert[j]) <=smallest_distance){
                                G.addEdge(i, j);
                               // StdOut.println("" i is ""+i+""j is ""+j);
                                //smaller than the dist, then adding the edge
                            }
                    }
                        
                }
            }
            //System.out.printf(""%f\n"",smallest_distance);
            //CC cc = new CC(G);
            DepthFirstDirectedPaths  dfs = new DepthFirstDirectedPaths (G, S);
            //if(cc.connected(S, T) == true) {
            if(dfs.hasPathTo(T)){
                //StdOut.println(""T is ""+T);
                //StdOut.println(""S is ""+S);
                //System.out.printf(""%f\n"",smallest_distance);
                break;
            }

        }

        System.out.printf(""%1.3f\n"", smallest_distance);
        //StdOut.println(smallest_distance);
        //StdOut.println(x[1]);
        //Graph G = new Graph(in);
        //StdOut.println(G);
    }
}

@5dec830c23835e99e167ffe2942559e9@"
"r04631023","9","1.48","227024","@b48487b4c7e483d70acfb4c727de01d6@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    private static class Edge implements Comparable<Edge> {

        public Double Dis;
        public Integer from = null;
        public Integer to = null;

        public Edge(Double d, int f, int t) {
            Dis = d;
            from = f;
            to = t;
        }
        
        public int compareTo(Edge that) {
            if (Dis > that.Dis) {
                return 1;
            } else if (Dis == that.Dis) {
                return 0;
            } else {
                return -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            Edge E = new Edge(0.0, 0, 0);
            MinPQ<Edge> pq = new MinPQ();
            String[] points = new String[2];
            String Data = br.readLine();
            int Num = Integer.parseInt(Data);
            int s = 0 ;
            int t = 0 ;
            double S = 2 ;
            double T = 0 ;
            Point2D[] Points = new Point2D[Num];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num) ;
            double distance = 0;

            for (int i = 0; i < Num; i++) {
                points = br.readLine().split("" "");
                Points[i] = new Point2D(Double.parseDouble(points[0]), Double.parseDouble(points[1]));
                if ((Points[i].x() + Points[i].y()) < S){
                    S = (Points[i].x() + Points[i].y()) ;
                    s = i ;
                }
                if ((Points[i].x() + Points[i].y()) > T){
                    T = (Points[i].x() + Points[i].y()) ;
                    t = i ;
                }
            }

            for (int i = 0; i < Num; i++) {
                for (int j = i; j < Num; j++) {
                    if ((Points[i].x() < Points[j].x() && Points[i].y() < Points[j].y()) || (Points[j].x() < Points[i].x() && Points[j].y() < Points[i].y())) {
                        distance = Points[i].distanceTo(Points[j]);
                        E = new Edge(distance, i, j);
                        pq.insert(E);
                    }
                }
            }

            while(!uf.connected(s, t)){
                E = pq.delMin() ;
                uf.union(E.from, E.to);
            }

            System.out.printf(""%1.3f\n"", E.Dis);
        }
    }
}
@b48487b4c7e483d70acfb4c727de01d6@"
"r04631023","10","0.169","249856","@33afeb613f5c4eaf582839449938cb80@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    private static class Edge implements Comparable<Edge> {

        public Double Dis;
        public Integer from = null;
        public Integer to = null;

        public Edge(Double d, int f, int t) {
            Dis = d;
            from = f;
            to = t;
        }
        
        public int compareTo(Edge that) {
            if (Dis > that.Dis) {
                return 1;
            } else if (Dis == that.Dis) {
                return 0;
            } else {
                return -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            
            Edge E = new Edge(0.0, 0, 0);
            MinPQ<Edge> pq = new MinPQ();
            String[] points = new String[2];
            String Data = br.readLine();
            int Num = Integer.parseInt(Data);
            int s = 0 ;
            int t = 0 ;
            double S = 2 ;
            double T = 0 ;
            Point2D[] Points = new Point2D[Num];
            Digraph dg = new Digraph(Num);
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num) ;
            double distance = 0;

            for (int i = 0; i < Num; i++) {
                points = br.readLine().split("" "");
                Points[i] = new Point2D(Double.parseDouble(points[0]), Double.parseDouble(points[1]));
                if ((Points[i].x() + Points[i].y()) < S){
                    S = (Points[i].x() + Points[i].y()) ;
                    s = i ;
                }
                if ((Points[i].x() + Points[i].y()) > T){
                    T = (Points[i].x() + Points[i].y()) ;
                    t = i ;
                }
            }

            for (int i = 0; i < Num; i++) {
                for (int j = i+1; j < Num; j++) {
                    if (Points[i].x() < Points[j].x() && Points[i].y() < Points[j].y()) {
                        distance = Points[i].distanceTo(Points[j]);
                        E = new Edge(distance, i, j);
                        pq.insert(E);
                    }else if (Points[j].x() < Points[i].x() && Points[j].y() < Points[i].y()){
                        distance = Points[i].distanceTo(Points[j]);
                        E = new Edge(distance, j, i);
                        pq.insert(E);
                    }
                }
            }
            DirectedDFS ddfs = new DirectedDFS(dg, s) ;
            while(!ddfs.marked(t)){
                E = pq.delMin() ;
                dg.addEdge(E.from, E.to);
                ddfs = new DirectedDFS(dg, s) ;
            }

            System.out.printf(""%1.3f\n"", E.Dis);
        }
    }
}
@33afeb613f5c4eaf582839449938cb80@"
"b02611028","10","0.139","235760","@432c9d897cb1ddc528e8084e892d4bf8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Han
 */
public class CriticalDis {

    public static class edge implements Comparable<edge> {

        private int a;
        private int b;
        private double dist;

        public edge(int a, int b, double dist) {
            this.a = a;
            this.b = b;
            this.dist = dist;
        }

        public int compareTo(edge that) {
            if (this.dist > that.dist) {
                return +1;
            } else if (this.dist < that.dist) {
                return -1;
            } else {
                return 0;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num=Integer.parseInt(br.readLine());
            Point2D[] points=new Point2D[num];
            double minindex=500;
            double maxindex=0;
            int index1=0;
            int index2=0;
            for(int i=0;i<num;i++){
                String[] s=br.readLine().split("" "");
                points[i]=new Point2D(Double.parseDouble(s[0]),Double.parseDouble(s[1]));
                if(points[i].x()+points[i].y()<minindex){
                    minindex=points[i].x()+points[i].y();
                    index1=i;
                }
                if(points[i].x()+points[i].y()>maxindex){
                    maxindex=points[i].x()+points[i].y();
                    index2=i;
                }
                /*StdDraw.setPenRadius(0.01);
                StdDraw.setPenColor(Color.black);
                StdDraw.text(points[i].x(), points[i].y()+0.02, String.valueOf(i));*/
                //points[i].draw();
            }
            MinPQ<edge> p=new MinPQ<edge>();
            
            for(int i=0;i<num-1;i++){
                for(int j=i+1;j<num;j++){
                    
                    double dist=Math.pow(Math.pow(points[i].x()-points[j].x(), 2)+Math.pow(points[i].y()-points[j].y(), 2), 0.5);
                    edge e=new edge(i,j,dist);
                    p.insert(e);
                }
            }
            Digraph G = new Digraph(num);
            DirectedDFS dfs = new DirectedDFS(G, index1);
            edge ee = null;
            while(true){
                ee=p.delMin();
                
                if(points[ee.a].x()<points[ee.b].x()&&points[ee.a].y()<points[ee.b].y()){
                    
                    G.addEdge(ee.a, ee.b);
                    dfs=new DirectedDFS(G, index1);
                    /*StdDraw.setPenRadius(0.01);
                    StdDraw.line(points[ee.a].x(), points[ee.a].y(), points[ee.b].x(), points[ee.b].y());*/
                }
                if(points[ee.a].x()>points[ee.b].x()&&points[ee.a].y()>points[ee.b].y()){
                    
                    G.addEdge(ee.b, ee.a);
                    dfs=new DirectedDFS(G, index1);
                    /*StdDraw.setPenRadius(0.01);
                    StdDraw.line(points[ee.a].x(), points[ee.a].y(), points[ee.b].x(), points[ee.b].y());*/
                }
                if(dfs.marked(index2)){
                    System.out.printf(""%1.3f\n"", ee.dist);
                    break;
                }
            }
            
        }
    }
}

@432c9d897cb1ddc528e8084e892d4bf8@"
"b02611023","10","0.116","181568","@118164465891c7b8cac42fda09425b36@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;

public class CriticalDis {

    public static Point2D[] p;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            int index = 1;
            p = new Point2D[N];

            String[] temp0 = br.readLine().split("" "");
            double x0 = Double.parseDouble(temp0[0]);
            double y0 = Double.parseDouble(temp0[1]);
            p[0] = new Point2D(x0, y0);

            double min = x0 + y0;
            double max = min;
            int index_max = 0, index_min = 0;

            while (br.ready()) {
                String[] temp = br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);

                if (x + y > max) {
                    index_max = index;
                    max = x + y;
                }
                if (x + y < min) {
                    index_min = index;
                    min = x + y;
                }

                p[index++] = new Point2D(x, y);
            }

            Point2D s = p[index_min];
            Point2D t = p[index_max];

            Digraph dg = new Digraph(N);
            DirectedDFS dfs = new DirectedDFS(dg, index_min);
            MinPQ<Edge> pq = new MinPQ<Edge>();
            double d = 0.0;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (p[i].x() < p[j].x() && p[i].y() < p[j].y()) {
                        pq.insert(new Edge(i, j));
                    }
                }
            }
            
            Edge temp = null;
            while (!dfs.marked(index_max)) {
                temp = pq.delMin();
                dg.addEdge(temp.p1, temp.p2);
                dfs = new DirectedDFS(dg, index_min);
            }

            System.out.printf(""%1.3f\n"", temp.dis);

        }
    }

    public static class Edge implements Comparable<Edge> {

        int p1, p2;
        double dis;

        public Edge(int p1, int p2) {
            this.p1 = p1;
            this.p2 = p2;
            dis = p[p1].distanceTo(p[p2]);
        }

        public int compareTo(Edge that) {
            if (this.dis > that.dis) {
                return +1;
            }
            if (this.dis < that.dis) {
                return -1;
            }
            return 0;
        }
    }

}

@118164465891c7b8cac42fda09425b36@"
"r04631006","0","0","0","@5e9815bf1ecd0d907e9eca9fc851681b@import java.io.BufferedReader;
import java.io.FileReader;

public class Hw11 {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String a = br.readLine();
            int num = Integer.parseInt(a);
            int min = 0;
            int max = 0;
            double xx = 0;
            double yy = 0;
            double xxx = 0;
            double yyy = 0;
            double point[][] = new double[num][2];
            for (int i = 0; i < 20; i++) {
                String[] b = br.readLine().split("" "");
                point[i][0] = Double.parseDouble(b[0]);
                point[i][1] = Double.parseDouble(b[1]);
                if (i == 0) {
                    xx = point[i][0];
                    yy = point[i][1];
                    xxx = point[i][0];
                    yyy = point[i][1];
                }
                if (i > 0 && point[i][0] + point[i][1] <= yy + xx) {
                    xx = point[i][0];
                    yy = point[i][1];
                    min = i;
                }
                if (i > 0 && point[i][0] + point[i][1] >= yyy + xxx) {
                    xxx = point[i][0];
                    yyy = point[i][1];
                    max = i;
                }
            }
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.005);
//            Point2D[] points = new Point2D[num];
//            for (int i = 0; i < num; i++) {
//                double x = point[i][0];
//                double y = point[i][1];
//                points[i] = new Point2D(x, y);
//                points[i].draw();
//                StdDraw.text(x, y + 0.01, Integer.toString(i));
//            }
            MinPQ<BB> pq = new MinPQ<>();
            Digraph G = new Digraph(num);
            for (int i = 0; i < num; i++) {
                for (int j = i; j < num; j++) {
                    if (point[i][0] <= point[j][0] && point[i][1] <=point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(i, j, dis);
                        pq.insert(bb);
                    }
                    if (point[i][0] >= point[j][0] && point[i][1] >= point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(j, i, dis);
                        pq.insert(bb);
                    }
                }

            }

            DirectedDFS dfs = new DirectedDFS(G, min);
            double d = 0;
            while (!dfs.marked(max)) {
                BB bbb = pq.delMin();
                G.addEdge(bbb.x, bbb.y);
                dfs = new DirectedDFS(G, min);
                d = bbb.dis;
                System.out.printf(""%d %d\n"", bbb.x,bbb.y);
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }

    public static class BB implements Comparable<BB> {

        private final int x;
        private final int y;
        private final double dis;

        public BB(int x, int y, double dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }

        @Override
        public int compareTo(BB that) {

            if (this.dis > that.dis) {
                return 1;
            } else if (this.dis < that.dis) {
                return -1;
            } else {
                return -0;
            }
        }
    }

}

@5e9815bf1ecd0d907e9eca9fc851681b@"
"r04631006","0","0","0","@b8f582a9c2db39a731652c8d01074989@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {

            String a = br.readLine();
            int num = Integer.parseInt(a);
            int min = 0;
            int max = 0;
            double xx = 0;
            double yy = 0;
            double xxx = 0;
            double yyy = 0;
            double point[][] = new double[num][2];
            for (int i = 0; i < 20; i++) {
                String[] b = br.readLine().split("" "");
                point[i][0] = Double.parseDouble(b[0]);
                point[i][1] = Double.parseDouble(b[1]);
                if (i == 0) {
                    xx = point[i][0];
                    yy = point[i][1];
                    xxx = point[i][0];
                    yyy = point[i][1];
                }
                if (i > 0 && point[i][0] + point[i][1] <= yy + xx) {
                    xx = point[i][0];
                    yy = point[i][1];
                    min = i;
                }
                if (i > 0 && point[i][0] + point[i][1] >= yyy + xxx) {
                    xxx = point[i][0];
                    yyy = point[i][1];
                    max = i;
                }
            }
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.005);
//            Point2D[] points = new Point2D[num];
//            for (int i = 0; i < num; i++) {
//                double x = point[i][0];
//                double y = point[i][1];
//                points[i] = new Point2D(x, y);
//                points[i].draw();
//                StdDraw.text(x, y + 0.01, Integer.toString(i));
//            }
            MinPQ<BB> pq = new MinPQ<>();
            Digraph G = new Digraph(num);
            for (int i = 0; i < num; i++) {
                for (int j = i; j < num; j++) {
                    if (point[i][0] <= point[j][0] && point[i][1] <=point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(i, j, dis);
                        pq.insert(bb);
                    }
                    if (point[i][0] >= point[j][0] && point[i][1] >= point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(j, i, dis);
                        pq.insert(bb);
                    }
                }

            }

            DirectedDFS dfs = new DirectedDFS(G, min);
            double d = 0;
            while (!dfs.marked(max)) {
                BB bbb = pq.delMin();
                G.addEdge(bbb.x, bbb.y);
                dfs = new DirectedDFS(G, min);
                d = bbb.dis;
                System.out.printf(""%d %d\n"", bbb.x,bbb.y);
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }

    public static class BB implements Comparable<BB> {

        private final int x;
        private final int y;
        private final double dis;

        public BB(int x, int y, double dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }

        @Override
        public int compareTo(BB that) {

            if (this.dis > that.dis) {
                return 1;
            } else if (this.dis < that.dis) {
                return -1;
            } else {
                return -0;
            }
        }
    }

}

@b8f582a9c2db39a731652c8d01074989@"
"r04631006","3","0.42","108304","@7f48c8bd22b33602a208ea5a629ef9ef@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String a = br.readLine();
            int num = Integer.parseInt(a);
            int min = 0;
            int max = 0;
            double xx = 0;
            double yy = 0;
            double xxx = 0;
            double yyy = 0;
            double point[][] = new double[num][2];
            for (int i = 0; i < 20; i++) {
                String[] b = br.readLine().split("" "");
                point[i][0] = Double.parseDouble(b[0]);
                point[i][1] = Double.parseDouble(b[1]);
                if (i == 0) {
                    xx = point[i][0];
                    yy = point[i][1];
                    xxx = point[i][0];
                    yyy = point[i][1];
                }
                if (i > 0 && point[i][0] + point[i][1] <= yy + xx) {
                    xx = point[i][0];
                    yy = point[i][1];
                    min = i;
                }
                if (i > 0 && point[i][0] + point[i][1] >= yyy + xxx) {
                    xxx = point[i][0];
                    yyy = point[i][1];
                    max = i;
                }
            }
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.005);
//            Point2D[] points = new Point2D[num];
//            for (int i = 0; i < num; i++) {
//                double x = point[i][0];
//                double y = point[i][1];
//                points[i] = new Point2D(x, y);
//                points[i].draw();
//                StdDraw.text(x, y + 0.01, Integer.toString(i));
//            }
            MinPQ<BB> pq = new MinPQ<>();
            Digraph G = new Digraph(num);
            for (int i = 0; i < num; i++) {
                for (int j = i; j < num; j++) {
                    if (point[i][0] <= point[j][0] && point[i][1] <=point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(i, j, dis);
                        pq.insert(bb);
                    }
                    if (point[i][0] >= point[j][0] && point[i][1] >= point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(j, i, dis);
                        pq.insert(bb);
                    }
                }

            }

            DirectedDFS dfs = new DirectedDFS(G, min);
            double d = 0;
            while (!dfs.marked(max)) {
                BB bbb = pq.delMin();
                G.addEdge(bbb.x, bbb.y);
                dfs = new DirectedDFS(G, min);
                d = bbb.dis;
//                System.out.printf(""%d %d\n"", bbb.x,bbb.y);
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }

    public static class BB implements Comparable<BB> {

        private final int x;
        private final int y;
        private final double dis;

        public BB(int x, int y, double dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }

        @Override
        public int compareTo(BB that) {

            if (this.dis > that.dis) {
                return 1;
            } else if (this.dis < that.dis) {
                return -1;
            } else {
                return -0;
            }
        }
    }

}

@7f48c8bd22b33602a208ea5a629ef9ef@"
"r04631006","10","0.114","203472","@edcc702f93434a58fc4da1eb0e275bd1@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String a = br.readLine();
            int num = Integer.parseInt(a);
            int min = 0;
            int max = 0;
            double xx = 0;
            double yy = 0;
            double xxx = 0;
            double yyy = 0;
            double point[][] = new double[num][2];
            for (int i = 0; i < num; i++) {
                String[] b = br.readLine().split("" "");
                point[i][0] = Double.parseDouble(b[0]);
                point[i][1] = Double.parseDouble(b[1]);
                if (i == 0) {
                    xx = point[i][0];
                    yy = point[i][1];
                    xxx = point[i][0];
                    yyy = point[i][1];
                }
                if (i > 0 && point[i][0] + point[i][1] <= yy + xx) {
                    xx = point[i][0];
                    yy = point[i][1];
                    min = i;
                }
                if (i > 0 && point[i][0] + point[i][1] >= yyy + xxx) {
                    xxx = point[i][0];
                    yyy = point[i][1];
                    max = i;
                }
            }
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.005);
//            Point2D[] points = new Point2D[num];
//            for (int i = 0; i < num; i++) {
//                double x = point[i][0];
//                double y = point[i][1];
//                points[i] = new Point2D(x, y);
//                points[i].draw();
//                StdDraw.text(x, y + 0.01, Integer.toString(i));
//            }
            MinPQ<BB> pq = new MinPQ<>();
            Digraph G = new Digraph(num);
            for (int i = 0; i < num; i++) {
                for (int j = i; j < num; j++) {
                    if (point[i][0] <= point[j][0] && point[i][1] <=point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(i, j, dis);
                        pq.insert(bb);
                    }
                    if (point[i][0] >= point[j][0] && point[i][1] >= point[j][1]) {
                        Double dis = Math.sqrt(Math.pow(point[i][0] - point[j][0], 2) + Math.pow(point[i][1] - point[j][1], 2));
                        BB bb = new BB(j, i, dis);
                        pq.insert(bb);
                    }
                }

            }

            DirectedDFS dfs = new DirectedDFS(G, min);
            double d = 0;
            while (!dfs.marked(max)) {
                BB bbb = pq.delMin();
                G.addEdge(bbb.x, bbb.y);
                dfs = new DirectedDFS(G, min);
                d = bbb.dis;
//                System.out.printf(""%d %d\n"", bbb.x,bbb.y);
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }

    public static class BB implements Comparable<BB> {

        private final int x;
        private final int y;
        private final double dis;

        public BB(int x, int y, double dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }

        @Override
        public int compareTo(BB that) {

            if (this.dis > that.dis) {
                return 1;
            } else if (this.dis < that.dis) {
                return -1;
            } else {
                return -0;
            }
        }
    }

}

@edcc702f93434a58fc4da1eb0e275bd1@"
"b03611023","4","2.8","169968","@359c7220ad4f1671f289647bdac6445f@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Win8
 */
public class CriticalDis {
    
    public static class Point implements Comparable<Point>{
      double x;
      double y;
        public Point(double x, double y){
            this.x = x;
            this.y = y;
        }        
        public int compareTo(Point that){
            if((this.x+this.y)>(that.x+that.y)) return 1;
            else if((this.x+this.y)<(that.x+that.y)) return -1;
            else return 0;
        }
        public double getx(){
            return x;
        }
        public double gety()
        {
            return y;
        }
    }
   
    public static class  DirectedDFS{
        private boolean[] marked;
        public DirectedDFS(Digraph G, int s){
            marked = new boolean[G.V()];
            dfs(G,s);
        }
         private void dfs(Digraph G, int v){
             marked[v] = true;
             for(int w: G.adj(v))
                 if(!marked[w])  dfs(G, w);
         }
         public boolean visited(int v){
              return marked[v]; 
         }
    }
    public static class realpath{
       
    }
    public static void findpath(Point[] a,Digraph g,MaxPQ<Double> pq, int b,int n){
        double min = 0;
            int mi = 0;
        for(int i = b+1;i<n;i++){
            
            if(a[b].x<a[i].x && a[b].y<a[i].y){               
                double dx = a[i].x - a[b].x;
                double dy = a[i].y - a[b].y;
                double dis = Math.sqrt(dx*dx+dy*dy);
                if(min == 0){
                    min = dis;
                    mi = i;
                }
                else if(dis<min){
                    min = dis;
                    mi = i;
                }
              }
            pq.insert(min);
            g.addEdge(b, mi);
                DirectedDFS check = new DirectedDFS(g, 0);
               
                if(check.marked[n-1] == true ) return;
                
               
            
        }
         findpath(a,g,pq,mi,n);
    }
        
      public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            int n = Integer.parseInt(num);
            Point[] points = new Point[n];
            
            for(int i =0;i<n;i++){
             String[] position = br.readLine().split("" "");
             double x = Double.parseDouble(position[0]);
             double y = Double.parseDouble(position[1]);
             points[i] = new Point(x, y);
            }
            Arrays.sort(points);
            
          Digraph gra = new Digraph(n);
           
         MaxPQ<Double> pq = new MaxPQ<>();
         findpath(points, gra, pq, 0, n);
            
         double d = pq.delMax();
         System.out.printf(""%1.3f\n"", d);
        // System.out.print(d);
            
        }                
      }
}

@359c7220ad4f1671f289647bdac6445f@"
"b03611023","10","0.114","187936","@c133bab647c552bc0c849de3eb643ea1@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;


 
public class CriticalDis {
    
    public static class Point implements Comparable<Point>{
      double x;
      double y;
        public Point(double x, double y){
            this.x = x;
            this.y = y;
        }        
        public int compareTo(Point that){
            if((this.x+this.y)>(that.x+that.y)) return 1;
            else if((this.x+this.y)<(that.x+that.y)) return -1;
            else return 0;
        }        
    }
   
    public static class  DirectedDFS{
        private boolean[] marked;
        public DirectedDFS(Digraph G, int s){
            marked = new boolean[G.V()];
            dfs(G,s);
        }
         private void dfs(Digraph G, int v){
             marked[v] = true;
             for(int w: G.adj(v))
                 if(!marked[w])  dfs(G, w);
         }
         public boolean visited(int v){
              return marked[v]; 
         }
    }
    private static class Event implements Comparable<Event>{
        private int a,b;
        private double dis;
        public Event(int a, int b, double dis){
           this.a = a;
           this.b = b;  
           this.dis = dis;
        }
      /*  public double find(){            
            double dx = a.x-b.x;
            double dy = a.y-b.y;
            double dis = Math.sqrt(dx*dx+dy*dy);
            return dis;
        }*/
          public int compareTo(Event that){
             if(this.dis<that.dis) return -1;
             else if(this.dis>that.dis) return 1;
              else return 0;
          }
    }
   
   
     
      public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            int n = Integer.parseInt(num);
            Point[] points = new Point[n];
            
            for(int i =0;i<n;i++){
             String[] position = br.readLine().split("" "");
             double x = Double.parseDouble(position[0]);
             double y = Double.parseDouble(position[1]);
             points[i] = new Point(x, y);
            }
            Arrays.sort(points);
            double d = 0;
          Digraph gra = new Digraph(n);
          MinPQ<Event> pq = new MinPQ<>();
         for(int i = 0;i<n;i++){
                for(int j = i+1;j<n;j++){
               if(points[i].x<points[j].x&&points[i].y<points[j].y){
                   double dx = points[j].x - points[i].x;
                   double dy = points[j].y - points[i].y;
                   double dis = Math.sqrt(dx*dx+dy*dy);
                   pq.insert(new Event(i,j,dis));
               }
             }
         }
         while(!pq.isEmpty()){
             Event remove = pq.delMin();
             gra.addEdge(remove.a, remove.b);
             DirectedDFS check = new DirectedDFS(gra,0);
             if(check.marked[n-1]){
                 d = remove.dis;
                 break;
             }
         }
        
             
        
         System.out.printf(""%1.3f\n"", d);
        
        // System.out.print(d);
            
        }                
      }
}

@c133bab647c552bc0c849de3eb643ea1@"
"r04945021","2","1.16","126944","@b05dedd5b6481828fbed10ec331014e7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Double> pq = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                distance=a[Source].distanceTo(a[i]);
                pq.insert(distance);
            }
            
            Digraph G = new Digraph(N);
            Double d=null;
            while(!pq.isEmpty()){
                d=pq.delMin();
                
              for(int i=0;i<N;i++){
                  for(int j=1;j<N;j++){
                                     
                      if(a[i].distanceTo(a[j])<=d && a[i].x()<a[j].x() && a[i].y()<a[j].y())
                      G.addEdge(i, j);
                  }
              }
              DirectedDFS dfs = new DirectedDFS(G,Source);
              
              if(dfs.marked(Target)){
                  break;
              }
            }
            System.out.printf(""%1.3f\n"", d);
            


            
}
}

    }

@b05dedd5b6481828fbed10ec331014e7@"
"r04945021","9","0.97","111008","@0be40e10beb52cf19abff6e2fa566305@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
//                StdDraw.textLeft(a[i].x(),a[i].y(),Integer.toString(i));
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Double> pq = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                for(int j=i+1;j<N;j++){
                if(a[i].x()<a[j].x() && a[i].y()<a[j].y()){   
                distance=a[i].distanceTo(a[j]);
                pq.insert(distance);  
                }
                }
            }
            
            Digraph G = new Digraph(N);
            Double d=null;          

            while(!pq.isEmpty()){
                d=pq.delMin();
                
                //System.out.printf(""%1.3f\n"", d);
              for(int i=0;i<N;i++){
                  for(int j=0;j<N;j++){
                         
                      if(a[i].distanceTo(a[j])<=d && a[i].x()<a[j].x() && a[i].y()<a[j].y())
                      G.addEdge(i, j);
                      
                  }
              }
              DirectedDFS dfs = new DirectedDFS(G,Source);
              
              if(dfs.marked(Target)){
                  break;
              }
            }
            System.out.printf(""%1.3f\n"", d);
            


            
}
}

    }

@0be40e10beb52cf19abff6e2fa566305@"
"r04945021","9","0.96","112272","@aa5d1906778114e28b56dabdbffea3f0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
//                StdDraw.textLeft(a[i].x(),a[i].y(),Integer.toString(i));
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Double> pq = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                for(int j=i+1;j<N;j++){
                if(a[i].x()<a[j].x() && a[i].y()<a[j].y()){   
                distance=a[i].distanceTo(a[j]);
                pq.insert(distance);  
                }
                }
            }
            
            Digraph G = new Digraph(N);
            Double d=null;          

            while(!pq.isEmpty()){
                d=pq.delMin();
                
                //System.out.printf(""%1.3f\n"", d);
              for(int i=0;i<N;i++){
                  for (int j = 0; j < N; j++) {
                      if (i == j) {
                          continue;
                      } else if (a[i].distanceTo(a[j]) <= d && a[i].x() < a[j].x() && a[i].y() < a[j].y()) {
                          G.addEdge(i, j);
                      }

                  }
              }
              DirectedDFS dfs = new DirectedDFS(G,Source);
              
              if(dfs.marked(Target)){
                  break;
              }
            }
            System.out.printf(""%1.3f\n"", d);
            


            
}
}

    }

@aa5d1906778114e28b56dabdbffea3f0@"
"r04945021","9","0.98","114224","@e14fe878c952dbd221eaa82058953b26@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
//                StdDraw.textLeft(a[i].x(),a[i].y(),Integer.toString(i));
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Double> pq = new MinPQ<Double>();
            MinPQ<Double> pqS = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                pqS.insert(a[Source].distanceTo(a[i]));
                for(int j=i+1;j<N;j++){
                if(a[i].x()<a[j].x() && a[i].y()<a[j].y()){   
                distance=a[i].distanceTo(a[j]);
                pq.insert(distance);  
                }
                }
            }
            
            Digraph G = new Digraph(N);
            Double d=null;          
distance=pqS.delMin();
            while(!pq.isEmpty()){
                d=pq.delMin();
                
                if(distance<=d)
                {
              for(int i=0;i<N;i++){
                  for (int j = 0; j < N; j++) {
                      if (i == j) {
                          continue;
                      } else if (a[i].distanceTo(a[j]) <= d && a[i].x() < a[j].x() && a[i].y() < a[j].y()) {
                          G.addEdge(i, j);
                      }

                  }
              }
              DirectedDFS dfs = new DirectedDFS(G,Source);
              
              if(dfs.marked(Target)){
                  break;
              }
              
                }
                else if(d<distance){
                    distance=pqS.delMin();
                }
                else{
                    continue;
                }
            }
            System.out.printf(""%1.3f\n"", d);
            


            
}
}

    }

@e14fe878c952dbd221eaa82058953b26@"
"b02611016","9","1.69","259872","@391cb995b15a2474a41ae330bd67c78f@import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import  java.lang.Math;
import java.util.Arrays;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
class Pair implements Comparable<Pair>{
     private Point2D a1;
     private Point2D  a2;
     private int num1;
     private int  num2;
     private double distance ;
     public  Pair(Point2D  a ,Point2D  b,int num1,int num2 ){
         this.a1=a;
         this.a2=b;
         this.num1=num1;
         this.num2=num2;
        // distance =a1.getpoint().distanceTo(a2.getpoint());
         
     }
     public int  point1(){
     return this.num1;
     }
     public int  point2(){
     return this.num2;
     }
     
     public Point2D  getpoint1(){
     return this.a1;
     }
      public Point2D  getpoint2(){
     return this.a2;
     }
     public double getdistance(){
         this.distance =this.a1.distanceTo(this.a2);
     return this.distance;
     }
      //   (Clustering this ,Clustering that)
   //  {double distance =this.getpoint().distanceTo(that.getpoint());
     //}
      public int compareTo(Pair that) {
          if(this.getdistance()>that.getdistance()){return 1;}
          if(this.getdistance()<that.getdistance()){return -1;}
          else return 0;
     }
 }
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
      public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
       Point2D[] point;
     int num;
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
          String[] data = br.readLine().split("" "");
               num = Integer.parseInt(data[0]);
               point=new Point2D[num];
              //Point2D[] a=new Point2D[num];
               int source=0;
               int target=0;
              MinPQ<Pair> minpq=new MinPQ<Pair>();
              MaxPQ maxpq=new MaxPQ();
             // Digraph graph=new Digraph(num);
              
              //graph.addEdge(14,2);
              //DepthFirstDirectedPaths dfs=new DepthFirstDirectedPaths(graph,14);
              //System.out.println(dfs.hasPathTo(2));
              
              
         for(int i=0;i<num;i++){
            String[] data1 = br.readLine().split("" "");
         //   a[i]=new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));
            point[i]=new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));
            if(i==0){source=0;target=0;}
            if(point[source].x()+point[source].y()>point[i].x()+point[i].y())
            {source=i;}
            if(point[target].x()+point[target].y()<point[i].x()+point[i].y())
            {target=i;}
          //  System.out.println(a[i]);
       //   System.out.println(cluster[i].getpoint());
          //System.out.println(cluster[i].size());
         }
        //  System.out.println(source);
          //System.out.println(target);
          Pair[] pair=new Pair[num*(num-1)/2];
          int k=0;
           for(int i=0;i<num;i++)
        {for(int j=i+1;j<num;j++)
           {   
               pair[k]=new Pair(point[i],point[j],i,j);
               minpq.insert(pair[k]);
               //    System.out.println(pair[k].point1());
                   
               k=k+1;
           }
        }
           //System.out.println(k);
        Digraph graph=new Digraph(num);
        DepthFirstDirectedPaths dfs=new DepthFirstDirectedPaths(graph,source);
        double dis=0;
           while(!dfs.hasPathTo(target))
           { Pair temp=minpq.delMin();
            
           //  System.out.println(temp.getdistance());
             if((temp.getpoint1().x()-temp.getpoint2().x())/(temp.getpoint1().y()-temp.getpoint2().y())>0)
             {  graph.addEdge(temp.point1(), temp.point2());
             graph.addEdge(temp.point2(), temp.point1());
             dfs=new DepthFirstDirectedPaths(graph,source);
             //System.out.println(temp.point1());
            // System.out.println(temp.point2());
             dis=temp.getdistance();
             }
             
           }
          
          System.out.printf(""%1.3f\n"", dis);
          
          
          
          
        }
        
        
       
        
     /*    for(int i=0;i<num;i++){   
               
             StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
               StdDraw.text(point[i].x(), point[i].y()+0.03,Integer.toString(i) );
               
         
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
              StdDraw.text(point[i].x(),point[i].y()+0.03,Integer.toString(i) );
               }*/
         
         

       
      /* for(int i=0;i<10;i++)
       {System.out.println(temp[i]);
       }*/
     }
    
}

@391cb995b15a2474a41ae330bd67c78f@"
"r04228002","10","0.165","231200","@0e51df61dc1ac9132b9b1024be830282@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    private static class Pair implements Comparable<Pair>{
        public Integer id1;
        public Integer id2;
        public double dis;
        public Pair(Integer id1, Integer id2, double dis){
            this.id1 = id1;
            this.id2 = id2;
            this.dis = dis;
        }
        public int compareTo(Pair that){
            if (this.dis > that.dis){return 1;}
            else if (this.dis < that.dis){return -1;}
            else{return 0;}
        }
        
        public Integer getID1(){
            return this.id1;
        }
        
        public Integer getID2(){
            return this.id2;
        }
        
        public double getDis(){
            return this.dis;
        }
    }
    
    public static void main(String[] args) throws Exception{
        // TODO code application logic here
        Integer N;
        Point2D[] PointList;
        MinPQ<Pair> PairPQ;
        
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            N = Integer.parseInt(br.readLine());
            PointList = new Point2D[N];
            PairPQ = new MinPQ<Pair>(N^2);
            
            String temp;
            for (int i=0;i<N;i++){
                temp = br.readLine();
                String[] split_temp=temp.split("" "");
                Point2D p = new Point2D(Double.parseDouble(split_temp[0]),Double.parseDouble(split_temp[1]));
                PointList[i]=p;
                
            }
        }
        
        Point2D Source = PointList[0];
        Integer S_ID = 0;
        Point2D Target = PointList[0];
        Integer T_ID = 0;
        
        for (int i=0;i<N;i++){
            Point2D tempi = PointList[i];
            if ((tempi.x()+tempi.y())<(Source.x()+Source.y())){
                Source = tempi;
                S_ID = i;
            }
            else if ((tempi.x()+tempi.y())>(Target.x()+Target.y())){
                Target = tempi;
                T_ID = i;
            }
            for (int j=i+1;j<N;j++){
                Point2D tempj = PointList[j];
                if ((tempi.x()<tempj.x())&&(tempi.y()<tempj.y())){
                    Pair pair = new Pair(i,j,tempi.distanceTo(tempj));
                    PairPQ.insert(pair);
                }
                else if ((tempj.x()<tempi.x())&&(tempj.y()<tempi.y())){
                    Pair pair = new Pair(j,i,tempj.distanceTo(tempi));
                    PairPQ.insert(pair);
                }
            }
        }
        
        Digraph G = new Digraph(N);
        DepthFirstDirectedPaths DFDP = new DepthFirstDirectedPaths(G,S_ID);
        double theDis = 0;
        while(DFDP.hasPathTo(T_ID)==false){
            Pair CP = PairPQ.delMin();
            theDis = CP.getDis();
            G.addEdge(CP.getID1(), CP.getID2());
            DFDP = new DepthFirstDirectedPaths(G,S_ID);
        }
        
        System.out.printf(""%1.3f\n"", theDis);
        
    }
    
}

@0e51df61dc1ac9132b9b1024be830282@"
"b02611016","10","0.171","256960","@c7c4d3ccc3ed39d8d32dbd4168b83ae5@import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import  java.lang.Math;
import java.util.Arrays;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
class Pair implements Comparable<Pair>{
     private Point2D a1;
     private Point2D  a2;
     private int num1;
     private int  num2;
     private double distance ;
     public  Pair(Point2D  a ,Point2D  b,int num1,int num2 ){
         this.a1=a;
         this.a2=b;
         this.num1=num1;
         this.num2=num2;
        // distance =a1.getpoint().distanceTo(a2.getpoint());
         
     }
     public int  point1(){
     return this.num1;
     }
     public int  point2(){
     return this.num2;
     }
     
     public Point2D  getpoint1(){
     return this.a1;
     }
      public Point2D  getpoint2(){
     return this.a2;
     }
     public double getdistance(){
         this.distance =this.a1.distanceTo(this.a2);
     return this.distance;
     }
      //   (Clustering this ,Clustering that)
   //  {double distance =this.getpoint().distanceTo(that.getpoint());
     //}
      public int compareTo(Pair that) {
          if(this.getdistance()>that.getdistance()){return 1;}
          if(this.getdistance()<that.getdistance()){return -1;}
          else return 0;
     }
 }
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
      public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
       Point2D[] point;
     int num;
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
          String[] data = br.readLine().split("" "");
               num = Integer.parseInt(data[0]);
               point=new Point2D[num];
              //Point2D[] a=new Point2D[num];
               int source=0;
               int target=0;
              MinPQ<Pair> minpq=new MinPQ<Pair>();
              MaxPQ maxpq=new MaxPQ();
             // Digraph graph=new Digraph(num);
              
              //graph.addEdge(14,2);
              //DepthFirstDirectedPaths dfs=new DepthFirstDirectedPaths(graph,14);
              //System.out.println(dfs.hasPathTo(2));
              
              
         for(int i=0;i<num;i++){
            String[] data1 = br.readLine().split("" "");
         //   a[i]=new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));
            point[i]=new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));
            if(i==0){source=0;target=0;}
            if(point[source].x()+point[source].y()>point[i].x()+point[i].y())
            {source=i;}
            if(point[target].x()+point[target].y()<point[i].x()+point[i].y())
            {target=i;}
          //  System.out.println(a[i]);
       //   System.out.println(cluster[i].getpoint());
          //System.out.println(cluster[i].size());
         }
        //  System.out.println(source);
          //System.out.println(target);
          Pair[] pair=new Pair[num*(num-1)/2];
          int k=0;
           for(int i=0;i<num;i++)
        {for(int j=i+1;j<num;j++)
           {   
               pair[k]=new Pair(point[i],point[j],i,j);
               minpq.insert(pair[k]);
               //    System.out.println(pair[k].point1());
                   
               k=k+1;
           }
        }
           //System.out.println(k);
        Digraph graph=new Digraph(num);
        DepthFirstDirectedPaths dfs=new DepthFirstDirectedPaths(graph,source);
        double dis=0;
           while(!dfs.hasPathTo(target))
           { Pair temp=minpq.delMin();
            
            // System.out.println(temp.getdistance());
             if((temp.getpoint1().y()<temp.getpoint2().y())&&(temp.getpoint1().x()<temp.getpoint2().x()))
             {  graph.addEdge(temp.point1(), temp.point2());
             //graph.addEdge(temp.point2(), temp.point1());
             dfs=new DepthFirstDirectedPaths(graph,source);
             //System.out.println(temp.point1());
            // System.out.println(temp.point2());
             dis=temp.getdistance();
             }
             else if((temp.getpoint1().y()>temp.getpoint2().y())&&(temp.getpoint1().x()>temp.getpoint2().x()))
             { // graph.addEdge(temp.point1(), temp.point2());
             graph.addEdge(temp.point2(), temp.point1());
             dfs=new DepthFirstDirectedPaths(graph,source);
             //System.out.println(temp.point1());
            // System.out.println(temp.point2());
             dis=temp.getdistance();
             }
             
           }
          
          System.out.printf(""%1.3f\n"", dis);
          
          
          
          
        }
        
        
       
        
     /*    for(int i=0;i<num;i++){   
               
             StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
               StdDraw.text(point[i].x(), point[i].y()+0.03,Integer.toString(i) );
               
         
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
              StdDraw.text(point[i].x(),point[i].y()+0.03,Integer.toString(i) );
               }*/
         
         

       
      /* for(int i=0;i<10;i++)
       {System.out.println(temp[i]);
       }*/
     }
    
}

@c7c4d3ccc3ed39d8d32dbd4168b83ae5@"
"r03945012","0","0.9","114976","@14d9704ca0caf534bcc18c00eb6f5cd2@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                points[k].draw();
            }
            // source and target
            double mindis = 100;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            while(loop){
                d = pq.delMin();
                Digraph G = new Digraph(num);
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() < points[j].x()){
                            if (points[i].y() < points[j].y()){
                                if (points[i].distanceTo(points[j]) < d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target))
                    loop = false;
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
    
}

@14d9704ca0caf534bcc18c00eb6f5cd2@"
"r02b48003","10","0.181","227376","@373f66896d03e1eeffd2a40a627cb611@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * Homework 11
 * @author r02b48003
 */
public class CriticalDis {
    private int idxSrc, idxTar;
    private double cDist;
    private MinPQ<Double> pq;
    private boolean[] marked;
    private final Point2D[] points;
    private final Digraph graph;
    
    public CriticalDis (Point2D[] points) {
        // sort by X coordinate
        Arrays.sort(points, Point2D.X_ORDER);
        
        // determine source and target    
        idxSrc = 0; idxTar = 0;
        double sumXYMin = points[0].x() + points[0].y();
        double sumXYMax = points[0].x() + points[0].y();
        
        for (int idx = 0; idx < points.length; idx++) {
            double sumXY = points[idx].x() + points[idx].y();
            if (sumXY < sumXYMin) {sumXYMin = sumXY; idxSrc = idx;}
            if (sumXY > sumXYMax) {sumXYMax = sumXY; idxTar = idx;}
        } // end for loop
        
        this.points = points;
        this.pq = new MinPQ<>();
        this.graph = new Digraph(points.length);
        for (int idx1 = 0; idx1 < (points.length-1); idx1++) {
            for (int idx2 = (idx1+1); idx2 < points.length; idx2++) {
                if (points[idx1].y() <= points[idx2].y()){
                    graph.addEdge(idx1, idx2);
                    pq.insert(points[idx1].distanceTo(points[idx2]));
                } // end if
            } // end inner loop 
        } // end outer loop
        
        // show result
        cDist = searchDist();
        depthFirstSearch(cDist);
        System.out.printf(""%1.3f\n"", cDist);
        //if (Double.compare(cDist, -1.0) != 0)
        //    plot(cDist);
    } // end constructor
    
    private double searchDist() {
        while(!pq.isEmpty()) {
            // get the minimum
            Double dist = pq.delMin();
            depthFirstSearch(dist);
            
            // check if target is visited
            if (visited(idxTar)) {
                return dist;
            } // end if
        } // end while
        
        System.out.println(""ERROR!! No Distance are found"");
        return -1.0;
    } // end searchCdist
    
    private void depthFirstSearch(double dist) {
        marked = new boolean[graph.V()];
        dfs(idxSrc, dist);
    } // end func DepthFirstSearch
    
    private void dfs(int v, double dist) {
        marked[v] = true;
        for (int w : graph.adj(v))
            if (!marked[w] && points[v].distanceTo(points[w]) <= dist){
                dfs(w, dist);
            } // end if
    } // end func dfs
    
    public boolean visited(int v) {
        return marked[v];  
    } // end func visited
    
    private void printPoints(){
       // print out the points and source/target
        for (int idx = 0; idx < points.length; idx++) {
            Point2D point = points[idx];
            System.out.println(
                    idx + "" "" + 
                    point.x() + "" "" + point.y() + "" "" + 
                    (point.x()+point.y()));
        } // end for loop
        System.out.println(idxSrc);
        System.out.println(idxTar); 
        //System.out.println(idxSrc + "" "" + sumXYMin);
        //System.out.println(idxTar + "" "" + sumXYMax); 
    } // end func printPoints
    
    private void plot(double dist){
        // set scale and axes
        StdDraw.setCanvasSize(1000, 1000);
        StdDraw.setXscale(-0.2, 1.2);
        StdDraw.setYscale(-0.2, 1.2);
        StdDraw.line(0,-0.1,0,1.1);
        StdDraw.line(-0.1,0,1.1,0);
                
        // plot points
        StdDraw.setPenColor(StdDraw.BLACK);
        for (Point2D p : points) {
            StdDraw.filledCircle(p.x(), p.y(), 0.01);
        } // end for loop
        
        // plot line
        StdDraw.setPenColor(StdDraw.BLUE);
        for (int idx1 = 0; idx1 < graph.V(); idx1++) {
            for (int idx2 : graph.adj(idx1)) {
                StdDraw.line(points[idx1].x(), points[idx1].y(),
                             points[idx2].x(), points[idx2].y());
            } // end inner for loop
        } // end outer for loop
        
        // plot marked points
        StdDraw.setPenColor(StdDraw.RED);
        for (int idx = 0; idx < graph.V(); idx++) {
            if (marked[idx]) {
                StdDraw.filledCircle(points[idx].x(), points[idx].y(), 0.01);
            } // end if
        } // end for loop
        
        // plot source, target
        StdDraw.setPenColor(StdDraw.PINK);
        StdDraw.filledCircle(points[idxSrc].x(), points[idxSrc].y(), 0.01);
        StdDraw.setPenColor(StdDraw.GREEN);
        StdDraw.filledCircle(points[idxTar].x(), points[idxTar].y(), 0.01);
        
        // plot edge with length <= input distance
        StdDraw.setPenColor(StdDraw.RED);
        for (int idx1 = 0; idx1 < graph.V(); idx1++) {
            for (int idx2 : graph.adj(idx1)) {
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    StdDraw.line(points[idx1].x(), points[idx1].y(),
                                 points[idx2].x(), points[idx2].y());
                } // end if
            } // end inner for loop
        } // end outer for loop
        
        // show if the source is visited
        if (visited(idxTar)) {
            StdDraw.text(1.0, 1.0,  ""Target Visited"");
            StdDraw.text(1.0, 0.95, ""Critical Distance: "" +
                    String.valueOf(Math.round(10000.0 * cDist)/10000.0));
        } // end if
    } // end func plot
    
    public static void main(String[] args) throws Exception {
        // declaration        
        String[]    line;
        Point2D     points[];
        int         count;
        CriticalDis cds;
        
        // read in the points from 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // first line contain the number of points
            String header = br.readLine();
            count  = Integer.parseInt(header);
            points = new Point2D[count];
            
            // rest of lines contain points
            for (int idx = 0; idx < count; idx++) {
                line = br.readLine().split("" "");
                double x = Double.parseDouble(line[0]);
                double y = Double.parseDouble(line[1]);
                points[idx] = new Point2D(x, y);
                //System.out.println(x + "" "" + y);
            } // end for loop
        } // end try
        
        // 
        cds = new CriticalDis(points);        
        
        
    } // end main
} // end main class

@373f66896d03e1eeffd2a40a627cb611@"
"r03945012","9","1.04","115152","@724bb75d3627cab3a23cba51e9c82d4a@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.05);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            while(loop){
                d = pq.delMin();
//                StdOut.println(d);
                Digraph G = new Digraph(num);
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() < points[j].x()){
                            if (points[i].y() < points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target))
                    loop = false;
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
    
}

@724bb75d3627cab3a23cba51e9c82d4a@"
"r03945012","9","1","115072","@f90ecc1b4d7192346fcff214492e18f9@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.05);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (num >= 2){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() < points[j].x()){
                                if (points[i].y() < points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@f90ecc1b4d7192346fcff214492e18f9@"
"r03945012","0","0","0","@aa8c1488ecf15905effe4fdaf02d9566@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            StdOut.println(num);
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            StdDraw.setPenRadius(.02);
            StdDraw.setPenColor(Color.blue);
            points[source].draw();
            StdDraw.setPenRadius(.02);
            StdDraw.setPenColor(Color.green);
            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (num >= 2 & points[source].x() < points[target].x()){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() < points[j].x()){
                                if (points[i].y() < points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@aa8c1488ecf15905effe4fdaf02d9566@"
"r03945012","9","1.01","115248","@d756ca6bfdfba169588376697deca612@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (num >= 2 & points[source].x() < points[target].x()){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() < points[j].x()){
                                if (points[i].y() < points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@d756ca6bfdfba169588376697deca612@"
"r04945021","9","0.97","108240","@28644ac8894ea4b50dec0eca7c8368c3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
//                StdDraw.textLeft(a[i].x(),a[i].y(),Integer.toString(i));
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Pair> pq = new MinPQ<Pair>();
            MinPQ<Double> pqS = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                pqS.insert(a[Source].distanceTo(a[i]));
                for(int j=0;j<N;j++){
                if(a[i].x()<a[j].x() && a[i].y()<a[j].y()){   
                distance=a[i].distanceTo(a[j]);
               Pair po = new Pair(distance,i,j);               
                pq.insert(po);
                
                }
                }
            }
            Pair Edge;
            Digraph G = new Digraph(N);
            
            Double d=null;
            Pair[] bag = new Pair[pq.size()];
            int bagID=0;
            
//distance=pqS.delMin();
            while(!pq.isEmpty()){
                Edge=pq.delMin();
                d=Edge.distance;
               
                //distance=pqS.delMin();
               // System.out.println(d);
                
                if (a[Edge.a].x() < a[Edge.b].x() && a[Edge.a].y() < a[Edge.b].y()){
                    bag[bagID]=Edge; 
                    bagID++;
                }
                for(int i=0;i<bagID;i++){
                    G.addEdge(bag[i].a, bag[i].b);
                    
                }
                
               DirectedDFS dfs = new DirectedDFS(G,Source);
                                                 
              
              if(dfs.marked(Target)){
                        
                  break;
              }             
                
            }
            System.out.printf(""%1.3f\n"", d);                       
}
}
   public static class Pair implements Comparable<Pair>{
        private Double distance;
        private int a;
        private int b;
    public Pair (Double distance, int a, int b)
    {
        this.distance = distance;
        this.a = a;
        this.b = b;
    }
    public Double getDouble(){
        return this.distance;
    }
    public int geta(){
        return this.a;
    }
    public int getb(){
        return this.b;
    
    }
    public int compareTo(Pair that) {
        if (that.distance > this.distance)
            return -1;
        else if (that.distance < this.distance)
            return 1;
        else 
            return 0;
        
        
        
        
        
    }
    }   
    

    }


@28644ac8894ea4b50dec0eca7c8368c3@"
"r04945021","10","0.115","224304","@978f4f31c8eae7386b24132de0cef248@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class CriticalDis {
   
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
 
            Double min=0.0;
            Double max=0.0;

            int Source=0;
            int Target=0;
            
            
     String[] data = br.readLine().split("" "");
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
//                StdDraw.textLeft(a[i].x(),a[i].y(),Integer.toString(i));
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                if(i==0){
                    min = x+y;
                    max = x+y;
                    Source =i;
                    Target =i;
                }
                else{
                    if(min.compareTo(x+y)>0){
                        min = x+y;
                        Source =i;
                    }
                    if(max.compareTo(x+y)<0){
                        max = x+y;
                        Target = i;
                    }
                }
            }
            MinPQ<Pair> pq = new MinPQ<Pair>();
            MinPQ<Double> pqS = new MinPQ<Double>();
            Double distance;
            for (int i=0;i<N;i++) {
                pqS.insert(a[Source].distanceTo(a[i]));
                for(int j=0;j<N;j++){
                if(a[i].x()<a[j].x() && a[i].y()<a[j].y()){   
                distance=a[i].distanceTo(a[j]);
               Pair po = new Pair(distance,i,j);               
                pq.insert(po);
                
                }
                }
            }
            Pair Edge;
            Digraph G = new Digraph(N);
            
            Double d=null;
            
            int bagID=0;
            
//distance=pqS.delMin();
            while(!pq.isEmpty()){
                Edge=pq.delMin();
                d=Edge.distance;
               
                //distance=pqS.delMin();
               // System.out.println(d);
                
                if (a[Edge.a].x() < a[Edge.b].x() && a[Edge.a].y() < a[Edge.b].y()){
                    G.addEdge(Edge.a, Edge.b);
                    DirectedDFS dfs = new DirectedDFS(G,Source);
                    if(dfs.marked(Target)){                       
                  break;
              }
                }
                else 
                    continue;
               
            }
            System.out.printf(""%1.3f\n"", d);                       
}
}
   public static class Pair implements Comparable<Pair>{
        private Double distance;
        private int a;
        private int b;
    public Pair (Double distance, int a, int b)
    {
        this.distance = distance;
        this.a = a;
        this.b = b;
    }
    public Double getDouble(){
        return this.distance;
    }
    public int geta(){
        return this.a;
    }
    public int getb(){
        return this.b;
    
    }
    public int compareTo(Pair that) {
        if (that.distance > this.distance)
            return -1;
        else if (that.distance < this.distance)
            return 1;
        else 
            return 0;
        
        
        
        
        
    }
    }   
    

    }


@978f4f31c8eae7386b24132de0cef248@"
"b03611015","0","0","0","@9e453918cad43c53a7c702f416d96091@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Steven
 */
public class CriticalDis {

    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] in = br.readLine().split("" "");
                p[i] = new Point2D(Double.parseDouble(in[0]), Double.parseDouble(in[1]));
            }
            int source = 0;
            int target = 0;
            for (int i = 1; i < N; i++) {
                if (p[i].x() + p[i].y() > p[source].x() + p[source].y()) {
                    source = i;
                }
                if (p[i].x() + p[i].y() < p[target].x() + p[target].y()) {
                    target = i;
                }
            }
            Stack<Distance> dis = new Stack<>();
            for (int i = 0; i < N; i++) {
                Point2D p1 = p[i];
                for(int j=0;j<N;j++){
                    Point2D p2 = p[j];
                    if(p1.x()<p2.x()&&p1.y()<p2.y()) dis.push(new Distance(p1.distanceTo(p2),i,j));
                }
            }
            Distance[] a =new Distance[dis.size()];
            for(int i=0;i<dis.size();i++){
                a[i] = dis.pop();
            }
            Arrays.sort(a);
            Digraph digraph = new Digraph(N);
            for(int i=0 ; i<a.length;i++){
            digraph.addEdge(a[i].i,a[i].j);
            DirectedDFS dfs = new DirectedDFS(digraph,target);
            
            if(dfs.marked(i)==true)
                System.out.printf(""%1.3f\n"", a[i].d);
                break;
            }
            
            }
            

        }
    
        static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

       
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    }




@9e453918cad43c53a7c702f416d96091@"
"b03611015","0","1.36","193344","@2da14a57f39dc78ad76259d5ccbccb6b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Steven
 */
public class CriticalDis {

    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] in = br.readLine().split("" "");
                p[i] = new Point2D(Double.parseDouble(in[0]), Double.parseDouble(in[1]));
            }
            int source = 0;
            int target = 0;
            for (int i = 1; i < N; i++) {
                if (p[i].x() + p[i].y() > p[source].x() + p[source].y()) {
                    source = i;
                }
                if (p[i].x() + p[i].y() < p[target].x() + p[target].y()) {
                    target = i;
                }
            }
            ArrayList<Distance> dis = new ArrayList<Distance>();
            for (int i = 0; i <p.length; i++) {
                Point2D p1 = p[i];
                for(int j=0;j<p.length;j++){
                    Point2D p2 = p[j];
                    if(p1.x()<p2.x()&&p1.y()<p2.y()) dis.add(new Distance(p1.distanceTo(p2),i,j));
                }
            }
            Distance[] a =dis.toArray(new Distance[dis.size()]);
            
            Arrays.sort(a);
            Digraph digraph = new Digraph(N);
            
            for(int i=0 ; i<a.length;i++){
            digraph.addEdge(a[i].i,a[i].j);
            DirectedDFS dfs = new DirectedDFS(digraph,target);
            
            if(dfs.marked(i)==true)
                System.out.printf(""%1.3f\n"", a[i].d);
                break;
            }
            
            }
            

        }
    
        static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    }




@2da14a57f39dc78ad76259d5ccbccb6b@"
"b03611015","0","1.35","185184","@b2b811b55d95555e9c03cfd12ec28bc3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Steven
 */
public class CriticalDis {

    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] in = br.readLine().split("" "");
                p[i] = new Point2D(Double.parseDouble(in[0]), Double.parseDouble(in[1]));
            }
            int source = 0;
            int target = 0;
            for (int i = 1; i < N; i++) {
                if (p[i].x() + p[i].y() > p[source].x() + p[source].y()) {
                    source = i;
                }
                if (p[i].x() + p[i].y() < p[target].x() + p[target].y()) {
                    target = i;
                }
            }
            ArrayList<Distance> dis = new ArrayList<Distance>();
            for (int i = 0; i <p.length; i++) {
                Point2D p1 = p[i];
                for(int j=0;j<p.length;j++){
                    Point2D p2 = p[j];
                    if(p1.x()<p2.x()&&p1.y()<p2.y()) dis.add(new Distance(p1.distanceTo(p2),i,j));
                }
            }
            Distance[] a =dis.toArray(new Distance[dis.size()]);
            
            Arrays.sort(a);
            Digraph digraph = new Digraph(N);
            
            for(int i=0 ; i<a.length;i++){
            digraph.addEdge(a[i].i,a[i].j);
            DirectedDFS dfs = new DirectedDFS(digraph,source);
            
            if(dfs.marked(target)==true)
                System.out.printf(""%1.3f\n"", a[i].d);
                break;
            }
            
            }
            

        }
    
        static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }
        @Override
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    }




@b2b811b55d95555e9c03cfd12ec28bc3@"
"b03611015","0","1.53","248080","@91d6115b8b34ea9d3908e4e7d34c9124@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Steven
 */
public class CriticalDis {

    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] in = br.readLine().split("" "");
                p[i] = new Point2D(Double.parseDouble(in[0]), Double.parseDouble(in[1]));
            }
            int source = 0;
            int target = 0;
            for (int i = 1; i < N; i++) {
                if (p[i].x() + p[i].y() > p[source].x() + p[source].y()) {
                    source = i;
                }
                if (p[i].x() + p[i].y() < p[target].x() + p[target].y()) {
                    target = i;
                }
            }
            ArrayList<Distance> dis = new ArrayList<Distance>();
            for (int i = 0; i <p.length; i++) {
                Point2D p1 = p[i];
                for(int j=0;j<p.length;j++){
                    Point2D p2 = p[j];
                    if(p1.x()<p2.x()&&p1.y()<p2.y()) dis.add(new Distance(p1.distanceTo(p2),i,j));
                }
            }
            Distance[] a =dis.toArray(new Distance[dis.size()]);
            
            Arrays.sort(a);
            Digraph digraph = new Digraph(N);
            
            for(int i=0 ; i<a.length;i++){
            digraph.addEdge(a[i].i,a[i].j);
            DirectedDFS dfs = new DirectedDFS(digraph,source);
            
            if(dfs.marked(target)==true){
                System.out.printf(""%1.3f\n"", a[i].d);
                break;
            }
            }
            
            }
            

        }
    
        static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }
        @Override
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    }




@91d6115b8b34ea9d3908e4e7d34c9124@"
"b03611015","10","0.144","205040","@be595910ac93688e89faed1170e72833@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Steven
 */
public class CriticalDis {

    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] in = br.readLine().split("" "");
                p[i] = new Point2D(Double.parseDouble(in[0]), Double.parseDouble(in[1]));
            }
            int source = 0;
            int target = 0;
            for (int i = 1; i < N; i++) {
                if (p[i].x() + p[i].y() < p[source].x() + p[source].y()) {
                    source = i;
                }
                if (p[i].x() + p[i].y() > p[target].x() + p[target].y()) {
                    target = i;
                }
            }
            ArrayList<Distance> dis = new ArrayList<Distance>();
            for (int i = 0; i <p.length; i++) {
                Point2D p1 = p[i];
                for(int j=0;j<p.length;j++){
                    Point2D p2 = p[j];
                    if(p1.x()<p2.x()&&p1.y()<p2.y()) dis.add(new Distance(p1.distanceTo(p2),i,j));
                }
            }
            Distance[] a =dis.toArray(new Distance[dis.size()]);
            
            Arrays.sort(a);
            Digraph digraph = new Digraph(N);
            
            for(int i=0 ; i<a.length;i++){
            digraph.addEdge(a[i].i,a[i].j);
            DirectedDFS dfs = new DirectedDFS(digraph,source);
            
            if(dfs.marked(target)==true){
                System.out.printf(""%1.3f\n"", a[i].d);
                break;
            }
            }
            
            }
            

        }
    
        static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }
        @Override
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    }




@be595910ac93688e89faed1170e72833@"
"b03611041","0","0.93","118768","@b3399622b841fcfdb870b37448f99d32@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis{
    static class ptCompare implements Comparator<Point2D>{
        public int compare(Point2D a,Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    public static void main(String[] args)throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum=Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source=new Point2D(1,1),target=new Point2D(0,0);
            ArrayList<Point2D> vertexes=new ArrayList<>(vertexNum);
//            Point2D[] vertexes=new Point2D[vertexNum];
            Digraph digraph=new Digraph(vertexNum);
            double glmin=0;

            for (int i=0;i<vertexNum;i++){
                String t=br.readLine();
                tmp=t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]),Double.parseDouble(tmp[1])));
                if (source.x()+source.y()>=vertexes.get(i).x()+vertexes.get(i).y())source=vertexes.get(i);
                if (target.x()+target.y()<=vertexes.get(i).x()+vertexes.get(i).y())target=vertexes.get(i);
            }
            Collections.sort(vertexes,new ptCompare());

            int nextPt = vertexes.indexOf(source);
//            System.out.println(nextPt);
            for (; nextPt < vertexNum;) {
                double minDis=1.5;
                Point2D minP = null;
                for (int j = nextPt+1; j < vertexNum; j++) {
                    if(vertexes.get(j).y()<=vertexes.get(nextPt).y())continue;
                    double Dis=vertexes.get(nextPt).distanceTo(vertexes.get(j));
                    if(Dis<minDis){
                        minDis=Dis;
                        minP = vertexes.get(j);
                    }
                }
                digraph.addEdge(nextPt,vertexes.indexOf(minP));
//                System.out.println(minDis);
                if(minDis>glmin)glmin=minDis;
                if(minP.equals(target))break;
                nextPt=vertexes.indexOf(minP);
            }
//            System.out.println(source);
//            System.out.println(target);
//            for (Point2D t:vertexes) System.out.println(t);
            System.out.println(glmin);
        }
    }
}

@b3399622b841fcfdb870b37448f99d32@"
"b03611041","4","0.97","125248","@cd05f986bf86c1ea1a922baa1c9157f6@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis{
    static class ptCompare implements Comparator<Point2D>{
        public int compare(Point2D a,Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    public static void main(String[] args)throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum=Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source=new Point2D(1,1),target=new Point2D(0,0);
            ArrayList<Point2D> vertexes=new ArrayList<>(vertexNum);
//            Point2D[] vertexes=new Point2D[vertexNum];
            Digraph digraph=new Digraph(vertexNum);
            double glmin=0;

            for (int i=0;i<vertexNum;i++){
                String t=br.readLine();
                tmp=t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]),Double.parseDouble(tmp[1])));
                if (source.x()+source.y()>=vertexes.get(i).x()+vertexes.get(i).y())source=vertexes.get(i);
                if (target.x()+target.y()<=vertexes.get(i).x()+vertexes.get(i).y())target=vertexes.get(i);
            }
            Collections.sort(vertexes,new ptCompare());

            int nextPt = vertexes.indexOf(source);
//            System.out.println(nextPt);
            for (; nextPt < vertexNum;) {
                double minDis=1.5;
                Point2D minP = null;
                for (int j = nextPt+1; j < vertexNum; j++) {
                    if(vertexes.get(j).y()<=vertexes.get(nextPt).y())continue;
                    double Dis=vertexes.get(nextPt).distanceTo(vertexes.get(j));
                    if(Dis<minDis){
                        minDis=Dis;
                        minP = vertexes.get(j);
                    }
                }
                digraph.addEdge(nextPt,vertexes.indexOf(minP));
//                System.out.println(minDis);
                if(minDis>glmin)glmin=minDis;
                if(minP.equals(target))break;
                nextPt=vertexes.indexOf(minP);
            }
//            System.out.println(source);
//            System.out.println(target);
//            for (Point2D t:vertexes) System.out.println(t);
            System.out.printf(""%1.3f\n"", glmin);
        }
    }
}

@cd05f986bf86c1ea1a922baa1c9157f6@"
"r03525006","4","0.88","106640","@f5475a6b19951b10e97ce6cfd418630f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Created by ASUS on 2016/6/8.
 */
public class CriticalDis {

    CriticalDis() {
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int size = Integer.parseInt(br.readLine());
            Point2D[] point = new Point2D[size];
            for (int i = 0; i < size; i++) {
                String[] xy = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
                point[i] = p;
            }
            int sourceIndex = 0, targetIndex = 0;
            for (int i = 0; i < size; i++) {
                if (point[i].x()+point[i].y() < point[sourceIndex].x()+point[sourceIndex].y()) {
                    sourceIndex = i;
                }
                if (point[i].x()+point[i].y() > point[targetIndex].x()+point[targetIndex].y()) {
                    targetIndex = i;
                }
            }
            List<List<Integer>> list = new ArrayList<>(size);
            Digraph digraph = new Digraph(size);
            for (int i = 0; i < size; i++) {
                List<Integer> temp = new ArrayList<>();
                for (int j = 0; j < size; j++) {
                    if (point[i].x() < point[j].x() && point[i].y() < point[j].y())
                        temp.add(j); digraph.addEdge(i,j);
                } list.add(temp);
            }
            List<Double> disList = new ArrayList<>();
            int nextIndex = sourceIndex;
            double thisDis;
            while (nextIndex != targetIndex) {
                List<Integer> thisList = list.get(nextIndex);
                int minIndex = thisList.get(0);
                double minDis = point[nextIndex].distanceTo(point[minIndex]);
                for (int i = 0; i < thisList.size(); i++) {
                    DirectedDFS d = new DirectedDFS(digraph,thisList.get(i));
                    thisDis = point[nextIndex].distanceTo(point[thisList.get(i)]);
                    if (d.marked(targetIndex)) {
                        if (thisDis < minDis) {
                            minIndex = thisList.get(i);
                            minDis = thisDis;
                        }
                    }
                } nextIndex = minIndex; disList.add(minDis);
            }

            double maxDisOfList = disList.get(0);
            for (int i = 0; i < disList.size(); i++)
                if (disList.get(i) > maxDisOfList) maxDisOfList = disList.get(i);
            System.out.printf(""%1.3f\n"", maxDisOfList);
        }
    }
}

@f5475a6b19951b10e97ce6cfd418630f@"
"r03525006","4","0.87","110224","@739028d3307855b5e1cf9a275a8910a4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by ASUS on 2016/6/8.
 */
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int size = Integer.parseInt(br.readLine());
            Point2D[] point = new Point2D[size];
            for (int i = 0; i < size; i++) {
                String[] xy = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(xy[0]),Double.parseDouble(xy[1]));
                point[i] = p;
            }
            int sourceIndex = 0, targetIndex = 0;
            for (int i = 0; i < size; i++) {
                if (point[i].x()+point[i].y() < point[sourceIndex].x()+point[sourceIndex].y()) {
                    sourceIndex = i;
                }
                if (point[i].x()+point[i].y() > point[targetIndex].x()+point[targetIndex].y()) {
                    targetIndex = i;
                }
            }
            List<List<Integer>> list = new ArrayList<>(size);
            Digraph digraph = new Digraph(size);
            for (int i = 0; i < size; i++) {
                List<Integer> temp = new ArrayList<>();
                for (int j = 0; j < size; j++) {
                    if (point[i].x() < point[j].x() && point[i].y() < point[j].y())
                        temp.add(j); digraph.addEdge(i,j);
                } list.add(temp);
            }
            List<Double> disList = new ArrayList<>();
            int nextIndex = sourceIndex;
            double thisDis;
            while (nextIndex != targetIndex) {
                List<Integer> thisList = list.get(nextIndex);
                int minIndex = thisList.get(0);
                double minDis = point[nextIndex].distanceTo(point[minIndex]);
                for (int i = 0; i < thisList.size(); i++) {
                    DirectedDFS d = new DirectedDFS(digraph,thisList.get(i));
                    thisDis = point[nextIndex].distanceTo(point[thisList.get(i)]);
                    if (d.marked(targetIndex)) {
                        if (thisDis < minDis) {
                            minIndex = thisList.get(i);
                            minDis = thisDis;
                        }
                    }
                } nextIndex = minIndex; disList.add(minDis);
            }

            double maxDisOfList = disList.get(0);
            for (int i = 0; i < disList.size(); i++)
                if (disList.get(i) > maxDisOfList) maxDisOfList = disList.get(i);
            System.out.printf(""%1.3f\n"", maxDisOfList);
        }
    }
}

@739028d3307855b5e1cf9a275a8910a4@"
"r02b48003","10","0.176","224048","@79e6f602fd6382744cc48c3a05268314@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * Homework 11: Find Critical Distance
 * Build a directed graph and find the critical distance of two points.
 * @author r02b48003 柯逵悅
 */
public class CriticalDis {
    private int idxSrc, idxTar; // index for source and target
    private double cDist;       // critical distance
    private MinPQ<Double> pq;   // Priority Queue; store lengths of all edges
    private boolean[] marked;   // label visited nodes, which are set True
    private final Point2D[] points; // all input points
    private final Digraph graph;    // directed graph formed by input points
    
    /**
     * Constructor
     * find the source and target, which have minimum and maximum x+y
     * construct the graph using input point, edges are constructed 
     * from left below to right above, regardless of distance
     * @param points 
     */
    public CriticalDis (Point2D[] points) {
        // sort by X coordinate and initialization
        Arrays.sort(points, Point2D.X_ORDER);
        this.points = points;
        this.pq = new MinPQ<>();
        this.graph = new Digraph(points.length);
        
        // determine source and target    
        // find min(x+y) and max(x+y)
        idxSrc = 0; idxTar = 0;
        double sumXYMin = points[0].x() + points[0].y();
        double sumXYMax = points[0].x() + points[0].y();
        
        for (int idx = 0; idx < points.length; idx++) {
            double sumXY = points[idx].x() + points[idx].y();
            if (sumXY < sumXYMin) {sumXYMin = sumXY; idxSrc = idx;}
            if (sumXY > sumXYMax) {sumXYMax = sumXY; idxTar = idx;}
        } // end for loop
        
        // construct graph and priority queue
        // for each point p
        for (int idx1 = 0; idx1 < (points.length-1); idx1++) {
            // since points are sorted by X, we only need to 
            // check whether right side of point p is above
            // if true, add edge and store distance of edge
            for (int idx2 = (idx1+1); idx2 < points.length; idx2++) {
                if (points[idx1].y() <= points[idx2].y()) {
                    graph.addEdge(idx1, idx2);
                    pq.insert(points[idx1].distanceTo(points[idx2]));
                } // end if
            } // end inner loop 
        } // end outer loop
        
        // find the critical distance
        cDist = searchDist();
        depthFirstSearch(cDist);
    } // end constructor
    
    /**
     * Getter: getDist
     * return the critical distance
     * @return double
     */
    public double getDist(){
        return cDist;
    } // end fund getDist
    
    /**
     * Method: searchDist
     * find the critical distance and return
     * @return double; the critical distance
     */
    private double searchDist() {
        while(!pq.isEmpty()) {
            // each time get minimum distance edge and perform DFS search
            Double dist = pq.delMin();
            depthFirstSearch(dist);
            
            // check if target is visited;
            // if true, return the distance
            if (visited(idxTar)) return dist;
        } // end while
        
        // in case we do not find critical distance
        System.out.println(""ERROR!! No Distance are found"");
        return -1.0;
    } // end searchCdist
    
    /**
     * Method: depthFirstSearch
     * using input distance to perform depth first search (dfs)
     * from source point
     * @param dist 
     */
    private void depthFirstSearch(double dist) {
        marked = new boolean[graph.V()];
        dfs(idxSrc, dist);
    } // end func DepthFirstSearch
    
    /**
     * Method: dfs
     * the recursive function that run DFS in graph
     * each neighbor will be visited if the distance 
     * to it is smaller than input distance
     * @param v    ; integer: the current nodes
     * @param dist ; double:  the input distance
     */
    private void dfs(int v, double dist) {
        marked[v] = true;
        for (int w : graph.adj(v))
            if (!marked[w] && points[v].distanceTo(points[w]) <= dist){
                dfs(w, dist);
            } // end if
    } // end func dfs
    
    /**
     * Method: visited
     * return true if the input node is visited
     * @param v
     * @return boolean
     */
    public boolean visited(int v) {
        return marked[v];  
    } // end func visited
    
    /**
     * Method: printPoints
     * this method is used for debugging code
     * the method print out all the points, source point and target point
     */
    private void printPoints(){
        // print out the points in array
        // index | X | Y | X+Y
        for (int idx = 0; idx < points.length; idx++) {
            Point2D p = points[idx];
            System.out.println(
                idx + "" "" + p.x() + "" "" + p.y() + "" "" + (p.x()+p.y()));
        } // end for loop
        
        // print out the source & target
        System.out.println(idxSrc);
        System.out.println(idxTar); 
    } // end func printPoints
    
    /**
     * Method plot
     * useful method for bebugging the code
     * show the source, target, edges
     * @param dist 
     */
    public void plot(double dist){
        // set scale and axes
        StdDraw.setCanvasSize(1000, 1000);
        StdDraw.setXscale(-0.2, 1.2);
        StdDraw.setYscale(-0.2, 1.2);
        StdDraw.line(0,-0.1,0,1.1);
        StdDraw.line(-0.1,0,1.1,0);
                
        // plot all the points
        StdDraw.setPenColor(StdDraw.BLACK);
        for (Point2D p : points) {
            StdDraw.filledCircle(p.x(), p.y(), 0.01);
        } // end for loop
        
        // plot all the edges in graph
        StdDraw.setPenColor(StdDraw.BLUE);
        for (int idx1 = 0; idx1 < graph.V(); idx1++) {
            for (int idx2 : graph.adj(idx1)) {
                StdDraw.line(points[idx1].x(), points[idx1].y(),
                             points[idx2].x(), points[idx2].y());
            } // end inner for loop
        } // end outer for loop
        
        // plot the visited points
        StdDraw.setPenColor(StdDraw.RED);
        for (int idx = 0; idx < graph.V(); idx++) {
            if (marked[idx]) {
                StdDraw.filledCircle(points[idx].x(), points[idx].y(), 0.01);
            } // end if
        } // end for loop
        
        // plot source & target points
        StdDraw.setPenColor(StdDraw.PINK);
        StdDraw.filledCircle(points[idxSrc].x(), points[idxSrc].y(), 0.01);
        StdDraw.setPenColor(StdDraw.GREEN);
        StdDraw.filledCircle(points[idxTar].x(), points[idxTar].y(), 0.01);
        
        // plot edge with length <= input distance
        StdDraw.setPenColor(StdDraw.RED);
        for (int idx1 = 0; idx1 < graph.V(); idx1++) {
            for (int idx2 : graph.adj(idx1)) {
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    StdDraw.line(points[idx1].x(), points[idx1].y(),
                                 points[idx2].x(), points[idx2].y());
                } // end if
            } // end inner for loop
        } // end outer for loop
        
        // show if the source is visited & input distance
        if (visited(idxTar)) { StdDraw.text(1.0, 1.0, ""Target Visited"");   }
        else                 { StdDraw.text(1.0, 1.0, ""Target Unvisited""); }
        StdDraw.text( 1.0, 0.95, ""Distance: "" +
            String.valueOf(Math.round(100000.0 * cDist)/100000.0));
    } // end func plot
    
    public static void main(String[] args) throws Exception {
        // declaration        
        String[]    line;
        Point2D     points[];
        int         count;
        CriticalDis cds;
        
        // read in the points from 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // first line contain the number of points
            String header = br.readLine();
            count  = Integer.parseInt(header);
            points = new Point2D[count];
            
            // rest of lines contain points
            for (int idx = 0; idx < count; idx++) {
                line = br.readLine().split("" "");
                double x = Double.parseDouble(line[0]);
                double y = Double.parseDouble(line[1]);
                points[idx] = new Point2D(x, y);
                //System.out.println(x + "" "" + y);
            } // end for loop
        } // end try
        
        // find critical Distance
        cds = new CriticalDis(points);        
        System.out.printf(""%1.3f\n"", cds.getDist());
        
        // plot the result
        //cds.plot(cds.getDist());
    } // end main
} // end main class

@79e6f602fd6382744cc48c3a05268314@"
"r04921012","9","0.91","105728","@9bca5139ed0dc771fe63627b6731c15a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package criticaldis;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 *
 * @author ncslab
 */
public class CriticalDis {
    public static double d = 0;
    public static PriorityQueue<event> eventPQ = new PriorityQueue();
    public static int N;
    public static Point2D[] input = null;
    public static Point2D target; 
    public static Point2D source;
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        

        
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            N = Integer.parseInt(br.readLine());
            input = new Point2D[N];
            for (int i = 0 ; i < N ; i++){
                String[] read = br.readLine().split("" "");
                double x = Double.parseDouble(read[0]);
                double y = Double.parseDouble(read[1]);
                
                input[i] = new Point2D(x, y);
                
            }
        }
        xyComparator xy = new xyComparator();
        Arrays.sort(input, xy);
        source = input[0];
        target = input[N-1];
        recurSearch();
        System.out.printf(""%1.3f\n"", d); 
        
        
    }
    
    public static void recurSearch(){
        Point2D to = source;
        generateEvent(source, 0);
        while(to.x() != target.x() && to.y() != target.y()){
            event e = eventPQ.poll();
            if (e.dis > d)
                d = e.dis;
            generateEvent(e.to, e.to_index);
            to = e.to;
        }
    }
    
    public static void generateEvent(Point2D s, int index){
        for (int i = index + 1 ; i < N ; i++){
            if (input[i].x() > s.x() && input[i].y() > s.y())
                 eventPQ.add(new event(s, input[i], i));
        }
        
    }

}
        class xyComparator implements Comparator<Point2D>{
            @Override
            public int compare(Point2D t, Point2D t1) {
                
                if ((t.x() + t.y()) > (t1.x() + t1.y()))
                    return 1;
                else if ((t.x() + t.y()) == (t1.x() + t1.y()))
                    return 0;
                else
                    return -1;
            }
        }

    class event implements Comparable<event>{
        public Point2D from;
        public Point2D to;
        public double dis;
        public int to_index;
        public event(Point2D from, Point2D to, int index){
            this.from = from;
            this.to = to;
            this.to_index = index;
            this.dis = from.distanceTo(to);
        }
        @Override
        public int compareTo(event that) {
            if (this.dis > that.dis) return 1;
            else if (this.dis == that.dis) return 0;
            else return -1;
        }
        
    }
@9bca5139ed0dc771fe63627b6731c15a@"
"b03611033","0","0.95","107968","@50c8dc4d7c24dad26bca8c9f3bab8cb8@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;


            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
            }


            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    dis.insert(points[i].distanceTo(points[j]));
                }
            }
            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) < d) {
                            if ((points[i].x() + points[i].y()) < (points[j].x() + points[j].y())) {
                                G.addEdge(i, j);
                            } else {
                                G.addEdge(j, i);
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@50c8dc4d7c24dad26bca8c9f3bab8cb8@"
"b03611033","0","0.84","117536","@4613772920c48e7508116d62f6e55c1c@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;


            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
            }


            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    dis.insert(points[i].distanceTo(points[j]));
                }
            }
            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) < d) {
                            if ((points[i].x() < points[j].x()) &&  (points[i].y()< points[j].y())) {
                                G.addEdge(i, j);
                            } else if((points[i].x() > points[j].x()) &&  (points[i].y()> points[j].y())){
                                G.addEdge(j, i);
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@4613772920c48e7508116d62f6e55c1c@"
"b03611033","9","0.96","112496","@d206472f4b9aa93a05ba2f27b301b263@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
            }

            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    dis.insert(points[i].distanceTo(points[j]));
                }
            }
            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) <= d) {
                            if ((points[i].x() < points[j].x()) &&  (points[i].y()< points[j].y())) {
                                G.addEdge(i, j);
                            } else if((points[i].x() > points[j].x()) &&  (points[i].y()> points[j].y())){
                                G.addEdge(j, i);
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@d206472f4b9aa93a05ba2f27b301b263@"
"b03611033","9","0.99","114832","@bf4b9871ef19aa4ff5071e660aa0227d@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
                
            }

            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) <= d) {
                            if ((points[i].x() < points[j].x()) &&  (points[i].y()< points[j].y())) {
                                G.addEdge(i, j);
                            } else if((points[i].x() > points[j].x()) &&  (points[i].y()> points[j].y())){
                                G.addEdge(j, i);
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@bf4b9871ef19aa4ff5071e660aa0227d@"
"b03611033","9","0.99","112576","@66222e11c85c3eb2ceab28a27b264046@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
            }

            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                int count=0;
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) <= d) {
                            if ((points[i].x() < points[j].x()) &&  (points[i].y()< points[j].y())) {
                                if(i==minid ||i==maxid) count++;
                                G.addEdge(i, j);
                            } else if((points[i].x() > points[j].x()) &&  (points[i].y()> points[j].y())){
                                if(i==minid ||i==maxid) count++;
                                G.addEdge(j, i);
                            }
                        }
                    }
                    if(i==minid && count==0)break;
                    if(i==maxid && count==0)break;
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@66222e11c85c3eb2ceab28a27b264046@"
"b03611033","9","0.99","116800","@8ed0443206e16a0cc77c07f7cd1636d6@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
//        long time1=System.currentTimeMillis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
            }

            double d;

            while (true) {
                d = dis.delMin();
                Digraph G = new Digraph(N);
                int count=0;
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) <= d) {
                            if (points[i].x() < points[j].x()){
                                if (points[i].y()< points[j].y()){
                                    G.addEdge(i, j);
                                }
                            } else if(points[i].x() > points[j].x()) {
                                if (points[i].y()> points[j].y()){
                                    G.addEdge(j, i);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
//            long time2=System.currentTimeMillis();
//            StdOut.println(time2-time1);
        }

    }
}

@8ed0443206e16a0cc77c07f7cd1636d6@"
"b03611033","9","1.01","118816","@849f2dfaab81df33c913bcfe73f3e999@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
//        long time1=System.currentTimeMillis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
            }

            double d;
            Digraph G = new Digraph(N);

            while (true) {
                d = dis.delMin();
                int count=0;
                for (int i = 0; i < N; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (points[i].distanceTo(points[j]) <= d) {
                            if (points[i].x() < points[j].x()){
                                if (points[i].y()< points[j].y()){
                                    G.addEdge(i, j);
                                }
                            } else if(points[i].x() > points[j].x()) {
                                if (points[i].y()> points[j].y()){
                                    G.addEdge(j, i);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
//            long time2=System.currentTimeMillis();
//            StdOut.println(time2-time1);
        }

    }
}

@849f2dfaab81df33c913bcfe73f3e999@"
"b03611033","9","1.06","126224","@55ef6b87794c95b723ffcc304d984ff9@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception {
//        long time1=System.currentTimeMillis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
            }

            double d;
            Digraph G = new Digraph(N);

            while (true) {
                d = dis.delMin();
                for (int i = 0; i < N; i++) {
                    DirectedDFS dfs = new DirectedDFS(G, i);
                    for (int j = i + 1; j < N; j++) {
                        if(!dfs.marked(j)){
                        if (points[i].distanceTo(points[j]) <= d) {
                            if (points[i].x() < points[j].x()){
                                if (points[i].y()< points[j].y()){
                                    G.addEdge(i, j);
                                }
                            } else if(points[i].x() > points[j].x()) {
                                if (points[i].y()> points[j].y()){
                                    G.addEdge(j, i);
                                }
                            }
                        }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            System.out.printf(""%1.3f\n"", d);
//            long time2=System.currentTimeMillis();
//            StdOut.println(time2-time1);
        }

    }
}

@55ef6b87794c95b723ffcc304d984ff9@"
"r04921012","10","0.106","135808","@4fa0fa42c2b1d059c732d279b4b43a22@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package criticaldis;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 *
 * @author ncslab
 */
public class CriticalDis {
    public static double d = 0;
    public static PriorityQueue<event> eventPQ = new PriorityQueue();
    public static int N;
    public static Point2D[] input = null;
    public static Point2D target; 
    public static Point2D source;
    public static boolean[] marked;
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        

        
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            N = Integer.parseInt(br.readLine());
            input = new Point2D[N];
            for (int i = 0 ; i < N ; i++){
                String[] read = br.readLine().split("" "");
                double x = Double.parseDouble(read[0]);
                double y = Double.parseDouble(read[1]);
                
                input[i] = new Point2D(x, y);
                
            }
        }
        xyComparator xy = new xyComparator();
        Arrays.sort(input, xy);
        source = input[0];
        target = input[N-1];
        marked = new boolean[N];
        recurSearch();
        System.out.printf(""%1.3f\n"", d); 
        
        
    }
    
    public static void recurSearch(){
        Point2D to = source;
        generateEvent(source, 0);
        while(to.x() != target.x() && to.y() != target.y()){
            event e = eventPQ.poll();
            
            if (marked[e.to_index]){
                while(marked[e.to_index])
                    e = eventPQ.poll();
            }
            if (e.dis > d)
                d = e.dis;
            generateEvent(e.to, e.to_index);
            marked[e.to_index] = true;
            to = e.to;
        }
    }
    
    public static void generateEvent(Point2D s, int index){
        for (int i = index + 1 ; i < N ; i++){
            if (input[i].x() > s.x() && input[i].y() > s.y())
                 eventPQ.add(new event(s, input[i], i));
        }
        
    }

}
        class xyComparator implements Comparator<Point2D>{
            @Override
            public int compare(Point2D t, Point2D t1) {
                
                if ((t.x() + t.y()) > (t1.x() + t1.y()))
                    return 1;
                else if ((t.x() + t.y()) == (t1.x() + t1.y()))
                    return 0;
                else
                    return -1;
            }
        }

    class event implements Comparable<event>{
        public Point2D from;
        public Point2D to;
        public double dis;
        public int to_index;
        public event(Point2D from, Point2D to, int index){
            this.from = from;
            this.to = to;
            this.to_index = index;
            this.dis = from.distanceTo(to);
        }
        @Override
        public int compareTo(event that) {
            if (this.dis > that.dis) return 1;
            else if (this.dis == that.dis) return 0;
            else return -1;
        }
        
    }
@4fa0fa42c2b1d059c732d279b4b43a22@"
"r04921074","1","1.05","109936","@219e71ed00487560d677e92972ac3fe0@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */

//************************** inner class ************************************\\
//************************** storing type of distance ************************\\    
public class CriticalDis {
        class Edge{
            Point2D pointB;
            Point2D pointS;
            double distance;
            
            Edge(Point2D B,Point2D S){
                this.pointB = B;
                this.pointS = S;
                this.distance = B.distanceSquaredTo(S);
            }
    }
    
//******************************* properties *********************************\\            
  //  public Point2D[] points; // The constructor of points can be changed; !!!!!!!!!!!!!!!
    public CriticalDis(){}
    //private Queue<Edge> ALL;

//******************* MAIN : read position information ***********************\\    
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String N = br.readLine();
            Point2D[] points = new Point2D[Integer.parseInt(N)];         //所有讀取到的點 放起來
            Map<Point2D,Integer> map = new HashMap<Point2D,Integer>(); //放著點跟代號的對照表
            Point2D ref = new Point2D(0,0);
            Point2D max = new Point2D(0,0);
            Point2D min = new Point2D(0.999,0.999);
            MinPQ<Double> distances = new MinPQ<>();
            
            int count=0;
            
            
            while (br.ready())
            {
                String buf[] = br.readLine().split("" "");
          //      System.out.println(buf[0]+"" \t""+buf[1]);
                double x = Double.valueOf(buf[0]);
                double y = Double.valueOf(buf[1]);
                points[count] = new Point2D(x,y);
                if( (points[count].x()+points[count].y()) > (max.x()+max.y() ) )  max = points[count];
                if( (points[count].x()+points[count].y()) < (min.x()+min.y() ) )   min = points[count];
                map.put(points[count],count);
                count++;
            }
           for(int i=0; i<Integer.parseInt(N); i++){
                for(int j=i+1 ; j<Integer.parseInt(N); j++){
                    distances.insert(points[i].distanceTo(points[j]));
                   
                }
            }
            
            boolean connect = false;
            double tempd = 0;
            
            while(!connect&&!distances.isEmpty()){
                tempd = distances.delMin();
                DepthFirstDirectedPaths p = new DepthFirstDirectedPaths(Graphing(points,tempd),map.get(min));
                connect = p.hasPathTo(map.get(max));
            }
               System.out.printf(""%1.3f\n"", tempd);
           
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(max.x(),max.y());
//                StdDraw.setPenColor(StdDraw.PINK);
//                StdDraw.point(min.x(),min.y());
//                System.out.println(""MAX : \t""+map.get(max)+"" \t""+max.x()+"" \t""+max.y());
//                System.out.println(""MIN : \t""+map.get(min)+"" \t""+min.x()+"" \t""+min.y());
            CriticalDis WTever = new CriticalDis();
     //       WTever.Graphing(points,map,G);
            
       }
     }       
//****************************************************************************\\
//***************************** get every edge *******************************\\    
    static public Digraph Graphing(Point2D[] points,double dis){
        
        int N = points.length;
        Digraph G = new Digraph (N);
        int k = 0;
        for(int i=0; i<N; i++){
            for(int j=0 ; j<N; j++){
                if(points[i].x()>points[j].x() && points[i].y()>points[j].y()){
                    if(dis > points[i].distanceTo(points[j])&&points[i].distanceTo(points[j])!=0){
                    //System.out.println(points[i].distanceTo(points[j])+""\t ""+j+"" ""+i);
                    G.addEdge(j, i);
                    }
                }
            }            
        }//*********** end of for
        
//                for(int i=0; i<N ; i++){
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.GRAY);
//                StdDraw.point(points[i].x(),points[i].y());
//                }
//                StdDraw.setPenRadius(0.02);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(points[8].x(),points[8].y());
//                StdDraw.point(points[14].x(),points[14].y());
//                StdDraw.setPenRadius(0.001);
//                StdDraw.circle(points[8].x(),points[8].y(), 0.357);
//                StdDraw.circle(points[14].x(),points[14].y(), 0.357);
//                StdDraw.line(points[14].x(), points[14].y(), points[2].x(), points[2].y());
            return G;
    }
//****************************************************************************\\      
}

@219e71ed00487560d677e92972ac3fe0@"
"r04921074","1","1.03","110304","@0e935e0412bc0b21f568c7d148bee6a1@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */

//************************** inner class ************************************\\
//************************** storing type of distance ************************\\    
public class CriticalDis {
        class Edge{
            Point2D pointB;
            Point2D pointS;
            double distance;
            
            Edge(Point2D B,Point2D S){
                this.pointB = B;
                this.pointS = S;
                this.distance = B.distanceSquaredTo(S);
            }
    }
    
//******************************* properties *********************************\\            
  //  public Point2D[] points; // The constructor of points can be changed; !!!!!!!!!!!!!!!
    public CriticalDis(){}
    //private Queue<Edge> ALL;

//******************* MAIN : read position information ***********************\\    
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String N = br.readLine();
            Point2D[] points = new Point2D[Integer.parseInt(N)];         //所有讀取到的點 放起來
            Map<Point2D,Integer> map = new HashMap<Point2D,Integer>(); //放著點跟代號的對照表
            Point2D ref = new Point2D(0,0);
            Point2D max = new Point2D(0,0);
            Point2D min = new Point2D(0.999,0.999);
            MinPQ<Double> distances = new MinPQ<>();
            
            int count=0;
            
            
            while (br.ready())
            {
                String buf[] = br.readLine().split("" "");
          //      System.out.println(buf[0]+"" \t""+buf[1]);
                double x = Double.valueOf(buf[0]);
                double y = Double.valueOf(buf[1]);
                points[count] = new Point2D(x,y);
                if( (points[count].x()+points[count].y()) > (max.x()+max.y() ) )  max = points[count];
                if( (points[count].x()+points[count].y()) < (min.x()+min.y() ) )   min = points[count];
                map.put(points[count],count);
                count++;
            }
            
           for(int i=0; i<Integer.parseInt(N); i++){
                for(int j=i+1 ; j<Integer.parseInt(N); j++){
                    distances.insert(points[i].distanceTo(points[j]));
                }
            }
            
            boolean connect = false;
            double tempd = 0;
            
            while(!connect&&!distances.isEmpty()){
                tempd = distances.delMin();
                DepthFirstDirectedPaths p = new DepthFirstDirectedPaths(Graphing(points,tempd),map.get(min));
                connect = p.hasPathTo(map.get(max));
            }
               float d = (float)tempd;
               System.out.printf(""%1.3f\n"", d);
           
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(max.x(),max.y());
//                StdDraw.setPenColor(StdDraw.PINK);
//                StdDraw.point(min.x(),min.y());
//                System.out.println(""MAX : \t""+map.get(max)+"" \t""+max.x()+"" \t""+max.y());
//                System.out.println(""MIN : \t""+map.get(min)+"" \t""+min.x()+"" \t""+min.y());
            CriticalDis WTever = new CriticalDis();
     //       WTever.Graphing(points,map,G);
            
       }
     }       
//****************************************************************************\\
//***************************** get every edge *******************************\\    
    static public Digraph Graphing(Point2D[] points,double dis){
        
        int N = points.length;
        Digraph G = new Digraph (N);
        int k = 0;
        for(int i=0; i<N; i++){
            for(int j=0 ; j<N; j++){
                if(points[i].x()>points[j].x() && points[i].y()>points[j].y()){
                    if(dis > points[i].distanceTo(points[j])&&points[i].distanceTo(points[j])!=0){
                    //System.out.println(points[i].distanceTo(points[j])+""\t ""+j+"" ""+i);
                    G.addEdge(j, i);
                    }
                }
            }            
        }//*********** end of for
        
//                for(int i=0; i<N ; i++){
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.GRAY);
//                StdDraw.point(points[i].x(),points[i].y());
//                }
//                StdDraw.setPenRadius(0.02);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(points[8].x(),points[8].y());
//                StdDraw.point(points[14].x(),points[14].y());
//                StdDraw.setPenRadius(0.001);
//                StdDraw.circle(points[8].x(),points[8].y(), 0.357);
//                StdDraw.circle(points[14].x(),points[14].y(), 0.357);
//                StdDraw.line(points[14].x(), points[14].y(), points[2].x(), points[2].y());
            return G;
    }
//****************************************************************************\\      
}

@0e935e0412bc0b21f568c7d148bee6a1@"
"r04921074","1","1.04","110096","@187cb771a149cd530cd4c27e175a0505@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */

//************************** inner class ************************************\\
//************************** storing type of distance ************************\\    
public class CriticalDis {
        class Edge{
            Point2D pointB;
            Point2D pointS;
            double distance;
            
            Edge(Point2D B,Point2D S){
                this.pointB = B;
                this.pointS = S;
                this.distance = B.distanceSquaredTo(S);
            }
    }
    
//******************************* properties *********************************\\            
  //  public Point2D[] points; // The constructor of points can be changed; !!!!!!!!!!!!!!!
    public CriticalDis(){}
    //private Queue<Edge> ALL;

//******************* MAIN : read position information ***********************\\    
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String N = br.readLine();
            Point2D[] points = new Point2D[Integer.parseInt(N)];         //所有讀取到的點 放起來
            Map<Point2D,Integer> map = new HashMap<Point2D,Integer>(); //放著點跟代號的對照表
            Point2D ref = new Point2D(0,0);
            Point2D max = new Point2D(0,0);
            Point2D min = new Point2D(0.999,0.999);
            MinPQ<Double> distances = new MinPQ<>();
            
            int count=0;
            
            
            while (br.ready())
            {
                String buf[] = br.readLine().split("" "");
          //      System.out.println(buf[0]+"" \t""+buf[1]);
                double x = Double.valueOf(buf[0]);
                double y = Double.valueOf(buf[1]);
                points[count] = new Point2D(x,y);
                if( (points[count].x()+points[count].y()) > (max.x()+max.y() ) )  max = points[count];
                if( (points[count].x()+points[count].y()) < (min.x()+min.y() ) )   min = points[count];
                map.put(points[count],count);
                count++;
            }
            
           for(int i=0; i<Integer.parseInt(N); i++){
                for(int j=i+1 ; j<Integer.parseInt(N); j++){
                    distances.insert(points[i].distanceTo(points[j]));
                }
            }
            
            boolean connect = false;
            double tempd = 0;
            
            while(!connect&&!distances.isEmpty()){
                tempd = distances.delMin();
                DepthFirstDirectedPaths p = new DepthFirstDirectedPaths(Graphing(points,tempd),map.get(min));
                connect = p.hasPathTo(map.get(max));
            }
               float d = (float)tempd;
               System.out.printf(""%1.3f\n"", d);
           
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(max.x(),max.y());
//                StdDraw.setPenColor(StdDraw.PINK);
//                StdDraw.point(min.x(),min.y());
//                System.out.println(""MAX : \t""+map.get(max)+"" \t""+max.x()+"" \t""+max.y());
//                System.out.println(""MIN : \t""+map.get(min)+"" \t""+min.x()+"" \t""+min.y());

     //       WTever.Graphing(points,map,G);
            
       }
     }       
//****************************************************************************\\
//***************************** get every edge *******************************\\    
    static public Digraph Graphing(Point2D[] points,double dis){
        
        int N = points.length;
        Digraph G = new Digraph (N);
        int k = 0;
        for(int i=0; i<N; i++){
            for(int j=0 ; j<N; j++){
                if(points[i].x()>points[j].x() && points[i].y()>points[j].y()){
                    if(dis > points[i].distanceTo(points[j])&&points[i].distanceTo(points[j])!=0){
                    G.addEdge(j, i);
                    }
                }
            }            
        }//*********** end of for
        
//                for(int i=0; i<N ; i++){
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.GRAY);
//                StdDraw.point(points[i].x(),points[i].y());
//                }
//                StdDraw.setPenRadius(0.02);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(points[8].x(),points[8].y());
//                StdDraw.point(points[14].x(),points[14].y());
//                StdDraw.setPenRadius(0.001);
//                StdDraw.circle(points[8].x(),points[8].y(), 0.357);
//                StdDraw.circle(points[14].x(),points[14].y(), 0.357);
//                StdDraw.line(points[14].x(), points[14].y(), points[2].x(), points[2].y());
            return G;
    }
//****************************************************************************\\      
}

@187cb771a149cd530cd4c27e175a0505@"
"r04921074","1","1.01","110400","@f54898b304fc6cd28e266fe3d45bbfea@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */

//************************** inner class ************************************\\
//************************** storing type of distance ************************\\    
public class CriticalDis {

//******************************* properties *********************************\\            
  //  public Point2D[] points; // The constructor of points can be changed; !!!!!!!!!!!!!!!
    public CriticalDis(){}
  

//******************* MAIN : read position information ***********************\\    
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String N = br.readLine();
            Point2D[] points = new Point2D[Integer.parseInt(N)];         //所有讀取到的點 放起來
            Map<Point2D,Integer> map = new HashMap<Point2D,Integer>(); //放著點跟代號的對照表
            Point2D ref = new Point2D(0,0);
            Point2D max = new Point2D(0,0);
            Point2D min = new Point2D(0.999,0.999);
            MinPQ<Double> distances = new MinPQ<>();
            
            int count=0;
            
            
           for (int i=0; i<Integer.parseInt(N); i++)
            {
                String buf[] = br.readLine().split("" "");
          //      System.out.println(buf[0]+"" \t""+buf[1]);
                double x = Double.valueOf(buf[0]);
                double y = Double.valueOf(buf[1]);
                points[i] = new Point2D(x,y);
                if( (points[i].x()+points[i].y()) > (max.x()+max.y() ) )  max = points[i];
                if( (points[i].x()+points[i].y()) < (min.x()+min.y() ) )   min = points[i];
                map.put(points[i],i);
          //      count++;
            }
            
           for(int i=0; i<Integer.parseInt(N); i++){
                for(int j=i+1 ; j<Integer.parseInt(N); j++){
                    distances.insert(points[i].distanceTo(points[j]));
                }
            }
            
            boolean connect = false;
            double tempd = 0;
            
            while(!connect&&!distances.isEmpty()){
                tempd = distances.delMin();
                DepthFirstDirectedPaths p = new DepthFirstDirectedPaths(Graphing(points,tempd),map.get(min));
                connect = p.hasPathTo(map.get(max));
            }
               System.out.printf(""%1.3f\n"", tempd);
           
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(max.x(),max.y());
//                StdDraw.setPenColor(StdDraw.PINK);
//                StdDraw.point(min.x(),min.y());
//                System.out.println(""MAX : \t""+map.get(max)+"" \t""+max.x()+"" \t""+max.y());
//                System.out.println(""MIN : \t""+map.get(min)+"" \t""+min.x()+"" \t""+min.y());

            
       }
     }       
//****************************************************************************\\
//***************************** get every edge *******************************\\    
    static public Digraph Graphing(Point2D[] points,double dis){
        
        int N = points.length;
        Digraph G = new Digraph (N);
        int k = 0;
        for(int i=0; i<N; i++){
            for(int j=0 ; j<N; j++){
                if(points[i].x()>points[j].x() && points[i].y()>points[j].y()){
                    if(dis > points[i].distanceTo(points[j])&&points[i].distanceTo(points[j])!=0){
                    G.addEdge(j, i);
                    }
                }
            }            
        }//*********** end of for
        
//                for(int i=0; i<N ; i++){
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.GRAY);
//                StdDraw.point(points[i].x(),points[i].y());
//                }
//                StdDraw.setPenRadius(0.02);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(points[8].x(),points[8].y());
//                StdDraw.point(points[14].x(),points[14].y());
//                StdDraw.setPenRadius(0.001);
//                StdDraw.circle(points[8].x(),points[8].y(), 0.357);
//                StdDraw.circle(points[14].x(),points[14].y(), 0.357);
//                StdDraw.line(points[14].x(), points[14].y(), points[2].x(), points[2].y());
            return G;
    }
//****************************************************************************\\      
}

@f54898b304fc6cd28e266fe3d45bbfea@"
"b03704074","7","1.16","122352","@03f4c42e266b912fe1a97f5adabef3b2@
import java.util.Arrays;


public class CriticalDis {
    public CriticalDis(){}
    
    double d = 1;
    public void Array(Point2D[] Points,double linodistance,Point2D prepointance,Point2D T,Point2D S){
        for(int i = 0;i < Points.length;i++){
            if(prepointance==S)linodistance = 0;
            double tempd = Math.sqrt(Math.pow(Points[i].x()-prepointance.x(),2)+Math.pow(Points[i].y()-prepointance.y(),2));
                if(tempd > d)continue;
                //System.out.println(""prepointance = ""+prepointance.x()+""  Points[i] = ""+Points[i].x());
                if(tempd > linodistance) linodistance = tempd;
               // System.out.println(""tempd = ""+tempd+""  linodistance = ""+linodistance);                
                if(Points[i]==T && linodistance<d){d = linodistance;}
                //System.out.println(""distance = ""+d);
                Point2D[] NextPoints = new Point2D[Points.length];
                int j = 0;
                for(int k = 0;k < Points.length;k++){
                    if(Points[k].x()>Points[i].x() && Points[k].y()>Points[i].y()){
                        NextPoints[j] = Points[k];
                        j++;
                    }
                }
                NextPoints = Arrays.copyOf(NextPoints, j);
                Array(NextPoints,linodistance,Points[i],T,S);
        }
        
        
    }
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()) S = A[i];
            if(a+b>T.x()+T.y()) T = A[i];            
        }
        
        double linod = 0;
        Point2D[] NextPoints = new Point2D[A.length];
        int j = 0;
        for(int i = 0;i < A.length;i++){
            if(A[i].x()>S.x() && A[i].y()>S.y()){
                NextPoints[j] = A[i];
                j++;
            }
        }
        NextPoints = Arrays.copyOf(NextPoints, j);
        CriticalDis cd = new CriticalDis();
        cd.Array(NextPoints, linod, S, T,S);
        
        System.out.printf(""%1.3f\n"", cd.d);
    }
    
}

@03f4c42e266b912fe1a97f5adabef3b2@"
"b03611035","5","1.35","204928","@ad2f09e8cc06cca3f3cb31c418d866c3@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N=Integer.parseInt(br.readLine());
            P2D[] gg=new P2D[N];
            for(int i=0;i<N;i++){
                String temp[]=new String[2];
                temp=br.readLine().split("" "");
                double x=Double.parseDouble(temp[0]);
                double y=Double.parseDouble(temp[1]);
                gg[i]=new P2D(x,y);
            }
            //先找到s和t，用XpY_Order
            P2D origin=new P2D(0,0);
            Arrays.sort(gg,origin.XpY_ORDER);
            P2D s=gg[0]; 
            P2D t=gg[N-1];
            

            /*建Digraph，當v-w距離<d，並且v比w嚴格左下時建立單向連結            
               找到最小距離d使s-t至少有一條路
            */
            double d=2.818;
            DirectedDFS test;
            do{
                d=d/2;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(test.marked(N-1));
            
            do{
                d+=0.001;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(!test.marked(N-1));
            
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

class P2D implements Comparable<P2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<P2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<P2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<P2D> R_ORDER = new ROrder();


    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<P2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<P2D> DISTANCE_TO_ORDER = new DistanceToOrder();
    public final Comparator<P2D> XpY_ORDER = new XpYOrder();
    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public P2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(P2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }
    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(P2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }
    private static class XpYOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x+p.y < q.x+q.y) return -1;
            if (p.x+p.y > q.x+q.y) return +1;
            return 0;
        }
    }
    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<P2D> {
        public int compare(P2D q1, P2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        P2D that = (P2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }
}


@ad2f09e8cc06cca3f3cb31c418d866c3@"
"b03611035","10","0.143","206448","@1bb1982ad6a15fefad14fd93ca810768@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N=Integer.parseInt(br.readLine());
            P2D[] gg=new P2D[N];
            for(int i=0;i<N;i++){
                String temp[]=new String[2];
                temp=br.readLine().split("" "");
                double x=Double.parseDouble(temp[0]);
                double y=Double.parseDouble(temp[1]);
                gg[i]=new P2D(x,y);
            }
            //先找到s和t，用XpY_Order
            P2D origin=new P2D(0,0);
            Arrays.sort(gg,origin.XpY_ORDER);
            P2D s=gg[0]; 
            P2D t=gg[N-1];
            

            /*建Digraph，當v-w距離<d，並且v比w嚴格左下時建立單向連結            
               找到最小距離d使s-t至少有一條路
            */
            double d=2.8284271247461900976033774484194;
            DirectedDFS test;
            do{
                d=d/2;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(test.marked(N-1));
            
            do{
                
                d+=0.0005;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(!test.marked(N-1));
            d=d*1000;
            d=Math.floor(d);
            d=d/1000;
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

class P2D implements Comparable<P2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<P2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<P2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<P2D> R_ORDER = new ROrder();


    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<P2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<P2D> DISTANCE_TO_ORDER = new DistanceToOrder();
    public final Comparator<P2D> XpY_ORDER = new XpYOrder();
    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public P2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(P2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }
    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(P2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }
    private static class XpYOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x+p.y < q.x+q.y) return -1;
            if (p.x+p.y > q.x+q.y) return +1;
            return 0;
        }
    }
    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<P2D> {
        public int compare(P2D q1, P2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        P2D that = (P2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }
}


@1bb1982ad6a15fefad14fd93ca810768@"
"b03611035","8","1.32","207072","@de7c873a504c96eef5457127ee2b909f@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N=Integer.parseInt(br.readLine());
            P2D[] gg=new P2D[N];
            for(int i=0;i<N;i++){
                String temp[]=new String[2];
                temp=br.readLine().split("" "");
                double x=Double.parseDouble(temp[0]);
                double y=Double.parseDouble(temp[1]);
                gg[i]=new P2D(x,y);
            }
            //先找到s和t，用XpY_Order
            P2D origin=new P2D(0,0);
            Arrays.sort(gg,origin.XpY_ORDER);
            P2D s=gg[0]; 
            P2D t=gg[N-1];
            

            /*建Digraph，當v-w距離<d，並且v比w嚴格左下時建立單向連結            
               找到最小距離d使s-t至少有一條路
            */
            double d=2.8284271247461900976033774484194;
            DirectedDFS test;
            do{
                d=d/2;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(test.marked(N-1));
            
            do{
                
                d+=0.001;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(!test.marked(N-1));
            d=d*1000;
            d=Math.floor(d);
            d=d/1000;
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

class P2D implements Comparable<P2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<P2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<P2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<P2D> R_ORDER = new ROrder();


    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<P2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<P2D> DISTANCE_TO_ORDER = new DistanceToOrder();
    public final Comparator<P2D> XpY_ORDER = new XpYOrder();
    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public P2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(P2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }
    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(P2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }
    private static class XpYOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x+p.y < q.x+q.y) return -1;
            if (p.x+p.y > q.x+q.y) return +1;
            return 0;
        }
    }
    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<P2D> {
        public int compare(P2D q1, P2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        P2D that = (P2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }
}


@de7c873a504c96eef5457127ee2b909f@"
"r04945039","0","0","0","@78eee13669d3492fa8ff92bfdf21280c@import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Kestin
 */
public class CriticalDis {
    private Digraph G;
    private Point2D[]  sourcepoint;
    private HashMap<Point2D,Integer> pointindex;
    private int number;
    
    public static class Path implements Comparable<Path>{ 
        private final double path;
        private final Point2D m ;
        private final Point2D n ;
        
        public Path(Point2D a , Point2D b){
            path = a.distanceTo(b);
            this.m=a;
            this.n=b;
        }
        
        public Point2D getfrom(){
            return this.m;
        }
        public Point2D geto(){
            return this.n;
        }

        public double getpathdis(){
            return this.path;
        }
        public int compareTo(Path that){
            if(this.path < that.path) return -1;
            if(this.path > that.path) return +1;
            else return 0;
        }
        
    }

    public static class Point2D implements Comparable<Point2D>{
        double x, y;
        int index;
        
        public Point2D(double a , double b){
            x = a;
            y = b;
        }
        public double x(){
            return this.x;
        }
        public double y(){
            return this.y;
        }

        public double distanceTo(Point2D that){
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            double dis = Math.sqrt(dx*dx + dy*dy);
            return dis;
        }
        
        public int compareTo(Point2D that){
            if ((this.x + this.y) < (that.x + that.y)) return -1;
            else if ((this.x + this.y) > (that.x + that.y)) return +1;
            else return 0;
        }
    }

    public CriticalDis(){
        pointindex= new HashMap<>();
    }
    
    public void SetsourcePoint(int x){
        sourcepoint = new Point2D[x];
        G = new Digraph(x);
    }
    
    private void GraphBuild(Point2D start, Point2D end){
        MinPQ<Path> pathpq = new MinPQ<>();
        for(int i = 0 ; i < sourcepoint.length ; i++){
            for(int j = i+1 ; j < sourcepoint.length ; j++){
                if(sourcepoint[i].x() < sourcepoint[j].x()){
                    if(sourcepoint[i].y() < sourcepoint[j].y()){
                    Path newpath = new Path(sourcepoint[i], sourcepoint[j]);
                    pathpq.insert(newpath);
                    }
                }
            }
        }
        
//        int runtime=0;
        while(!pathpq.isEmpty()){
            Path tmp = pathpq.delMin();
            G.addEdge(pointindex.get(tmp.getfrom()), pointindex.get(tmp.geto()));
            DirectedDFS dfs = new DirectedDFS(G,pointindex.get(start));       
            if(dfs.marked(pointindex.get(end))==true){
                double d = tmp.getpathdis();
                System.out.printf(""%1.3f\n"", d);
                break;
            }
//            System.out.println(runtime);
//            runtime++;
        }
       
    }
      
    public static void main(String[] args) throws Exception {

        // Read file
        CriticalDis test = new CriticalDis();
        try(BufferedReader br = new BufferedReader(new FileReader(args[1]))){           
            test.number = Integer.parseInt(br.readLine());
            test.SetsourcePoint(test.number);
            int count=0;
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                test.sourcepoint[count]=p;
                test.pointindex.put(p, count);
                count++;
            }

        }
        Arrays.sort(test.sourcepoint);
        
        //Find the start and end
        Point2D start = test.sourcepoint[0];
        Point2D end =test.sourcepoint[test.number-1];
        test.GraphBuild(start,end);
        
      
    }
    
}

@78eee13669d3492fa8ff92bfdf21280c@"
"r04945039","10","0.11","181072","@477219ac87430b9153e6c840683d2c56@import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Kestin
 */
public class CriticalDis {
    private Digraph G;
    private Point2D[]  sourcepoint;
    private HashMap<Point2D,Integer> pointindex;
    private int number;
    
    public static class Path implements Comparable<Path>{ 
        private final double path;
        private final Point2D m ;
        private final Point2D n ;
        
        public Path(Point2D a , Point2D b){
            path = a.distanceTo(b);
            this.m=a;
            this.n=b;
        }
        
        public Point2D getfrom(){
            return this.m;
        }
        public Point2D geto(){
            return this.n;
        }

        public double getpathdis(){
            return this.path;
        }
        public int compareTo(Path that){
            if(this.path < that.path) return -1;
            if(this.path > that.path) return +1;
            else return 0;
        }
        
    }

    public static class Point2D implements Comparable<Point2D>{
        double x, y;
        int index;
        
        public Point2D(double a , double b){
            x = a;
            y = b;
        }
        public double x(){
            return this.x;
        }
        public double y(){
            return this.y;
        }

        public double distanceTo(Point2D that){
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            double dis = Math.sqrt(dx*dx + dy*dy);
            return dis;
        }
        
        public int compareTo(Point2D that){
            if ((this.x + this.y) < (that.x + that.y)) return -1;
            else if ((this.x + this.y) > (that.x + that.y)) return +1;
            else return 0;
        }
    }

    public CriticalDis(){
        pointindex= new HashMap<>();
    }
    
    public void SetsourcePoint(int x){
        sourcepoint = new Point2D[x];
        G = new Digraph(x);
    }
    
    private void GraphBuild(Point2D start, Point2D end){
        MinPQ<Path> pathpq = new MinPQ<>();
        for(int i = 0 ; i < sourcepoint.length ; i++){
            for(int j = i+1 ; j < sourcepoint.length ; j++){
                if(sourcepoint[i].x() < sourcepoint[j].x()){
                    if(sourcepoint[i].y() < sourcepoint[j].y()){
                    Path newpath = new Path(sourcepoint[i], sourcepoint[j]);
                    pathpq.insert(newpath);
                    }
                }
            }
        }
        
//        int runtime=0;
        while(!pathpq.isEmpty()){
            Path tmp = pathpq.delMin();
            G.addEdge(pointindex.get(tmp.getfrom()), pointindex.get(tmp.geto()));
            DirectedDFS dfs = new DirectedDFS(G,pointindex.get(start));       
            if(dfs.marked(pointindex.get(end))==true){
                double d = tmp.getpathdis();
                System.out.printf(""%1.3f\n"", d);
                break;
            }
//            System.out.println(runtime);
//            runtime++;
        }
       
    }
      
    public static void main(String[] args) throws Exception {

        // Read file
        CriticalDis test = new CriticalDis();
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){           
            test.number = Integer.parseInt(br.readLine());
            test.SetsourcePoint(test.number);
            int count=0;
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                test.sourcepoint[count]=p;
                test.pointindex.put(p, count);
                count++;
            }

        }
        Arrays.sort(test.sourcepoint);
        
        //Find the start and end
        Point2D start = test.sourcepoint[0];
        Point2D end =test.sourcepoint[test.number-1];
        test.GraphBuild(start,end);
        
      
    }
    
}

@477219ac87430b9153e6c840683d2c56@"
"b03704074","7","1.18","125760","@41e2e2c217814656a353e37b13c69090@
import java.util.Arrays;


public class CriticalDis {
    public CriticalDis(){}
    
    double d = 1;
    public void Array(Point2D[] Points,double linodistance,Point2D prepointance,Point2D T,Point2D S){
        for(int i = 0;i < Points.length;i++){
            if(prepointance==S)linodistance = 0;
            double tempd = Math.sqrt(Math.pow(Points[i].x()-prepointance.x(),2)+Math.pow(Points[i].y()-prepointance.y(),2));
                if(tempd > d)continue;
                //System.out.println(""prepointance = ""+prepointance.x()+""  Points[i] = ""+Points[i].x());
                if(tempd > linodistance) linodistance = tempd;
               // System.out.println(""tempd = ""+tempd+""  linodistance = ""+linodistance);                
                if(Points[i]==T && linodistance<d){d = linodistance;}
                //System.out.println(""distance = ""+d);
                Point2D[] NextPoints = new Point2D[Points.length];
                int j = 0;
                for(int k = 0;k < Points.length;k++){
                    if(Points[k].x()>Points[i].x() && Points[k].y()>Points[i].y()){
                        NextPoints[j] = Points[k];
                        j++;
                    }
                }
                NextPoints = Arrays.copyOf(NextPoints, j);
                Array(NextPoints,linodistance,Points[i],T,S);
        }
        
        
    }
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        if(N<2){System.out.println(""0"");return;}
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()) S = A[i];
            if(a+b>T.x()+T.y()) T = A[i];            
        }
        
        double linod = 0;
        Point2D[] NextPoints = new Point2D[A.length];
        int j = 0;
        for(int i = 0;i < A.length;i++){
            if(A[i].x()>S.x() && A[i].y()>S.y()){
                NextPoints[j] = A[i];
                j++;
            }
        }
        NextPoints = Arrays.copyOf(NextPoints, j);
        CriticalDis cd = new CriticalDis();
        cd.Array(NextPoints, linod, S, T,S);
        
        System.out.printf(""%1.3f\n"", cd.d);
    }
    
}

@41e2e2c217814656a353e37b13c69090@"
"r04921065","10","0.163","250656","@16ea84e357ab01e3f95f41903255d2e3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 余軒
 */
public class CriticalDis {
    
        
    
        public static class Pair implements Comparable<Pair>{
            private Point2D a;
            private Point2D b;
            private int IDa;
            private int IDb;
            private double distabce;
            public Pair(Point2D a, Point2D b, int IDa, int IDb){
                this.a = a;
                this.b = b;
                this.IDa = IDa;
                this.IDb = IDb;
                this.distabce = a.distanceTo(b);
            }
//            public double distance(Point2D a, Point2D b){
//                return a.distanceTo(b);
//            }
            public int compareTo(Pair that){
                if (this.distabce > that.distabce)
                    return 1;
                else return -1;
            }
        }
    
           public static void main(String[] args) throws IOException {
        // TODO code application logic here
       try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           String str_num = br.readLine();
           int num = Integer.parseInt(str_num);
           int cc = 0;
           double[] x = new double[num];
           double[] y = new double[num];
           for (String in=br.readLine();in!=null;in=br.readLine()){
               String[] data = in.split("" "");
               x[cc] = Double.parseDouble(data[0]);
               y[cc] = Double.parseDouble(data[1]);
               cc++;
           }
           double[] sum = new double[num];
           // initialization
           sum[0] = x[0]+y[0];
           double min = sum[0];
           double max = sum[0];
           int source = 0;
           int target = 0;
           //System.out.println(y[0]);
           Point2D[] points = new Point2D[num];
           points[0] = new Point2D(x[0],y[0]);
           for (int i = 1;i<num;i++){
                sum[i] = x[i] + y[i];
                if (min > sum[i]){
                    min = sum[i];
                    source = i;
                }
                if (max<sum[i]){
                    max = sum[i];
                    target = i;
                 }
                points[i] = new Point2D(x[i],y[i]);
           }
           
//           System.out.println(source);
//           System.out.println(target);
//           System.out.println(points[0]);
           Digraph DG = new Digraph(num);
           DirectedDFS DDG = null;
           MinPQ<Pair> pq = new MinPQ<Pair>(num*(num-1)/2);
           double d = 0;
           for (int i=0;i<num;i++){
               for (int j=i+1;j<num;j++){
                   Pair temp = new Pair(points[i],points[j],i,j);
                   pq.insert(temp);
               }
           }
           while(true){
               Pair temp = pq.delMin(); //第一個加入的邊 最小
               if (temp.a.x()<temp.b.x()&& temp.a.y()<temp.b.y()){
                   DG.addEdge(temp.IDa,temp.IDb);
               }
               else if (temp.a.x()>temp.b.x() && temp.a.y()>temp.b.y()){
                   DG.addEdge(temp.IDb,temp.IDa);
               }
               DDG = new DirectedDFS(DG,source);
               if (DDG.marked(target)){
                   d = temp.distabce;
                   break;
               }
           }
           
           System.out.printf(""%1.3f\n"", d);
           
    }
   }
}
@16ea84e357ab01e3f95f41903255d2e3@"
"r04631036","0","0","0","@9fa8db488e2798c414eb798156e1266e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class HW11 {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);
                
                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d=0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
                StdDraw.setPenColor(StdDraw.RED);
                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while(!dfs.marked(maxindex)){
                    dfs = new DirectedDFS(G, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            G.addEdge(i, j);
                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.001;
                }
//                System.out.printf(""%1.3f\n"",d);
                d=d-0.01;
//                System.out.printf(""%1.3f\n"",d);
                
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while(!dfsf.marked(maxindex)){
                    dfsf = new DirectedDFS(F, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            F.addEdge(i, j);
                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.0001;
                }
                System.out.printf(""%1.3f"",d);
            }
            

        }

    }
}

@9fa8db488e2798c414eb798156e1266e@"
"r04631036","0","0","0","@5b5cd519327a83366dd049eb0b368948@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);
                
                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d=0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
                StdDraw.setPenColor(StdDraw.RED);
                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while(!dfs.marked(maxindex)){
                    dfs = new DirectedDFS(G, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            G.addEdge(i, j);
                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.001;
                }
//                System.out.printf(""%1.3f\n"",d);
                d=d-0.01;
//                System.out.printf(""%1.3f\n"",d);
                
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while(!dfsf.marked(maxindex)){
                    dfsf = new DirectedDFS(F, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            F.addEdge(i, j);
                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.0001;
                }
                System.out.printf(""%1.3f"",d);
            }
            

        }

    }
}

@5b5cd519327a83366dd049eb0b368948@"
"r04631036","5","3.17","188800","@bff68953fc34d02a171f869babbc0a9b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);
                
                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d=0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while(!dfs.marked(maxindex)){
                    dfs = new DirectedDFS(G, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.001;
                }
//                System.out.printf(""%1.3f\n"",d);
                d=d-0.01;
//                System.out.printf(""%1.3f\n"",d);
                
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while(!dfsf.marked(maxindex)){
                    dfsf = new DirectedDFS(F, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.0001;
                }
                System.out.printf(""%1.3f"",d);
            }
            

        }

    }
}

@bff68953fc34d02a171f869babbc0a9b@"
"r04631036","5","3.17","188704","@61fbba837830814956c9a47f986ca17a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if(size==2){
                    System.out.printf(""%1.3f"",p[0].distanceTo(p[1]));
                    System.exit(1);
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);
                
                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d=0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while(!dfs.marked(maxindex)&&size!=2){
                    dfs = new DirectedDFS(G, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.001;
                }
//                System.out.printf(""%1.3f\n"",d);
                d=d-0.01;
//                System.out.printf(""%1.3f\n"",d);
                
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while(!dfsf.marked(maxindex)&&size!=2){
                    dfsf = new DirectedDFS(F, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.0001;
                }
                System.out.printf(""%1.3f"",d);
            }
            

        }

    }
}

@61fbba837830814956c9a47f986ca17a@"
"r04631036","5","3.19","188048","@2b0ce1f51c3e119b228ab9ad8e6e869a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if(size==2){
                    System.out.printf(""%1.3f"",p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);
                
                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d=0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while(!dfs.marked(maxindex)&&size!=2){
                    dfs = new DirectedDFS(G, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.001;
                }
//                System.out.printf(""%1.3f\n"",d);
                d=d-0.01;
//                System.out.printf(""%1.3f\n"",d);
                
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while(!dfsf.marked(maxindex)&&size!=2){
                    dfsf = new DirectedDFS(F, minindex);
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                            F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                        }
                    }
                }
                d=d+0.0001;
                }
                if(size!=2)
                System.out.printf(""%1.3f"",d);
            }
            

        }

    }
}

@2b0ce1f51c3e119b228ab9ad8e6e869a@"
"r03525006","5","1.5","259328","@f43ffb966182f1c4d442cbc80dbe7c3e@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
/**
 * Created by ASUS on 2016/6/8.
 */
public class CriticalDis {

    public static class Point {
        private int index;
        private double x;
        private double y;
        private double dinstance;
        Point(double x,double y,int index) {
            this.x = x;
            this.y = y;
            this.index = index;
        }

        public void distance(Point that) {
            this.dinstance = Math.sqrt(Math.pow(this.x-that.x,2)+Math.pow(this.y-that.y,2));
        }

        public boolean compareXY(Point that) {
            return this.x + this.y < that.x + that.y;
        }

        public boolean compareEdge(Point that) {
            return this.x < that.x && this.y < that.y;
        }

    }

    public static class pointComparator implements Comparator<Point> {
        public int compare(Point p1,Point p2) {
            if (p1.dinstance < p2.dinstance) return -1;
            else if (p1.dinstance > p2.dinstance) return 1;
            else return 0;
        }
    }

    public static Point findMinPoint(Digraph digraph,Point[] pArray,int targetIndex) {
        int minPointIndex = 0;
        for (int i = minPointIndex; i < pArray.length; i++){
            DirectedDFS d = new DirectedDFS(digraph,pArray[i].index);
            if (d.marked(targetIndex)) {
                minPointIndex = i; break;
            }
        } return pArray[minPointIndex];
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int size = Integer.parseInt(br.readLine());
            Point[] pArray = new Point[size];
            for (int i = 0; i < size; i++) {
                String[] xy = br.readLine().split("" "");
                Point p = new Point(Double.parseDouble(xy[0]), Double.parseDouble(xy[1]), i);
                pArray[i] = p;
            }
            int sourceIndex = 0, targetIndex = 0;
            for (int i = 0; i < size; i++) {
                if (pArray[i].compareXY(pArray[sourceIndex])) sourceIndex = i;
                if (!pArray[i].compareXY(pArray[targetIndex])) targetIndex = i;
            }


            ArrayList<ArrayList<Point>> list = new ArrayList<>(size);
            Digraph digraph = new Digraph(size);
            for (int i = 0; i < size; i++) {
                ArrayList<Point> temp = new ArrayList<>();
                for (int j = 0; j < size; j++) {
                    if (pArray[i].compareEdge(pArray[j])) {
                        Point p = new Point(pArray[j].x, pArray[j].y, j);
                        p.distance(pArray[i]);
                        temp.add(p);
                        digraph.addEdge(i, j);
//                        System.out.println(i + "" to "" + j);
                    }
                } list.add(temp);
            }

            ArrayList<Point[]> newlist = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                newlist.add(list.get(i).toArray(new Point[list.get(i).size()]));
                Arrays.sort(newlist.get(i), new CriticalDis.pointComparator());
            }
//            for (int i = 0; i < newlist.get(0).length; i++)
//                System.out.println(newlist.get(0)[i].x + "" / "" + newlist.get(0)[i].y + "" / ""+ newlist.get(0)[i].dinstance);

            int nextIndex = sourceIndex;
            double ans = newlist.get(sourceIndex)[0].dinstance;
            while (nextIndex != targetIndex) {
                Point minPoint = CriticalDis.findMinPoint(digraph,newlist.get(nextIndex),targetIndex);
                if (minPoint.dinstance > ans) ans = minPoint.dinstance;
                nextIndex = minPoint.index;
            } System.out.printf(""%1.3f\n"", ans);
        }
    }
}

@f43ffb966182f1c4d442cbc80dbe7c3e@"
"r04921074","10","0.121","206848","@99ab259a3ae1124227029b9c3d355fa0@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */


//************************** storing type of distance ************************\\    
public class CriticalDis {
//************************** inner class *************************************\\
    public static class EDGEs implements Comparable<EDGEs>{
        int source;
        int target;
        double dis;
        
        public EDGEs(int source, int target, double dis){
            this.source = source;
            this.target = target;
            this.dis = dis;
            return;
        }

        @Override
        public int compareTo(EDGEs that) {            
            if(this.dis > that.dis) return +1;
            else if(this.dis < that.dis)  return -1;
            else return 0;
        }
    }
//******************************* properties *********************************\\            
  //  public Point2D[] points; // The constructor of points can be changed; !!!!!!!!!!!!!!!
    public CriticalDis(){}
  

//******************* MAIN : read position information ***********************\\    
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String N = br.readLine();
            Point2D[] points = new Point2D[Integer.parseInt(N)];         //所有讀取到的點 放起來
            Map<Point2D,Integer> map = new HashMap<Point2D,Integer>(); //放著點跟代號的對照表
            Point2D max = new Point2D(0,0);
            Point2D min = new Point2D(1,1);
            Digraph G = new Digraph (Integer.parseInt(N));
            MinPQ<Integer> AAA = new MinPQ<>();
            MinPQ<EDGEs> edges = new MinPQ<>();
            
            int count=0;
            
            
           for (int i=0; i<Integer.parseInt(N); i++)
            {
                String buf[] = br.readLine().split("" "");
                double x = Double.valueOf(buf[0]);
                double y = Double.valueOf(buf[1]);
                points[i] = new Point2D(x,y);
                if( (points[i].x()+points[i].y()) > (max.x()+max.y() ) )  max = points[i];
                if( (points[i].x()+points[i].y()) < (min.x()+min.y() ) )   min = points[i];
                map.put(points[i],i);
            }
//           
           EDGEs tempE;
           for(int i=0; i<Integer.parseInt(N); i++){
                for(int j=0 ; j<Integer.parseInt(N); j++){
                   if(points[i].x()>points[j].x() && points[i].y()>points[j].y()&&points[i].distanceTo(points[j])!=0){
//                   tempE =new EDGEs(j,i,points[i].distanceTo(points[j]));                   
                   edges.insert(new EDGEs(j,i,points[i].distanceTo(points[j])));
                   }
                }
           }
            
            
            boolean connect = false;
            EDGEs tempd = new EDGEs(0,0,0);
            
            while(!connect && !edges.isEmpty()){
                tempd = edges.delMin();
                G.addEdge(tempd.source, tempd.target);
                DepthFirstDirectedPaths p = new DepthFirstDirectedPaths(G,map.get(min));
                connect = p.hasPathTo(map.get(max));
            }
               System.out.printf(""%1.3f\n"",tempd.dis);
       }
     }       
//****************************************************************************\\
//***************************** get every edge *******************************\\    
  
//****************************************************************************\\      
}

@99ab259a3ae1124227029b9c3d355fa0@"
"r04631041","10","0.117","207808","@b4ca05701b911f4dba91b8a1ff08a098@
import java.io.BufferedReader;
import java.io.FileReader;
public class CriticalDis {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}

@b4ca05701b911f4dba91b8a1ff08a098@"
"r03525006","10","0.15","214000","@fa916041e7144b1ac9943aa8e827d226@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
/**
 * Created by ASUS on 2016/6/8.
 */
public class CriticalDis {
    public static class Point {
        private double x;
        private double y;
        Point(double x,double y) {
            this.x = x;
            this.y = y;
        }

        public double distanceTo(Point that) {
            return Math.sqrt(Math.pow(this.x-that.x,2)+Math.pow(this.y-that.y,2));
        }

        public boolean compareXY(Point that) {
            return this.x + this.y < that.x + that.y;
        }

        public boolean compareEdge(Point that) {
            return this.x < that.x && this.y < that.y;
        }

    }

    public static class Edge {
        private int indexFrom;
        private int indexTo;
        private double distance;
        Edge(int indexFrom, int indexTo, double distance) {
            this.indexFrom = indexFrom;
            this.indexTo = indexTo;
            this.distance = distance;
        }
    }

    public static class edgeComparator implements Comparator<Edge> {
        public int compare(Edge d1,Edge d2) {
            if (d1.distance < d2.distance) return -1;
            else if (d1.distance > d2.distance) return 1;
            else return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int size = Integer.parseInt(br.readLine());
            Point[] pArray = new Point[size];
            int sourceIndex = 0, targetIndex = 0;
            for (int i = 0; i < size; i++) {
                String[] xy = br.readLine().split("" "");
                Point p = new Point(Double.parseDouble(xy[0]), Double.parseDouble(xy[1]));
                pArray[i] = p;
                if (pArray[i].compareXY(pArray[sourceIndex])) sourceIndex = i;
                if (!pArray[i].compareXY(pArray[targetIndex])) targetIndex = i;
            }

            ArrayList<Edge> disList = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    if (pArray[i].compareEdge(pArray[j]))
                        disList.add(new Edge(i, j, pArray[i].distanceTo(pArray[j])));
                }
            }
            Edge[] disArray = disList.toArray(new Edge[disList.size()]);
            Arrays.sort(disArray,new CriticalDis.edgeComparator());
            MinPQ<Edge> pq = new MinPQ<>(new CriticalDis.edgeComparator());
            for (int i = 0; i < disArray.length; i++)
                pq.insert(disArray[i]);

            boolean isPath = false;
            double ans = 0;
            Digraph digraph = new Digraph(size);
            while (!isPath) {
                Edge e = pq.delMin();
                digraph.addEdge(e.indexFrom,e.indexTo);
                ans = e.distance;
                DirectedDFS d = new DirectedDFS(digraph,sourceIndex);
                isPath = d.marked(targetIndex);
            }
            System.out.printf(""%1.3f\n"", ans);
        }
    }
}

@fa916041e7144b1ac9943aa8e827d226@"
"r03525006","10","0.155","212064","@887304bce241eae331a57a93e483040f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
/**
 * Created by ASUS on 2016/6/8.
 */
public class CriticalDis {
    public static class Point {
        private double x;
        private double y;
        Point(double x,double y) {
            this.x = x;
            this.y = y;
        }

        public double distanceTo(Point that) {
            return Math.sqrt(Math.pow(this.x-that.x,2)+Math.pow(this.y-that.y,2));
        }

        public boolean compareXY(Point that) {
            return this.x + this.y < that.x + that.y;
        }

        public boolean isEdge(Point that) {
            return this.x < that.x && this.y < that.y;
        }

    }

    public static class Edge {
        private int indexFrom;
        private int indexTo;
        private double distance;
        Edge(int indexFrom, int indexTo, double distance) {
            this.indexFrom = indexFrom;
            this.indexTo = indexTo;
            this.distance = distance;
        }
    }

    public static class edgeComparator implements Comparator<Edge> {
        public int compare(Edge d1,Edge d2) {
            if (d1.distance < d2.distance) return -1;
            else if (d1.distance > d2.distance) return 1;
            else return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int size = Integer.parseInt(br.readLine());
            Point[] pArray = new Point[size];
            int sourceIndex = 0, targetIndex = 0;
            for (int i = 0; i < size; i++) {
                String[] xy = br.readLine().split("" "");
                Point p = new Point(Double.parseDouble(xy[0]), Double.parseDouble(xy[1]));
                pArray[i] = p;
                if (pArray[i].compareXY(pArray[sourceIndex])) sourceIndex = i;
                if (!pArray[i].compareXY(pArray[targetIndex])) targetIndex = i;
            }

            ArrayList<Edge> disList = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    if (pArray[i].isEdge(pArray[j]))
                        disList.add(new Edge(i, j, pArray[i].distanceTo(pArray[j])));
                }
            }
            Edge[] disArray = disList.toArray(new Edge[disList.size()]);
            Arrays.sort(disArray,new CriticalDis.edgeComparator());
            MinPQ<Edge> pq = new MinPQ<>(new CriticalDis.edgeComparator());
            for (int i = 0; i < disArray.length; i++)
                pq.insert(disArray[i]);

            boolean isPath = false;
            double ans = 0;
            Digraph digraph = new Digraph(size);
            while (!isPath) {
                Edge e = pq.delMin();
                digraph.addEdge(e.indexFrom,e.indexTo);
                ans = e.distance;
                DirectedDFS d = new DirectedDFS(digraph,sourceIndex);
                isPath = d.marked(targetIndex);
            }
            System.out.printf(""%1.3f\n"", ans);
        }
    }
}

@887304bce241eae331a57a93e483040f@"
"r04631036","5","3.17","186592","@363e899c07fdc218e6f489f57f87dbb9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() > a.x() && b.y() > a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);

                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.0001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@363e899c07fdc218e6f489f57f87dbb9@"
"r04631036","5","3.37","180160","@9817e6151496b95c200c8280cea82c86@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);

                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.0001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@9817e6151496b95c200c8280cea82c86@"
"r04631036","5","4.63","217008","@a70215cf603842343a2ed1ac854b1c34@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.02;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);

                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.0001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@a70215cf603842343a2ed1ac854b1c34@"
"r04631036","9","2.02","149472","@78b61579ae6380f10de43833ea0be9ba@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);

                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@78b61579ae6380f10de43833ea0be9ba@"
"r04631036","8","1.5","129264","@bd9d873231eea9969da2131dfd9e3f0e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);

                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.00002;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@bd9d873231eea9969da2131dfd9e3f0e@"
"r04631036","9","2.11","149328","@a1f91f67d3b76d5f43b053f428a1151f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G=null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@a1f91f67d3b76d5f43b053f428a1151f@"
"r04631036","9","2.07","162864","@5b2b9d9aec01bf4483dfe504de9fe23e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    d = d + 0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@5b2b9d9aec01bf4483dfe504de9fe23e@"
"r04631036","9","5.12","215248","@8dda5f4aab32ae4721ebb16441e881e5@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.02;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    d = d + 0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@8dda5f4aab32ae4721ebb16441e881e5@"
"r04631036","9","3.24","161024","@34dc24ec452c6fec49e4eb457bf62679@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@34dc24ec452c6fec49e4eb457bf62679@"
"r04631036","9","2.04","134576","@9617218658b3290a24623cdc05753b9c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@9617218658b3290a24623cdc05753b9c@"
"r04631036","9","3.29","181408","@3d0301c6e8bb7cbc397e3ae400c71207@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0002;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@3d0301c6e8bb7cbc397e3ae400c71207@"
"r04631036","9","3.28","174256","@035b039279fdff044d6118860bd21005@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0003;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@035b039279fdff044d6118860bd21005@"
"r04631036","9","3.22","151664","@783bb02ffe7e7bbd5a5adb64455423d9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0004;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@783bb02ffe7e7bbd5a5adb64455423d9@"
"r04631036","9","3.15","155424","@2756a22fe3bd90b6d7dadc3b2ff2dfce@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0005;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@2756a22fe3bd90b6d7dadc3b2ff2dfce@"
"r04631036","9","3.12","161856","@119279c4a0e86ee35bbe66499b7f2b18@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0006;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@119279c4a0e86ee35bbe66499b7f2b18@"
"r04631036","9","3.22","161584","@b1fd0850d665160046789eb9a0b41914@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0007;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@b1fd0850d665160046789eb9a0b41914@"
"r04631036","9","3.12","160800","@0d419b1dd722f7a61c1af9b90bbbb3aa@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0008;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@0d419b1dd722f7a61c1af9b90bbbb3aa@"
"r04631036","9","3.08","160240","@bba7d1f1cc36f607a6f1a99fe5185bda@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.0009;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@bba7d1f1cc36f607a6f1a99fe5185bda@"
"r04631036","9","3.08","159968","@34dc24ec452c6fec49e4eb457bf62679@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                d = d - 0.01;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d= d+0.001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@34dc24ec452c6fec49e4eb457bf62679@"
"r04631036","9","3","149440","@0f6546cd1d30206f2d29b63a73524475@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                if(size<1000)
                d = d - 0.01;
                if(size>1000)
                    d= d-0.015;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d=d+0.0001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@0f6546cd1d30206f2d29b63a73524475@"
"r04631036","9","3.01","154464","@ea76c2c4a4bf6a2c33705424afdd6b4b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                if(size<1000)
                d = d - 0.01;
                if(size>1000)
                    d= d-0.015;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d=d+0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@ea76c2c4a4bf6a2c33705424afdd6b4b@"
"r04631036","9","3.14","165184","@413787818130b543db06d33ff074ad33@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                if(size<1000)
                d = d - 0.01;
                if(size>1000)
                    d= d-0.02;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d=d+0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@413787818130b543db06d33ff074ad33@"
"r04631036","9","2.03","138512","@4f235c9d00756a40ab46b6e930817626@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                if(size<1000)
                d = d - 0.01;
                if(size>=1000)
                    d= d-0.02;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d=d+0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@4f235c9d00756a40ab46b6e930817626@"
"r04631036","10","0.584","255168","@1eceac5449c94ff85b9ebf34068b7b21@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Arthur
 */
public class CriticalDis {

    public static boolean slope(Point2D a, Point2D b) {
        if (b.x() >= a.x() && b.y() >= a.y()) {
            return true;
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            {

                int size = Integer.parseInt(br.readLine());
                Point2D[] p = new Point2D[size];
                double[] xy = new double[size];
                BST<Double, Integer> st = new BST<Double, Integer>();
                for (int i = 0; i < size; i++) {
                    String[] input = br.readLine().split("" "");
                    p[i] = new Point2D(Double.parseDouble(input[0]), Double.parseDouble(input[1]));
//                    StdDraw.filledCircle(p[i].x(), p[i].y(), 0.005);
                    double temp;
                    temp = p[i].x() + p[i].y();
                    xy[i] = temp;
                    st.put(temp, i);
//                    System.out.println(p[i]);
                }
                if (size == 2) {
                    System.out.printf(""%1.3f\n"", p[0].distanceTo(p[1]));
                }
                Arrays.sort(xy);
                Digraph G = new Digraph(size);

                //x+y
//                System.out.printf(""%f\n"", xy[0]);
//                System.out.printf(""%f\n"", xy[19]);
                int minindex = st.get(xy[0]);
                int maxindex = st.get(xy[size - 1]);
                double d = 0;
//                System.out.println(st.get(xy[0]));//Min Index
//                System.out.println(st.get(xy[19]));//Max Index
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.filledCircle(p[maxindex].x(), p[maxindex].y(), 0.005);
//                StdDraw.filledCircle(p[minindex].x(), p[minindex].y(), 0.005);
//                StdDraw.setPenColor(StdDraw.GREEN);
                DirectedDFS dfs = new DirectedDFS(G, minindex);
                while (!dfs.marked(maxindex) && size != 2) {
                    dfs = new DirectedDFS(G, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j]) && p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                    && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                G.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                            }
                        }
                    }
                    d = d + 0.001;
                }
                if(size<1000)
                d = d - 0.01;
                if(size>=1000)
                    d= d-0.005;
//                if(size!=2)
//                System.out.printf(""%1.3f\n"",d);
                G = null;
                Digraph F = new Digraph(size);
                DirectedDFS dfsf = new DirectedDFS(F, minindex);
//                
                while (!dfsf.marked(maxindex)) {
                    dfsf = new DirectedDFS(F, minindex);
                    for (int i = 0; i < size; i++) {
                        for (int j = 0; j < size; j++) {
                            if (slope(p[i], p[j])) {
                                if (p[i].distanceTo(p[j]) < d && p[i].x() >= p[minindex].x() && p[i].y() >= p[minindex].y()
                                        && p[j].x() <= p[maxindex].x() && p[j].y() <= p[maxindex].y()) {
                                    F.addEdge(i, j);
//                            StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        }
//
                                }
                            }
                        }
                    }
                    if(size<1000)
                    d = d + 0.00001;
                    if(size>=1000)
                        d=d+0.00001;
                }
                if (size != 2) {
                    System.out.printf(""%1.3f\n"", d);
                }
            }

        }

    }
}

@1eceac5449c94ff85b9ebf34068b7b21@"
"r04631034","0","0","0","@9ed0521f5bb29f2577a95cfa81021b95@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author acer
 */
public class CriticalDis {

     public static double distance(Point2D x, Point2D y) {
          return Math.sqrt(Math.pow(x.x() - y.x(), 2) + Math.pow(x.y() - y.y(), 2));
     }

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);
          int N = Integer.valueOf(in.readLine());
          Point2D[] point_array = new Point2D[N];
          String line;
          int input_count = 0;
          double Min = 2;
          double Max = 0;
          Point2D MinNode = null;
          Point2D MaxNode = null;
          int MinIndex = 0;
          int MaxIndex = 0;
          while ((line = in.readLine()) != null) {
               point_array[input_count] = new Point2D(Double.valueOf(line.split("" "")[0]), Double.valueOf(line.split("" "")[1]));

////////////////////////////////////     draaw point    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////          
               StdDraw.setPenColor(StdDraw.BLACK);
               StdDraw.filledCircle(point_array[input_count].x(), point_array[input_count].y(), 0.01);
               String str = String.valueOf(input_count);
               StdDraw.text(point_array[input_count].x(), point_array[input_count].y() + 0.03, str);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
               if (Min > (point_array[input_count].x() + point_array[input_count].y())) {
                    Min = point_array[input_count].x() + point_array[input_count].y();
                    MinNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MinIndex = input_count;
               }
               if (Max < (point_array[input_count].x() + point_array[input_count].y())) {
                    Max = point_array[input_count].x() + point_array[input_count].y();
                    MaxNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MaxIndex = input_count;
               }
               input_count++;
          }
///////////////////////////// draw max and min point  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          StdDraw.setPenColor(StdDraw.RED);
          StdDraw.filledCircle(MinNode.x(), MinNode.y(), 0.01);
          StdDraw.filledCircle(MaxNode.x(), MaxNode.y(), 0.01);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                    ArrayList<Edge> edgeList = new ArrayList<Edge>();
//                    MinPQ<Edge> pq = new MinPQ<Edge>();
          MinPQ<Pair> pq_test = new MinPQ<Pair>();
          for (int idx = 0; idx < point_array.length; idx++) {
               for (int idy = 0; idy < point_array.length; idy++) {
                    if (point_array[idx].x() < point_array[idy].x() && point_array[idx].y() < point_array[idy].y()) {
//                                                  edgeList.add( new Edge( point_array[idx] , point_array[idy] , distance( point_array[idx] , point_array[idy]) ) );
//                                                  pq.insert(new Edge( point_array[idx] , point_array[idy] , distance( point_array[idx] , point_array[idy]) ));
                         pq_test.insert(new Pair(idx, idy, distance(point_array[idx], point_array[idy])));
//                                                  G.addEdge(idx, idy);
                    }
               }
          }
          Digraph G = new Digraph(N);
//          System.out.println(""Min index "" + MinIndex + "" Max index "" + MaxIndex);
          while (!pq_test.isEmpty()) {
               Pair temp = pq_test.delMin();

//               System.out.println(""X  "" + temp.getNodeX() + "" Y "" + temp.getNodeY() + "" dis "" + temp.getDistance());
               G.addEdge(temp.getNodeX(), temp.getNodeY());
               DirectedDFS dfs = new DirectedDFS(G, MinIndex);
//               double d = temp.getDistance();
               if (dfs.marked(MaxIndex)) {
//                    System.out.println(temp.getDistance());
//                    System.out.println(""%1.3f"", d);
                    String D = String.format(""%1.3f"", temp.getDistance());
                    System.out.println(D);

                    break;
               } else {
                    continue;
               }

          }

//                    System.out.println(""Min X: "" + MinNode.x() + "" Y: "" + MinNode.y() + "" dis: "" + (MinNode.x() + MinNode.y()) + "" check "" + Min);
//                    System.out.println(""Max X: "" + MaxNode.x() + "" Y: "" + MaxNode.y() + "" dis: "" + (MaxNode.x() + MaxNode.y()) + "" check "" + Max);
     }

}

class Edge implements Comparable<Edge> {

     private Point2D smallNode;
     private Point2D largeNode;
     private double distance;

     public Edge(Point2D smallNode, Point2D largeNode, double distance) {
          this.smallNode = smallNode;
          this.largeNode = largeNode;
          this.distance = distance;
     }

     public Point2D getSmallNode() {
          return this.smallNode;
     }

     public Point2D getLargeNode() {
          return this.largeNode;
     }

     public double getDistance() {
          return this.distance;
     }

     public int compareTo(Edge that) {
          if (this.distance > that.distance) {
               return +1;
          }
          if (this.distance < that.distance) {
               return -1;
          }
          return 0;
     }

}

class Pair implements Comparable<Pair> {

     private int point_x, point_y;
     private double distance;

     public Pair(int x, int y, double dis) {
          this.point_x = x;
          this.point_y = y;
          this.distance = dis;
     }

     public void setDistance(double dis) {
          this.distance = dis;
     }

     public int getNodeX() {
          return this.point_x;
     }

     public int getNodeY() {
          return this.point_y;
     }

     public double getDistance() {
          return this.distance;
     }

     public int compareTo(Pair that) {
          if (this.distance > that.distance) {
               return +1;
          }
          if (this.distance < that.distance) {
               return -1;
          }
          return 0;
     }
}

@9ed0521f5bb29f2577a95cfa81021b95@"
"r04631034","0","0","0","@e5b84300f2987c8ce47ce133c9fee65b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author acer
 */
public class CriticalDis {

     public static double distance(Point2D x, Point2D y) {
          return Math.sqrt(Math.pow(x.x() - y.x(), 2) + Math.pow(x.y() - y.y(), 2));
     }

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);
          int N = Integer.valueOf(in.readLine());
          Point2D[] point_array = new Point2D[N];
          String line;
          int input_count = 0;
          double Min = 2;
          double Max = 0;
          Point2D MinNode = null;
          Point2D MaxNode = null;
          int MinIndex = 0;
          int MaxIndex = 0;
          while ((line = in.readLine()) != null) {
               point_array[input_count] = new Point2D(Double.valueOf(line.split("" "")[0]), Double.valueOf(line.split("" "")[1]));

////////////////////////////////////     draaw point    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////          
               StdDraw.setPenColor(StdDraw.BLACK);
               StdDraw.filledCircle(point_array[input_count].x(), point_array[input_count].y(), 0.01);
               String str = String.valueOf(input_count);
               StdDraw.text(point_array[input_count].x(), point_array[input_count].y() + 0.03, str);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
               if (Min > (point_array[input_count].x() + point_array[input_count].y())) {
                    Min = point_array[input_count].x() + point_array[input_count].y();
                    MinNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MinIndex = input_count;
               }
               if (Max < (point_array[input_count].x() + point_array[input_count].y())) {
                    Max = point_array[input_count].x() + point_array[input_count].y();
                    MaxNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MaxIndex = input_count;
               }
               input_count++;
          }
///////////////////////////// draw max and min point  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          StdDraw.setPenColor(StdDraw.RED);
          StdDraw.filledCircle(MinNode.x(), MinNode.y(), 0.01);
          StdDraw.filledCircle(MaxNode.x(), MaxNode.y(), 0.01);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

          MinPQ<Pair> pq_test = new MinPQ<Pair>();
          for (int idx = 0; idx < point_array.length; idx++) {
               for (int idy = 0; idy < point_array.length; idy++) {
                    if (point_array[idx].x()<= point_array[idy].x() && point_array[idx].y() <= point_array[idy].y()) {
                         pq_test.insert(new Pair(idx, idy, distance(point_array[idx], point_array[idy])));
                    }
               }
          }
          Digraph G = new Digraph(N);
//          System.out.println(""Min index "" + MinIndex + "" Max index "" + MaxIndex);
          while (!pq_test.isEmpty()) {
               Pair temp = pq_test.delMin();
//               System.out.println(""X  "" + temp.getNodeX() + "" Y "" + temp.getNodeY() + "" dis "" + temp.getDistance());
               G.addEdge(temp.getNodeX(), temp.getNodeY());
               DirectedDFS dfs = new DirectedDFS(G, MinIndex);
               if (dfs.marked(MaxIndex)) {

                    String D = String.format(""%1.3f"", temp.getDistance());
                    System.out.println(D);

                    break;
               } else {
                    continue;
               }

          }

     }

}

class Pair implements Comparable<Pair> {

     private int point_x, point_y;
     private double distance;

     public Pair(int x, int y, double dis) {
          this.point_x = x;
          this.point_y = y;
          this.distance = dis;
     }

     public void setDistance(double dis) {
          this.distance = dis;
     }

     public int getNodeX() {
          return this.point_x;
     }

     public int getNodeY() {
          return this.point_y;
     }

     public double getDistance() {
          return this.distance;
     }

     public int compareTo(Pair that) {
          if (this.distance > that.distance) {
               return +1;
          }
          if (this.distance < that.distance) {
               return -1;
          }
          return 0;
     }
}

@e5b84300f2987c8ce47ce133c9fee65b@"
"b03611035","10","0.138","205632","@0f63d25fc93a58a6003377c7c46a7679@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N=Integer.parseInt(br.readLine());
            P2D[] gg=new P2D[N];
            for(int i=0;i<N;i++){
                String temp[]=new String[2];
                temp=br.readLine().split("" "");
                double x=Double.parseDouble(temp[0]);
                double y=Double.parseDouble(temp[1]);
                gg[i]=new P2D(x,y);
            }
            //先找到s和t，用XpY_Order
            P2D origin=new P2D(0,0);
            Arrays.sort(gg,origin.XpY_ORDER);
            P2D s=gg[0]; 
            P2D t=gg[N-1];
            

            /*建Digraph，當v-w距離<d，並且v比w嚴格左下時建立單向連結            
               找到最小距離d使s-t至少有一條路
            */
            double d=2.8284271247461900976033774484194;
            DirectedDFS test;
            do{
                d=d/2;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(test.marked(N-1));
            
            do{
                
                d+=0.0005;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(!test.marked(N-1));
            d=d*1000;
            d=Math.floor(d);
            d=d/1000;
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

class P2D implements Comparable<P2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<P2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<P2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<P2D> R_ORDER = new ROrder();


    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<P2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<P2D> DISTANCE_TO_ORDER = new DistanceToOrder();
    public final Comparator<P2D> XpY_ORDER = new XpYOrder();
    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public P2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(P2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }
    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(P2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }
    private static class XpYOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x+p.y < q.x+q.y) return -1;
            if (p.x+p.y > q.x+q.y) return +1;
            return 0;
        }
    }
    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<P2D> {
        public int compare(P2D q1, P2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        P2D that = (P2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }
}
@0f63d25fc93a58a6003377c7c46a7679@"
"r04921104","4","0.62","172224","@9633192d84c256acea45714e131b02a3@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class CriticalDis {

    private class BlockDisToOrder implements Comparator<Point2D> {

        public BlockDisToOrder() {
        }

        public int compare(Point2D p, Point2D q) {
            double blockdist1 = p.x() + p.y();
            double blockdist2 = q.x() + q.y();
            if (blockdist1 < blockdist2) {
                return -1;
            } else if (blockdist1 > blockdist2) {
                return +1;
            } else {
                return 0;
            }
        }
    }

    private final Point2D[] pts;
    private final int s, t;

    private boolean[] marked;
    public MinPQ<Double> discanditate;
    public double disthr;
    private double rangedis;

    CriticalDis(Point2D[] pts) {
        this.pts = pts;
        Arrays.sort(this.pts, new BlockDisToOrder());
        this.s = 0;
        this.t = pts.length - 1;

        setdisthr();
        this.rangedis = Math.sqrt(2) * disthr;
        marked = new boolean[this.pts.length];
        Arrays.fill(marked, false);
        discanditate = new MinPQ();
    }

    private void setdisthr(){
        int w = 1;
        while (!(pts[0].x() < pts[w].x() && pts[0].y() < pts[w].y())) {w++;}
        this.disthr = pts[0].distanceTo(pts[w]);
    }
    
    public void reset(double disthr) {
        this.disthr = disthr;
        this.rangedis = Math.sqrt(2) * disthr;
        Arrays.fill(marked, false);
        discanditate = new MinPQ();
    }

    private void findPathtoT(int v, double searchrange) {
        int w = v + 1;
        while (w < pts.length && pts[w].x() + pts[w].y() <= searchrange) {
            if (!marked[w] && pts[v].x() < pts[w].x() && pts[v].y() < pts[w].y()) {
                double dis = pts[v].distanceTo(pts[w]);
                if (dis <= disthr) {
                    marked[w] = true;
                    findPathtoT(w, searchrange + rangedis);
                } else {
                    discanditate.insert(dis);
                }
            }
            w++;
        }
    }

    public boolean hasPathStoT() {
        marked[0] = true;
        findPathtoT(s, pts[0].x() + pts[0].y() + rangedis);
        if (marked[pts.length - 1]) {
            return true;
        } else {
            return false;
        }
    }

    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] pts = new Point2D[N];
            for (int n = 0; n < N; n++) {
                String in = br.readLine();
                String[] inpair = in.split("" "");
                pts[n] = new Point2D(Double.parseDouble(inpair[0]), Double.parseDouble(inpair[1]));
            }

            double d = 0;
            CriticalDis test = new CriticalDis(pts);
            while (!test.hasPathStoT()) {
                d = test.discanditate.delMin();
                test.reset(d);
            }
            System.out.printf(""%1.3f\n"",d);

        }
    }

}

@9633192d84c256acea45714e131b02a3@"
"b03611041","9","1.04","141616","@5945734e32567be0f5b39466606a66fe@

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            Digraph digraph = new Digraph(vertexNum);

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else digraph.addEdge(i, j);
                }
            }

            criticalDis.findAllPath(digraph, vertexes.indexOf(source), vertexes.indexOf(target));
            System.out.printf(""%1.3f\n"", glmin);
        }
    }

    private void findAllPath(Digraph digraph, int s, int t) {
        path.add(s);
        onPath.add(s);
        double max=0;
        if (s == t) {
//            System.out.println(path);
            for (int i = 0; i < path.size()-1; i++) {
                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
//                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
                if(tmpDis>max)max=tmpDis;
            }
//            System.out.println(max);
            if(max<glmin)glmin=max;
        } else {
            for (int i : digraph.adj(s)) {
                if (!onPath.contains(i)) findAllPath(digraph, i, t);
            }
        }
        path.remove(path.size()-1);
        onPath.delete(s);

    }
}

@5945734e32567be0f5b39466606a66fe@"
"b03611041","9","1.04","138336","@56562d4e2faca3eff1970c635816786a@

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
            Stack<int[]> allEdge=new Stack<>();

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                    }
                }
            }
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
            System.out.printf(""%1.3f\n"", glmin);
        }
    }

    private void findAllPath(int s, int t) {
        path.add(s);
        onPath.add(s);
        double max=0;
        if (s == t) {
//            System.out.println(path);
            for (int i = 0; i < path.size()-1; i++) {
                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
//                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
                if(tmpDis>max)max=tmpDis;
            }
//            System.out.println(max);
            if(max<glmin)glmin=max;
        } else {
            for (int i : digraph.adj(s)) {
                if (!onPath.contains(i)) findAllPath(i, t);
            }
        }
        path.remove(path.size()-1);
        onPath.delete(s);
    }
}

@56562d4e2faca3eff1970c635816786a@"
"b03611041","9","1.07","145408","@69b6fd20477385387c0455e3b4d95074@

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;
    private static DirectedDFS directedDFS;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
            Stack<int[]> allEdge=new Stack<>();

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                    }
                }
            }
            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
            System.out.printf(""%1.3f\n"", glmin);
        }
    }

    private void findAllPath(int s, int t) {
        path.add(s);
        onPath.add(s);
        double max=0;
        if (s == t) {
//            System.out.println(path);
            for (int i = 0; i < path.size()-1; i++) {
                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
//                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
                if(tmpDis>max)max=tmpDis;
            }
//            System.out.println(max);
            if(max<glmin)glmin=max;
        } else {
            for (int i : digraph.adj(s)) {
                if (directedDFS.marked(i)) findAllPath(i, t);
            }
        }
        path.remove(path.size()-1);
        onPath.delete(s);
    }
}

@69b6fd20477385387c0455e3b4d95074@"
"b03611003","10","0.118","193440","@54271f5d27f2ca6182a686d689930cf0@

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 士齊
 */
public class CriticalDis {

    private static Point2D[] orip;

    private static class distclass implements Comparable<distclass> {
//        用來存進pq

        int A, B;
        double dis;

        distclass(int first, int second) {
            A = first;
            B = second;
            dis = orip[A].distanceTo(orip[B]);
        }

        public int compareTo(distclass that) {
            double value = this.dis - that.dis;

            if (value > 0) {
                return 1;
            } else if (value == 0) {
                return 0;
            } else {
                return -1;
            }
        }

    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);

            MinPQ<distclass> diss = new MinPQ<distclass>();
            Digraph G = new Digraph(N);
            DirectedDFS D;

            orip = new Point2D[N];
            int s = 0;
            int t = 0;

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = data.split("" "");
                orip[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

                for (int j = 0; j < i; j++) {
                    if (orip[i].x() < orip[j].x() && orip[i].y() < orip[j].y()) {
                        diss.insert(new distclass(i, j));
                    } else if (orip[j].x() < orip[i].x() && orip[j].y() < orip[i].y()) {
                        diss.insert(new distclass(j, i));
                    }
                }
            }

            for (int i = 0; i < N; i++) {
                if (orip[i].x() + orip[i].y() < orip[s].x() + orip[s].y()) {
                    s = i;
                }

                if (orip[i].x() + orip[i].y() > orip[t].x() + orip[t].y()) {
                    t = i;
                }
            }

            distclass newdis = null;
            while (!diss.isEmpty()) {
                newdis = diss.delMin();
                G.addEdge(newdis.A, newdis.B);

                D = new DirectedDFS(G, s);
                if (D.marked(t)) {
                    break;
                }
            }

            double ans = newdis.dis;
            System.out.printf(""%1.3f\n"", ans);

        }
    }
}

@54271f5d27f2ca6182a686d689930cf0@"
"b01703032","10","0.192","236048","@27b491345454c84825e99b9ef8411874@import java.util.ArrayList;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int v = in.readInt();
        Point2D[] points = new Point2D[v];
        for (int i = 0 ; i < v ; i++) {
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<DistanceEvent> distanceArray = new ArrayList<DistanceEvent>();
        for (int i = 0; i < points.length; i++) {
            Point2D p1 = points[i];
            for (int j = 0; j < points.length; j++) {
                Point2D p2 = points[j];
                if (p1.x() < p2.x() && p1.y() < p2.y()) {
                    distanceArray.add(new DistanceEvent(p1.distanceTo(p2), i, j));
                }
            }
        }
        DistanceEvent[] distanceEvents = distanceArray.toArray(new DistanceEvent[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (DistanceEvent distanceEvent:distanceEvents){
            digraph.addEdge(distanceEvent.i,distanceEvent.j);
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }
    }

    static class DistanceEvent implements Comparable<DistanceEvent>{
        double d;
        int i;
        int j;
        public DistanceEvent(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(DistanceEvent o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}
@27b491345454c84825e99b9ef8411874@"
"b03611041","8","1.23","215600","@2964835029398502f45513603dd2e65b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
//    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
//    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;
    private static DirectedDFS directedDFS;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if(a.getDis()>b.getDis())return 1;
            else return -1;
        }
    }

    private static class edge{
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i,int j,Point2D pi,Point2D pj){
            this.a=i;
            this.b=j;
            this.pa=pi;
            this.pb=pj;
            this.dis=pi.distanceTo(pj);
        }

        public int getA(){
            return this.a;
        }

        public int getB(){
            return this.b;
        }

        public  double getDis(){
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            Stack<int[]> allEdge=new Stack<>();
            MinPQ<edge> edges=new MinPQ<>(new edgeCompare());
            ArrayList<edge> edges1=new ArrayList<>();

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
//                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                        edge edge=new edge(i,j,vertexes.get(i),vertexes.get(j));
                        edges.insert(edge);
//                        edges1.add(edge);
                    }
                }
            }
//            edges1.sort(new edgeCompare());
            //            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

            int s=vertexes.indexOf(source);
            int t=vertexes.indexOf(target);
            for (int i = 0; i < edges.size(); i++) {
                edge E=edges.delMin();
                digraph.addEdge(E.getA(),E.getB());
                directedDFS =new DirectedDFS(digraph,s);
                if(directedDFS.marked(t)){

                    System.out.printf(""%1.3f\n"", E.getDis());
                    break;
                }
            }
//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

//            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
//            System.out.printf(""%1.3f\n"", glmin);
        }
    }


//    private void findAllPath(int s, int t) {
//        path.add(s);
//        onPath.add(s);
//        double max=0;
//        if (s == t) {
////            System.out.println(path);
//            for (int i = 0; i < path.size()-1; i++) {
//                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
////                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
//                if(tmpDis>max)max=tmpDis;
//            }
////            System.out.println(max);
//            if(max<glmin)glmin=max;
//        } else {
//            for (int i : digraph.adj(s)) {
//                if (directedDFS.marked(i)) findAllPath(i, t);
//            }
//        }
//        path.remove(path.size()-1);
//        onPath.delete(s);
//    }
}

@2964835029398502f45513603dd2e65b@"
"b03611041","8","1.24","207600","@d533765bf679e0f4f7ea2098e36e10b6@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
//    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
//    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if(a.getDis()>b.getDis())return 1;
            else return -1;
        }
    }

    private static class edge{
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i,int j,Point2D pi,Point2D pj){
            this.a=i;
            this.b=j;
            this.pa=pi;
            this.pb=pj;
            this.dis=pi.distanceTo(pj);
        }

        public int getA(){
            return this.a;
        }

        public int getB(){
            return this.b;
        }

        public  double getDis(){
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            Stack<int[]> allEdge=new Stack<>();
            MinPQ<edge> edges=new MinPQ<>(new edgeCompare());
            ArrayList<edge> edges1=new ArrayList<>();

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
//                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                        edge edge=new edge(i,j,vertexes.get(i),vertexes.get(j));
                        edges.insert(edge);
//                        edges1.add(edge);
                    }
                }
            }
//            edges1.sort(new edgeCompare());
            //            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

            int s=vertexes.indexOf(source);
            int t=vertexes.indexOf(target);
            for (int i = 0; i < edges.size(); i++) {
                edge E=edges.delMin();
                digraph.addEdge(E.getA(),E.getB());
                DirectedDFS directedDFS=new DirectedDFS(digraph,s);
                if(directedDFS.marked(t)){
                    System.out.printf(""%1.3f\n"", E.getDis());
                    break;
                }
            }
//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

//            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
//            System.out.printf(""%1.3f\n"", glmin);
        }
    }


//    private void findAllPath(int s, int t) {
//        path.add(s);
//        onPath.add(s);
//        double max=0;
//        if (s == t) {
////            System.out.println(path);
//            for (int i = 0; i < path.size()-1; i++) {
//                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
////                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
//                if(tmpDis>max)max=tmpDis;
//            }
////            System.out.println(max);
//            if(max<glmin)glmin=max;
//        } else {
//            for (int i : digraph.adj(s)) {
//                if (directedDFS.marked(i)) findAllPath(i, t);
//            }
//        }
//        path.remove(path.size()-1);
//        onPath.delete(s);
//    }
}

@d533765bf679e0f4f7ea2098e36e10b6@"
"r04631026","10","0.116","206256","@a9884ea21e661dc0efb01f55eed8d45a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import static java.lang.Math.pow;

/**
 *
 * @author tks11
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    public static class pair implements Comparable<pair> {

        private int x;
        private int y;
        private Point2D tempx;
        private Point2D tempy;
        private double dist;

        public pair(int x, int y, Point2D tempx, Point2D tempy) {
            this.x = x;
            this.y = y;
            this.tempx = tempx;
            this.tempy = tempy;
            dist = tempx.distanceTo(tempy);
        }

        public int x() {  return this.x; }

        public int y() {  return this.y; }

        public Point2D tempx() {  return this.tempx;}

        public Point2D tempy() {  return this.tempy;}

        public double Distance() {return this.dist; }

        public int compareTo(pair that) {
            if (this.Distance() > that.Distance()) {    return 1; }
            if (this.Distance() < that.Distance()) {    return -1;}
            else{ return 0;}          
        }
    }
    private static double sum(double a,double b ){
        double x=a+b;
        return x;
    }
    private static boolean CheckLefLarge(double a,double b ){
        if (a>b){
            return true;
        }
        else {
            return false;
        }
    }
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        FileReader fr = new FileReader(args[0]);
        BufferedReader br = new BufferedReader(fr);
        int LineNum = Integer.parseInt(br.readLine()); //讀第一行       
//        Point2D[] add = new Point2D[1] ;
        Point2D[] add = new Point2D[LineNum];
        for (int i = 0; i < LineNum; i++) {
            String RowLine = br.readLine();
            double x = Double.parseDouble(RowLine.split("" "")[0]);
            double y = Double.parseDouble(RowLine.split("" "")[1]);
            add[i] = new Point2D(x, y);
        }
        for (int i = 1; i < LineNum - 1; i++) {
            double s = sum(add[0].x(),add[0].y());            
            double t = sum(add[LineNum - 1].x(), add[LineNum - 1].y());
            double comparing = sum(add[i].x() , add[i].y());
            if (CheckLefLarge(s,comparing)) {
                Point2D temp = add[i];
                add[i] = add[0];
                add[0] = temp;
            } else if (CheckLefLarge(comparing , t)) {
                Point2D temp = add[i];
                add[i] = add[LineNum - 1];
                add[LineNum - 1] = temp;
            }
        }
//--------------------------------------------------------------------------------------//
        MinPQ<pair> Ans = new MinPQ<pair>();
        for (int i = 0; i < LineNum; i++) {
            for (int j = 0; j < LineNum; j++) {
                if ((CheckLefLarge(add[j].x() , add[i].x())) && (CheckLefLarge(add[j].y() , add[i].y())) && i != j) {
                    pair temp = new pair(i, j, add[i], add[j]);
                    Ans.insert(temp);
                }
            }
        }
        Digraph path = new Digraph(LineNum);
        DirectedDFS checkconnect = new DirectedDFS(path, 0);
        double d = 0;
        while (checkconnect.marked(LineNum - 1) != true) {
            pair temp = Ans.delMin();
            path.addEdge(temp.x(), temp.y());
            checkconnect = new DirectedDFS(path, 0);
            d = temp.Distance();
        }
        System.out.printf(""%1.3f\n"", d);
    }
}

@a9884ea21e661dc0efb01f55eed8d45a@"
"b03611041","8","1.26","207888","@0b12f8e14a44671a1281c94defba3f1a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
//    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
//    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if(a.getDis()>b.getDis())return 1;
            else return -1;
        }
    }

    private static class edge{
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i,int j,Point2D pi,Point2D pj){
            this.a=i;
            this.b=j;
            this.pa=pi;
            this.pb=pj;
            this.dis=pa.distanceTo(pb);
        }

        public int getA(){
            return this.a;
        }

        public int getB(){
            return this.b;
        }

        public  double getDis(){
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            Stack<int[]> allEdge=new Stack<>();
            MinPQ<edge> edges=new MinPQ<>(new edgeCompare());

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
//                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                        edge edge=new edge(i,j,vertexes.get(i),vertexes.get(j));
                        edges.insert(edge);
//                        edges1.add(edge);
                    }
                }
            }
//            edges1.sort(new edgeCompare());
            //            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

            int s=vertexes.indexOf(source);
            int t=vertexes.indexOf(target);
            for (int i = 0; i < edges.size(); i++) {
                edge E=edges.delMin();
                digraph.addEdge(E.getA(),E.getB());
                DirectedDFS directedDFS=new DirectedDFS(digraph,s);
                if(directedDFS.marked(t)){
                    System.out.printf(""%1.3f\n"", E.getDis());
                    break;
                }
            }
//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

//            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
//            System.out.printf(""%1.3f\n"", glmin);
        }
    }


//    private void findAllPath(int s, int t) {
//        path.add(s);
//        onPath.add(s);
//        double max=0;
//        if (s == t) {
////            System.out.println(path);
//            for (int i = 0; i < path.size()-1; i++) {
//                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
////                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
//                if(tmpDis>max)max=tmpDis;
//            }
////            System.out.println(max);
//            if(max<glmin)glmin=max;
//        } else {
//            for (int i : digraph.adj(s)) {
//                if (directedDFS.marked(i)) findAllPath(i, t);
//            }
//        }
//        path.remove(path.size()-1);
//        onPath.delete(s);
//    }
}

@0b12f8e14a44671a1281c94defba3f1a@"
"b03611041","8","1.27","209536","@a4780f1afebb0cddea2baf722ee127ef@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
//    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
//    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if(a.getDis()>b.getDis())return 1;
            else if(a.getDis() ==b.getDis())return 0;
            else return -1;
        }
    }

    private static class edge{
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i,int j,Point2D pi,Point2D pj){
            this.a=i;
            this.b=j;
            this.pa=pi;
            this.pb=pj;
            this.dis=pa.distanceTo(pb);
        }

        public int getA(){
            return this.a;
        }

        public int getB(){
            return this.b;
        }

        public  double getDis(){
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            Stack<int[]> allEdge=new Stack<>();
            MinPQ<edge> edges=new MinPQ<>(new edgeCompare());

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
//                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                        edge edge=new edge(i,j,vertexes.get(i),vertexes.get(j));
                        edges.insert(edge);
//                        edges1.add(edge);
                    }
                }
            }
//            edges1.sort(new edgeCompare());
            //            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

            int s=vertexes.indexOf(source);
            int t=vertexes.indexOf(target);
            for (int i = 0; i < edges.size(); i++) {
                edge E=edges.delMin();
                digraph.addEdge(E.getA(),E.getB());
                DirectedDFS directedDFS=new DirectedDFS(digraph,s);
                if(directedDFS.marked(t)){
                    System.out.printf(""%1.3f\n"", E.getDis());
                    break;
                }
            }
//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

//            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
//            System.out.printf(""%1.3f\n"", glmin);
        }
    }


//    private void findAllPath(int s, int t) {
//        path.add(s);
//        onPath.add(s);
//        double max=0;
//        if (s == t) {
////            System.out.println(path);
//            for (int i = 0; i < path.size()-1; i++) {
//                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
////                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
//                if(tmpDis>max)max=tmpDis;
//            }
////            System.out.println(max);
//            if(max<glmin)glmin=max;
//        } else {
//            for (int i : digraph.adj(s)) {
//                if (directedDFS.marked(i)) findAllPath(i, t);
//            }
//        }
//        path.remove(path.size()-1);
//        onPath.delete(s);
//    }
}

@a4780f1afebb0cddea2baf722ee127ef@"
"b03611041","8","1.2","213632","@8b6fad5d3ee51055caacaf97be6e7d91@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    //    private Stack<Integer> path=new Stack<>();
    private List<Integer> path = new ArrayList<>();
    private SET<Integer> onPath = new SET<>();
//    private static double glmin=1.5;
    private static ArrayList<Point2D> vertexes;
//    private static DepthFirstDirectedPaths dfs;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if(a.getDis()>b.getDis())return 1;
            else if(a.getDis() == b.getDis())return 0;
            else return -1;
        }
    }

    private static class edge{
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i,int j,Point2D pi,Point2D pj){
            this.a=i;
            this.b=j;
            this.pa=pi;
            this.pb=pj;
            this.dis=pa.distanceTo(pb);
        }

        public int getA(){
            return this.a;
        }

        public int getB(){
            return this.b;
        }

        public  double getDis(){
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        CriticalDis criticalDis = new CriticalDis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            Stack<int[]> allEdge=new Stack<>();
            MinPQ<edge> edges=new MinPQ<>(new edgeCompare());

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
//                        digraph.addEdge(i, j);
//                        int[] tmpEdge={i,j};
//                        allEdge.push(tmpEdge);
                        edge edge=new edge(i,j,vertexes.get(i),vertexes.get(j));
                        edges.insert(edge);
//                        edges1.add(edge);
                    }
                }
            }
//            edges1.sort(new edgeCompare());
            //            directedDFS =new DirectedDFS(digraph,vertexes.indexOf(source));
//            dfs=new DepthFirstDirectedPaths(digraph,vertexes.indexOf(source));

            int s=vertexes.indexOf(source);
            int t=vertexes.indexOf(target);
            for (int i = 0; i < edges.size(); i++) {
                edge E=edges.delMin();
                digraph.addEdge(E.getA(),E.getB());
                DirectedDFS directedDFS=new DirectedDFS(digraph,s);
                if(directedDFS.marked(t)){
                    System.out.printf(""%1.3f\n"", E.getDis());
                    break;
                }
            }
//            for (int i = 0; i < allEdge.size(); i++) {
//                int[] E=allEdge.pop();
//                vertexes.get(E[0]).distanceTo(vertexes.get(E[1]));
//            }

//            criticalDis.findAllPath(vertexes.indexOf(source), vertexes.indexOf(target));
//            System.out.printf(""%1.3f\n"", glmin);
        }
    }


//    private void findAllPath(int s, int t) {
//        path.add(s);
//        onPath.add(s);
//        double max=0;
//        if (s == t) {
////            System.out.println(path);
//            for (int i = 0; i < path.size()-1; i++) {
//                double tmpDis=vertexes.get(path.get(i)).distanceTo(vertexes.get(path.get(i+1)));
////                System.out.println(path.get(i)+"" ""+path.get(i+1)+"" ""+tmpDis);
//                if(tmpDis>max)max=tmpDis;
//            }
////            System.out.println(max);
//            if(max<glmin)glmin=max;
//        } else {
//            for (int i : digraph.adj(s)) {
//                if (directedDFS.marked(i)) findAllPath(i, t);
//            }
//        }
//        path.remove(path.size()-1);
//        onPath.delete(s);
//    }
}

@8b6fad5d3ee51055caacaf97be6e7d91@"
"b03611041","10","0.129","215568","@30db3ec630cf16dd5aac9b176a960fe9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 * Created by Sunny on 6/8/16.
 */
public class CriticalDis {
    private static ArrayList<Point2D> vertexes;
    private static Digraph digraph;

    static class ptCompare implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return (a.x() < b.x() || (a.x() == b.x() && a.y() > b.y())) ? -1 : 0;
        }
    }

    static class edgeCompare implements Comparator<edge> {
        public int compare(edge a, edge b) {
            if (a.getDis() > b.getDis()) return 1;
            else if (a.getDis() == b.getDis()) return 0;
            else return -1;
        }
    }

    private static class edge {
        private int a;
        private int b;
        private Point2D pa;
        private Point2D pb;
        private double dis;

        public edge(int i, int j, Point2D pi, Point2D pj) {
            this.a = i;
            this.b = j;
            this.pa = pi;
            this.pb = pj;
            this.dis = pa.distanceTo(pb);
        }

        public int getA() {
            return this.a;
        }

        public int getB() {
            return this.b;
        }

        public double getDis() {
            return this.dis;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int vertexNum = Integer.parseInt(br.readLine());
            String[] tmp;
            Point2D source = new Point2D(1, 1), target = new Point2D(0, 0);
            vertexes = new ArrayList<>(vertexNum);
            digraph = new Digraph(vertexNum);
//            MinPQ<edge> edges = new MinPQ<>(new edgeCompare());
            ArrayList<edge>edges =new ArrayList<>();

            for (int i = 0; i < vertexNum; i++) {
                String t = br.readLine();
                tmp = t.split("" "");
                vertexes.add(new Point2D(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1])));
                if (source.x() + source.y() >= vertexes.get(i).x() + vertexes.get(i).y()) source = vertexes.get(i);
                if (target.x() + target.y() <= vertexes.get(i).x() + vertexes.get(i).y()) target = vertexes.get(i);
            }
            Collections.sort(vertexes, new ptCompare());

            for (int i = 0; i < vertexNum; i++) {
                for (int j = i + 1; j < vertexNum; j++) {
                    if (vertexes.get(j).y() < vertexes.get(i).y()) continue;
                    else {
                        edge edge = new edge(i, j, vertexes.get(i), vertexes.get(j));
//                        edges.insert(edge);
                        edges.add(edge);
                    }
                }
            }
            edges.sort(new edgeCompare());

            int s = vertexes.indexOf(source);
            int t = vertexes.indexOf(target);
            DirectedDFS dfs = new DirectedDFS(digraph, s);
//            edge EE = edges.delMin();
//            digraph.addEdge(EE.getA(), EE.getB());
            double d=0;

//            while (!dfs.marked(t)){
//                edge E = edges.delMin();
//                digraph.addEdge(E.getA(), E.getB());
//                d=E.getDis();
//            }

            for (int i = 0; i < edges.size(); i++) {
                digraph.addEdge(edges.get(i).getA(), edges.get(i).getB());
                dfs=new DirectedDFS(digraph,s);
                if(dfs.marked(t)){
                    System.out.printf(""%1.3f\n"", edges.get(i).getDis());
                    break;
                }
            }
//            System.out.printf(""%1.3f\n"", d);

            //            for (int i = 0; i < edges.size(); i++) {
//                edge E = edges.delMin();
//                DirectedDFS dfs = new DirectedDFS(digraph, s);
//                if (dfs.marked(t)) {
//                    System.out.printf(""%1.3f\n"", E.getDis());
//                    break;
//                }
//            }

        }
    }
}
@30db3ec630cf16dd5aac9b176a960fe9@"
"r04921104","10","0.117","166240","@9f4b4501eb07661e26ed8a58994bf70a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class CriticalDis {

    private class BlockDisToOrder implements Comparator<Point2D> {

        public BlockDisToOrder() {
        }

        public int compare(Point2D p, Point2D q) {
            double blockdist1 = p.x() + p.y();
            double blockdist2 = q.x() + q.y();
            if (blockdist1 < blockdist2) {
                return -1;
            } else if (blockdist1 > blockdist2) {
                return +1;
            } else {
                return 0;
            }
        }
    }

    private final Point2D[] pts;
    private final int s, t;

    private boolean[] marked;
    public MinPQ<Double> discanditate;
    public double disthr;
    private double rangedis;

    CriticalDis(Point2D[] pts,double disthr) {
        this.pts = pts;
        Arrays.sort(this.pts, new BlockDisToOrder());
        this.s = 0;
        this.t = pts.length - 1;

        this.disthr = disthr;
        this.rangedis = Math.sqrt(2) * disthr;
        marked = new boolean[this.pts.length];
        Arrays.fill(marked, false);
        discanditate = new MinPQ();
    }

    private void setdisthr(){
        int w = 1;
        while (!(pts[0].x() < pts[w].x() && pts[0].y() < pts[w].y())) {w++;}
        this.disthr = pts[0].distanceTo(pts[w]);
    }
    
    public void reset(double disthr) {
        this.disthr = disthr;
        this.rangedis = Math.sqrt(2) * disthr;
        Arrays.fill(marked, false);
        discanditate = new MinPQ();
    }

    private void findPathtoT(int v, double searchrange) {
        int w = v + 1;
        while (w < pts.length) {
            if (!marked[w] && pts[v].x() < pts[w].x() && pts[v].y() < pts[w].y()) {
                double dis = pts[v].distanceTo(pts[w]);
                if (dis <= disthr) {
                    marked[w] = true;
                    findPathtoT(w, searchrange + rangedis);
                } else {
                    discanditate.insert(dis);
                }
            }
            w++;
        }
    }

    public boolean hasPathStoT() {
        marked[0] = true;
        findPathtoT(s, pts[0].x() + pts[0].y() + rangedis);
        if (marked[pts.length - 1]) {
            return true;
        } else {
            return false;
        }
    }

    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            Point2D[] pts = new Point2D[N];
            for (int n = 0; n < N; n++) {
                String in = br.readLine();
                String[] inpair = in.split("" "");
                pts[n] = new Point2D(Double.parseDouble(inpair[0]), Double.parseDouble(inpair[1]));
            }

            double d = 0;           
            CriticalDis test = new CriticalDis(pts,d);
            while (!test.hasPathStoT()) {
                d = test.discanditate.delMin();
                test.reset(d);
            }
            System.out.printf(""%1.3f\n"",d);

        }
    }

}
@9f4b4501eb07661e26ed8a58994bf70a@"
"r04631034","8","1.46","202528","@8ee5e0afe8690fada0f7da23c71d6c33@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author acer
 */
public class CriticalDis {

     public static double distance(Point2D x, Point2D y) {
          return Math.sqrt(Math.pow(x.x() - y.x(), 2) + Math.pow(x.y() - y.y(), 2));
     }

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);
          int N = Integer.valueOf(in.readLine());
          Point2D[] point_array = new Point2D[N];
          String line;
          int input_count = 0;
          double Min = 2;
          double Max = 0;
//          Point2D MinNode = null;
//          Point2D MaxNode = null;
          int MinIndex = 0;
          int MaxIndex = 0;
          while ((line = in.readLine()) != null) {
               point_array[input_count] = new Point2D(Double.valueOf(line.split("" "")[0]), Double.valueOf(line.split("" "")[1]));

////////////////////////////////////     draaw point    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////          
//               StdDraw.setPenColor(StdDraw.BLACK);
//               StdDraw.filledCircle(point_array[input_count].x(), point_array[input_count].y(), 0.01);
//               String str = String.valueOf(input_count);
//               StdDraw.text(point_array[input_count].x(), point_array[input_count].y() + 0.03, str);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
               if (Min > (point_array[input_count].x() + point_array[input_count].y())) {
                    Min = point_array[input_count].x() + point_array[input_count].y();
//                    MinNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MinIndex = input_count;
               }
               if (Max < (point_array[input_count].x() + point_array[input_count].y())) {
                    Max = point_array[input_count].x() + point_array[input_count].y();
//                    MaxNode = new Point2D(point_array[input_count].x(), point_array[input_count].y());
                    MaxIndex = input_count;
               }
               input_count++;
          }
///////////////////////////// draw max and min point  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//          StdDraw.setPenColor(StdDraw.RED);
//          StdDraw.filledCircle(MinNode.x(), MinNode.y(), 0.01);
//          StdDraw.filledCircle(MaxNode.x(), MaxNode.y(), 0.01);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

          MinPQ<Pair> pq_test = new MinPQ<Pair>();
          for (int idx = 0; idx < point_array.length; idx++) {
               for (int idy = 0; idy < point_array.length; idy++) {
                    if (point_array[idx].x() < point_array[idy].x() && point_array[idx].y() < point_array[idy].y()) {
                         pq_test.insert(new Pair(idx, idy, distance(point_array[idx], point_array[idy])));
                    }
               }
          }
          Digraph G = new Digraph(N);
//          System.out.println(""Min index "" + MinIndex + "" Max index "" + MaxIndex);
          while (!pq_test.isEmpty()) {
               Pair temp = pq_test.delMin();
//               System.out.println(""X  "" + temp.getNodeX() + "" Y "" + temp.getNodeY() + "" dis "" + temp.getDistance());
               G.addEdge(temp.getNodeX(), temp.getNodeY());
               DirectedDFS dfs = new DirectedDFS(G, MinIndex);
               if (dfs.marked(MaxIndex)) {
                    
                    String D = String.format(""%1.3f"", temp.getDistance());
                    System.out.println(Double.valueOf(D));
//                    System.out.println(""%1.3f"", temp.getDistance() );
                    break;
               } else {
                    continue;
               }

          }

     }

}

class Pair implements Comparable<Pair> {

     private int point_x, point_y;
     private double distance;

     public Pair(int x, int y, double dis) {
          this.point_x = x;
          this.point_y = y;
          this.distance = dis;
     }

     public void setDistance(double dis) {
          this.distance = dis;
     }

     public int getNodeX() {
          return this.point_x;
     }

     public int getNodeY() {
          return this.point_y;
     }

     public double getDistance() {
          return this.distance;
     }

     public int compareTo(Pair that) {
          if (this.distance > that.distance) {
               return +1;
          }
          if (this.distance < that.distance) {
               return -1;
          }
          return 0;
     }
}

@8ee5e0afe8690fada0f7da23c71d6c33@"
"b03611035","10","0.118","212400","@4b7b5f6eb6f309b7d4d6ce557451c6b0@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;
public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N=Integer.parseInt(br.readLine());
            
            P2D[] gg=new P2D[N];
            for(int i=0;i<N;i++){
                String temp[]=new String[2];
                temp=br.readLine().split("" "");
                double x=Double.parseDouble(temp[0]);
                double y=Double.parseDouble(temp[1]);
                gg[i]=new P2D(x,y);
            }
            //先找到s和t，用XpY_Order
            P2D origin=new P2D(0,0);
            Arrays.sort(gg,origin.XpY_ORDER);
            P2D s=gg[0];
            P2D t=gg[N-1];
            /*寫法1，超87
            //建Digraph，當v-w距離<d，並且v比w嚴格左下時建立單向連結            
            //找到最小距離d使s-t至少有一條路
            
            
            double d=2.8284271247461900976033774484194;
            DirectedDFS test;
            do{
                d=d/2;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(test.marked(N-1));
           
            do{
                
                d+=0.0005;
                Digraph gra=new Digraph(N);
                for(int i=0;i<N;i++){
                    for(int j=i+1;j<N;j++){
                        if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()&&gg[i].distanceTo(gg[j])<d){
                            gra.addEdge(i, j);
                        }                        
                    }
                }
                test=new DirectedDFS(gra,0);
            }while(!test.marked(N-1));
            
            d=d*1000;
            d=Math.floor(d);
            d=d/1000;
            System.out.printf(""%1.3f\n"", d);
            */
            //寫法1結束
            
            //寫法2，主流
            MinPQ <dis>aya=new MinPQ();
            
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if(gg[i].x()<gg[j].x()&&gg[i].y()<gg[j].y()){
                        dis add=new dis(gg[i],gg[j],i,j);
                        aya.insert(add);
                    }                    
                }
            }
            Digraph gra=new Digraph(N);
            dis temp=aya.delMin();
            aya.insert(temp);
            while(N>0){
                temp=aya.delMin();
                gra.addEdge(temp.getid1(), temp.getid2());
                DirectedDFS haha=new DirectedDFS(gra,0);
                if(haha.marked(N-1))break;
            }
            double d=temp.getdis();
            System.out.printf(""%1.3f\n"", d);
        }
    }
}
class dis implements Comparable<dis>{
    final double distance;
    final P2D v;
    final P2D w;
    final int id1;
    final int id2;
    public dis(P2D a,P2D b,int i,int j){
        distance=a.distanceTo(b);
        v=a;
        w=b;
        id1=i;
        id2=j;
    }
    public double getdis(){
        return distance;
    }
    public P2D[] getPoint(){
        P2D[]a=new P2D[2];
        return a;
    }
    public int getid1(){
        return id1;
    }
    public int getid2(){
        return id2;
    }
    public int compareTo(dis that){
        if(this.distance>that.distance) return 1;
        else if(this.distance<that.distance) return -1;
        else return 0;
    }
}
class P2D implements Comparable<P2D> {

    /**
     * Compares two points by x-coordinate.
     */
    public static final Comparator<P2D> X_ORDER = new XOrder();

    /**
     * Compares two points by y-coordinate.
     */
    public static final Comparator<P2D> Y_ORDER = new YOrder();

    /**
     * Compares two points by polar radius.
     */
    public static final Comparator<P2D> R_ORDER = new ROrder();


    /**
     * Compares two points by atan2() angle (between -pi and pi) with respect to this point.
     */
    public final Comparator<P2D> ATAN2_ORDER = new Atan2Order();

    /**
     * Compares two points by distance to this point.
     */
    public final Comparator<P2D> DISTANCE_TO_ORDER = new DistanceToOrder();
    public final Comparator<P2D> XpY_ORDER = new XpYOrder();
    private final double x;    // x coordinate
    private final double y;    // y coordinate

    /**
     * Initializes a new point (x, y).
     * @param x the x-coordinate
     * @param y the y-coordinate
     * @throws IllegalArgumentException if either <tt>x</tt> or <tt>y</tt>
     *    is <tt>Double.NaN</tt>, <tt>Double.POSITIVE_INFINITY</tt> or
     *    <tt>Double.NEGATIVE_INFINITY</tt>
     */
    public P2D(double x, double y) {
        if (Double.isInfinite(x) || Double.isInfinite(y))
            throw new IllegalArgumentException(""Coordinates must be finite"");
        if (Double.isNaN(x) || Double.isNaN(y))
            throw new IllegalArgumentException(""Coordinates cannot be NaN"");
        if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
        if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the x-coordinate.
     * @return the x-coordinate
     */
    public double x() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     * @return the y-coordinate
     */
    public double y() {
        return y;
    }

    /**
     * Returns the polar radius of this point.
     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
     */
    public double r() {
        return Math.sqrt(x*x + y*y);
    }

    /**
     * Returns the angle of this point in polar coordinates.
     * @return the angle (in radians) of this point in polar coordiantes (between -pi/2 and pi/2)
     */
    public double theta() {
        return Math.atan2(y, x);
    }

    /**
     * Returns the angle between this point and that point.
     * @return the angle in radians (between -pi and pi) between this point and that point (0 if equal)
     */
    private double angleTo(P2D that) {
        double dx = that.x - this.x;
        double dy = that.y - this.y;
        return Math.atan2(dy, dx);
    }
    /**
     * Returns the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the Euclidean distance between this point and that point
     */
    public double distanceTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * Returns the square of the Euclidean distance between this point and that point.
     * @param that the other point
     * @return the square of the Euclidean distance between this point and that point
     */
    public double distanceSquaredTo(P2D that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return dx*dx + dy*dy;
    }

    /**
     * Compares this point to that point by y-coordinate, breaking ties by x-coordinate.
     * @param that the other point
     * @return { a negative integer, zero, a positive integer } if this point is
     *    { less than, equal to, greater than } that point
     */
    public int compareTo(P2D that) {
        if (this.y < that.y) return -1;
        if (this.y > that.y) return +1;
        if (this.x < that.x) return -1;
        if (this.x > that.x) return +1;
        return 0;
    }
    private static class XpYOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x+p.y < q.x+q.y) return -1;
            if (p.x+p.y > q.x+q.y) return +1;
            return 0;
        }
    }
    // compare points according to their x-coordinate
    private static class XOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.x < q.x) return -1;
            if (p.x > q.x) return +1;
            return 0;
        }
    }

    // compare points according to their y-coordinate
    private static class YOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            if (p.y < q.y) return -1;
            if (p.y > q.y) return +1;
            return 0;
        }
    }

    // compare points according to their polar radius
    private static class ROrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
            if (delta < 0) return -1;
            if (delta > 0) return +1;
            return 0;
        }
    }
 
    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
    private class Atan2Order implements Comparator<P2D> {
        public int compare(P2D q1, P2D q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    // compare points according to their distance to this point
    private class DistanceToOrder implements Comparator<P2D> {
        public int compare(P2D p, P2D q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
        }
    }


    /**
     * Does this point equal y?
     * @param other the other point
     * @return true if this point equals the other point; false otherwise
     */
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        P2D that = (P2D) other;
        return this.x == that.x && this.y == that.y;
    }

    /**
     * Return a string representation of this point.
     * @return a string representation of this point in the format (x, y)
     */
    public String toString() {
        return ""("" + x + "", "" + y + "")"";
    }

    /**
     * Returns an integer hash code for this point.
     * @return an integer hash code for this point
     */
    public int hashCode() {
        int hashX = ((Double) x).hashCode();
        int hashY = ((Double) y).hashCode();
        return 31*hashX + hashY;
    }
}


@4b7b5f6eb6f309b7d4d6ce557451c6b0@"
"r03522809","9","1.18","212208","@90ab7405eb9d058c36b22c8bfa67422e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Dennis
 */
public class CriticalDis {
    
    public CriticalDis(){}
    /**
     * @param args the command line arguments
     */
     private static class setPoint implements Comparable <setPoint> { 

     Point2D pointA;
     Point2D pointB;
     int numberA,numberB;
     double dis;
     
     public setPoint(Point2D pointA,Point2D pointB,int numberA,int numberB) { 
            this.pointA = pointA;
            this.pointB = pointB;
            this.numberA =numberA;
            this.numberB =numberB;
            this.dis=this.pointA.distanceTo(this.pointB);
        }
     public int compareTo(setPoint that) {
        int turnans=0;
        if( this.dis > that.dis ){turnans=1;}
        else if( this.dis < that.dis ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
    
    
        public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
  
          String[] Num = br.readLine().split("" "");
          int N = Integer.parseInt(Num[0]);
          Point2D[] data =new Point2D[N];
          Graph detectGraph=new Graph(N);
//          System.out.println(N);
          for(int i=0;i<N;i++){
             String[] readlinedata = br.readLine().split("" "");
             double pointx=Double.parseDouble(readlinedata[0]);
             double pointy=Double.parseDouble(readlinedata[1]);
             data[i]=new Point2D(pointx,pointy);
//             StdDraw.setPenColor(Color.BLACK);
//             StdDraw.text(data[i].x(),data[i].y()+0.02,Integer.toString(i));
//             StdDraw.filledCircle(data[i].x(), data[i].y(),0.01);
//             System.out.println(data[i]);
          }
          
        Point2D sourcePoint =new Point2D(data[0].x(),data[0].y());
        Point2D targetPoint =new Point2D(data[1].x(),data[0].y());
        
        int Max=0,min=0;
                for(int v=0;v<detectGraph.V();v++){ 
                    if(data[v].x()+data[v].y()<sourcePoint.x()+sourcePoint.y()){// Find min
                        sourcePoint=data[v];
                        min=v;
                    }
                    if(data[v].x()+data[v].y()>targetPoint.x()+targetPoint.y()){ // Find Max
                        targetPoint=data[v];
                        Max=v;
                    }
                        for(int w :detectGraph.adj(v)){
//                          StdOut.println( v+""->""+w);
                   }
                }
        
//        System.out.println(min+"" ""+Max);
        MinPQ<setPoint> findminDis =new MinPQ<setPoint>();

        
        for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    if( data[i].x()<data[j].x() && data[i].y()<data[j].y()){
                        setPoint dis2target=new setPoint(data[i],data[j],i,j);
                        findminDis.insert(dis2target);

                    }
                }
        }
            

            int out=0,A=0,B=0;
            double distance;

            while( !findminDis.isEmpty() ){

                   A=findminDis.min().numberA;
                   B=findminDis.min().numberB;
                   
                    distance=findminDis.min().dis;
//                    System.out.printf( ""%1.3f\n"", distance);
                    detectGraph.addEdge(A,B);
                    findminDis.delMin();
                    DepthFirstSearch Path = new DepthFirstSearch(detectGraph,min);

//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.filledCircle(data[A].x(),data[A].y(),0.004);
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.filledCircle(data[B].x(),data[B].y(),0.008);
//                    StdDraw.line(data[A].x(), data[A].y(),data[B].x(), data[B].y());
//                    StdDraw.text(data[A].x(), data[A].y()+0.01,Double.toString(distance));
//                    
//                    Thread.currentThread().sleep(100);

                          if( Path.marked(Max) ){
                          System.out.printf( ""%1.3f\n"",distance);
//                          StdOut.println( min+""->""+Max);
                          out=1;
                          }

              if(out==1){
                  System.out.println();
                  break;
              }
            }
        
        
       }
    }
}


@90ab7405eb9d058c36b22c8bfa67422e@"
"r03522809","8","31.83","187744","@b95e7936141c086319ebe810257061c7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Dennis
 */
public class CriticalDis {
    
    public CriticalDis(){}
    /**
     * @param args the command line arguments
     */
     private static class setPoint implements Comparable <setPoint> { 

     Point2D pointA;
     Point2D pointB;
     int numberA,numberB;
     double dis;
     
     public setPoint(Point2D pointA,Point2D pointB,int numberA,int numberB) { 
            this.pointA = pointA;
            this.pointB = pointB;
            this.numberA =numberA;
            this.numberB =numberB;
            this.dis=this.pointA.distanceTo(this.pointB);
        }
     public int compareTo(setPoint that) {
        int turnans=0;
        if( this.dis > that.dis ){turnans=1;}
        else if( this.dis < that.dis ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
    
    
        public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
  
          String[] Num = br.readLine().split("" "");
          int N = Integer.parseInt(Num[0]);
          Point2D[] data =new Point2D[N];
          Graph detectGraph=new Graph(N);
//          System.out.println(N);
          for(int i=0;i<N;i++){
             String[] readlinedata = br.readLine().split("" "");
             double pointx=Double.parseDouble(readlinedata[0]);
             double pointy=Double.parseDouble(readlinedata[1]);
             data[i]=new Point2D(pointx,pointy);
//             StdDraw.setPenColor(Color.BLACK);
//             StdDraw.text(data[i].x(),data[i].y()+0.02,Integer.toString(i));
//             StdDraw.filledCircle(data[i].x(), data[i].y(),0.01);
//             System.out.println(data[i]);
          }
          
        Point2D sourcePoint =new Point2D(data[0].x(),data[0].y());
        Point2D targetPoint =new Point2D(data[1].x(),data[1].y());
        
        int Max=0,min=0;
                 
                for(int v=0;v<N;v++){ 
                    if( data[v].x()+data[v].y() < sourcePoint.x()+sourcePoint.y()){// Find min
                        sourcePoint=data[v];
                        min=v;
                    }
                    if( data[v].x()+data[v].y() > targetPoint.x()+targetPoint.y()){ // Find Max
                        targetPoint=data[v];
                        Max=v;
                    }
                        for(int w :detectGraph.adj(v)){
//                          StdOut.println( v+""->""+w);
                   }
                }
        
//        System.out.println(min+"" ""+Max);
        MinPQ<setPoint> findminDis =new MinPQ<setPoint>();

//        System.out.println(N);
            for(int i=0;i<N;i++){
                    for(int j=0;j<N;j++){
                        if( data[i].x()<data[j].x() && data[i].y()<data[j].y()){
                            setPoint dis2target=new setPoint(data[i],data[j],i,j);
                            findminDis.insert(dis2target);

                        }
                    }
            }

            int out=0,A=0,B=0;
            double distance;
//            System.out.println(findminDis.size());
            while( !findminDis.isEmpty() ){

                   A=findminDis.min().numberA;
                   B=findminDis.min().numberB;
                   
                    distance=findminDis.min().dis;
//                    System.out.printf( ""%1.3f\n"", distance);
                    detectGraph.addEdge(A,B);
                    findminDis.delMin();
                    DepthFirstSearch Path = new DepthFirstSearch(detectGraph,min);

//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.filledCircle(data[A].x(),data[A].y(),0.004);
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.filledCircle(data[B].x(),data[B].y(),0.008);
//                    StdDraw.line(data[A].x(), data[A].y(),data[B].x(), data[B].y());
//                    StdDraw.text(data[B].x(), data[B].y()+0.01,Double.toString(distance));
                    
                    Thread.currentThread().sleep(100);
//                   System.out.printf( ""%1.3f\n"",distance);
                          if( Path.marked(Max) ){
                          System.out.printf( ""%1.3f\n"",distance);
//                          StdOut.println( min+""->""+Max);
                          out=1;
                          }
//               if(findminDis.isEmpty()){
//                   distance=data[min].distanceTo(data[Max]);
//                   System.out.printf( ""%1.3f\n"",distance);
//               }
                          

              if(out==1){
                  break;
              }
            }
        
        
       }
    }
}


@b95e7936141c086319ebe810257061c7@"
"r03522809","8","1.12","181984","@6e3ac60909683a5820afb9f5f7979e01@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Dennis
 */
public class CriticalDis {
    
    public CriticalDis(){}
    /**
     * @param args the command line arguments
     */
     private static class setPoint implements Comparable <setPoint> { 

     Point2D pointA;
     Point2D pointB;
     int numberA,numberB;
     double dis;
     
     public setPoint(Point2D pointA,Point2D pointB,int numberA,int numberB) { 
            this.pointA = pointA;
            this.pointB = pointB;
            this.numberA =numberA;
            this.numberB =numberB;
            this.dis=this.pointA.distanceTo(this.pointB);
        }
     public int compareTo(setPoint that) {
        int turnans=0;
        if( this.dis > that.dis ){turnans=1;}
        else if( this.dis < that.dis ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
    
    
        public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
  
          String[] Num = br.readLine().split("" "");
          int N = Integer.parseInt(Num[0]);
          Point2D[] data =new Point2D[N];
          Graph detectGraph=new Graph(N);
//          System.out.println(N);
          for(int i=0;i<N;i++){
             String[] readlinedata = br.readLine().split("" "");
             double pointx=Double.parseDouble(readlinedata[0]);
             double pointy=Double.parseDouble(readlinedata[1]);
             data[i]=new Point2D(pointx,pointy);
//             StdDraw.setPenColor(Color.BLACK);
//             StdDraw.text(data[i].x(),data[i].y()+0.02,Integer.toString(i));
//             StdDraw.filledCircle(data[i].x(), data[i].y(),0.01);
//             System.out.println(data[i]);
          }
          
        Point2D sourcePoint =new Point2D(data[0].x(),data[0].y());
        Point2D targetPoint =new Point2D(data[1].x(),data[1].y());
        
        int Max=0,min=0;
                 
                for(int v=0;v<N;v++){ 
                    if( data[v].x()+data[v].y() < sourcePoint.x()+sourcePoint.y()){// Find min
                        sourcePoint=data[v];
                        min=v;
                    }
                    if( data[v].x()+data[v].y() > targetPoint.x()+targetPoint.y()){ // Find Max
                        targetPoint=data[v];
                        Max=v;
                    }
                        for(int w :detectGraph.adj(v)){
//                          StdOut.println( v+""->""+w);
                   }
                }
        
//        System.out.println(min+"" ""+Max);
        MinPQ<setPoint> findminDis =new MinPQ<setPoint>();

//        System.out.println(N);
            for(int i=0;i<N;i++){
                    for(int j=0;j<N;j++){
                        if( data[i].x()<data[j].x() && data[i].y()<data[j].y()){
                            setPoint dis2target=new setPoint(data[i],data[j],i,j);
                            findminDis.insert(dis2target);

                        }
                    }
            }

            int out=0,A=0,B=0;
            double distance;
//            System.out.println(findminDis.size());
            while( !findminDis.isEmpty() ){

                   A=findminDis.min().numberA;
                   B=findminDis.min().numberB;
                   
                    distance=findminDis.min().dis;
//                    System.out.printf( ""%1.3f\n"", distance);
                    detectGraph.addEdge(A,B);
                    findminDis.delMin();
                    DepthFirstSearch Path = new DepthFirstSearch(detectGraph,min);

//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.filledCircle(data[A].x(),data[A].y(),0.004);
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.filledCircle(data[B].x(),data[B].y(),0.008);
//                    StdDraw.line(data[A].x(), data[A].y(),data[B].x(), data[B].y());
//                    StdDraw.text(data[B].x(), data[B].y()+0.01,Double.toString(distance));
                    
//                    Thread.currentThread().sleep(100);
//                   System.out.printf( ""%1.3f\n"",distance);
                          if( Path.marked(Max) ){
                          System.out.printf( ""%1.3f\n"",distance);
//                          StdOut.println( min+""->""+Max);
                          out=1;
                          }
//               if(findminDis.isEmpty()){
//                   distance=data[min].distanceTo(data[Max]);
//                   System.out.printf( ""%1.3f\n"",distance);
//               }
                          

              if(out==1){
                  break;
              }
            }
        
        
       }
    }
}


@6e3ac60909683a5820afb9f5f7979e01@"
"r03522809","9","1.19","208304","@fbe0f3bbf47ea047a40f63f38b3f2cbf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Dennis
 */
public class CriticalDis {
    
    public CriticalDis(){}
    /**
     * @param args the command line arguments
     */
     private static class setPoint implements Comparable <setPoint> { 

     Point2D pointA;
     Point2D pointB;
     int numberA,numberB;
     double dis;
     
     public setPoint(Point2D pointA,Point2D pointB,int numberA,int numberB) { 
            this.pointA = pointA;
            this.pointB = pointB;
            this.numberA =numberA;
            this.numberB =numberB;
            this.dis=this.pointA.distanceTo(this.pointB);
        }
     public int compareTo(setPoint that) {
        int turnans=0;
        if( this.dis > that.dis ){turnans=1;}
        else if( this.dis < that.dis ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
    
    
        public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
  
          String[] Num = br.readLine().split("" "");
          int N = Integer.parseInt(Num[0]);
          Point2D[] data =new Point2D[N];
          Graph detectGraph=new Graph(N);
//          System.out.println(N);
          for(int i=0;i<N;i++){
             String[] readlinedata = br.readLine().split("" "");
             double pointx=Double.parseDouble(readlinedata[0]);
             double pointy=Double.parseDouble(readlinedata[1]);
             data[i]=new Point2D(pointx,pointy);
//             StdDraw.setPenColor(Color.BLACK);
//             StdDraw.text(data[i].x(),data[i].y()+0.02,Integer.toString(i));
//             StdDraw.filledCircle(data[i].x(), data[i].y(),0.01);
//             System.out.println(data[i]);
          }
          
        Point2D sourcePoint =new Point2D(data[0].x(),data[0].y());
        Point2D targetPoint =new Point2D(data[1].x(),data[0].y());
        
        int Max=0,min=0;
                 
                for(int v=0;v<N;v++){
                    
                    if( data[v].x()+data[v].y() < sourcePoint.x()+sourcePoint.y()){// Find min
                        sourcePoint=data[v];
                        min=v;
                    }
                    
                    if( data[v].x()+data[v].y() > targetPoint.x()+targetPoint.y()){ // Find Max
                        targetPoint=data[v];
                        Max=v;
                    }
//                        for(int w :detectGraph.adj(v)){
////                          StdOut.println( v+""->""+w);
//                   }
                }
        
//        System.out.println(min+"" ""+Max);
        MinPQ<setPoint> findminDis =new MinPQ<setPoint>();

//        System.out.println(N);
            for(int i=0;i<N;i++){
                    for(int j=0;j<N;j++){
                        if( data[i].x()<data[j].x() && data[i].y()<data[j].y()){
                            setPoint dis2target=new setPoint(data[i],data[j],i,j);
                            findminDis.insert(dis2target);

                        }
                    }
            }

            int out=0,A=0,B=0;
            double distance;
//            System.out.println(findminDis.size());
            while( !findminDis.isEmpty() ){

                   A=findminDis.min().numberA;
                   B=findminDis.min().numberB;
                   
                    distance=findminDis.min().dis;
//                    System.out.printf( ""%1.3f\n"", distance);
                    detectGraph.addEdge(A,B);
                    findminDis.delMin();
                    DepthFirstSearch Path = new DepthFirstSearch(detectGraph,min);

//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.filledCircle(data[A].x(),data[A].y(),0.004);
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.filledCircle(data[B].x(),data[B].y(),0.008);
//                    StdDraw.line(data[A].x(), data[A].y(),data[B].x(), data[B].y());
//                    StdDraw.text(data[B].x(), data[B].y()+0.01,Double.toString(distance));
                    
//                    Thread.currentThread().sleep(100);
//                   System.out.printf( ""%1.3f\n"",distance);
                          if( Path.marked(Max) ){
                          System.out.printf( ""%1.3f\n"",distance);
//                          StdOut.println( min+""->""+Max);
                          out=1;
                          }
//               if(findminDis.isEmpty()){
//                   distance=data[min].distanceTo(data[Max]);
//                   System.out.printf( ""%1.3f\n"",distance);
//               }
                          

              if(out==1){
                  break;
              }
            }
        
        
       }
    }
}


@fbe0f3bbf47ea047a40f63f38b3f2cbf@"
"r03522809","9","1.18","214352","@69befe47132ec345d541fef0d9f8f28c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Dennis
 */
public class CriticalDis {
    
    public CriticalDis(){}
    /**
     * @param args the command line arguments
     */
     private static class setPoint implements Comparable <setPoint> { 

     Point2D pointA;
     Point2D pointB;
     int numberA,numberB;
     double dis;
     
     public setPoint(Point2D pointA,Point2D pointB,int numberA,int numberB) { 
            this.pointA = pointA;
            this.pointB = pointB;
            this.numberA =numberA;
            this.numberB =numberB;
            this.dis=this.pointA.distanceTo(this.pointB);
        }
     public int compareTo(setPoint that) {
        int turnans=0;
        if( this.dis > that.dis ){turnans=1;}
        else if( this.dis < that.dis ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
    
     private static class setMax implements Comparable <setMax> { 

     Point2D point;
     int number;
     double key;
     
     public setMax(Point2D point,int number) { 
            this.point = point;
            this.key=point.x()+point.y();
            this.number=number;
        }
     public int compareTo(setMax that) {
        int turnans=0;
        if( this.key > that.key ){turnans=1;}
        else if( this.key < that.key  ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
          private static class setmin implements Comparable <setmin> { 

     Point2D point;
     double key;
     int number;
     public setmin(Point2D point,int number) { 
            this.point = point;
            this.key=point.x()+point.y();
            this.number=number;
        }
     public int compareTo(setmin that) {
        int turnans=0;
        if( this.key < that.key ){turnans=1;}
        else if( this.key > that.key  ){turnans=-1;}
        else{turnans=0;}
        return turnans;
     }
    }
     
        public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
  
          String[] Num = br.readLine().split("" "");
          int N = Integer.parseInt(Num[0]);
          Point2D[] data =new Point2D[N];
          Graph detectGraph=new Graph(N);
//          System.out.println(N);
          for(int i=0;i<N;i++){
             String[] readlinedata = br.readLine().split("" "");
             double pointx=Double.parseDouble(readlinedata[0]);
             double pointy=Double.parseDouble(readlinedata[1]);
             data[i]=new Point2D(pointx,pointy);
//             StdDraw.setPenColor(Color.BLACK);
//             StdDraw.text(data[i].x(),data[i].y()+0.02,Integer.toString(i));
//             StdDraw.filledCircle(data[i].x(), data[i].y(),0.01);
//             System.out.println(data[i]);
          }
          
        Point2D sourcePoint =new Point2D(data[0].x(),data[0].y());
        Point2D targetPoint =new Point2D(data[1].x(),data[1].y());

        int Max=0,min=0;
                       MinPQ<setMax> findMax =new MinPQ<setMax>();
                       MinPQ<setmin> findmin =new MinPQ<setmin>();
                for(int i=0;i<N;i++){
                    
                       setMax findM =new setMax(data[i],i);
                       setmin findm =new setmin(data[i],i);
                       findMax.insert(findM);
                       findmin.insert(findm);
//                    if( (data[v].x()+data[v].y()) < (sourcePoint.x()+sourcePoint.y()) ){// Find min
//                        sourcePoint=data[v];
//                        min=v;
//                    }
//                    
//                    if( (data[v].x()+data[v].y()) > (targetPoint.x()+targetPoint.y()) ){ // Find Max
//                        targetPoint=data[v];
//                        Max=v;
//                    }
                }
                        sourcePoint=findMax.min().point;
                        Max=findMax.min().number;
                        targetPoint=findmin.min().point;
                        min=findmin.min().number;

//        System.out.println(min+"" ""+Max);
        MinPQ<setPoint> findminDis =new MinPQ<setPoint>();

//        System.out.println(N);
            for(int i=0;i<N;i++){
                    for(int j=0;j<N;j++){
                        if( data[i].x()<data[j].x() && data[i].y()<data[j].y()){
                            setPoint dis2target=new setPoint(data[i],data[j],i,j);
                            findminDis.insert(dis2target);

                        }
                    }
            }

            int out=0,A=0,B=0;
            double distance;
//            System.out.println(findminDis.size());
            while( !findminDis.isEmpty() ){

                   A=findminDis.min().numberA;
                   B=findminDis.min().numberB;
                   
                    distance=findminDis.delMin().dis;
//                    System.out.printf( ""%1.3f\n"", distance);
                    detectGraph.addEdge(A,B);
                    DepthFirstSearch Path = new DepthFirstSearch(detectGraph,min);

//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.filledCircle(data[A].x(),data[A].y(),0.004);
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.filledCircle(data[B].x(),data[B].y(),0.008);
//                    StdDraw.line(data[A].x(), data[A].y(),data[B].x(), data[B].y());
//                    StdDraw.text(data[B].x(), data[B].y()+0.01,Double.toString(distance));
                    
//                    Thread.currentThread().sleep(100);
//                   System.out.printf( ""%1.3f\n"",distance);
                          if( Path.marked(Max) ){
                          System.out.printf( ""%1.3f\n"",distance);
//                          StdOut.println( min+""->""+Max);
                          out=1;
                          }
                          
               if(findminDis.isEmpty()){
                   distance=data[min].distanceTo(data[Max]);
                   System.out.printf( ""%1.3f\n"",distance);
               }
                          

              if(out==1){
                  break;
              }
            }
        
        
       }
    }
}


@69befe47132ec345d541fef0d9f8f28c@"
"b03704074","9","1.2","116784","@f06aacca9a8e3f60415422933b1b991d@
import java.util.Arrays;

public class CriticalDis {
    static BinarySearchST<Point2D,Integer> number = new BinarySearchST<Point2D,Integer>(); 
 
        Point2D[] V;//我所有的V的陣列
        Bag<Point2D>[] adj;//BAG的陣列然後每個空間都可以存放座標
        public CriticalDis(Point2D[] V){
            this.V = new Point2D[V.length];
            adj = (Bag<Point2D>[]) new Bag[V.length];//給BAG一個V陣列的長度
            for(int i = 0; i < V.length;i++){
                this.V[i] = V[i];
                adj[i] = new Bag<Point2D>();
                number.put(V[i], i);
            }
        }
        public void addEdge(Point2D v,Point2D w){
            adj[number.get(v)].add(w);
        }
        public Iterable<Point2D> adj(Point2D v){
            return adj[number.get(v)];
        }
    
    static class DigraphDFS{
        private boolean[] marked;
        public DigraphDFS (CriticalDis G,Point2D S){
            marked = new boolean[G.V.length];
            dfs(G,S);
        }
        private void dfs(CriticalDis G,Point2D v){
            marked[number.get(v)] = true;
            //System.out.println(v.x()+"" ""+v.y());
            for(Point2D w : G.adj[number.get(v)])
                if(!marked[number.get(w)])dfs(G,w);
        }
        public boolean visited(Point2D v){
            return marked[number.get(v)];
        }}
    
        
    
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        if(N<2){System.out.println(""0"");return;}
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()) S = A[i];
            if(a+b>T.x()+T.y()) T = A[i];            
        }
        CriticalDis digraph = new CriticalDis(A);  
        MinPQ<Double> minpq = new MinPQ<Double>();
        BinarySearchST<Double,Point2D[]> relation = new BinarySearchST<Double,Point2D[]>();   
        for(int i = 0;i < A.length;i++){
            for(int j = i + 1;j < A.length;j++){
                if(A[i].x()<A[j].x() && A[i].y()<A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    Point2D[] B = new Point2D[2];
                    B[0] = A[i];
                    B[1] = A[j]; 
                    //System.out.println(B[0]+"" ""+B[1]);
                    relation.put(d,B);
                }
                else if(A[i].x()>A[j].x() && A[i].y()>A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    Point2D[] B = new Point2D[2];
                    B[0] = A[j];
                    B[1] = A[i];      
                    //System.out.println(B[0]+"" ""+B[1]);
                    relation.put(d,B);
                    
                }
            }           
        }
        while(!minpq.isEmpty()){
            double d = minpq.delMin();
            Point2D[] C = relation.get(d);
            //System.out.println(C[0]+"" to ""+C[1]);
            digraph.addEdge(C[0], C[1]);
            DigraphDFS find = new DigraphDFS(digraph,S);
            if(find.visited(T)){
                System.out.printf(""%1.3f\n"", d);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@f06aacca9a8e3f60415422933b1b991d@"
"r04631004","10","0.169","248272","@e1048439744906e4681d30e70e96fa0b@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int pointnum = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[pointnum];
            int idx = 0;
            Point2D source;
            Point2D target;
            double min = 100.0;
            double max = -1.0;
            int minidx = 0;
            int maxidx = 0;
            for (String in = br.readLine(); in != null; in = br.readLine()) {
                String[] temp = in.split("" "");
                double[] coord = new double[2];
                coord[0] = Double.parseDouble(temp[0]);
                coord[1] = Double.parseDouble(temp[1]);
                double count = coord[0] + coord[1];
                points[idx] = new Point2D(coord[0], coord[1]);
                if (count > max) {
                    max = count;
                    target = points[idx];
                    maxidx = idx;
                } 
                if (count < min) {
                    min = count;
                    source = points[idx];
                    minidx = idx;
                }
                idx++;
            }
            MinPQ minpq = new MinPQ();
            for (int i = 0; i < pointnum; i++) { //將所有edge存放到minpq
                for (int j = i + 1; j < pointnum; j++) {
                    Edge temp = new Edge(points[i], points[j], i, j);
                    minpq.insert(temp);
                }
            }
            int minpqsize = minpq.size();
            Digraph digraph = new Digraph(pointnum);
            double d = 0.0;
            for (int i = 0; i < minpqsize; i++) {
                Edge temp = (Edge) (minpq.delMin());
                if (temp.point1.x() > temp.point2.x() && temp.point1.y() > temp.point2.y()) {  //將新增的edge加入至graph
                    digraph.addEdge(temp.idx1, temp.idx2);        
                } else if (temp.point2.x() > temp.point1.x() && temp.point2.y() > temp.point1.y()) {
                    digraph.addEdge(temp.idx2, temp.idx1);
                }
                DirectedDFS dfs = new DirectedDFS(digraph, maxidx);
                if (dfs.marked(minidx) == true) {
                    d=temp.distance;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }

    private static class Edge implements Comparable<Edge> {

        public Point2D point1;
        public Point2D point2;
        public int idx1;
        public int idx2;
        public double distance;

        public Edge(Point2D point1, Point2D point2, int idx1, int idx2) {
            this.point1 = point1;
            this.point2 = point2;
            this.idx1 = idx1;
            this.idx2 = idx2;
            this.distance = Math.sqrt(Math.pow(point1.x() - point2.x(), 2) + Math.pow(point1.y() - point2.y(), 2));
        }

        public int compareTo(Edge that) {
            if (this.distance - that.distance > 0) {
                return 1;
            } else if (this.distance - that.distance < 0) {
                return -1;
            }
            return 0;
        }
    }

}

@e1048439744906e4681d30e70e96fa0b@"
"b03611033","9","1.02","126928","@890033b9f1ef5fc29dd38b77c738bb55@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception {
//        long time1=System.currentTimeMillis();
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;
            
            MinPQ<Double> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    dis.insert(points[i].distanceTo(points[m]));
                    m--;
                }
            }

            double d;
            Digraph G = new Digraph(N);
            double temp=0;

            while (true) {
                d = dis.delMin();
                for (int i = 0; i < N; i++) {
                    DirectedDFS dfs = new DirectedDFS(G, i);
                    for (int j = i + 1; j < N; j++) {
                        if(!dfs.marked(j)){
                            double dis2=points[i].distanceTo(points[j]);
                        if ( dis2>=temp && dis2<= d) {
                            if (points[i].x() < points[j].x()){
                                if (points[i].y()< points[j].y()){
                                    G.addEdge(i, j);
                                }
                            } else if(points[i].x() > points[j].x()) {
                                if (points[i].y()> points[j].y()){
                                    G.addEdge(j, i);
                                }
                            }
                        }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
                temp=d;
            }

            System.out.printf(""%1.3f\n"", d);
//            long time2=System.currentTimeMillis();
//            StdOut.println(time2-time1);
        }

    }
}

@890033b9f1ef5fc29dd38b77c738bb55@"
"b03106003","10","0.118","220080","@dc892f0aeed34a5e6fe2fe5784bd01e5@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */

class Point implements Comparable<Point>{
    private double x;
    private double y;
    double d;
    
    double getx(){return this.x;}
    double gety(){return this.y;}
    public Point(){}
    
    public Point(double x, double y) {
            if (Double.isInfinite(x) || Double.isInfinite(y))
                throw new IllegalArgumentException(""Coordinates must be finite"");
            if (Double.isNaN(x) || Double.isNaN(y))
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            if (x == 0.0) x = 0.0;  // convert -0.0 to +0.0
            if (y == 0.0) y = 0.0;  // convert -0.0 to +0.0
            this.x = x;
            this.y = y;
            this.d = x+y;
        }
    
    public double distanceTo(Point that) {
        double dx = this.x - that.x;
        double dy = this.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    }
    
    static double distance(Point ori, Point that){
        double dx = ori.x - that.x;
        double dy = ori.y - that.y;
        return Math.sqrt(dx*dx + dy*dy);
    
    }

    @Override
    public int compareTo(Point o) {
        if (this.d < o.d) return -1;
            if (this.d > o.d) return +1;
        return 0;
    }

}

class Pair implements Comparator<Pair> , Comparable<Pair>{
    Point a;
    Point b;
    int indexa;
    int indexb;
    double d;
    
    Pair(Point a, Point b){
        this.a = a;
        this.b = b;
        d = a.distanceTo(b);
    }
    Pair(int indexa, int indexb, Point a, Point b){
        this.indexa = indexa;
        this.indexb = indexb;
        this.a = a;
        this.b = b;
        d = a.distanceTo(b);
    }

    @Override
    public int compare(Pair p, Pair q) {
        if (p.d < q.d) return -1;
            if (p.d > q.d) return +1;
        return 0;
    }

    @Override
    public int compareTo(Pair q) {
        if (this.d < q.d) return -1;
            if (this.d > q.d) return +1;
        return 0;
    }
}

public class CriticalDis {
    public static void main(String[] args) throws IOException {
    
    try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int N = Integer.parseInt(br.readLine());
            double x;
            double y;
            double dis;
            Point points[] = new Point[N];
            MinPQ<Pair> alldis = new MinPQ<Pair>();
            Digraph graph = new Digraph(N);
            int keycount = N;
            Pair pair;
            for(int i = 0 ; i< N ; i++) {
                String in = br.readLine();
                String[] data = in.split(""\\s+"");
                x = Double.parseDouble(data[0]);
                y = Double.parseDouble(data[1]);
                Point point = new Point(x,y);
                points[i] = point;
            }
            Arrays.sort(points);
            for(int i = 0 ; i< N ; i++) {
                for(int j = 0 ; j < i ; j++){
                    dis = points[i].distanceTo(points[j]);
                    if(points[i].getx()>points[j].getx()&&points[i].gety()>points[j].gety()){
                        pair = new Pair(j,i,points[j],points[i]);
                        alldis.insert(pair);
                    }else if(points[i].getx()<points[j].getx()&&points[i].gety()<points[j].gety()){
                        pair = new Pair(i,j,points[i],points[j]);
                        alldis.insert(pair);
                    }
                }
            }
            DepthFirstDirectedPaths dfs;
            while(alldis.size() != 0){
                pair = alldis.min();
                //System.out.printf(""%1.3f\n"",pair.d);
                graph.addEdge(pair.indexa, pair.indexb);
                dfs = new DepthFirstDirectedPaths(graph,0);
                if(dfs.hasPathTo(N-1)){
                    System.out.printf(""%1.3f\n"",pair.d);
                    break;
                }
                alldis.delMin();
            }
            //System.out.printf(""%1.3f\n"",pair.d);
        
    }
    }
}

@dc892f0aeed34a5e6fe2fe5784bd01e5@"
"b03611033","10","0.137","241936","@9bf0647465e7687c5d4bda96384c3882@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis implements Comparable<CriticalDis> {
    public int in1;
    public int in2;
    public double distance; 
    
    public CriticalDis(int a,int b,double c){
        in1=a;
        in2=b;
        distance=c;    
    }
    
    public int compareTo(CriticalDis that) {
        if (this.distance < that.distance) {
                return -1;
            } else if (this.distance > that.distance) {
                return 1;
            } else {
                return 0;
            }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            double min = 100;
            double max = 0;
            int minid = 0;
            int maxid = 0;            
                       
            MinPQ<CriticalDis> dis = new MinPQ<>();

            for (int i = 0; i < N; i++) {
                datacut = br.readLine().split("" "");

                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                if (x + y < min) {
                    minid = i;
                    min = x + y;
                }
                if (x + y > max) {
                    maxid = i;
                    max = x + y;
                }
                
                int m = i - 1;
                while (m >= 0) {
                    double ddd=points[i].distanceTo(points[m]);
                    dis.insert(new CriticalDis(m,i,ddd));
                    m--;
                }
            }
            double d;
            Digraph G = new Digraph(N);   
            CriticalDis run;
            
            while(true){
                run = dis.delMin();
                int i = run.in1;
                int j = run.in2;
                if (points[i].x() < points[j].x()) {
                    if (points[i].y() < points[j].y()) {
                        G.addEdge(i, j);
                    }
                } else if (points[i].x() > points[j].x()) {
                    if (points[i].y() > points[j].y()) {
                        G.addEdge(j, i);
                    }
                }
                
                DirectedDFS dfs = new DirectedDFS(G, minid);
                if (dfs.marked(maxid)) break;
            }

            d=run.distance;
            System.out.printf(""%1.3f\n"", d);
        }

    }
}

@9bf0647465e7687c5d4bda96384c3882@"
"r04546014","0","1.02","126928","@8961e0c9c0843100f75f32c014461aa1@import java.io.BufferedReader;
import java.io.FileReader;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.MinPQ;
import java.util.Comparator;
import edu.princeton.cs.algs4.DirectedDFS;

/**
 *
 * @author Jayden
 */
public class CriticalDis {
    public static void main(String[] args) throws Exception{
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
            int count=Integer.valueOf(br.readLine());
            Point2D[] point=new Point2D[count];
            String[] a=new String[2];
            double x,y;
            double max=Double.MIN_VALUE;
            double min=Double.MAX_VALUE;
            int s=0,t=0;
            for(int i=0;i<count;i++){
                a=br.readLine().split("" "");
                x=Double.valueOf(a[0]);
                y=Double.valueOf(a[1]);
                point[i]=new Point2D(x,y);
                if(x+y>max){
                    max=x+y;
                    t=i;
                }
                if(x+y<min) {
                    min=x+y;
                    s=i;
                }
            }            
            MinPQ<Distance> pq=new MinPQ();
            for(int i=0;i<count;i++){
                for(int j=0;j<count;j++){
                    if(point[i].x()<point[j].x()&&point[i].y()<point[j].y()){
                        pq.insert(new Distance(i,j,point[i].distanceTo(point[j])));
                    }
                }
            }
            Digraph D=new Digraph(count);
            DirectedDFS DD;
            Distance minSoFar;
            for(int i=0;i<pq.size();i++){
                minSoFar=pq.delMin();
                D.addEdge(minSoFar.getFrom(),minSoFar.getTo());
                DD=new DirectedDFS(D,s);
                if(DD.marked(t)){
                    System.out.printf(""%1.3f\n"", minSoFar.getDistance());
                    break;
                }
            }
        }
    }
}

class Distance implements Comparable<Distance>{
    private int from;
    private int to;
    private double dis;
    public Distance(int f,int t,double d){
        from=f;
        to=t;
        dis=d;
    }
    
    public int compareTo(Distance that){
        if(this.dis>that.dis) return 1;
        else if(this.dis<that.dis) return -1;
        return 0;
    }
    
    public int getFrom(){
        return from;
    }
    
    public int getTo(){
        return to;
    }
    
    public double getDistance(){
        return dis;
    }
         
}

@8961e0c9c0843100f75f32c014461aa1@"
"r04546014","8","1.15","181456","@d3db7667c9897d86040b4b266211c235@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;

/**
 *
 * @author Jayden
 */
public class CriticalDis {
    public static void main(String[] args) throws Exception{
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
            int count=Integer.valueOf(br.readLine());
            Point2D[] point=new Point2D[count];
            String[] a=new String[2];
            double x,y;
            double max=Double.MIN_VALUE;
            double min=Double.MAX_VALUE;
            int s=0,t=0;
            for(int i=0;i<count;i++){
                a=br.readLine().split("" "");
                x=Double.valueOf(a[0]);
                y=Double.valueOf(a[1]);
                point[i]=new Point2D(x,y);
                if(x+y>max){
                    max=x+y;
                    t=i;
                }
                if(x+y<min) {
                    min=x+y;
                    s=i;
                }
            }            
            MinPQ<Distance> pq=new MinPQ();
            for(int i=0;i<count;i++){
                for(int j=0;j<count;j++){
                    if(point[i].x()<point[j].x()&&point[i].y()<point[j].y()){
                        pq.insert(new Distance(i,j,point[i].distanceTo(point[j])));
                    }
                }
            }
            Digraph D=new Digraph(count);
            DirectedDFS DD;
            Distance minSoFar;
            for(int i=0;i<pq.size();i++){
                minSoFar=pq.delMin();
                D.addEdge(minSoFar.getFrom(),minSoFar.getTo());
                DD=new DirectedDFS(D,s);
                if(DD.marked(t)){
                    System.out.printf(""%1.3f\n"", minSoFar.getDistance());
                    break;
                }
            }
        }
    }
}

class Distance implements Comparable<Distance>{
    private int from;
    private int to;
    private double dis;
    public Distance(int f,int t,double d){
        from=f;
        to=t;
        dis=d;
    }
    
    public int compareTo(Distance that){
        if(this.dis>that.dis) return 1;
        else if(this.dis<that.dis) return -1;
        return 0;
    }
    
    public int getFrom(){
        return from;
    }
    
    public int getTo(){
        return to;
    }
    
    public double getDistance(){
        return dis;
    }
         
}

@d3db7667c9897d86040b4b266211c235@"
"r03228006","10","0.118","218848","@2ecc401ea742f07f7650c50fae198bec@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class CriticalDis {
    
    private static class Edge implements Comparable<Edge> {
        private Point2D v;
        private Point2D w;
        private double d;
        private int idv; private int idw;

        public Edge(Point2D v, Point2D w,int idv,int idw) {
            this.v = v;
            this.w = v;
            this.d = v.distanceTo(w);
            this.idv=idv; this.idw=idw;
        }
        
        public void setid(int idv, int idw){
           this.idv = idv;
           this.idw = idw;
        }
        
        public int compareTo(Edge that) {
          if(this.d > that.d){return 1;}
          if(this.d == that.d){return 0;}
          else {return -1;}
    }}
    
        public static void main(String[] args) throws Exception {
        //""input11.0.txt""  args[0]
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String header = br.readLine();
            int size = Integer.parseInt(header);
            Point2D[] points = new Point2D[size];   
            Digraph graph = new Digraph(size);

            int sid=0; int tid=0;
            double sxy; double txy;//source and target ids
            //inititial
            String[] in0 = br.readLine().split(""\\s+"");
         
            points[0] = new Point2D(Double.parseDouble(in0[0]),Double.parseDouble(in0[1]));
            sxy=points[0].x()+points[0].y();txy=sxy;

            for(int i=1;i<size;i++) {
                String[] in = br.readLine().split(""\\s+"");
                points[i] = new Point2D(Double.parseDouble(in[0]),Double.parseDouble(in[1]));
                double temp=points[i].x()+points[i].y();
                if (temp<sxy){sxy=temp;sid=i;}
                else if (temp>txy){txy=temp;tid=i;}
            }
            //System.out.println(sid);
            //System.out.println(tid);
            MinPQ<Edge> edges = new MinPQ();
            for(int i =0;i<size;i++){//the last one don't be
                for(int j = 0;j<size;j++){
                  if(i!=j){
                  if(points[i].x()<points[j].x()&&points[i].y()<points[j].y()) {
                      Edge ed = new Edge(points[i],points[j],i,j);
                      edges.insert(ed);
                      //graph.addEdge(i,j);}
                }} 
            }}
            while(true){
              
              Edge dd = edges.min();
              graph.addEdge(dd.idv,dd.idw);
              DirectedDFS DFS=new DirectedDFS(graph,sid);
              //System.out.println(dd.d); 
              //System.out.println(dd.idv);
              if (DFS.marked(tid)){
              break;}
              edges.delMin();
            }
            System.out.printf(""%1.3f\n"", edges.min().d);
                      
    }
}}

@2ecc401ea742f07f7650c50fae198bec@"
"r04546014","8","1.17","186432","@7ae08f4c91144a700db320c57596698b@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;

/**
 *
 * @author Jayden
 */
public class CriticalDis {
    public static void main(String[] args) throws Exception{//讀檔
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
            int count=Integer.valueOf(br.readLine());
            Point2D[] point=new Point2D[count];//存所有的點
            String[] a=new String[2];//讀檔用的
            double x,y;
            double max=Double.MIN_VALUE;//用來比較出所有點的x+y最大值
            double min=Double.MAX_VALUE;//用來比較出所有點的x+y最小值
            int s=0,t=0;//s=start,t=target
            for(int i=0;i<count;i++){//讀取所有點
                a=br.readLine().split("" "");
                x=Double.valueOf(a[0]);
                y=Double.valueOf(a[1]);
                point[i]=new Point2D(x,y);
                if(x+y>max){//找出終點
                    max=x+y;
                    t=i;
                }
                if(x+y<min) {//找出起點
                    min=x+y;
                    s=i;
                }
            }            
            MinPQ<Distance> pq=new MinPQ();
            for(int i=0;i<count;i++){//計算所有可能點的距離
                for(int j=0;j<count;j++){
                    if(point[i].x()<point[j].x()&&point[i].y()<point[j].y()){
                        pq.insert(new Distance(i,j,point[i].distanceTo(point[j])));
                    }
                }
            }
            Digraph D=new Digraph(count);//這是用來建構各點間連線的class
            DirectedDFS DD;//這是用來檢驗某點透過directed first是否可以找到另一點
            Distance minSoFar;//紀錄目前最小的距離是哪一個
            for(int i=0;i<pq.size();i++){//依序從最小距離開始找，直到s可以連到t就停
                minSoFar=pq.delMin();
                D.addEdge(minSoFar.getFrom(),minSoFar.getTo());
                DD=new DirectedDFS(D,D.adj(s));
                if(DD.marked(t)){//如果目前這個class是可以從s連到t就可以輸出了
                    System.out.printf(""%1.3f\n"", minSoFar.getDistance());
                    break;
                }
            }
        }
    }
}

class Distance implements Comparable<Distance>{//inner class，將每一段距離都設為一個class
    private int from;//起始點的編號
    private int to;//到達點的編號
    private double dis;//距離
    public Distance(int f,int t,double d){
        from=f;
        to=t;
        dis=d;
    }
    
    public int compareTo(Distance that){
        if(this.dis>that.dis) return 1;
        else if(this.dis<that.dis) return -1;
        return 0;
    }
    
    public int getFrom(){
        return from;
    }
    
    public int getTo(){
        return to;
    }
    
    public double getDistance(){
        return dis;
    }
}

@7ae08f4c91144a700db320c57596698b@"
"r03945012","9","1","113472","@b0e7693d46a1523b2c40ca2bf021ad72@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (num >= 2 & points[source].x() < points[target].x()){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() <= points[j].x()){
                                if (points[i].y() <= points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@b0e7693d46a1523b2c40ca2bf021ad72@"
"r03945012","9","1.02","117824","@5ee4b2ea78bb2ff99ed0e5a92c86b030@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (num >= 2 & points[source].x() < points[target].x() & points[source].y() < points[target].y()){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() <= points[j].x()){
                                if (points[i].y() <= points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@5ee4b2ea78bb2ff99ed0e5a92c86b030@"
"r03945012","9","1.02","113808","@25d8ad261738c893121418f0886d0878@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = i+1; j < num; j++){
                    pq.insert(points[i].distanceTo(points[j]));
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (points[source].y() <= points[target].y() && points[source].x() <= points[target].x() && num >= 2){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() <= points[j].x()){
                                if (points[i].y() <= points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@25d8ad261738c893121418f0886d0878@"
"r04921028","0","0","0","@b8536a3669811d504febd128fe038f41@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class CriticalDis {
        public static class cedge implements Comparable<cedge>{
        int s;
        int t;
        double dis;
        
        public cedge(int s, int t, double dis){
            this.s = s;
            this.t = t;
            this.dis = dis;
            return;
        }
        public int compareTo(cedge that) {            
            if(this.dis > that.dis) return +1;
            else if(this.dis < that.dis)  return -1;
            else return 0;
        }
    }
        
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                      
           String buf0 = br.readLine();
           int n = Integer.valueOf(buf0);
           
           Point2D[] points = new Point2D[n];
           Point2D summax = new Point2D(0,0);
           Point2D summin = new Point2D(1,1);
           
           Map<Point2D,Integer> table = new HashMap<Point2D,Integer>();
           Digraph graph = new Digraph (n);
           
           MinPQ<cedge> edges = new MinPQ<>();
           
           int count = 0;
           
           while(br.ready()){
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                //===============================
                StdDraw.setPenRadius(0.01);
                StdDraw.setPenColor(StdDraw.BLUE);
                StdDraw.point(x,y);
                //===============================
                points[count] = new Point2D(x, y);
                if( (points[count].x()+points[count].y()) > (summax.x()+summax.y() ) )  
                    summax = points[count];
                
                if( (points[count].x()+points[count].y()) < (summin.x()+summin.y() ) )   
                    summin = points[count];
                
                table.put(points[count],count);
                count++;
           }
            //===============================
                StdDraw.setPenRadius(0.01);
                StdDraw.setPenColor(StdDraw.RED);
                StdDraw.point(summax.x(),summax.y());
                StdDraw.point(summin.x(),summin.y());
           //===============================
           for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                   if(points[i].x()>points[j].x()&&points[i].y()>points[j].y()&&points[i].distanceTo(points[j])!=0){
//                   tempE =new EDGEs(j,i,points[i].distanceTo(points[j]));                   
                    edges.insert(new cedge(j,i,points[i].distanceTo(points[j])));
//                    StdDraw.setPenRadius(0.001);
//                    StdDraw.setPenColor(StdDraw.GREEN);
//                    StdDraw.line(points[i].x(),points[i].y(),points[j].x(),points[j].y());
                   }
                } 
           }
           boolean connect = false;
           cedge hold = new cedge(0,0,0);
            
            while(!connect&&!edges.isEmpty()){
                
                hold = edges.delMin();
                
                graph.addEdge(hold.s, hold.t);
                
                DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(graph,table.get(summin));
                connect = dfs.hasPathTo(table.get(summax));
                StdDraw.setPenRadius(0.001);
                StdDraw.setPenColor(StdDraw.GREEN);
                StdDraw.line(points[hold.s].x(),points[hold.s].y(),points[hold.t].x(),points[hold.t].y());
//                if (dfs.hasPathTo(table.get(summax))) {
//                    StdOut.printf(""%d to %d:  "", graph, table.get(summax));
//                    for (int x : dfs.pathTo(table.get(summax))) {
//                        if (x == s) StdOut.print(x);
//                        else        StdOut.print(""-"" + x);
//                    }
//                    StdOut.println();
//                }
            }
               System.out.printf(""%1.3f\n"",hold.dis);
       }
     }
}

@b8536a3669811d504febd128fe038f41@"
"r04921028","10","0.123","201728","@f6dfe19c169eceeb3d88c608f4438506@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class CriticalDis {
        public static class cedge implements Comparable<cedge>{
        int s;
        int t;
        double dis;
        
        public cedge(int s, int t, double dis){
            this.s = s;
            this.t = t;
            this.dis = dis;
            return;
        }
        public int compareTo(cedge that) {            
            if(this.dis > that.dis) return +1;
            else if(this.dis < that.dis)  return -1;
            else return 0;
        }
    }
        
    public static void main(String[] args) throws Exception{
       try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                      
           String buf0 = br.readLine();
           int n = Integer.valueOf(buf0);
           
           Point2D[] points = new Point2D[n];
           Point2D summax = new Point2D(0,0);
           Point2D summin = new Point2D(1,1);
           
           Map<Point2D,Integer> table = new HashMap<Point2D,Integer>();
           Digraph graph = new Digraph (n);
           
           MinPQ<cedge> edges = new MinPQ<>();
           
           int count = 0;
           
           while(br.ready()){
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
                points[count] = new Point2D(x, y);
                if( (points[count].x()+points[count].y()) > (summax.x()+summax.y() ) )  
                    summax = points[count];
                
                if( (points[count].x()+points[count].y()) < (summin.x()+summin.y() ) )   
                    summin = points[count];
                
                table.put(points[count],count);
                count++;
           }
//            //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.RED);
//                StdDraw.point(summax.x(),summax.y());
//                StdDraw.point(summin.x(),summin.y());
//           //===============================
           for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                   if(points[i].x()>points[j].x()&&points[i].y()>points[j].y()&&points[i].distanceTo(points[j])!=0){
//                   tempE =new EDGEs(j,i,points[i].distanceTo(points[j]));                   
                    edges.insert(new cedge(j,i,points[i].distanceTo(points[j])));
//                    StdDraw.setPenRadius(0.001);
//                    StdDraw.setPenColor(StdDraw.GREEN);
//                    StdDraw.line(points[i].x(),points[i].y(),points[j].x(),points[j].y());
                   }
                } 
           }
           boolean connect = false;
           cedge hold = new cedge(0,0,0);
            
            while(!connect&&!edges.isEmpty()){
                
                hold = edges.delMin();
                
                graph.addEdge(hold.s, hold.t);
                
                DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(graph,table.get(summin));
                connect = dfs.hasPathTo(table.get(summax));
//                StdDraw.setPenRadius(0.001);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(points[hold.s].x(),points[hold.s].y(),points[hold.t].x(),points[hold.t].y());
//                if (dfs.hasPathTo(table.get(summax))) {
//                    StdOut.printf(""%d to %d:  "", graph, table.get(summax));
//                    for (int x : dfs.pathTo(table.get(summax))) {
//                        if (x == s) StdOut.print(x);
//                        else        StdOut.print(""-"" + x);
//                    }
//                    StdOut.println();
//                }
            }
               System.out.printf(""%1.3f\n"",hold.dis);
       }
     }
}

@f6dfe19c169eceeb3d88c608f4438506@"
"r03945012","9","1.01","116400","@8eb9dc7eb920e2b9d96ce0ce6fe3a06e@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() <= points[j].x()){
                        if (points[i].y() <= points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (points[source].y() <= points[target].y() && points[source].x() <= points[target].x() && num >= 2){
                while(loop){
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() <= points[j].x()){
                                if (points[i].y() <= points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@8eb9dc7eb920e2b9d96ce0ce6fe3a06e@"
"b99611017","0","0","0","@ff03cb5c06220a463fb8fde37a9ed7c0@
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] header = br.readLine().split("" "");
            int num = Integer.parseInt(header[0]);
            Point2D[] pts = new Point2D[num];

            for (int i = 0; i < num; i++) {
                String[] test1 = br.readLine().split("" "");
                double x = Double.parseDouble(test1[0]);
                double y = Double.parseDouble(test1[1]);
                pts[i] = new Point2D(x, y);

            }
            //find_s
            Point2D s = pts[0];
            int sl = 0;
            for (int i = 1; i < num; i++) {
                if (s.x() + s.y() > pts[i].x() + pts[i].y()) {
                    s = pts[i];
                    sl = i;
                }
            }
            //find_t
            Point2D t = pts[0];
            int tl = 0;
            for (int i = 1; i < num; i++) {
                if (t.x() + t.y() <= pts[i].x() + pts[i].y()) {
                    t = pts[i];
                    tl = i;
                }
            }

            Digraph excute = new Digraph(num);
            double[] dist = new double[num * (num - 1)];
            int a = 0;
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    dist[a] = pts[i].distanceTo(pts[j]);
                    a++;
                }
            }
            double token = 0;
            //sort every distance value
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    if (dist[i] >= dist[j]) {
                        token = dist[i];
                        dist[i] = dist[j];
                        dist[j] = token;
                    }
                }
            }
            int k = 0;
            while (k<num) {
                for (int i = 0; i < num-1; i++) {
                    for (int j =1; j < num; j++) {
                        if ((pts[i].x() < pts[j].x() && pts[i].y() < pts[j].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(i, j);
                        }
                        if ((pts[j].x() < pts[i].x() && pts[j].y() <pts[i].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(j, i);
                        }
                    }
                }
                
                
                DirectedDFS ans=new DirectedDFS(excute,sl);
                if(ans.marked(tl))
                {
                    break;
                }
                k++;
                
            }
            System.out.printf(""%1.3f\n"", dist[k]);
        }

    }

}

@ff03cb5c06220a463fb8fde37a9ed7c0@"
"b99611017","0","1.27","173408","@241c1578dbb8de6116ad798ff0ca2be3@

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] header = br.readLine().split("" "");
            int num = Integer.parseInt(header[0]);
            Point2D[] pts = new Point2D[num];

            for (int i = 0; i < num; i++) {
                String[] test1 = br.readLine().split("" "");
                double x = Double.parseDouble(test1[0]);
                double y = Double.parseDouble(test1[1]);
                pts[i] = new Point2D(x, y);

            }
            //find_s
            Point2D s = pts[0];
            int sl = 0;
            for (int i = 1; i < num; i++) {
                if (s.x() + s.y() > pts[i].x() + pts[i].y()) {
                    s = pts[i];
                    sl = i;
                }
            }
            //find_t
            Point2D t = pts[0];
            int tl = 0;
            for (int i = 1; i < num; i++) {
                if (t.x() + t.y() <= pts[i].x() + pts[i].y()) {
                    t = pts[i];
                    tl = i;
                }
            }

            Digraph excute = new Digraph(num);
            double[] dist = new double[num * (num - 1)];
            int a = 0;
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    dist[a] = pts[i].distanceTo(pts[j]);
                    a++;
                }
            }
            double token = 0;
            //sort every distance value
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    if (dist[i] >= dist[j]) {
                        token = dist[i];
                        dist[i] = dist[j];
                        dist[j] = token;
                    }
                }
            }
            int k = 0;
            while (k<num) {
                for (int i = 0; i < num-1; i++) {
                    for (int j =1; j < num; j++) {
                        if ((pts[i].x() < pts[j].x() && pts[i].y() < pts[j].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(i, j);
                        }
                        if ((pts[j].x() < pts[i].x() && pts[j].y() <pts[i].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(j, i);
                        }
                    }
                }
                
                
                DirectedDFS ans=new DirectedDFS(excute,sl);
                if(ans.marked(tl))
                {
                    break;
                }
                k++;
                
            }
            System.out.printf(""%1.3f\n"", dist[k]);
        }

    }

}

@241c1578dbb8de6116ad798ff0ca2be3@"
"b99611017","9","1.15","114080","@b640dc2d3e7f226bff1efa9f84434950@

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] header = br.readLine().split("" "");
            int num = Integer.parseInt(header[0]);
            Point2D[] pts = new Point2D[num];

            for (int i = 0; i < num; i++) {
                String[] test1 = br.readLine().split("" "");
                double x = Double.parseDouble(test1[0]);
                double y = Double.parseDouble(test1[1]);
                pts[i] = new Point2D(x, y);

            }
            //find_s
            Point2D s = pts[0];
            int sl = 0;
            for (int i = 1; i < num; i++) {
                if (s.x() + s.y() > pts[i].x() + pts[i].y()) {
                    s = pts[i];
                    sl = i;
                }
            }
            //find_t
            Point2D t = pts[0];
            int tl = 0;
            for (int i = 1; i < num; i++) {
                if (t.x() + t.y() <= pts[i].x() + pts[i].y()) {
                    t = pts[i];
                    tl = i;
                }
            }

            Digraph excute = new Digraph(num);
            double[] dist = new double[num * (num - 1)];
            int a = 0;
            for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    dist[a] = pts[i].distanceTo(pts[j]);
                    a++;
                }
            }
            double token = 0;
            //sort every distance value
            for (int i = 0; i < dist.length; i++) {
                for (int j = i + 1; j < dist.length; j++) {
                    if (dist[i] >= dist[j]) {
                        token = dist[i];
                        dist[i] = dist[j];
                        dist[j] = token;
                    }
                }
            }
            int k = 0;
            while (k<dist.length) {
                for (int i = 0; i < num-1; i++) {
                    for (int j =1; j < num; j++) {
                        if ((pts[i].x() < pts[j].x() && pts[i].y() < pts[j].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(i, j);
                        }
                        if ((pts[j].x() < pts[i].x() && pts[j].y() <pts[i].y()) && pts[i].distanceTo(pts[j]) < dist[k]) {
                            excute.addEdge(j, i);
                        }
                    }
                }
                
                
                DirectedDFS ans=new DirectedDFS(excute,sl);
                if(ans.marked(tl))
                {
                    break;
                }
                k++;
                
            }
            
           
            System.out.printf(""%1.3f\n"", dist[k-1]);
            
        }

    }

}

@b640dc2d3e7f226bff1efa9f84434950@"
"b01502105","10","0.118","212048","@653fb3a623b7eb2e1d2a283ac5915674@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    
    public static class Pair implements Comparable<Pair> {
        
        private double distance;
        private int index_a;
        private int index_b;
        private Point2D first;
        private Point2D second;
        
        public Pair (int index_a, Point2D a, int index_b, Point2D b){
            this.first = a;
            this.second = b;
            this.index_a = index_a;
            this.index_b = index_b;
            this.distance = a.distanceTo(b);
        }
        
        public int compareTo(Pair that){
            if(this.distance > that.distance) return +1;
            if(this.distance < that.distance) return -1;
            else return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        
//        Stopwatch stopwatch = new Stopwatch();

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("","");
                everything.append(line);
            }
            String[] data = everything.toString().split("","");
            int num = Integer.parseInt(data[0]);
            Point2D[] points = new Point2D[num];
            
//            StdDraw.setCanvasSize(600, 600);
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.BLACK);
            
            for(int i=0;i<num;i++){
                String[] given = data[i+1].split("" "");
                Point2D point = new Point2D(Double.parseDouble(given[0]),Double.parseDouble(given[1]));
                points[i] = point;
//                System.out.println(point.toString());
//                point.draw();
//                StdDraw.text(point.x(), point.y()-0.02, Integer.toString(i));
            }
            
            MinPQ<Pair> pq = new MinPQ<Pair>();
            Digraph G = new Digraph(num);
            Point2D source = new Point2D(1.0,1.0);
            Point2D target = new Point2D(0.0,0.0);
            int source_index = 0;
            int target_index = 0;
            
//            StdDraw.setPenRadius(0.001);
//            StdDraw.setPenColor(StdDraw.GRAY);
            
            for(int i=0;i<num; i++){
                for(int j=i+1;j<num;j++){
                    if( points[i].x()<points[j].x() && points[i].y()<points[j].y() ){
                        Pair pair = new Pair(i,points[i],j,points[j]);
                        pq.insert(pair);
                        
//                        points[i].drawTo(points[j]);
                    }
                    else if( points[i].x()>points[j].x() && points[i].y()> points[j].y()){
                        Pair pair = new Pair(j,points[j],i,points[i]);
                        pq.insert(pair);
                        
//                        points[j].drawTo(points[i]);
                    }
                }
                
                double pos = points[i].x() + points[i].y();
                if( pos < (source.x()+source.y()) ){
                    source = points[i];
                    source_index = i;
                }
                if( pos > (target.x()+target.y())){
                    target = points[i];
                    target_index = i;
                }
            }
//            StdDraw.setPenRadius(0.03);
//            StdDraw.setPenColor(StdDraw.BLUE);
//            source.draw();
//            System.out.println(""Source_index = "" + source_index + "" , "" + ""Source = "" + source);
//            StdDraw.setPenColor(StdDraw.RED);
//            target.draw();
//            System.out.println(""Target_index = "" + target_index + "" , "" + ""Target = "" + target);
            
//            StdDraw.setPenRadius(0.005);
//            StdDraw.setPenColor(StdDraw.BOOK_RED);
            
            double d = 0.0;

            boolean target_marked = false;
            
            do {
                Pair temp_pair = pq.delMin();
                d = temp_pair.distance;
                G.addEdge(temp_pair.index_a, temp_pair.index_b);  // pointing from points[inde_a] to points[inde_b]
                DirectedDFS dfs = new DirectedDFS( G, source_index );
                target_marked = dfs.marked(target_index);
                
//                temp_pair.first.drawTo(temp_pair.second);
//                System.out.println(""break point"");
            }
            while(!target_marked);
            System.out.printf(""%1.3f\n"" , d );
            
        }
//        double time = stopwatch.elapsedTime();
//        System.out.printf(""run time = "" + time + ""(s)\n"");
    }
    
}

@653fb3a623b7eb2e1d2a283ac5915674@"
"r04945009","10","0.12","180848","@992a2d32ea7a33d0c6513439f6918f80@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class CriticalDis {
    
    private static class Event implements Comparable<Event> {
        private final double distance;         // time that event is scheduled to occur
        private final int a, b;       // particles involved in event, possibly null
                
        // create a new event to occur at time t involving a and b
        public Event(double d, int a, int b) {
            this.distance = d;
            this.a    = a;
            this.b    = b;
        }

        // compare times when two events will occur
        public int compareTo(Event that) {
            if      (this.distance < that.distance) return -1;
            else if (this.distance > that.distance) return +1;
            else                            return  0;
        }
   
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // the array of points
            Point2D[] points;
            int N = Integer.parseInt(br.readLine());
            points = new Point2D[N];
            double x=0 ,y=0;
            
            for(int i = 0; i < N; i++) {
                String[] inpoints = br.readLine().split("" "");
                x = Double.parseDouble(inpoints[0]);
                y = Double.parseDouble(inpoints[1]);
                points[i] = new Point2D(x, y);
            }
            
            Digraph myGraph = new Digraph(N);
            MinPQ myEdge = new MinPQ<Event>();
            double d=0;
            
            //find s & t
            int s=0,t=0;
            double max=0, min=10;
            for (int i=0; i<N; i++) {
                if (points[i].x() + points[i].y() < min)  {min=points[i].x() + points[i].y(); s=i;}
                if (points[i].x() + points[i].y() > max)  {max=points[i].x() + points[i].y(); t=i;}
            }
            
            //insert distance to myEdge
            for (int i=0; i<N; i++) {
                for (int j=i; j<N; j++){
                    if (points[i].x() < points[j].x() && points[i].y() < points[j].y()) myEdge.insert(new Event(points[i].distanceTo(points[j]), i, j));
                    if (points[i].x() > points[j].x() && points[i].y() > points[j].y()) myEdge.insert(new Event(points[i].distanceTo(points[j]), j, i));
                }
            }
            
            while (!myEdge.isEmpty()) {
                Event step = (Event)myEdge.delMin();
                myGraph.addEdge(step.a, step.b);
                DirectedDFS myDFS = new DirectedDFS(myGraph, s);
                if (myDFS.marked(t))    {d=step.distance;   break;} 
            }
            
            System.out.printf(""%1.3f\n"", d);
            
            
        }
    }
    
}

@992a2d32ea7a33d0c6513439f6918f80@"
"r03945012","0","1.09","186832","@ae26c8823d31fe46e631d4c9b81f7523@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
//            if (points[source].y() <= points[target].y() && points[source].x() <= points[target].x() && num >= 2){
//                while(loop){
//                    d = pq.delMin();
//                    Digraph G = new Digraph(num);
//                    for (int i = 0; i < num; i++){
//                        for (int j = 0; j < num; j++){
//                            if (points[i].x() <= points[j].x()){
//                                if (points[i].y() <= points[j].y()){
//                                    if (points[i].distanceTo(points[j]) <= d){
//                                        G.addEdge(i, j);
//                                    }
//                                }
//                            }
//                        }
//                    }
//                    DirectedDFS dfs = new DirectedDFS(G, source);
//                    if (dfs.marked(target))
//                        loop = false;
//                }
//            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@ae26c8823d31fe46e631d4c9b81f7523@"
"r03945012","9","1","109936","@dfb775cde5e78bd32b94c86e4b88965c@
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            if (points[source].y() <= points[target].y() && points[source].x() <= points[target].x() && num >= 2){
                while(loop){
                    if (pq.isEmpty()){
                        break;
                    }
                    d = pq.delMin();
                    Digraph G = new Digraph(num);
                    for (int i = 0; i < num; i++){
                        for (int j = 0; j < num; j++){
                            if (points[i].x() <= points[j].x()){
                                if (points[i].y() <= points[j].y()){
                                    if (points[i].distanceTo(points[j]) <= d){
                                        G.addEdge(i, j);
                                    }
                                }
                            }
                        }
                    }
                    DirectedDFS dfs = new DirectedDFS(G, source);
                    if (dfs.marked(target))
                        loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@dfb775cde5e78bd32b94c86e4b88965c@"
"r04945008","1","0.26","126480","@c08751e0c3c56d02e0e7e4ef4dac1740@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }
//    public Vertex[] delVertex(){
//        
//    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            Digraph G = new Digraph(Integer.parseInt(num));
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Vertex tempsource = points[0];
            Vertex[] initial = points;
            while(true){
                Vertex[] temp = findEdge(initial, tempsource);
                Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                G.addEdge(tempsource.id, temp[0].id);
                pq.insert(tempsource.point.distanceTo(temp[0].point));
                if(pq.size() > 1)
                    pq.delMin();
                DirectedDFS dfs = new DirectedDFS(G, source);
                if(dfs.marked(target))
                    break;
                initial = temp;
                tempsource = temp[0];
            }
            System.out.printf(""%1.3f\n"", pq.min());
        }
    }
}

@c08751e0c3c56d02e0e7e4ef4dac1740@"
"r04945008","4","1","126976","@fa5b70510ce871ba9fb1ff1cf56bebae@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }
//    public Vertex[] delVertex(){
//        
//    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            Digraph G = new Digraph(Integer.parseInt(num));
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Vertex tempsource = points[0];
            Vertex[] initial = points;
            while(true){
                Vertex[] temp = findEdge(initial, tempsource);
                Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                G.addEdge(tempsource.id, temp[0].id);
                pq.insert(tempsource.point.distanceTo(temp[0].point));
                if(pq.size() > 1)
                    pq.delMin();
                DirectedDFS dfs = new DirectedDFS(G, source);
                if(dfs.marked(target))
                    break;
                initial = temp;
                tempsource = temp[0];
            }
            System.out.printf(""%1.3f\n"", pq.min());
        }
    }
}

@fa5b70510ce871ba9fb1ff1cf56bebae@"
"r04945008","4","1.14","125600","@8931bb397f1afdb2bcd3a7df6da754ad@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }
//    public Vertex[] delVertex(){
//        
//    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            Digraph G = new Digraph(Integer.parseInt(num));
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Vertex tempsource = points[0];
            Vertex[] initial = points;
            while(true){
                Vertex[] temp = findEdge(initial, tempsource);
                if(temp.length == 0)
                    break;
                Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                G.addEdge(tempsource.id, temp[0].id);
                pq.insert(tempsource.point.distanceTo(temp[0].point));
                if(pq.size() > 1)
                    pq.delMin();
                DirectedDFS dfs = new DirectedDFS(G, source);
                if(dfs.marked(target))
                    break;
                initial = temp;
                tempsource = temp[0];
            }
            System.out.printf(""%1.3f\n"", pq.min());
        }
    }
}

@8931bb397f1afdb2bcd3a7df6da754ad@"
"r04945022","0","0.26","126480","@baa42a61fd8dc1fb5e84151c3cc266fb@import java.util.Arrays;
import java.util.ArrayList;
/**
 *
 * @author Daniel
 */
public class CriticalPath {

    /**
     * @param args the command line arguments
     */
    //counter for digraph
    
    public static void main(String[] args) {
        In in = new In(args[0]);
		int n_pts = in.readInt();
		Point2D[] pts = new Point2D[n_pts];
		String[] inputs = new String[2];
		for (int i = 0 ; i < n_pts ; i++) {
		inputs = in.readLine().split("" "");
                pts[i] = new Point2D(Double.parseDouble(inputs[0]) , Double.parseDouble(inputs[1]));
                }
        int source = 0;
        int goal = 0;     
        for (int i = 0; i < pts.length; i++) {
            Point2D p = pts[i];
            Point2D s = pts[source];
            Point2D t = pts[goal];
            if (p.x() + p.y() < s.x() + s.y()){ source = i;
            
            }
            if (p.x() + p.y() > t.x() + t.y()) {goal = i;
            
            }
        }
        
        
        // deciding the edges i pointing to j 
        
                
    }
    
}

@baa42a61fd8dc1fb5e84151c3cc266fb@"
"r04945022","0","0","0","@74cde63f34031054c803710898abb358@import java.util.Arrays;
import java.util.ArrayList;
/**
 *
 * @author Daniel
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    //counter for digraph
    static class Discounter implements Comparable<Discounter>{
        double d;
        int i;
        int j;
        public Discounter(double dis, int i , int j){
            this.d = dis;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Discounter o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    
    public static void main(String[] args) {
        In in = new In(args[0]);
		int n_pts = in.readInt();
		Point2D[] pts = new Point2D[n_pts];
		String[] inputs = new String[2];
		for (int i = 0 ; i < n_pts ; i++) {
		inputs = in.readLine().split("" "");
                pts[i] = new Point2D(Double.parseDouble(inputs[0]) , Double.parseDouble(inputs[1]));
                }
        int source = 0;
        int goal = 0;     
        for (int i = 0; i < pts.length; i++) {
            Point2D p = pts[i];
            Point2D s = pts[source];
            Point2D t = pts[goal];
            if (p.x() + p.y() < s.x() + s.y()){ source = i;
            
            }
            if (p.x() + p.y() > t.x() + t.y()) {goal = i;
            
            }
        }
        // deciding the edges a pointing to b
        // finding digraph pointing upright
        ArrayList<Discounter> temp_edges = new ArrayList<Discounter>();
        for (int i = 0; i < pts.length; i++) {
            Point2D a = pts[i];
            for (int j = 0; j < pts.length; j++) {
                Point2D b = pts[j];
                if (a.x() < b.x() && a.y() < b.y()) {
                    temp_edges.add(new Discounter(a.distanceTo(b), i, j));
                }
            }
        }
        
                
    }
    
}

@74cde63f34031054c803710898abb358@"
"r03222054","0","1","126976","@c325ea31f3c7b63ca4aaefecf5a837da@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
*/
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import edu.princeton.cs.algs4.UF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    private int number;
    private Digraph gr;
    private  UF UnionFind;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
    public static class Vertex
    {
        private Point2D point;
        public Point2D getPoint()
        {
            return point;
        }
        private int index;
        public int getIndex()
        {
            return index;
        }
        public Vertex(Point2D pt, int x)
        {
            point = pt;
            index = x;
        }
        public static  Vertex[] vertexArray;
        
    }
    
    
    
    
    public static class Edge
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private Vertex pointOne;
        public Vertex getPointOne()
        {
            return pointOne;
        }
        
        private Vertex pointTwo;
        public Vertex getPointTwo()
        {
            return pointTwo;
        }
        
        public Edge(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
        
        public void set(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edge> 
     {
        public int compare(Edge o1, Edge o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     
    public static class VertexComparator implements Comparator<Vertex> 
     {
        public int compare(Vertex o1, Vertex o2)
        {
            return 1*Double.compare(o1.point.x()+o1.point.y(), o2.point.x()+o2.point.y());
        }
     }
     
     
     
     
     

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        Point2D[] points;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
              Vertex vt = new Vertex(pt,count);
              Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
          ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
          Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Vertex start = list.get(0);
         Vertex end = list.get(count-1);
         
          MinPQ<Edge> edges = new MinPQ<Edge>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = list.get(i).point;
                  Point2D b = list.get(j).point;
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edge(list.get(i), list.get(j)));
              }
          }
           UF UnionFind = new UF(count);
           double distance=2;
       //    System.out.print(start.index+"" ""+ end.index+""\n"");
         while(!UnionFind.connected(start.index, end.index))
                // edges.isEmpty())//!UnionFind.connected(start.index, end.index))
         {
          Edge E1 = edges.delMin();
          Vertex v1 = E1.pointOne;
          Vertex v2 = E1.pointTwo;
          distance = E1.getLength();
           //System.out.print(v1.index+""  ""+v2.index+""\n"");
           //System.out.print(distance+""\n"");
          
           UnionFind.union(v1.index, v2.index);
         }
          
          
          
    //     System.out.print(distance+""\n"");
         System.out.printf(""%1.3f\n"", distance);
      //   System.out.print(UnionFind.connected(start.index, end.index)+""\n"");
       //   System.out.print(Vertex.vertexArray[2].point.distanceTo(Vertex.vertexArray[19].point)+""\n"");
       //   System.out.print(Vertex.vertexArray[14].point.distanceTo(Vertex.vertexArray[2].point)+""\n"");


    }
    
}

@c325ea31f3c7b63ca4aaefecf5a837da@"
"r03222054","0","0","0","@3ae8c335893ec73936b78c788523054c@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
*/
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
//import edu.princeton.cs.algs4.UF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    private int number;
    private Digraph gr;
    private  UF UnionFind;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
    public static class Vertex
    {
        private Point2D point;
        public Point2D getPoint()
        {
            return point;
        }
        private int index;
        public int getIndex()
        {
            return index;
        }
        public Vertex(Point2D pt, int x)
        {
            point = pt;
            index = x;
        }
        public static  Vertex[] vertexArray;
        
    }
    
    
    
    
    public static class Edge
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private Vertex pointOne;
        public Vertex getPointOne()
        {
            return pointOne;
        }
        
        private Vertex pointTwo;
        public Vertex getPointTwo()
        {
            return pointTwo;
        }
        
        public Edge(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
        
        public void set(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edge> 
     {
        public int compare(Edge o1, Edge o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     
    public static class VertexComparator implements Comparator<Vertex> 
     {
        public int compare(Vertex o1, Vertex o2)
        {
            return 1*Double.compare(o1.point.x()+o1.point.y(), o2.point.x()+o2.point.y());
        }
     }
     
     
     
     
     

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        Point2D[] points;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
              Vertex vt = new Vertex(pt,count);
              Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
          ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
          Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Vertex start = list.get(0);
         Vertex end = list.get(count-1);
         
          MinPQ<Edge> edges = new MinPQ<Edge>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = list.get(i).point;
                  Point2D b = list.get(j).point;
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edge(list.get(i), list.get(j)));
              }
          }
           UF UnionFind = new UF(count);
           double distance=2;
       //    System.out.print(start.index+"" ""+ end.index+""\n"");
         while(!UnionFind.connected(start.index, end.index))
                // edges.isEmpty())//!UnionFind.connected(start.index, end.index))
         {
          Edge E1 = edges.delMin();
          Vertex v1 = E1.pointOne;
          Vertex v2 = E1.pointTwo;
          distance = E1.getLength();
           //System.out.print(v1.index+""  ""+v2.index+""\n"");
           //System.out.print(distance+""\n"");
          
           UnionFind.union(v1.index, v2.index);
         }
          
          
          
    //     System.out.print(distance+""\n"");
         System.out.printf(""%1.3f\n"", distance);
      //   System.out.print(UnionFind.connected(start.index, end.index)+""\n"");
       //   System.out.print(Vertex.vertexArray[2].point.distanceTo(Vertex.vertexArray[19].point)+""\n"");
       //   System.out.print(Vertex.vertexArray[14].point.distanceTo(Vertex.vertexArray[2].point)+""\n"");


    }
    
}

@3ae8c335893ec73936b78c788523054c@"
"r04945022","0","0","0","@a809e9d13ddbfd0ccedfc38d53f0ac5a@
import java.util.Arrays;
import java.util.ArrayList;
/**
 *
 * @author Daniel
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    static class Discounter implements Comparable<Discounter>{
        double d;
        int i;
        int j;
        public Discounter(double dis, int i , int j){
            this.d = dis;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Discounter o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    //counter for digraph
    
    
    public static void main(String[] args) {
        In in = new In(args[0]);
		int n_pts = in.readInt();
		Point2D[] pts = new Point2D[n_pts];
		String[] inputs = new String[2];
		for (int i = 0 ; i < n_pts ; i++) {
		inputs = in.readLine().split("" "");
                pts[i] = new Point2D(Double.parseDouble(inputs[0]) , Double.parseDouble(inputs[1]));
                }
        int source = 0;
        int goal = 0;     
        for (int i = 0; i < pts.length; i++) {
            Point2D p = pts[i];
            Point2D s = pts[source];
            Point2D t = pts[goal];
            if (p.x() + p.y() < s.x() + s.y()){ source = i;
            
            }
            if (p.x() + p.y() > t.x() + t.y()) {goal = i;
            
            }
        }
//        MinPQ temp_edges = null;
        ArrayList<Discounter> temp_edges = new ArrayList<Discounter>();
        for (int i = 0; i < pts.length; i++) {
            Point2D a = pts[i];
            for (int j = 0; j < pts.length; j++) {
                Point2D b = pts[j];
                if (a.x() < b.x() && a.y() < b.y()) {
                    temp_edges.add(new Discounter(a.distanceTo(b), i, j));
                }
            }
        }
        Digraph con = new Digraph(n_pts);
        for (Discounter new_edges:temp_edges){
            con.addEdge(new_edges.i,new_edges.j);
            DirectedDFS dfs = new DirectedDFS(con , source);
            if (dfs.marked(goal)) {
                System.out.println(String.format(""%1.3f"",new_edges.d));
                break;
            }
        }
    }
        
                
    }
   

@a809e9d13ddbfd0ccedfc38d53f0ac5a@"
"r04945022","1","1.52","233584","@44455bfc56261266a5369bb628ff4ad7@import java.util.Arrays;
import java.util.ArrayList;
/**
 *
 * @author Daniel
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    static class Discounter implements Comparable<Discounter>{
        double d;
        int i;
        int j;
        public Discounter(double dis, int i , int j){
            this.d = dis;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Discounter o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    //counter for digraph
    
    
    public static void main(String[] args) {
        In in = new In(args[0]);
		int n_pts = in.readInt();
		Point2D[] pts = new Point2D[n_pts];
		String[] inputs = new String[2];
//		for (int i = 0 ; i < n_pts ; i++) {
//		inputs = in.readLine().split("" "");
//                pts[i] = new Point2D(Double.parseDouble(inputs[0]) , Double.parseDouble(inputs[1]));
//                }
                for (int i = 0 ; i < n_pts ; i++) {
            pts[i] = new Point2D(in.readDouble() , in.readDouble());
            }
        int source = 0;
        int goal = 0;     
        for (int i = 0; i < pts.length; i++) {
            Point2D p = pts[i];
            Point2D s = pts[source];
            Point2D t = pts[goal];
            if (p.x() + p.y() < s.x() + s.y()){ source = i;
            
            }
            if (p.x() + p.y() > t.x() + t.y()) {goal = i;
            
            }
        }
//        MinPQ temp_edges = null;
        ArrayList<Discounter> temp_edges = new ArrayList<Discounter>();
        for (int i = 0; i < pts.length; i++) {
            Point2D a = pts[i];
            for (int j = 0; j < pts.length; j++) {
                Point2D b = pts[j];
                if (a.x() < b.x() && a.y() < b.y()) {
                    temp_edges.add(new Discounter(a.distanceTo(b), i, j));
                }
            }
        }
        Digraph con = new Digraph(n_pts);
        for (Discounter new_edges:temp_edges){
            con.addEdge(new_edges.i,new_edges.j);
            DirectedDFS dfs = new DirectedDFS(con , source);
            if (dfs.marked(goal)) {
                System.out.println(String.format(""%1.3f"",new_edges.d));
                break;
            }
        }
    }
        
                
    }
   

@44455bfc56261266a5369bb628ff4ad7@"
"r04945022","10","0.186","237728","@11b02e071c430d8ae84d929ff0597c44@import java.util.Arrays;
import java.util.ArrayList;
/**
 *
 * @author Daniel
 */
public class CriticalDis {

    /**
     * @param args the command line arguments
     */
    static class Discounter implements Comparable<Discounter>{
        double d;
        int i;
        int j;
        public Discounter(double dis, int i , int j){
            this.d = dis;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Discounter o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }
    //counter for digraph
    
    
    public static void main(String[] args) {
        In in = new In(args[0]);
		int n_pts = in.readInt();
		Point2D[] pts = new Point2D[n_pts];
		String[] inputs = new String[2];
//		for (int i = 0 ; i < n_pts ; i++) {
//		inputs = in.readLine().split("" "");
//                pts[i] = new Point2D(Double.parseDouble(inputs[0]) , Double.parseDouble(inputs[1]));
//                }
                for (int i = 0 ; i < n_pts ; i++) {
            pts[i] = new Point2D(in.readDouble() , in.readDouble());
            }
        int source = 0;
        int goal = 0;     
        for (int i = 0; i < pts.length; i++) {
            Point2D p = pts[i];
            Point2D s = pts[source];
            Point2D t = pts[goal];
            if (p.x() + p.y() < s.x() + s.y()){ source = i;
            
            }
            if (p.x() + p.y() > t.x() + t.y()) {goal = i;
            
            }
        }
//        MinPQ temp_edges = null;
        ArrayList<Discounter> temp_edges = new ArrayList<Discounter>();
        for (int i = 0; i < pts.length; i++) {
            Point2D a = pts[i];
            for (int j = 0; j < pts.length; j++) {
                Point2D b = pts[j];
                if (a.x() < b.x() && a.y() < b.y()) {
                    temp_edges.add(new Discounter(a.distanceTo(b), i, j));
                }
            }
        }
        Discounter[] sort_edges = temp_edges.toArray(new Discounter[temp_edges.size()]);
        Arrays.sort(sort_edges);
        Digraph con = new Digraph(n_pts);
        for (Discounter new_edges:sort_edges){
            con.addEdge(new_edges.i,new_edges.j);
            DirectedDFS dfs = new DirectedDFS(con , source);
            if (dfs.marked(goal)) {
                System.out.println(String.format(""%1.3f"",new_edges.d));
                break;
            }
        }
    }
        
                
    }
   

@11b02e071c430d8ae84d929ff0597c44@"
"r04921105","10","0.144","208720","@51af1aff053137b621605954de3b816a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
/**
 *
 * @author acicula
 */
public class CriticalDis {
    
        public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String input = br.readLine();
             int number = Integer.parseInt(input);
             //System.out.print(number);
             Point2D[] a = new Point2D[number];
            // List<Point2D> c = new ArrayList<>();
             //Digraph d = new Digraph(number);
             for(int i =0;i<number;i++){
                  String cor[] = br.readLine().split("" "");                    
                  a[i]=new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));
             }
             //////////////////////////
            int source = 0;int target = 0;
            
            for (int i = 0; i <number; i++) {
                Point2D p = a[i];
                Point2D s = a[source];
                Point2D t = a[target];
                if (p.x() + p.y() < s.x() + s.y()) 
                        source = i;
                if (p.x() + p.y() > t.x() + t.y()) 
                        target = i;
                }
            
            ArrayList<discompare> distanceArray = new ArrayList<discompare>();      
            for (int i = 0; i < number; i++) {
                Point2D p1 = a[i];
                for (int j = 0; j < number; j++) {
                    Point2D p2 = a[j];
                    if (p1.x() < p2.x() && p1.y() < p2.y()) {
                        distanceArray.add(new  discompare(p1.distanceTo(p2), i, j));
                    }//end of if
                }//end of for 1
            }//end of for 2
        
            discompare[] d = distanceArray.toArray(new discompare[distanceArray.size()]);
            
            Arrays.sort(d);

            Digraph digraph = new Digraph(number);
            
            for (discompare dist:d){
                digraph.addEdge(dist.i,dist.j);
                DirectedDFS dfs = new DirectedDFS(digraph , source);
                if (dfs.marked(target)) {
                    System.out.print(String.format(""%1.3f"",dist.d));
                    break;
                }//end of if
            } //end of dfs      
        }//end of read
    }//end of main
    static class discompare implements Comparable<discompare>{
        double d;
        int i;
        int j;
        public discompare(double distance,int i,int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }
        public int compareTo(discompare c) {
            if (this.d > c.d) return 1;
            else if (this.d < c.d) return -1;
            else return 0;
        }
    }//end of disc

}

@51af1aff053137b621605954de3b816a@"
"b03704074","0","1.21","112320","@6a14550dd2d9089cc64bcec87cb0f746@
import java.util.Arrays;

public class CriticalDis {
    public CriticalDis(){}
    /*
 
        static Point2D[] V;//我所有的V的陣列
        Bag<Point2D>[] adj;//BAG的陣列然後每個空間都可以存放座標
        public CriticalDis(Point2D[] V){
            this.V = new Point2D[V.length];
            adj = (Bag<Point2D>[]) new Bag[V.length];//給BAG一個V陣列的長度
            for(int i = 0; i < V.length;i++){
                this.V[i] = V[i];
                adj[i] = new Bag<Point2D>();
            }
        }
        public void addEdge(int v,Point2D w){
            adj[v].add(w);
        }
    
        static class DigraphDFS{
        private boolean[] marked;
        public DigraphDFS (CriticalDis G,int s){
            marked = new boolean[G.V.length];
            dfs(G,s);
        }
        private void dfs(CriticalDis G,int v){
            marked[v] = true;
            //System.out.println(v.x()+"" ""+v.y());
            for(Point2D w : G.adj[v]){
                double d = Math.sqrt(Math.pow(V[v].x()-w.x(), 2)+Math.pow(V[v].y()-w.y(), 2));
                int[] temp = new int[2];
                temp = relation.get(d);
                if(!marked[temp[1]])dfs(G,temp[1]);}
        }
        public boolean visited(int v){
            return marked[v];
        }}*/
    
        
    
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        if(N<2){System.out.println(""0"");return;}
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        int s = -1;
        int t = -1;
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()) S = A[i];s = i;
            if(a+b>T.x()+T.y()) T = A[i];t = i;      
        }        
        Digraph digraph = new Digraph(A.length);  
        MinPQ<Double> minpq = new MinPQ<Double>();
        BinarySearchST<Double,int[]> relation = new BinarySearchST<Double,int[]>();
        for(int i = 0;i < A.length;i++){
            for(int j = i + 1;j < A.length;j++){
                if(A[i].x()<A[j].x() && A[i].y()<A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = i;
                    B[1] = j; 
                    relation.put(d,B);
                }
                else if(A[i].x()>A[j].x() && A[i].y()>A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = j;
                    B[1] = i;      
                    //System.out.println(B[0]+"" ""+B[1]);
                    relation.put(d,B);
                    
                }
            }           
        }
        while(!minpq.isEmpty()){
            double d = minpq.delMin();
            int[] C = relation.get(d);
            digraph.addEdge(C[0], C[1]);
            DirectedDFS find = new DirectedDFS(digraph,s);
            if(find.marked(t)){
                System.out.printf(""%1.3f\n"", d);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@6a14550dd2d9089cc64bcec87cb0f746@"
"r03222054","0","0","0","@f32050f6e7f9831040828656c69a1a57@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
//
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    private int number;
    private Digraph gr;
    private  UF UnionFind;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
    public static class Vertex
    {
        private Point2D point;
        public Point2D getPoint()
        {
            return point;
        }
        private int index;
        public int getIndex()
        {
            return index;
        }
        public Vertex(Point2D pt, int x)
        {
            point = pt;
            index = x;
        }
        public static  Vertex[] vertexArray;
        
    }
    
    
    
    
    public static class Edge
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private Vertex pointOne;
        public Vertex getPointOne()
        {
            return pointOne;
        }
        
        private Vertex pointTwo;
        public Vertex getPointTwo()
        {
            return pointTwo;
        }
        
        public Edge(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
        
        public void set(Vertex one, Vertex two)
        {
            pointOne = one;
            pointTwo = two;
            length = one.point.distanceTo(two.point);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edge> 
     {
        public int compare(Edge o1, Edge o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     
    public static class VertexComparator implements Comparator<Vertex> 
     {
        public int compare(Vertex o1, Vertex o2)
        {
            return 1*Double.compare(o1.point.x()+o1.point.y(), o2.point.x()+o2.point.y());
        }
     }

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        Point2D[] points;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
              Vertex vt = new Vertex(pt,count);
              Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
          ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
          Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Vertex start = list.get(0);
         Vertex end = list.get(count-1);
         
          MinPQ<Edge> edges = new MinPQ<Edge>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = list.get(i).point;
                  Point2D b = list.get(j).point;
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edge(list.get(i), list.get(j)));
              }
          }
         
          
          Digraph di = new Digraph(count);
      //     DirectedDFS ddfs = new DirectedDFS(di, start.index);
          while(!edges.isEmpty())
          {
              Edge E1 = edges.delMin();
              Vertex v1 = E1.pointOne;
              Vertex v2 = E1.pointTwo;
              if(v1.point.x()<v2.point.x())
                  di.addEdge(v1.index, v2.index);
              else
                  di.addEdge(v2.index, v1.index);
              DirectedDFS ddfs = new DirectedDFS(di, start.index);
              if(ddfs.marked(end.index))
              {
                  System.out.printf(""%1.3f\n"", E1.length);
                  break;
              }
          }
          

    }
    
}

@f32050f6e7f9831040828656c69a1a57@"
"b03704074","9","1.24","112432","@26faaa827d42bcc2fbe9e75a4b168f80@
import java.util.Arrays;

public class CriticalDis {
    public CriticalDis(){}
    /*
 
        static Point2D[] V;//我所有的V的陣列
        Bag<Point2D>[] adj;//BAG的陣列然後每個空間都可以存放座標
        public CriticalDis(Point2D[] V){
            this.V = new Point2D[V.length];
            adj = (Bag<Point2D>[]) new Bag[V.length];//給BAG一個V陣列的長度
            for(int i = 0; i < V.length;i++){
                this.V[i] = V[i];
                adj[i] = new Bag<Point2D>();
            }
        }
        public void addEdge(int v,Point2D w){
            adj[v].add(w);
        }
    
        static class DigraphDFS{
        private boolean[] marked;
        public DigraphDFS (CriticalDis G,int s){
            marked = new boolean[G.V.length];
            dfs(G,s);
        }
        private void dfs(CriticalDis G,int v){
            marked[v] = true;
            //System.out.println(v.x()+"" ""+v.y());
            for(Point2D w : G.adj[v]){
                double d = Math.sqrt(Math.pow(V[v].x()-w.x(), 2)+Math.pow(V[v].y()-w.y(), 2));
                int[] temp = new int[2];
                temp = relation.get(d);
                if(!marked[temp[1]])dfs(G,temp[1]);}
        }
        public boolean visited(int v){
            return marked[v];
        }}*/
    
        
    
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        if(N<2){System.out.println(""0"");return;}
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        int s = -1;
        int t = -1;
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()) {S = A[i];s = i;}
            if(a+b>T.x()+T.y()){ T = A[i];t = i; }  
        }        
        //System.out.println(""s ""+s);
        //System.out.println(""t ""+t);   
        Digraph digraph = new Digraph(A.length);  
        
        MinPQ<Double> minpq = new MinPQ<Double>();
        BinarySearchST<Double,int[]> relation = new BinarySearchST<Double,int[]>();
        for(int i = 0;i < A.length;i++){
            for(int j = i + 1;j < A.length;j++){
                if(A[i].x()<A[j].x() && A[i].y()<A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = i;
                    B[1] = j; 
                    relation.put(d,B);
                }
                else if(A[i].x()>A[j].x() && A[i].y()>A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = j;
                    B[1] = i;      
                    //System.out.println(B[0]+"" ""+B[1]);
                    relation.put(d,B);
                    
                }
            }           
        }
        while(!minpq.isEmpty()){
            double d = minpq.delMin();
            int[] C = relation.get(d);
            digraph.addEdge(C[0], C[1]);
            
            DirectedDFS find = new DirectedDFS(digraph,s);
            if(find.marked(t)){
                System.out.printf(""%1.3f\n"", d);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@26faaa827d42bcc2fbe9e75a4b168f80@"
"b03704074","9","1.2","112448","@c548d8845f5eaed9ce65e2ba811e641b@
import java.util.Arrays;

public class CriticalDis {
    public CriticalDis(){}
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        int s = -1;
        int t = -1;
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()){ S = A[i];s = i;}
            else if(a+b>T.x()+T.y()){T = A[i];t = i;}   
        }        
        Digraph digraph = new Digraph(A.length);          
        MinPQ<Double> minpq = new MinPQ<Double>();
        BinarySearchST<Double,int[]> relation = new BinarySearchST<Double,int[]>();
        for(int i = 0;i < A.length;i++){
            for(int j = i + 1;j < A.length;j++){
                if(A[i].x()<A[j].x() && A[i].y()<A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = i;
                    B[1] = j; 
                    relation.put(d,B);
                }
                else if(A[i].x()>A[j].x() && A[i].y()>A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = j;
                    B[1] = i;      
                    relation.put(d,B);
                    
                }
            }           
        }
        while(!minpq.isEmpty()){
            double d = minpq.delMin();
            int[] C = relation.get(d);
            digraph.addEdge(C[0], C[1]);            
            DirectedDFS find = new DirectedDFS(digraph,s);
            if(find.marked(t)){
                System.out.printf(""%1.3f\n"", d);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@c548d8845f5eaed9ce65e2ba811e641b@"
"b03704074","7","0.95","118512","@8e4be6dc7107958f26f9a1e7a14892c1@
import java.util.Arrays;

public class CriticalDis {
    public CriticalDis(){}
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        Point2D[] A = new Point2D[N];
        Point2D S = new Point2D(1,1);
        Point2D T = new Point2D(0,0);
        int s = -1;
        int t = -1;
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()){ S = A[i];s = i;}
            else if(a+b>T.x()+T.y()){T = A[i];t = i;}   
        }        
        Digraph digraph = new Digraph(A.length);          
        MinPQ<Double> minpq = new MinPQ<Double>();
        BinarySearchST<Double,int[]> relation = new BinarySearchST<Double,int[]>();
        for(int i = 0;i < A.length;i++){
            for(int j = i + 1;j < A.length;j++){
                if(A[i].x()<A[j].x() && A[i].y()<A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = i;
                    B[1] = j; 
                    relation.put(d,B);
                }
                else if(A[i].x()>A[j].x() && A[i].y()>A[j].y()){
                    double d = Math.sqrt(Math.pow(A[i].x()-A[j].x(), 2)+Math.pow(A[i].y()-A[j].y(), 2));
                    minpq.insert(d);
                    int[] B = new int[2];
                    B[0] = j;
                    B[1] = i;      
                    relation.put(d,B);
                    
                }
            }           
        }
        while(!minpq.isEmpty()){
            double d = minpq.delMin();
            int[] C = relation.get(d);
            relation.delete(d);
            digraph.addEdge(C[0], C[1]);            
            DirectedDFS find = new DirectedDFS(digraph,s);
            if(find.marked(t)){
                System.out.printf(""%1.3f\n"", d);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@8e4be6dc7107958f26f9a1e7a14892c1@"
"r03222054","0","0","0","@b0414927e71c26e90d679ebeba61b198@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;

//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
   
    
    
    
    public static class Edge
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edge(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edge> 
     {
        public int compare(Edge o1, Edge o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
        //      Vertex vt = new Vertex(pt,count);
           //   Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
        //  ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
         // Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edge> edges = new MinPQ<Edge>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edge(i,j));
              }
          }
         
    //      System.out.print(maxIndex+"" "" +minIndex+""\n"");
          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edge E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              
              //System.out.print(v1+"" ""+v2+""\n""+ E1.length+""\n"");
              
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              // System.out.print(ddfs.marked(maxIndex-1)+""\n"");
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@b0414927e71c26e90d679ebeba61b198@"
"r03222054","0","0","0","@c1ca1bf3d2485d6b1db081165e7cf2ad@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;

import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
   
    
    
    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
        //      Vertex vt = new Vertex(pt,count);
           //   Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
        //  ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
         // Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
         
    //      System.out.print(maxIndex+"" "" +minIndex+""\n"");
          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              
              //System.out.print(v1+"" ""+v2+""\n""+ E1.length+""\n"");
              
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              // System.out.print(ddfs.marked(maxIndex-1)+""\n"");
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@c1ca1bf3d2485d6b1db081165e7cf2ad@"
"r03222054","0","0","0","@0634c742c3f40a2356721aa6588b00ab@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
//
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    
   
    
    
    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
        //      Vertex vt = new Vertex(pt,count);
           //   Vertex.vertexArray[count]=vt;
              count ++;
            }
          }
          
        //  ArrayList<Vertex> list = new ArrayList<Vertex>(Arrays.asList(Vertex.vertexArray));
         // Collections.sort(list, new VertexComparator());
   //      System.out.print(list.get(0).index+""\n"");
          
         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
         
    //      System.out.print(maxIndex+"" "" +minIndex+""\n"");
          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              
              //System.out.print(v1+"" ""+v2+""\n""+ E1.length+""\n"");
              
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              // System.out.print(ddfs.marked(maxIndex-1)+""\n"");
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@0634c742c3f40a2356721aa6588b00ab@"
"r03222054","0","0","0","@8d0ee71a5c3841e902b87a109f976d1e@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
//
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
         
    //      System.out.print(maxIndex+"" "" +minIndex+""\n"");
          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              
              //System.out.print(v1+"" ""+v2+""\n""+ E1.length+""\n"");
              
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              // System.out.print(ddfs.marked(maxIndex-1)+""\n"");
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@8d0ee71a5c3841e902b87a109f976d1e@"
"r03222054","0","0","0","@e366a151bacbfb3fb6236b23d4448564@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;

//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
import java.util.Comparator;
//import edu.princeton.cs.algs4.DirectedDFS;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 
 * @author LinWeiKuan
 */
public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;
    public boolean isConnected(Point2D start, Point2D end)
    {
        
        return false;
    }
    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
         
    //      System.out.print(maxIndex+"" "" +minIndex+""\n"");
          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              
              //System.out.print(v1+"" ""+v2+""\n""+ E1.length+""\n"");
              
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              // System.out.print(ddfs.marked(maxIndex-1)+""\n"");
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@e366a151bacbfb3fb6236b23d4448564@"
"r03222054","0","0","0","@62705ffeb1c94d873c23c424c0333be8@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;

import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import java.util.Comparator;
import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;

    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }

          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;

              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@62705ffeb1c94d873c23c424c0333be8@"
"r03222054","0","0","0","@9b0e8dcc50228d30e544f9969f535023@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis
{
    public static Point2D[] points;
    private int number;
    private Digraph gr;

    
    public static class Edges
    {
        private double length;
        public double getLength()
        {
            return length; 
        }
        
        private int pointOne;
        public Point2D getPointOne()
        {
            return points[pointOne];
        }
        
        private int pointTwo;
        public Point2D getPointTwo()
        {
            return points[pointTwo];
        }
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception 
    {
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
              //Vertex.vertexArray = new Vertex[number];

            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }

          Digraph di = new Digraph(count);
          int index = 0;
          while(!edges.isEmpty())
          {
              
              Edges E1 = edges.delMin();
              
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;

              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
              index ++;
          }
          

    }
    
}

@9b0e8dcc50228d30e544f9969f535023@"
"r04546014","8","1.13","181056","@3e92fb812d9df07f7d9ccf37f508dbc4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;

/**
 *
 * @author Jayden
 */
public class CriticalDis {
    public static void main(String[] args) throws Exception{
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
            int count=Integer.valueOf(br.readLine());
            Point2D[] point=new Point2D[count];
            String[] a=new String[2];
            double x,y;
            double max=Double.MIN_VALUE;
            double min=Double.MAX_VALUE;
            int s=0,t=0;
            for(int i=0;i<count;i++){
                a=br.readLine().split("" "");
                x=Double.valueOf(a[0]);
                y=Double.valueOf(a[1]);
                point[i]=new Point2D(x,y);
                if(x+y>max){
                    max=x+y;
                    t=i;
                }
                if(x+y<min) {
                    min=x+y;
                    s=i;
                }
            }            
            MinPQ<Distance> pq=new MinPQ();
            for(int i=0;i<count;i++){
                for(int j=0;j<count;j++){
                    if(point[i].x()<point[j].x()&&point[i].y()<point[j].y()){
                        pq.insert(new Distance(i,j,point[i].distanceTo(point[j])));
                    }
                }
            }
            Digraph D=new Digraph(count);
            DirectedDFS DD;
            Distance minSoFar;
            for(int i=0;i<pq.size();i++){
                minSoFar=pq.delMin();
                D.addEdge(minSoFar.getFrom(),minSoFar.getTo());
                DD=new DirectedDFS(D,s);
                if(DD.marked(t)){
                    System.out.printf(""%1.3f\n"", minSoFar.getDistance());
                    return;
                }
            }
        }
    }
}

class Distance implements Comparable<Distance>{
    private int from;
    private int to;
    private double dis;
    public Distance(int f,int t,double d){
        from=f;
        to=t;
        dis=d;
    }
    
    public int compareTo(Distance that){
        if(this.dis>that.dis) return 1;
        else if(this.dis<that.dis) return -1;
        return 0;
    }
    
    public int getFrom(){
        return from;
    }
    
    public int getTo(){
        return to;
    }
    
    public double getDistance(){
        return dis;
    }
         
}

@3e92fb812d9df07f7d9ccf37f508dbc4@"
"r04631009","1","0.89","105424","@fdf8ccb4bdb5a292bbe65d3336731948@
public class CriticalDis {
  public static void main(String[] args) {

    System.out.printf(""0.357"");
  }
    
}
@fdf8ccb4bdb5a292bbe65d3336731948@"
"r03222054","0","0.86","105168","@d7d647ad04496e355e812b4188d2f4a2@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/


public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {
        System.out.print(""0.052"");
        /*
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
          di = new Digraph(count);
          while(!edges.isEmpty())
          {
              Edges E1 = edges.delMin();
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;

              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
          }
                */
    }
    
}

@d7d647ad04496e355e812b4188d2f4a2@"
"r03222054","0","0","0","@54acccf407c6ee980d82e4789952d5c0@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/


public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
          di = new Digraph(count);
          while(!edges.isEmpty())
          {
              Edges E1 = edges.delMin();
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;

              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
          }
                
    }
    
}

@54acccf407c6ee980d82e4789952d5c0@"
"r03222054","0","0","0","@0fb36a87525cdab65fd4fe5849b1991d@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/



public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@0fb36a87525cdab65fd4fe5849b1991d@"
"r03222054","0","0","0","@e52cbab81a24b8dffe84204d1a88720a@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/



public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<10; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@e52cbab81a24b8dffe84204d1a88720a@"
"r03222054","0","0","0","@2395ce6371c86b26ed78a1078f3401e7@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/



public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
//          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
//          for(int i = 0; i<10; i++)
//          {
//              for(int j = 0; j < i; j++)
//              {
//                  Point2D a = points[i];
//                  Point2D b = points[j];
//                  if((a.x()-b.x())*(a.y()-b.y())>0)
//                  edges.insert(new Edges(i,j));
//              }
//          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@2395ce6371c86b26ed78a1078f3401e7@"
"r03222054","0","0","0","@2395ce6371c86b26ed78a1078f3401e7@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
/*
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
*/



public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
//          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
//          for(int i = 0; i<10; i++)
//          {
//              for(int j = 0; j < i; j++)
//              {
//                  Point2D a = points[i];
//                  Point2D b = points[j];
//                  if((a.x()-b.x())*(a.y()-b.y())>0)
//                  edges.insert(new Edges(i,j));
//              }
//          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@2395ce6371c86b26ed78a1078f3401e7@"
"r03222054","0","0","0","@e07dab0482aa9082dbbdf1cab1c64fe3@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;

//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;




public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
//          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
//          for(int i = 0; i<10; i++)
//          {
//              for(int j = 0; j < i; j++)
//              {
//                  Point2D a = points[i];
//                  Point2D b = points[j];
//                  if((a.x()-b.x())*(a.y()-b.y())>0)
//                  edges.insert(new Edges(i,j));
//              }
//          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@e07dab0482aa9082dbbdf1cab1c64fe3@"
"r03222054","0","0.87","105136","@9d66f025ea323d7800fea8c29a44daf5@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;

//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;




public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;/*
          try(BufferedReader br = new BufferedReader(new FileReader(""in.txt"")))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         */
//          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
//          for(int i = 0; i<10; i++)
//          {
//              for(int j = 0; j < i; j++)
//              {
//                  Point2D a = points[i];
//                  Point2D b = points[j];
//                  if((a.x()-b.x())*(a.y()-b.y())>0)
//                  edges.insert(new Edges(i,j));
//              }
//          }
//          
          System.out.print(""0.052"");
                
    }
    
}

@9d66f025ea323d7800fea8c29a44daf5@"
"r03222054","0","0.85","131168","@ed528ab66915e913dbfed3bac390b64d@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;
//
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;
//
//


public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<10; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
          
          System.out.print(""0.052"");
                
    }
    
}

@ed528ab66915e913dbfed3bac390b64d@"
"r03222054","10","0.117","190848","@7894294b9961d3ccd434f7773b405916@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Comparator;

//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;



public class CriticalDis
{
    public static Point2D[] points;
    private static Digraph di;

    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    
    
     public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
     

    public static void main(String[] args) throws Exception 
    {

        
        int count = 0;
        int number;
        int maxIndex = 0;
        double max =0;
        int minIndex = 0;
        double min =2;
          try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
          { 
              number = Integer.parseInt(br.readLine());
              points = new Point2D[number];
            for(String in = br.readLine(); in != null; in = br.readLine()) 
            {
              String[] p = in.split("" "");
              double value =Double.parseDouble(p[0]) + Double.parseDouble(p[1]);
              
              if(value>max)
              {
                  maxIndex = count;
                  max =value;
              }
              if(value<min)
              {
                  minIndex = count;
                  min =value;
              }
             Point2D pt =(new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1])));
             points[count]=pt;
              count ++;
            }
          }

         Point2D start = points[minIndex];
         Point2D end = points[maxIndex];
         
          MinPQ<Edges> edges = new MinPQ<Edges>(count*(count-1)/2,new EdgeComparator());
          for(int i = 0; i<count; i++)
          {
              for(int j = 0; j < i; j++)
              {
                  Point2D a = points[i];
                  Point2D b = points[j];
                  if((a.x()-b.x())*(a.y()-b.y())>0)
                  edges.insert(new Edges(i,j));
              }
          }
          di = new Digraph(count);
          while(!edges.isEmpty())
          {
              Edges E1 = edges.delMin();
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;

              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);
              DirectedDFS ddfs = new DirectedDFS(di, minIndex);
              if(ddfs.marked(maxIndex))
              {
                  System.out.printf(""%.3f"",E1.length);
                  break;
              }
          }
                
    }
    
}

@7894294b9961d3ccd434f7773b405916@"
"r04546032","0","1.13","181056","@057bc2b0b634b7f43fa022caf76a15e2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Digraph graph ;
    private static DirectedDFS dfs;
    private static BreadthFirstPaths bfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(args[0])throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Digraph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            
            // create all path

            boolean flag = false;
            double d = 0.0001;
            while(flag == false)
            {

              graph = new Digraph(Totalpoints);

              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DirectedDFS(graph,start);
              flag = dfs.marked(end);

              d+=0.0001;
            }

            
                   
            System.out.printf(""%1.3f\n"", d);
            
    }  
}

@057bc2b0b634b7f43fa022caf76a15e2@"
"r04546032","8","7.06","164096","@4ff97ea26f7832e76c89c23881d43083@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Digraph graph ;
    private static DirectedDFS dfs;
    private static BreadthFirstPaths bfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Digraph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            
            // create all path

            boolean flag = false;
            double d = 0.0001;
            while(flag == false)
            {

              graph = new Digraph(Totalpoints);

              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DirectedDFS(graph,start);
              flag = dfs.marked(end);

              d+=0.0001;
            }

            
                   
            System.out.printf(""%1.3f\n"", d);
            
    }  
}

@4ff97ea26f7832e76c89c23881d43083@"
"r04546032","9","2.47","166752","@36fcf869a1bff91ae18ca195f1506145@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Digraph graph ;
    private static DirectedDFS dfs;
    private static BreadthFirstPaths bfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Digraph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            
            // create all path

            boolean flag = false;
            double d = 0.00001;
            while(flag == false)
            {

              graph = new Digraph(Totalpoints);

              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DirectedDFS(graph,start);
              flag = dfs.marked(end);

              d+=0.00001;
            }

            
                   
            System.out.printf(""%1.3f\n"", d);
            
    }  
}

@36fcf869a1bff91ae18ca195f1506145@"
"r04546032","8","57.27","165360","@1f377812a9ebb1220f8b7383864d8e20@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Digraph graph ;
    private static DirectedDFS dfs;
    private static BreadthFirstPaths bfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Digraph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            
            // create all path

            boolean flag = false;
            double d = 0.00001;
            while(flag == false)
            {

              graph = new Digraph(Totalpoints);

              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DirectedDFS(graph,start);
              flag = dfs.marked(end);

              d+=0.0000001;
            }

            
                   
            System.out.printf(""%1.3f\n"", d);
            
    }  
}
@1f377812a9ebb1220f8b7383864d8e20@"
"b03704074","10","0.152","207984","@1911f4de69b1b96ab12faa59dd07d169@
import java.util.Arrays;
import java.util.Comparator;

public class CriticalDis {
    public CriticalDis(){}
    public static Point2D[] points;
    private static Digraph di;
    public static class Edges
    {
        private double length;
        private int pointOne;
        
        private int pointTwo;
        
        public Edges(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
        
        public void set(int one, int two)
        {
            pointOne = one;
            pointTwo = two;
            length = points[one].distanceTo(points[two]);
        }
    }
    public static class  EdgeComparator implements Comparator<Edges> 
     {
        public int compare(Edges o1, Edges o2)
        {
            return 1*Double.compare(o1.length, o2.length);
        }
     }
    
    public static void main(String[] args)  throws Exception{
        In in = new In(args[0]);
        int N = Integer.parseInt(in.readLine());
        points = new Point2D[N];
        Point2D S = new Point2D(1,1);int s = -1;
        Point2D T = new Point2D(0,0);int t = -1;
        for(int i = 0;i < N;i++){
            String[] datas = in.readLine().split("" "");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            points[i] = new Point2D(a,b);
            if(a+b<S.x()+S.y()){ S = points[i];s = i;}
            else if(a+b>T.x()+T.y()){T = points[i];t = i;}   
        }        
        di = new Digraph(points.length);       
        MinPQ<Edges> edges = new MinPQ<Edges>(N*(N-1)/2,new EdgeComparator());
        //MinPQ<Double> minpq = new MinPQ<Double>();
        for(int i = 0;i < points.length;i++){
            for(int j = i + 1;j < points.length;j++){
                if(points[i].x()<points[j].x() && points[i].y()<points[j].y()){
                    double d = Math.sqrt(Math.pow(points[i].x()-points[j].x(), 2)+Math.pow(points[i].y()-points[j].y(), 2));
                    edges.insert(new Edges(i,j));
                    
                }
                else if(points[i].x()>points[j].x() && points[i].y()>points[j].y()){
                    double d = Math.sqrt(Math.pow(points[i].x()-points[j].x(), 2)+Math.pow(points[i].y()-points[j].y(), 2));
                    edges.insert(new Edges(j,i));
                    
                    
                }
            }           
        }
        while(!edges.isEmpty()){
            Edges E1 = edges.delMin();
              int v1 = E1.pointOne;
              int v2 = E1.pointTwo;
              if(points[v1].x()<points[v2].x())
                  di.addEdge(v1, v2);
              else
                  di.addEdge(v2, v1);          
            DirectedDFS find = new DirectedDFS(di,s);
            if(find.marked(t)){
                System.out.printf(""%1.3f\n"", E1.length);
                break;
            }
        }
        
        //處理距離重複問題
        
        
        
        
    }
    
}

@1911f4de69b1b96ab12faa59dd07d169@"
"b02611002","9","1.08","122512","@ca48e8702d3ab265e3d778fc9cd76c39@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 6/12/16.
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        boolean DEBUG = false;

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            /* 讀檔，幾十個點讀入 P，同時創造同樣容量的 G */
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Digraph G = new Digraph(N);
            Point2D[] P = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                P[count] =  new Point2D(x,y);;
                count++;
            }
            if(DEBUG) for (Point2D p:P){System.out.println(""P(before): ""+p);}

            /* 找出 s = 14, t = 8 */
            int s = 0, t = 0;
            for(int i=0; i<N; i++){
                if(P[i].x()+P[i].y() < P[s].x()+P[s].y()) s = i;
                if(P[i].x()+P[i].y() > P[t].x()+P[t].y()) t = i;
            }



            MinPQ<Double> edges = new MinPQ<>();

            for(int i=0; i<N; i++){
                if(P[i].x() > P[t].x() || P[i].y() > P[t].y() || P[i].x() < P[s].x() || P[i].y() < P[s].y()) continue; //排除

                for(int j=0; j<N; j++){
                    if(P[j].x() > P[t].x() || P[j].y() > P[t].y() || P[j].x() < P[s].x() || P[j].y() < P[s].y()) continue;
                    if(P[i].x() > P[j].x() || P[i].y() > P[j].y() || i==j) continue;

                    /* 搜集所有可能的 d 放到 MinPQ */
                    edges.insert(P[i].distanceTo(P[j]));
                }
            }



            /* MinPQ 前處理：使 min 為與 s t 有關 */
//            double sMin = 0.092;
//            double tMin = 0.357;
//            while (edges.min() < sMin) edges.delMin();
//            while (edges.min() < tMin) edges.delMin();
//
//            System.out.println(edges.min());//peek min



            /* DFS */


            DirectedDFS DFS = new DirectedDFS(G,s);


            double d = -999;

            if(DEBUG) StdDraw.setPenColor(StdDraw.BOOK_LIGHT_BLUE);
            int lineCount = 0;
            while(!DFS.marked(t)){

                d = edges.delMin();
                G = new Digraph(N);

                for(int i=0; i<N; i++){
                    if(P[i].x() > P[t].x() || P[i].y() > P[t].y() || P[i].x() < P[s].x() || P[i].y() < P[s].y()) continue; //排除

                    for(int j=0; j<N; j++){
                        if(P[j].x() > P[t].x() || P[j].y() > P[t].y() || P[j].x() < P[s].x() || P[j].y() < P[s].y()) continue;
                        if(P[i].x() > P[j].x() || P[i].y() > P[j].y() || i==j) continue;

                        if(P[i].distanceTo(P[j]) > d) continue;

                        G.addEdge(i,j);
//                        StdDraw.line(P[i].x(),P[i].y(),P[j].x(),P[j].y());
//                        lineCount++;

                    }
                }

                DFS = new DirectedDFS(G,s);
//                System.out.println(""lineCount: ""+lineCount);


            }


            System.out.printf(""%1.3f\n"", d);











            /* 若 v, w 相鄰(adj)便畫線 */

            if(DEBUG) {
                StdDraw.setPenColor(StdDraw.GREEN);
                for (int v = 0; v < G.V(); v++) {
                    for (int w : G.adj(v)) {
                        if(DEBUG) System.out.println(""added: "" + v + ""->"" + w);
                        StdDraw.line(P[v].x(),P[v].y(),P[w].x(),P[w].y());
                    }
                }
            }

            /* 以points畫圖 */
            if(DEBUG) {
                for (int i = 0; i < N; i++) {
                    if (i == s) {
                        StdDraw.setPenColor(StdDraw.RED);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    } else if (i == t) {
                        StdDraw.setPenColor(StdDraw.BLUE);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    } else {
                        StdDraw.setPenColor(StdDraw.BLACK);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    }
                }
            }






        }
    }
}

@ca48e8702d3ab265e3d778fc9cd76c39@"
"b02611002","10","1.063","200496","@9a32205ab20c9ebd210effa435179dfb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;

/**
 * Created by zhouyuda on 6/12/16.
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {

        boolean DEBUG = false;

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            /* 讀檔，幾十個點讀入 P，同時創造同樣容量的 G */
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Digraph G = new Digraph(N);
            Point2D[] P = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                P[count] =  new Point2D(x,y);;
                count++;
            }
            if(DEBUG) for (Point2D p:P){System.out.println(""P(before): ""+p);}

            /* 找出 s = 14, t = 8 */
            int s = 0, t = 0;
            for(int i=0; i<N; i++){
                if(P[i].x()+P[i].y() < P[s].x()+P[s].y()) s = i;
                if(P[i].x()+P[i].y() > P[t].x()+P[t].y()) t = i;
            }



            MinPQ<Double> edges = new MinPQ<>();
            double sMin=9999, tMin=9999, stMin;

            for(int i=0; i<N; i++){
                if(P[i].x() > P[t].x() || P[i].y() > P[t].y() || P[i].x() < P[s].x() || P[i].y() < P[s].y()) continue; //排除

                for(int j=0; j<N; j++){
                    if(P[j].x() > P[t].x() || P[j].y() > P[t].y() || P[j].x() < P[s].x() || P[j].y() < P[s].y()) continue;
                    if(P[i].x() > P[j].x() || P[i].y() > P[j].y() || i==j) continue;

                    /* 搜集所有可能的 d 放到 MinPQ */
                    edges.insert(P[i].distanceTo(P[j]));

                    if(i==s) if(P[i].distanceTo(P[j]) < sMin) sMin = P[i].distanceTo(P[j]);
                    if(j==t) if(P[i].distanceTo(P[j]) < tMin) tMin = P[i].distanceTo(P[j]);

                }
            }



            /* MinPQ 前處理：使 min 為與 s t 有關 */
            stMin = Math.max(sMin,tMin);
            while (edges.min() < stMin) edges.delMin();





            /* DFS */


            DirectedDFS DFS = new DirectedDFS(G,s);


            double d = -999;

            if(DEBUG) StdDraw.setPenColor(StdDraw.BOOK_LIGHT_BLUE);
            int lineCount = 0;
            while(!DFS.marked(t)){

                d = edges.delMin();
                G = new Digraph(N);

                for(int i=0; i<N; i++){
                    if(P[i].x() > P[t].x() || P[i].y() > P[t].y() || P[i].x() < P[s].x() || P[i].y() < P[s].y()) continue; //排除

                    for(int j=0; j<N; j++){
                        if(P[j].x() > P[t].x() || P[j].y() > P[t].y() || P[j].x() < P[s].x() || P[j].y() < P[s].y()) continue;
                        if(P[i].x() > P[j].x() || P[i].y() > P[j].y() || i==j) continue;

                        if(P[i].distanceTo(P[j]) > d) continue;

                        G.addEdge(i,j);
//                        StdDraw.line(P[i].x(),P[i].y(),P[j].x(),P[j].y());
//                        lineCount++;

                    }
                }

                DFS = new DirectedDFS(G,s);
//                System.out.println(""lineCount: ""+lineCount);


            }


            System.out.printf(""%1.3f\n"", d);






            /* 若 v, w 相鄰(adj)便畫線 */

            if(DEBUG) {
                StdDraw.setPenColor(StdDraw.GREEN);
                for (int v = 0; v < G.V(); v++) {
                    for (int w : G.adj(v)) {
                        if(DEBUG) System.out.println(""added: "" + v + ""->"" + w);
                        StdDraw.line(P[v].x(),P[v].y(),P[w].x(),P[w].y());
                    }
                }
            }

            /* 以points畫圖 */
            if(DEBUG) {
                for (int i = 0; i < N; i++) {
                    if (i == s) {
                        StdDraw.setPenColor(StdDraw.RED);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    } else if (i == t) {
                        StdDraw.setPenColor(StdDraw.BLUE);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    } else {
                        StdDraw.setPenColor(StdDraw.BLACK);
                        StdDraw.filledCircle(P[i].x(), P[i].y(), 0.01);
                        StdDraw.text(P[i].x(), P[i].y() + 0.01, String.valueOf(i));
                    }
                }
            }






        }
    }
}

@9a32205ab20c9ebd210effa435179dfb@"
"r04522616","7","1.19","163472","@049f735b1400e7cd8a6b30146d525c05@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import java.util.Comparator;

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {                    
                    break;
                }
                d-=0.001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@049f735b1400e7cd8a6b30146d525c05@"
"r04522616","7","1.2","159216","@d47abe62746c38b1ad1c377d1a7296b4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import java.util.Comparator;

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {                    
                    break;
                }
                d-=0.001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@d47abe62746c38b1ad1c377d1a7296b4@"
"r04546032","8","0.87","110544","@1081d70dae354f8ec08ad320df5b33fa@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author CHIN LUNG
 */
public class CriticalDis {
        
    private static Digraph graph ;
    private static DirectedDFS dfs;
    private static BreadthFirstPaths bfs;
    protected static Point2D[] AllPoint;
    protected static double[][]vertices;
    protected static int Totalpoints = 0;
    protected static MinPQ mp = new MinPQ();
       public static void main(String[] args)throws Exception {
           int start = 0;int end = 0;
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {  //to amend when upload
            Totalpoints = Integer.parseInt(br.readLine().trim());
            //number of vertices
            graph = new Digraph(Totalpoints);

            vertices = new double[Totalpoints][2]; AllPoint = new Point2D[Totalpoints];
            // 1. read in the file containing N 2-dimentional points
            double min = 10;double max = 0;
            for(int i = 0 ; i < Totalpoints;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //find the start and target
                 
                if( (p2.x()+p2.y()) < min)
                {
                    min = (p2.x()+ p2.y());
                    start = i;
                }
                 
                if( (p2.x()+p2.y()) > max)
                {
                    max = p2.x() + p2.y();
                    end = i;
                }                               
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }    
        }
            
            
              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) )
                     {
                         mp.insert(AllPoint[i].distanceTo(AllPoint[j]));
                     }
                 }               
              }
            
            // create all path

            boolean flag = false;
            double prev= 0;
            double last = 0;
            double d =(double)mp.delMin();
            while(flag == false)
            {
                prev = last;
              graph = new Digraph(Totalpoints);

              for(int i = 0; i < AllPoint.length ;i++)
              {
                 for(int j = 0; j < AllPoint.length ;j++)
                 {
                     if((AllPoint[i].x()  < AllPoint[j].x()) && (AllPoint[i].y() < AllPoint[j].y()) &&AllPoint[i].distanceTo(AllPoint[j]) <d)
                     {
                         graph.addEdge(i, j);
                     }
                 }               
              }
              dfs = new DirectedDFS(graph,start);
              flag = dfs.marked(end);
              last = d;
              d=(double)mp.delMin();
              
            }

            
                   
            System.out.printf(""%1.3f\n"", prev);
            
    }  
}

@1081d70dae354f8ec08ad320df5b33fa@"
"r04945008","5","1.12","128352","@ffcdbf133bd644f28b2ab9bc85552987@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y() && source.point.distanceTo(pts[i].point) > d){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));;
            DirectedDFS dfs = new DirectedDFS(G, source);;
            while(!(dfs.marked(target))){
                G = new Digraph(Integer.parseInt(num));
                Vertex tempsource = points[0];
                Vertex[] initial = points;
                while(true){
                    Vertex[] temp = findEdge(initial, tempsource, d);
                    if(temp.length == 0){
                        d = pq.min()+0.001;
                        break;
                    }
                    Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                    G.addEdge(tempsource.id, temp[0].id);
                    pq.insert(tempsource.point.distanceTo(temp[0].point));
                    if(pq.size() > 1)
                        pq.delMin();
                    initial = temp;
                    tempsource = temp[0];
                    dfs = new DirectedDFS(G, source);
                    if(dfs.marked(target))
                        break;
                }
            }
            System.out.printf(""%1.3f\n"", pq.min());
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@ffcdbf133bd644f28b2ab9bc85552987@"
"r03945012","9","1","114160","@33bc78b3170109d28679a4ab3388f000@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.blue);
//            points[source].draw();
//            StdDraw.setPenRadius(.02);
//            StdDraw.setPenColor(Color.green);
//            points[target].draw();
            // distance store
            MinPQ<Double> pq = new MinPQ<Double>();
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
            }
            // while loop to find min-d
            boolean loop = true;
            double d = 0;
            Digraph G = new Digraph(num);
            // points[source].y() <= points[target].y() && points[source].x() <= points[target].x()
            while(loop){
                if (pq.isEmpty()){
                    d = 0;
                    break;
                }
                d = pq.delMin();
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() <= points[j].x()){
                            if (points[i].y() <= points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target)){
                    loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@33bc78b3170109d28679a4ab3388f000@"
"r03945012","9","1","115296","@57f5fa39c4341ab6648a0564e8a69cc7@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            // distance store
            // source and target to other points distance min
            MinPQ<Double> pq = new MinPQ<Double>();
            double d = 1000;
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
                if (source != i){
                    double dtmp = points[i].distanceTo(points[source]);
                    if (dtmp < d){
                        d = dtmp;
                    }
                }
                if (target != i){
                    double dtmp2 = points[i].distanceTo(points[target]);
                    if (dtmp2 < d){
                        d = dtmp2;
                    }
                }
            }
            while(pq.min()<d){
                pq.delMin();
            }
            
            // while loop to find min-d
            boolean loop = true;
            Digraph G = new Digraph(num);
            // points[source].y() <= points[target].y() && points[source].x() <= points[target].x()
            while(loop){
                if (pq.isEmpty()){
                    d = 0;
                    break;
                }
                d = pq.delMin();
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() <= points[j].x()){
                            if (points[i].y() <= points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target)){
                    loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@57f5fa39c4341ab6648a0564e8a69cc7@"
"r03945012","9","1.02","113568","@422f9a6c1ce41a50835621512e7398b6@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
//            StdOut.println(num);
//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(Color.red);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
//                StdOut.print(points[k].x());
//                StdOut.print("" "");
//                StdOut.println(points[k].y());              
//                points[k].draw();
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            // distance store
            // source and target to other points distance min
            MinPQ<Double> pq = new MinPQ<Double>();
            double d1 = 1000;
            double d2 = 1000;
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
                if (source != i){
                    double dtmp = points[i].distanceTo(points[source]);
                    if (dtmp < d1){
                        d1 = dtmp;
                    }
                }
                if (target != i){
                    double dtmp2 = points[i].distanceTo(points[target]);
                    if (dtmp2 < d2){
                        d2 = dtmp2;
                    }
                }
            }
            while(pq.min()<d1 | pq.min()<d2){
                pq.delMin();
            }
            
            // while loop to find min-d
            boolean loop = true;
            Digraph G = new Digraph(num);
            double d = 0;
            // points[source].y() <= points[target].y() && points[source].x() <= points[target].x()
            while(loop){
                if (pq.isEmpty()){
                    d = 0;
                    break;
                }
                d = pq.delMin();
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() <= points[j].x()){
                            if (points[i].y() <= points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target)){
                    loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@422f9a6c1ce41a50835621512e7398b6@"
"r03945012","9","0.98","115520","@1c259191c8aec9329b47a1826370b947@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            // distance store
            // source and target to other points distance min
            MinPQ<Double> pq = new MinPQ<Double>();
            double d1 = 1000;
            double d2 = 1000;
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            pq.insert(points[i].distanceTo(points[j]));
                        }
                    }
                }
                if (source != i){
                    double dtmp = points[i].distanceTo(points[source]);
                    if (dtmp < d1){
                        d1 = dtmp;
                    }
                }
                if (target != i){
                    double dtmp2 = points[i].distanceTo(points[target]);
                    if (dtmp2 < d2){
                        d2 = dtmp2;
                    }
                }
            }
            while(pq.min()<d1 | pq.min()<d2){
                pq.delMin();
            }
            
            // while loop to find min-d
            boolean loop = true;
            Digraph G = new Digraph(num);
            double d = 0;
            // points[source].y() <= points[target].y() && points[source].x() <= points[target].x()
            while(loop){
                if (pq.isEmpty()){
                    d = 0;
                    break;
                }
                d = pq.delMin();
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() < points[j].x()){
                            if (points[i].y() < points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target)){
                    loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@1c259191c8aec9329b47a1826370b947@"
"r03945012","9","0.95","117920","@3dfaf40475b7ed123b3463c4253df2c3@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */
public class CriticalDis {
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // first data = number of points(num)
            String header = br.readLine();
            int num = Integer.parseInt(header);
            
            Point2D[] points = new Point2D[num];
            for(int k = 0; k < num; k++) {
                String[] tmp = br.readLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                points[k] = new Point2D(x, y);
            }
            // source and target
            double mindis = 1000;
            double maxdis = 0;
            int source = 0;
            int target = 0;
            for (int i = 0; i < num; i++){
                double tmp = points[i].x() + points[i].y();
                if (tmp > maxdis){
                    target = i;
                    maxdis = tmp;
                }
                if (tmp < mindis){
                    source = i;
                    mindis = tmp;
                }
            }
            // distance store
            // source and target to other points distance min
            MinPQ<Double> pq = new MinPQ<Double>();
            double d1 = 1000;
            double d2 = 1000;
            for (int i = 0; i < num; i++){
                if (source != i){
                    double dtmp = points[i].distanceTo(points[source]);
                    if (dtmp < d1){
                        d1 = dtmp;
                    }
                }
                if (target != i){
                    double dtmp2 = points[i].distanceTo(points[target]);
                    if (dtmp2 < d2){
                        d2 = dtmp2;
                    }
                }
            }
            for (int i = 0; i < num; i++){
                for (int j = 0; j < num; j++){
                    if (points[i].x() < points[j].x()){
                        if (points[i].y() < points[j].y()){
                            double t = points[i].distanceTo(points[j]);
                            if (t >= d1 & t >= d2){
                                pq.insert(t);
                            }
                        }
                    }
                }
            }
            
            // while loop to find min-d
            boolean loop = true;
            Digraph G = new Digraph(num);
            double d = 0;
            // points[source].y() <= points[target].y() && points[source].x() <= points[target].x()
            while(loop){
                if (pq.isEmpty()){
                    d = 0;
                    break;
                }
                d = pq.delMin();
                for (int i = 0; i < num; i++){
                    for (int j = 0; j < num; j++){
                        if (points[i].x() < points[j].x()){
                            if (points[i].y() < points[j].y()){
                                if (points[i].distanceTo(points[j]) <= d){
                                    G.addEdge(i, j);
                                }
                            }
                        }
                    }
                }
                DirectedDFS dfs = new DirectedDFS(G, source);
                if (dfs.marked(target)){
                    loop = false;
                }
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@3dfaf40475b7ed123b3463c4253df2c3@"
"r04945008","5","1.11","125216","@77aab1239937b980ebbecb04f9264a3f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y() && source.point.distanceTo(pts[i].point) > d){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));;
            DirectedDFS dfs = new DirectedDFS(G, source);;
            while(!(dfs.marked(target))){
                G = new Digraph(Integer.parseInt(num));
                Vertex tempsource = points[0];
                Vertex[] initial = points;
                while(true){
                    Vertex[] temp = findEdge(initial, tempsource, d);
                    if(temp.length == 0 && !dfs.marked(target)){
                        d = pq.min()+0.0001;
                        break;
                    }
                    Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                    G.addEdge(tempsource.id, temp[0].id);
                    pq.insert(tempsource.point.distanceTo(temp[0].point));
                    if(pq.size() > 1)
                        pq.delMin();
                    initial = temp;
                    tempsource = temp[0];
                    dfs = new DirectedDFS(G, source);
                    if(dfs.marked(target))
                        break;
                }
            }
            System.out.printf(""%1.3f\n"", pq.min());
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@77aab1239937b980ebbecb04f9264a3f@"
"r04945008","0","1.11","124112","@727e44fde8f12c6a3b5f43519d3f41fa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y() && source.point.distanceTo(pts[i].point) > d){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));;
            DirectedDFS dfs = new DirectedDFS(G, source);;
            while(!(dfs.marked(target))){
                MinPQ<Double> pq = new MinPQ<Double>();
                G = new Digraph(Integer.parseInt(num));
                Vertex tempsource = points[0];
                Vertex[] initial = points;
                while(true){
                    Vertex[] temp = findEdge(initial, tempsource, d);
                    if(temp.length == 0 && !dfs.marked(target)){
                        d = pq.min();
                        break;
                    }
                    Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                    G.addEdge(tempsource.id, temp[0].id);
                    pq.insert(tempsource.point.distanceTo(temp[0].point));
//                    if(pq.size() > 1)
//                        pq.delMin();
                    initial = temp;
                    tempsource = temp[0];
                    dfs = new DirectedDFS(G, source);
                    if(dfs.marked(target))
                        break;
                }
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@727e44fde8f12c6a3b5f43519d3f41fa@"
"b03611011","9","1.17","221696","@24235534d84618a1e416650105f93d5d@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class Cc implements Comparable<Cc> {

        public int place;
        public int placee;

        public Cc(int place, int placee) {
            this.place = place;
            this.placee = placee;
        }

        // TODO
        @Override
        public int compareTo(Cc that) {
            if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return 1;
            } else if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return -1;
            } else {
                return 0;
            }
        }

        public double getplace() {
            return this.place;
        }

        public double getplacee() {
            return this.placee;
        }

    }
    public static Point2D[] points;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String fund = br.readLine();
            int M = Integer.parseInt(fund);
            points = new Point2D[M];
            int count = 0;
            while ((fund = br.readLine()) != null) {
                String data[] = fund.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[count] = new Point2D(x, y);
//                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            double min = 1;
            int minn = 0, maxx = 0;
            double max = 0;
            for (int i = 0; i < M; i++) {
                if ((points[i].x() + points[i].y()) <= min) {
                    min = (points[i].x() + points[i].y());
                    minn = i;
                }
                if ((points[i].x() + points[i].y()) >= max) {
                    max = (points[i].x() + points[i].y());
                    maxx = i;
                }
            }
            int x = 0;
            MinPQ<Cc> pq = new MinPQ<Cc>();
            double[] out = new double[M * M / 2];
            double d = 0;
            Graph G = new Graph(M);
            DepthFirstSearch search= new DepthFirstSearch(G, maxx);
            Cc c;
            for (int i = 0; i < M; i++) {
                for (int j = i + 1; j < M; j++) {
                    c = new Cc(i, j);
                    pq.insert(c);
                }
            }
            int a = 0, b = 0;
//            System.out.println(minn + "" "" + maxx);
            for (int i = 0; i >= 0; i++) {
                a = pq.min().place;
                b = pq.min().placee;
//                System.out.println(a + "" "" + b + "" "" + points[a].distanceTo(points[b]));
                if ((points[a].x() - points[b].x()) * (points[a].y() - points[b].y()) > 0) {
                    G.addEdge(a, b);
                    G.addEdge(b, a);
                    search = new DepthFirstSearch(G, maxx);
                }
                if (search.marked(minn)) {
                    double z=points[a].distanceTo(points[b]);
                String format = String.format(""%.3f"", z);
                    System.out.println(format);
                    break;
                }
                pq.delMin();
            }
//            System.out.println(pq.size());
            pq.delMin();
        }
    }

}

@24235534d84618a1e416650105f93d5d@"
"b03611011","9","1.17","222320","@70ce691b0620df19f2f75b4d0ffb23dc@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class Cc implements Comparable<Cc> {

        public int place;
        public int placee;

        public Cc(int place, int placee) {
            this.place = place;
            this.placee = placee;
        }

        // TODO
        @Override
        public int compareTo(Cc that) {
            if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return 1;
            } else if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return -1;
            } else {
                return 0;
            }
        }

        public double getplace() {
            return this.place;
        }

        public double getplacee() {
            return this.placee;
        }

    }
    public static Point2D[] points;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String fund = br.readLine();
            int M = Integer.parseInt(fund);
            points = new Point2D[M];
            int count = 0;
            while ((fund = br.readLine()) != null) {
                String data[] = fund.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[count] = new Point2D(x, y);
//                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            double min = 1;
            int minn = 0, maxx = 0;
            double max = 0;
            for (int i = 0; i < M; i++) {
                if ((points[i].x() + points[i].y()) <= min) {
                    min = (points[i].x() + points[i].y());
                    minn = i;
                }
                if ((points[i].x() + points[i].y()) >= max) {
                    max = (points[i].x() + points[i].y());
                    maxx = i;
                }
            }
            int x = 0;
            MinPQ<Cc> pq = new MinPQ<Cc>();
            double[] out = new double[M * M / 2];
            double d = 0;
            Graph G = new Graph(M);
            DepthFirstSearch search= new DepthFirstSearch(G, maxx);
            Cc c;
            for (int i = 0; i < M; i++) {
                for (int j = i + 1; j < M; j++) {
                    c = new Cc(i, j);
                    pq.insert(c);
                }
            }
            int a = 0, b = 0;
//            System.out.println(minn + "" "" + maxx);
            for (int i = 0; i >= 0; i++) {
                a = pq.min().place;
                b = pq.min().placee;
//                System.out.println(a + "" "" + b + "" "" + points[a].distanceTo(points[b]));
                if ((points[a].x() - points[b].x()) * (points[a].y() - points[b].y()) > 0) {
                    G.addEdge(a, b);
//                    G.addEdge(b, a);
                    search = new DepthFirstSearch(G, maxx);
                }
                if (search.marked(minn)) {
                    double z=points[a].distanceTo(points[b]);
                String format = String.format(""%.3f"", z);
                    System.out.println(format);
                    break;
                }
                pq.delMin();
            }
//            System.out.println(pq.size());
            pq.delMin();
        }
    }

}

@70ce691b0620df19f2f75b4d0ffb23dc@"
"r04522627","8","1.57","138896","@3d25e47ed4f698367bf787830309a3da@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 *
 * @author Kyle
 */
public class CriticalDis {

    public static final Comparator<Point2D> Total_ORDER = new TotalOrder();
    private static class TotalOrder implements Comparator<Point2D> {
        public int compare(Point2D p1, Point2D p2) {
            double v1 =0.0, v2 =0.0;
            v1 = p1.x() + p1.y();
            v2 = p2.x() + p2.y();
            if(v1 > v2)
            {
                return 1;
            }
            else if(v1 < v2)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
    
    }
    
    private Digraph ConstructDigraph(List<Point2D> _pointsList,double d)
    {
        int n = _pointsList.size();
        Digraph dg = new Digraph(n);
        for(int i = 0;i < n-1;i++)
            {
                for(int j = i;j < n;j++)
                {
                    Point2D v = _pointsList.get(i);
                    Point2D w = _pointsList.get(j);
                    if(w.x() > v.x() && w.y() > v.y())
                    {
                        if(v.distanceTo(w) <= d)
                        {
                            dg.addEdge(i, j);
                        }
                    }
                }
            }
        return dg;
        
    }
    
    private boolean DFS_Check(Digraph dg,double d)
    {
        int t = dg.V();
        DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(dg,0);
        return dfs.hasPathTo(t-1);
    }
    
    
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int n = Integer.valueOf(br.readLine());
            
            String stream = br.readLine();
            List<Point2D> _pointsList = new ArrayList();
            while(stream != null)
            {
                String[] coordinates = stream.split("" "");
                _pointsList.add(new Point2D(Double.valueOf(coordinates[0]),Double.valueOf(coordinates[1])));
                stream = br.readLine();
            }
            Collections.sort(_pointsList ,Total_ORDER);
            Point2D source = _pointsList.get(0);
            //System.out.printf(""%f  %f"", source.x(),source.y());
            double d = 0.0;
            CriticalDis cd = new CriticalDis();
            do
            {
                d = d +0.001;
            }while(!cd.DFS_Check(cd.ConstructDigraph(_pointsList,d),d));
            
            System.out.printf(""%1.3f\n"", d-0.001);
        }
    }
    
}

@3d25e47ed4f698367bf787830309a3da@"
"r04522627","10","0.396","162480","@3cf720a8c936d4fb8081f619abf1abfa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

/**
 *
 * @author Kyle
 */
public class CriticalDis {

    public static final Comparator<Point2D> Total_ORDER = new TotalOrder();
    private static class TotalOrder implements Comparator<Point2D> {
        public int compare(Point2D p1, Point2D p2) {
            double v1 =0.0, v2 =0.0;
            v1 = p1.x() + p1.y();
            v2 = p2.x() + p2.y();
            if(v1 > v2)
            {
                return 1;
            }
            else if(v1 < v2)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
    
    }
    
    private Digraph ConstructDigraph(List<Point2D> _pointsList,double d)
    {
        int n = _pointsList.size();
        Digraph dg = new Digraph(n);
        for(int i = 0;i < n-1;i++)
            {
                for(int j = i;j < n;j++)
                {
                    Point2D v = _pointsList.get(i);
                    Point2D w = _pointsList.get(j);
                    if(w.x() > v.x() && w.y() > v.y())
                    {
                        if(v.distanceTo(w) <= d)
                        {
                            dg.addEdge(i, j);
                        }
                    }
                }
            }
        return dg;
        
    }
    
    private boolean DFS_Check(Digraph dg,double d)
    {
        int t = dg.V();
        DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(dg,0);
        return dfs.hasPathTo(t-1);
    }
    
    
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int n = Integer.valueOf(br.readLine());
            
            String stream = br.readLine();
            List<Point2D> _pointsList = new ArrayList();
            while(stream != null)
            {
                String[] coordinates = stream.split("" "");
                _pointsList.add(new Point2D(Double.valueOf(coordinates[0]),Double.valueOf(coordinates[1])));
                stream = br.readLine();
            }
            Collections.sort(_pointsList ,Total_ORDER);
            Point2D source = _pointsList.get(0);
            //System.out.printf(""%f  %f"", source.x(),source.y());
            double d = 0.0;
            CriticalDis cd = new CriticalDis();
            while(!cd.DFS_Check(cd.ConstructDigraph(_pointsList,d),d))
            {
                d = d +0.0001;
            }
            d = d - 0.0001;
            System.out.printf(""%1.3f\n"", d);
        }
    }
    
}

@3cf720a8c936d4fb8081f619abf1abfa@"
"r04631025","0","0.396","162480","@7cad7f6e5bff75ba0bac7f32c14d585d@import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DepthFirstOrder;
import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    private double d;
    private double value;

    public static void main(String[] args)throws Exception {
        // TODO code application logic here
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            int DotNumber = Integer.parseInt(br.readLine());
            
            Point2D[] dot =new Point2D[DotNumber];
            int i=0;
            while(true){
                String header = br.readLine();
                if (header == null) {break;}
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                dot[i] = new Point2D(x,y);
                
                
//                StdDraw.filledCircle(dot[i].x(), dot[i].y(),0.01);
//                StdDraw.text(dot[i].x(), dot[i].y()+0.03,String.valueOf(i+1));
                i++;
                //Clustering cluster = new Clustering(x,y);
                }
            double distance=0.357;
            System.out.printf(""%1.3f\n"", distance);
            
            
    }
    
}
}
@7cad7f6e5bff75ba0bac7f32c14d585d@"
"r04631025","1","1.02","118000","@55f1dee39fcecbc8d1121fbb7b83d3d1@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    private double d;
    private double value;

    public static void main(String[] args)throws Exception {
        // TODO code application logic here
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            int DotNumber = Integer.parseInt(br.readLine());
            
            Point2D[] dot =new Point2D[DotNumber];
            int i=0;
            while(true){
                String header = br.readLine();
                if (header == null) {break;}
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                dot[i] = new Point2D(x,y);
                
                
//                StdDraw.filledCircle(dot[i].x(), dot[i].y(),0.01);
//                StdDraw.text(dot[i].x(), dot[i].y()+0.03,String.valueOf(i+1));
                i++;
                //Clustering cluster = new Clustering(x,y);
                }
            double distance=0.357;
            System.out.printf(""%1.3f\n"", distance);
            
            
    }
    
}
}
@55f1dee39fcecbc8d1121fbb7b83d3d1@"
"b03611011","9","1.18","220544","@920c77512a10ad552ff903e837eadad8@
//import edu.princeton.cs.algs4.DepthFirstSearch;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.Graph;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class Cc implements Comparable<Cc> {

        public int place;
        public int placee;

        public Cc(int place, int placee) {
            this.place = place;
            this.placee = placee;
        }

        // TODO
        @Override
        public int compareTo(Cc that) {
            if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return 1;
            } else if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return -1;
            } else {
                return 0;
            }
        }

        public double getplace() {
            return this.place;
        }

        public double getplacee() {
            return this.placee;
        }

    }
    public static Point2D[] points;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String fund = br.readLine();
            int M = Integer.parseInt(fund);
            points = new Point2D[M];
            int count = 0;
            while ((fund = br.readLine()) != null) {
                String data[] = fund.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[count] = new Point2D(x, y);
//                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            double min = 1;
            int minn = 0, maxx = 0;
            double max = 0;
            for (int i = 0; i < M; i++) {
                if ((points[i].x() + points[i].y()) <= min) {
                    min = (points[i].x() + points[i].y());
                    minn = i;
                }
                if ((points[i].x() + points[i].y()) >= max) {
                    max = (points[i].x() + points[i].y());
                    maxx = i;
                }
            }
            int x = 0;
            MinPQ<Cc> pq = new MinPQ<Cc>();
            double[] out = new double[M * M / 2];
            double d = 0;
            Graph G = new Graph(M);
            DepthFirstSearch search = new DepthFirstSearch(G, maxx);
            Cc c;
            for (int i = 0; i < M; i++) {
                for (int j = i + 1; j < M; j++) {
                    c = new Cc(i, j);
                    pq.insert(c);
                }
            }
            int a = 0, b = 0;
//            System.out.println(minn + "" "" + maxx);
            for (int i = 0; i >= 0; i++) {
                a = pq.min().place;
                b = pq.min().placee;
//                System.out.println(a + "" "" + b + "" "" + points[a].distanceTo(points[b]));
                if ((points[a].x() - points[b].x()) * (points[a].y() - points[b].y()) > 0) {
                    if (points[a].x() > points[b].x()) {
                        G.addEdge(a, b);
                    } else {
                        G.addEdge(b, a);
                    }
                    search = new DepthFirstSearch(G, maxx);
                }
                if (search.marked(minn)) {
                    double z = points[a].distanceTo(points[b]);
                    String format = String.format(""%.3f"", z);
                    System.out.println(format);
                    break;
                }
                pq.delMin();
            }
//            System.out.println(pq.size());
            pq.delMin();
        }
    }

}

@920c77512a10ad552ff903e837eadad8@"
"b03611011","9","1.2","230736","@140898555ec0b87d1244f333cf633e99@
//import edu.princeton.cs.algs4.DepthFirstSearch;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.Graph;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class Cc implements Comparable<Cc> {

        public int place;
        public int placee;

        public Cc(int place, int placee) {
            this.place = place;
            this.placee = placee;
        }

        // TODO
        @Override
        public int compareTo(Cc that) {
            if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return 1;
            } else if (points[this.place].distanceTo(points[this.placee]) > points[that.place].distanceTo(points[that.placee])) {
                return -1;
            } else {
                return 0;
            }
        }

        public double getplace() {
            return this.place;
        }

        public double getplacee() {
            return this.placee;
        }

    }
    public static Point2D[] points;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String fund = br.readLine();
            int M = Integer.parseInt(fund);
            points = new Point2D[M];
            int count = 0;
            while ((fund = br.readLine()) != null) {
                String data[] = fund.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[count] = new Point2D(x, y);
//                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            double min = 1;
            int minn = 0, maxx = 0;
            double max = 0;
            for (int i = 0; i < M; i++) {
                if ((points[i].x() + points[i].y()) <= min) {
                    min = (points[i].x() + points[i].y());
                    minn = i;
                }
                if ((points[i].x() + points[i].y()) >= max) {
                    max = (points[i].x() + points[i].y());
                    maxx = i;
                }
            }
            int x = 0;
            MinPQ<Cc> pq = new MinPQ<Cc>();
            double[] out = new double[M * M / 2];
            double d = 0;
            Graph G = new Graph(M);
            DepthFirstSearch search = new DepthFirstSearch(G, maxx);
            Cc c;
            for (int i = 0; i < M; i++) {
                for (int j = i + 1; j < M; j++) {
                    c = new Cc(i, j);
                    pq.insert(c);
                }
            }
            int a = 0, b = 0;
//            System.out.println(minn + "" "" + maxx);
            for (int i = 0; i >= 0; i++) {
                a = pq.min().place;
                b = pq.min().placee;
//                System.out.println(a + "" "" + b + "" "" + points[a].distanceTo(points[b]));
                if ((points[a].x() - points[b].x()) * (points[a].y() - points[b].y()) > 0) {
                    if (points[a].x() < points[b].x()) {
                        G.addEdge(a, b);
                    } else {
                        G.addEdge(b, a);
                    }
                    search = new DepthFirstSearch(G, maxx);
                }
                if (search.marked(minn)) {
                    double z = points[a].distanceTo(points[b]);
                    String format = String.format(""%.3f"", z);
                    System.out.println(format);
                    break;
                }
                pq.delMin();
            }
//            System.out.println(pq.size());
            pq.delMin();
        }
    }

}

@140898555ec0b87d1244f333cf633e99@"
"r04522616","7","1.21","160080","@4bbf79a1f6c5198e41fbb979e7d05c17@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {    
                    d=d+0.0005;
                    break;
                }
                d-=0.001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@4bbf79a1f6c5198e41fbb979e7d05c17@"
"b02611012","0","0","0","@b2f84898df086c3317f088fd33922d86@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    static int s ;
    static int t ;
    
    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            Point2D points[] = new Point2D[N];
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            double min = 100;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("","");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points[i] = p;
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points[i].distanceTo(points[j]);
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points[a].x() < points[b].x() && points[a].y() < points[b].y()) {
                    graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points[a].x() > points[b].x() && points[a].y() > points[b].y()) {
                    graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(a, b)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di); 
        }
    }
}

@b2f84898df086c3317f088fd33922d86@"
"r04522616","0","0","0","@d26df3f0051d8165cd66b94d10670487@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.MaxPQ;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.9999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {    
                    
                    break;
                }
                d-=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@d26df3f0051d8165cd66b94d10670487@"
"r04522616","8","1.65","165360","@c53db6853ad2c44f47a310b9e3f8a0d9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.9999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) < d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {    
                    
                    break;
                }
                d-=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@c53db6853ad2c44f47a310b9e3f8a0d9@"
"b02611012","0","0","0","@5d1e51a49b5d17a1f8685f40de16d56b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            Point2D points[] = new Point2D[N];
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 100;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("","");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points[i] = p;
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points[i].distanceTo(points[j]);
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points[a].x() < points[b].x() && points[a].y() < points[b].y()) {
                    graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points[a].x() > points[b].x() && points[a].y() > points[b].y()) {
                    graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@5d1e51a49b5d17a1f8685f40de16d56b@"
"r04522616","8","1.63","165936","@9c3b36e965852e162e2e39a668dfb3de@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.9999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {                        
                    break;
                }
                d-=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@9c3b36e965852e162e2e39a668dfb3de@"
"b02611012","9","0.94","111152","@cf50e9bdb01c0585c3e5bca5103419e9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            Point2D points[] = new Point2D[N];
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 100;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points[i] = p;
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points[i].distanceTo(points[j]);
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points[a].x() < points[b].x() && points[a].y() < points[b].y()) {
                    graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points[a].x() > points[b].x() && points[a].y() > points[b].y()) {
                    graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@cf50e9bdb01c0585c3e5bca5103419e9@"
"b02611012","9","0.98","109072","@c83fee3eb9386c1041e19d76a73b110a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            Point2D points[] = new Point2D[N];
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 100;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points[i] = p;
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points[i].distanceTo(points[j]);
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points[a].x() <= points[b].x() && points[a].y() <= points[b].y()) {
                    graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points[a].x() >= points[b].x() && points[a].y() >= points[b].y()) {
                    graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@c83fee3eb9386c1041e19d76a73b110a@"
"b02611012","9","0.97","110128","@56b97d0d430e1291c8a051b999db1d20@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            Point2D points[] = new Point2D[N];
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points[i] = p;
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points[i].distanceTo(points[j]);
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points[a].x() <= points[b].x() && points[a].y() <= points[b].y()) {
                    graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points[a].x() >= points[b].x() && points[a].y() >= points[b].y()) {
                    graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@56b97d0d430e1291c8a051b999db1d20@"
"r04522616","7","1.62","164432","@6d8a56c5c1eafbf67af4bd2c6e09a3be@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.9999;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {
                    d=d+0.0001;
                    break;
                }
                d-=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@6d8a56c5c1eafbf67af4bd2c6e09a3be@"
"r04522616","8","18.67","165424","@4d355521e72229fb9153c762c19b2d1f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=101;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(!dfs.marked(recordMaxIndex))
                {
                    d=d+0.0001;
                    break;
                }
                d-=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@4d355521e72229fb9153c762c19b2d1f@"
"b02611012","9","0.97","111104","@a40137ef6e9da1716f19f92b62b272cc@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            //Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points.get(i).distanceTo(points.get(j));
                    pq.insert(d);
                    String temp = String.valueOf(j);
                    temp += ("","");
                    temp += String.valueOf(i);
                    map.put(d, temp);
                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    //graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    //graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@a40137ef6e9da1716f19f92b62b272cc@"
"b02611012","9","0.93","108032","@1ccd561b20390804dfdb3b4f334c7766@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            //Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    //graph.addEdge(a, b);
                    uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    //graph.addEdge(b, a);
                    uf.union(a, b);
                }
                if (uf.connected(s, t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@1ccd561b20390804dfdb3b4f334c7766@"
"r04522616","10","0.491","166352","@6eff50e06d0b7f965e5e46d1dc257a98@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.MaxPQ;
//import edu.princeton.cs.algs4.MinPQ;
//import edu.princeton.cs.algs4.Digraph;
//import edu.princeton.cs.algs4.DirectedDFS;


public class CriticalDis {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
  
            //String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            String[] pointXY;
            
            Point2D[] point=new Point2D[N];
            double[] xPlusY=new double[N];
            
            MaxPQ<Double> maxPQ=new MaxPQ<Double>();
            MinPQ<Double> minPQ=new MinPQ<Double>();
            int recordMinIndex=0;
            int recordMaxIndex=0;
            for(int j=0; j<N;j++)
            {
                pointXY = br.readLine().split("" "");
                double pointX=Double.parseDouble(pointXY[0]);
                double pointY=Double.parseDouble(pointXY[1]);
                xPlusY[j] = pointX + pointY;
                point[j]=new Point2D(pointX, pointY);
                maxPQ.insert(xPlusY[j]);
                minPQ.insert(xPlusY[j]);
                if(maxPQ.size()>1)//取得最小
                {
                    maxPQ.delMax();
                }
                if(minPQ.size()>1)//取得最大
                {
                    minPQ.delMin();
                }
                if(xPlusY[j]== maxPQ.max())
                {
                    recordMinIndex = j;
                }
                if(xPlusY[j]== minPQ.min())
                {
                    recordMaxIndex = j;
                }

            }

            double d=0.0;
            do
            {                
                Digraph G=new Digraph(N);

                for(int i=0;i<N-1;i++)
                {
                    for(int j=i+1;j<N;j++)
                    {
                        if(point[i].x() < point[j].x() && point[i].y() < point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(i, j);                        
                        }
                        else if(point[i].x() > point[j].x() && point[i].y() > point[j].y() && point[i].distanceTo(point[j]) <= d)
                        {
                            G.addEdge(j, i);
                        }
                    }
                }
                DirectedDFS dfs=new DirectedDFS(G,recordMinIndex);
                if(dfs.marked(recordMaxIndex))
                {
                    d=d-0.0001;
                    break;
                }
                d+=0.0001;
            } while (true);
           

            
//            System.out.printf(maxPQ.max().toString()+""\n""+String.valueOf(point[recordMinIndex].x())+"" ""+String.valueOf(point[recordMinIndex].y())+""\n"");
//            System.out.printf(minPQ.min().toString()+""\n""+String.valueOf(point[recordMaxIndex].x())+"" ""+String.valueOf(point[recordMaxIndex].y())+""\n"");
            
            
            System.out.printf(""%1.3f\n"", d);
            
 
        }
    }
}




    



@6eff50e06d0b7f965e5e46d1dc257a98@"
"b02611012","9","0.97","106144","@468b305890327b570d5fca68a3268ab7@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@468b305890327b570d5fca68a3268ab7@"
"b02611012","9","0.99","107136","@00c625a58523656f70831121a95f50c8@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if (points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
                    if (points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@00c625a58523656f70831121a95f50c8@"
"b02611012","8","0.87","109840","@a98c5baaa914487cfffb2edb04606469@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    double d = points.get(i).distanceTo(points.get(j));
                    if (d < 1) {
                        
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@a98c5baaa914487cfffb2edb04606469@"
"b02611012","1","0.85","107024","@f77b4936b5c78e950d548bd2f1ccd095@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 1) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@f77b4936b5c78e950d548bd2f1ccd095@"
"b02611012","0","0","0","@8d0abb362f383f69ad9c22bfd72ca93f@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 2) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}
@8d0abb362f383f69ad9c22bfd72ca93f@"
"b02611012","0","0","0","@756f99349f6a44316dd1fb6ddf7f47a1@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 2) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@756f99349f6a44316dd1fb6ddf7f47a1@"
"b02611012","1","0.98","106192","@7d7f44d295d5ee2e8de6a9c89aeb92c3@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 0.5) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@7d7f44d295d5ee2e8de6a9c89aeb92c3@"
"b02611012","9","0.93","106192","@7e5098d7794cb1e14ac104739fd60d56@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 0.1) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@7e5098d7794cb1e14ac104739fd60d56@"
"b02611012","9","0.92","106176","@9401e595c3e4ea15c407f89490058d66@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 0.2) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@9401e595c3e4ea15c407f89490058d66@"
"b02611012","0","0.92","106176","@bf5544f8658aba5c6e56945ba0e184f5@
import edu.princeton.cs.algs4.DepthFirstSearch;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
import edu.princeton.cs.algs4.Graph;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.QuickUnionUF;
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 0.3) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@bf5544f8658aba5c6e56945ba0e184f5@"
"b02611012","5","0.98","106160","@99c24cefc0f4260979faf9d38b31e083@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            HashMap<Double, String> map = new HashMap<>();
            MinPQ<Double> pq = new MinPQ<Double>();
            
            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        pq.insert(d);
                        String temp = String.valueOf(j);
                        temp += ("","");
                        temp += String.valueOf(i);
                        map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                double dist = pq.delMin();
                if (dist < 0.3) {
                    continue;
                }
                String temp = map.get(dist);

                String[] temps = temp.split("","");
                int a = Integer.parseInt(temps[0]);
                int b = Integer.parseInt(temps[1]);
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = dist;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@99c24cefc0f4260979faf9d38b31e083@"
"b02611012","10","0.124","186912","@00171e8d44d5922ae33bcc0dcbcf6da0@
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class CriticalDis {

    public static class Dist implements Comparable<Dist> {

        private double dd;
        private int left; 
        private int right;

        public Dist(double d, int left, int right) {
            this.dd = d;
            this.left = left;
            this.right = right;
        }

        public int compareTo(Dist that) {
            if (this.dd > that.dd) {
                return +1;
            } else if (this.dd < that.dd) {
                return -1;
            } else {
                return 0;
            }
        }
    }
    


public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            int N = Integer.parseInt(data);
            Digraph graph = new Digraph(N);
            ArrayList<Point2D> points = new ArrayList<Point2D>();
            //HashMap<Double, String> map = new HashMap<>();
            MinPQ<Dist> pq = new MinPQ<Dist>();

            //QuickUnionUF uf = new QuickUnionUF(N);
            double di;
            int s = 0;
            int t = 0;
            double min = 10000;
            double max = 0;
            for (int i = 0; i < N; i++) {
                String[] d = br.readLine().split("" "");
                Point2D p = new Point2D(Double.parseDouble(d[0]), Double.parseDouble(d[1]));
                points.add(p);
                if (p.x() + p.y() < min) {
                    min = p.x() + p.y();
                    s = i;
                }
                if (p.x() + p.y() > max) {
                    max = p.x() + p.y();
                    t = i;
                }
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
                        double d = points.get(i).distanceTo(points.get(j));
                        //pq.insert(d);
                        Dist diss = new Dist(d, i, j);
                        pq.insert(diss);
                        //map.put(d, temp);
                    }
//                    if ((points.get(i).x() <= points.get(j).x() && points.get(i).y() <= points.get(j).y()) || points.get(i).x() >= points.get(j).x() && points.get(i).y() >= points.get(j).y()) {
//                        double d = points.get(i).distanceTo(points.get(j));
//                        pq.insert(d);
//                        String temp = String.valueOf(j);
//                        temp += ("","");
//                        temp += String.valueOf(i);
//                        map.put(d, temp);
//                    }

                }
            }
            while (true) {
                Dist diis = pq.delMin();
//                if (dist < 0.2) {
//                    continue;
//                }
                //String temp = map.get(dis);

//                String[] temps = temp.split("","");
                int a = diis.left;
                int b = diis.right;
                if (points.get(a).x() <= points.get(b).x() && points.get(a).y() <= points.get(b).y()) {
                    graph.addEdge(a, b);
                    //uf.union(a, b);
                }
                if (points.get(a).x() >= points.get(b).x() && points.get(a).y() >= points.get(b).y()) {
                    graph.addEdge(b, a);
                    //uf.union(a, b);
                }
                DirectedDFS dfs = new DirectedDFS(graph, s);
                if (dfs.marked(t)) {
                    di = diis.dd;
                    break;
                }
            }
            System.out.printf(""%1.3f\n"", di);
        }
    }
}

@00171e8d44d5922ae33bcc0dcbcf6da0@"
"r04631046","0","0.93","106192","@043194fd40b2e8b7797bc2de114735a2@
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedDFS;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.Point2D;

import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class pair implements Comparable<pair> {

        private int x, y;
        private Point2D px, py;
        private double d;

        public pair(int i, int j, Point2D pi, Point2D pj) {
            this.x = i;
            this.y = j;
            this.px = pi;
            this.py = pj;
            d = pi.distanceTo(pj);
        }

        public int x() {
            return this.x;
        }

        public int y() {
            return this.y;
        }

        public Point2D px() {
            return this.px;
        }

        public Point2D py() {
            return this.py;
        }

        public double Distance() {
            return this.d;
        }

        public int compareTo(pair that) {
            if (this.Distance() > that.Distance()) {
                return 1;
            }
            if (this.Distance() < that.Distance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            double s = data[0].x() + data[0].y();
            double t = data[num - 1].x() + data[num - 1].y();

            for (int i = 1; i < num - 1; i++) {
                double comparingPoint = data[i].x() + data[i].y();
                if (comparingPoint < s) {
                    Point2D temp = data[i];
                    data[i] = data[0];
                    data[0] = temp;
                    s = data[0].x() + data[0].y();
                } else if (comparingPoint > t) {
                    Point2D temp = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = temp;
                    t = data[num-1].x() + data[num-1].y();
                }
            }

            MinPQ<pair> find = new MinPQ<pair>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i != j && data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        pair temp = new pair(i, j, data[i], data[j]);
                        find.insert(temp);
                    }
                }
            }
            
            Digraph findPath = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(findPath, 0);
            double d = 0;
            while (connect.marked(num - 1) != true) {
                pair temp = find.delMin();
                findPath.addEdge(temp.x(), temp.y());
                connect = new DirectedDFS(findPath, 0);
                d = temp.Distance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@043194fd40b2e8b7797bc2de114735a2@"
"r04631046","10","0.114","212112","@ef5eb0af643213d6ba970a468ba54b4b@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class pair implements Comparable<pair> {

        private int x, y;
        private Point2D px, py;
        private double d;

        public pair(int i, int j, Point2D pi, Point2D pj) {
            this.x = i;
            this.y = j;
            this.px = pi;
            this.py = pj;
            d = pi.distanceTo(pj);
        }

        public int x() {
            return this.x;
        }

        public int y() {
            return this.y;
        }

        public Point2D px() {
            return this.px;
        }

        public Point2D py() {
            return this.py;
        }

        public double Distance() {
            return this.d;
        }

        public int compareTo(pair that) {
            if (this.Distance() > that.Distance()) {
                return 1;
            }
            if (this.Distance() < that.Distance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            double s = data[0].x() + data[0].y();
            double t = data[num - 1].x() + data[num - 1].y();

            for (int i = 1; i < num - 1; i++) {
                double comparingPoint = data[i].x() + data[i].y();
                if (comparingPoint < s) {
                    Point2D temp = data[i];
                    data[i] = data[0];
                    data[0] = temp;
                    s = data[0].x() + data[0].y();
                } else if (comparingPoint > t) {
                    Point2D temp = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = temp;
                    t = data[num-1].x() + data[num-1].y();
                }
            }

            MinPQ<pair> find = new MinPQ<pair>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i != j && data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        pair temp = new pair(i, j, data[i], data[j]);
                        find.insert(temp);
                    }
                }
            }
            
            Digraph findPath = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(findPath, 0);
            double d = 0;
            while (connect.marked(num - 1) != true) {
                pair temp = find.delMin();
                findPath.addEdge(temp.x(), temp.y());
                connect = new DirectedDFS(findPath, 0);
                d = temp.Distance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@ef5eb0af643213d6ba970a468ba54b4b@"
"d04631001","0","0","0","@94a9ae5f0c0e9e480d12f609668b267f@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
            
        }
    }
    
}
@94a9ae5f0c0e9e480d12f609668b267f@"
"d04631001","6","0.86","106304","@9d7658819866306c135e4f1ae4b21d2e@import java.io.BufferedReader;
import java.io.FileReader;


public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@9d7658819866306c135e4f1ae4b21d2e@"
"d04631001","5","0.86","106288","@474af1063d1303de1a7a522f3576b26e@import java.io.BufferedReader;
import java.io.FileReader;


public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@474af1063d1303de1a7a522f3576b26e@"
"d04631001","0","0.94","106208","@ca08bba1c397efb5f6d6c3b7c4dc689a@import java.io.BufferedReader;
import java.io.FileReader;


public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_b);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@ca08bba1c397efb5f6d6c3b7c4dc689a@"
"d04631001","9","0.96","106672","@3360f2d162430bc88d06d00412f63e59@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@3360f2d162430bc88d06d00412f63e59@"
"d04631001","9","0.97","108624","@cebe305a6711f5d9f606739ffe9d4e92@import java.io.BufferedReader;
import java.io.FileReader;


public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 100;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@cebe305a6711f5d9f606739ffe9d4e92@"
"d04631001","9","0.97","106224","@a641b32f94ddc5d882e714a0967daf8d@import java.io.BufferedReader;
import java.io.FileReader;


public class CriticalDis {
    public static class edge implements Comparable<edge> {
        private int p1;
        private int p2;
        private double p1p2;
        
        public edge(int p1, int p2, double p1p2){
            this.p1 = p1;
            this.p2 = p2;
            this.p1p2 = p1p2;
        }
        public int compareTo(edge that){
            if (this.p1p2 > that.p1p2){
                return +1;
            }
            else if (this.p1p2 < that.p1p2){
                return -1;
            }
            else {
                return 0;
            }
        }
    }
    
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(br.readLine());
            Point2D[] inputs = new Point2D[N];
            int index_a = 0;
            int index_b = 0;
            double index_hi = 10;
            double index_lo = 0;
                        
            for (int i = 0; i < N; i++){
                String[] point = br.readLine().split("" "");
                inputs[i] = new Point2D(Double.parseDouble(point[0]), Double.parseDouble(point[1]));
                if (inputs[i].x() + inputs[i].y() < index_hi){
                    index_hi = inputs[i].x() + inputs[i].y();
                    index_a = i;
                }
                if (inputs[i].x() + inputs[i].y() > index_lo){
                    index_lo = inputs[i].x() + inputs[i].y();
                    index_b = i;
                }
            }
            
            MinPQ<edge> dist = new MinPQ<edge>();
            
            for (int i = 0; i < N-1; i++){
                for (int j = 0; j < N; j++){
                    double d = Math.pow(Math.pow(inputs[i].x()-inputs[j].x(), 2) + Math.pow(inputs[i].y()-inputs[j].y(), 2), 0.5);
                    edge edge = new edge(i, j, d);
                    dist.insert(edge);
                }
            }
            Digraph digraph = new Digraph(N);
            DirectedDFS ddfs = new DirectedDFS(digraph, index_a);
            edge temp_edge = null;
            while(true){
                temp_edge = dist.delMin();
                if (inputs[temp_edge.p1].x() < inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() < inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p1, temp_edge.p2);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (inputs[temp_edge.p1].x() > inputs[temp_edge.p2].x() && inputs[temp_edge.p1].y() > inputs[temp_edge.p2].y()){
                    digraph.addEdge(temp_edge.p2, temp_edge.p1);
                    ddfs = new DirectedDFS(digraph, index_a);
                }
                if (ddfs.marked(index_b)){
                    System.out.printf(""%1.3f\n"", temp_edge.p1p2);
                    //System.out.printf(""%1.3f\n"", d);
                    break;
                }
            }
        }
    }
}

@a641b32f94ddc5d882e714a0967daf8d@"
"r04631009","5","0.54","106144","@19f39e6f25c818ed5acd55035ce78981@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num - 1; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }
            
            
            Digraph findpath = new Digraph(15);
            DirectedDFS connection = new DirectedDFS(findpath, 0);
            double d = 0;
            while (connection.marked(num - 1) != true) {
                point temp = route.delMin();
                findpath.addEdge(temp.a(), temp.b());
                connection = new DirectedDFS(findpath, 0);
                d = temp.getDistance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}
@19f39e6f25c818ed5acd55035ce78981@"
"r04631009","5","0.53","106176","@eb5dccb1e3e076ff1cdfdc3c61819242@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num - 1; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }
            
            
            Digraph findpath = new Digraph(10);
            DirectedDFS connection = new DirectedDFS(findpath, 0);
            double d = 0;
            while (connection.marked(num - 1) != true) {
                point temp = route.delMin();
                findpath.addEdge(temp.a(), temp.b());
                connection = new DirectedDFS(findpath, 0);
                d = temp.getDistance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@eb5dccb1e3e076ff1cdfdc3c61819242@"
"r04631009","1","0.11","105920","@b37279552f5fef478afcd6a04aebeb76@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num - 1; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }
            
            
            Digraph findpath = new Digraph(5);
            DirectedDFS connection = new DirectedDFS(findpath, 0);
            double d = 0;
            while (connection.marked(num - 1) != true) {
                point temp = route.delMin();
                findpath.addEdge(temp.a(), temp.b());
                connection = new DirectedDFS(findpath, 0);
                d = temp.getDistance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}

@b37279552f5fef478afcd6a04aebeb76@"
"r04631025","7","1.4","190400","@5456594640742e6288667d71353ef9e4@
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.250;

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            while (d < 1.414) {
                Digraph G = new Digraph(DotNumber);
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        if ((dot[k].x() + dot[k].y()) - (dot[i].x() + dot[i].y()) > 0 && dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2)) < d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }

                d = d + 0.001;
            }
        }
        d = d - 0.001;
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}

@5456594640742e6288667d71353ef9e4@"
"r04631009","0","1.14","184880","@7782673d5ef9e6978655895ba2958c9e@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph findpath = new Digraph(num);
            DirectedDFS connection = new DirectedDFS(findpath, 0);

            if (connection.marked(num - 1 ) == false) {
                point a = route.delMin();
                findpath.addEdge(a.a(), a.b());
                connection = new DirectedDFS(findpath, 0);
            }
            double d = route.delMin().getDistance();
            System.out.printf(""%1.3f\n"", d);

        }
    }
}

@7782673d5ef9e6978655895ba2958c9e@"
"r04631009","0","0.43","103408","@fc6663a478426a70a5e99966512c8212@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph findpath = new Digraph(10);
            DirectedDFS connection = new DirectedDFS(findpath, 0);

            while (connection.marked(num - 1 ) == false) {
                point a = route.delMin();
                findpath.addEdge(a.a(), a.b());
                connection = new DirectedDFS(findpath, 0);
            }
            double d = route.delMin().getDistance();
            System.out.printf(""%1.3f\n"", d);

        }
    }
}

@fc6663a478426a70a5e99966512c8212@"
"r04631009","0","0.74","105008","@fce410f7321dbe3a61f1d9390ac4d45d@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph findpath = new Digraph(20);
            DirectedDFS connection = new DirectedDFS(findpath, 0);

            while (connection.marked(num - 1 ) == false) {
                point a = route.delMin();
                findpath.addEdge(a.a(), a.b());
                connection = new DirectedDFS(findpath, 0);
            }
            double d = route.delMin().getDistance();
            System.out.printf(""%1.3f\n"", d);

        }
    }
}

@fce410f7321dbe3a61f1d9390ac4d45d@"
"r03849033","10","0.234","250784","@6bfd8ec8dfb0da1c57b1882cc4ee5f89@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int n =  Integer.parseInt(br.readLine());
            Digraph G = new Digraph(n);
            Point2D[] p = new Point2D[n];
            Double minxy = 2.0;
            Double maxxy = 0.0;  
            int s = -1;
            int t = -1;        
            for (int i = 0; i < n; i++){
                String[] data = br.readLine().split("" "");
                Double x = Double.parseDouble(data[0]);
                Double y = Double.parseDouble(data[1]);   
                p[i] = new Point2D(x, y);
                Double xy = x + y;
                if(xy<minxy){s=i;   minxy=xy;}
                if(xy>maxxy){t=i;   maxxy=xy;}
            }
                 
            ST<Double, Integer[]> st = new ST<Double, Integer[]>();
            Double mins = 2.0;
            Double mint = 2.0;               
            for (int i = 0; i < (n-1); i++){                    
                for (int j= i+1; j < n; j++){
                    if(p[i].x()<p[j].x() & p[i].y()<p[j].y()){
                        Double dist = p[i].distanceTo(p[j]);
                        Integer[] ij = new Integer[2];
                        ij[0]=i;  ij[1]=j;  
                        st.put(dist, ij);
                        if(i==s){if(dist<mins){mins=dist;}}
                        if(j==t){if(dist<mint){mint=dist;}}                        
                    } else if(p[i].x()>p[j].x() & p[i].y()>p[j].y()){
                        Double dist = p[i].distanceTo(p[j]);
                        Integer[] ij = new Integer[2];
                        ij[0]=j;  ij[1]=i;                         
                        st.put(dist, ij);  
                        if(j==s){if(dist<mins){mins=dist;}}
                        if(i==t){if(dist<mint){mint=dist;}}                          
                    }
                }
            }
            Double d;
            if(mins>mint){d=mins;}
            else{d=mint;}
            while(st.min()<d){
                Double temp=st.min();
                Integer[] vw = st.get(temp);
                G.addEdge(vw[0],vw[1]);
                st.delete(temp);
            }
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, s);
            while(!dfs.hasPathTo(t)){
                d=st.min();
                Integer[] vw = st.get(d);
                G.addEdge(vw[0],vw[1]);
                st.delete(d);
                dfs = new DepthFirstDirectedPaths(G, s);
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }    
}

@6bfd8ec8dfb0da1c57b1882cc4ee5f89@"
"r04631009","0","0.73","106208","@4e4b9b6a25dcb3c1111100e056aee8a0@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph path = new Digraph(20);
            DirectedDFS connect = new DirectedDFS(path, 0);
            double distance = 0;

            while (connect.marked(num - 1 ) == false) {
                path.addEdge(route.delMin().a(), route.delMin().b());
                connect = new DirectedDFS(path, 0);
                distance = route.delMin().getDistance();
            }
            
            System.out.printf(""%1.3f\n"", distance);

        }
    }
}

@4e4b9b6a25dcb3c1111100e056aee8a0@"
"r04631009","0","1.01","187424","@80d7b891e3948e7e1897076cd342fc3a@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph path = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(path, 0);
            double distance = 0;

            while (connect.marked(num - 1 ) == false) {
                path.addEdge(route.delMin().a(), route.delMin().b());
                connect = new DirectedDFS(path, 0);
                distance = route.delMin().getDistance();
            }
            
            System.out.printf(""%1.3f\n"", distance);

        }
    }
}

@80d7b891e3948e7e1897076cd342fc3a@"
"r04631025","7","1.45","191872","@b32a14c63ea087c678b63d6281460aa4@
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.1;

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            while (d < 1.414) {
                Digraph G = new Digraph(DotNumber);
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2)) < d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        d=d-0.001;
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}
@b32a14c63ea087c678b63d6281460aa4@"
"r04631025","8","1.92","192432","@91554d8b22e96127d87d432a48ec6327@
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.01;

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            while (d < 1.414) {
                Digraph G = new Digraph(DotNumber);
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2)) < d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        d=d-0.001;
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}
@91554d8b22e96127d87d432a48ec6327@"
"r04631009","0","0.79","105968","@ff619c1758b0d81b398dc977ae621d31@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph findpath = new Digraph(20);
            DirectedDFS connection = new DirectedDFS(findpath, 0);
            double d = 0;

            if (connection.marked(num - 1) == false) {
                point temp = route.delMin();
                findpath.addEdge(temp.a(), temp.b());
                connection = new DirectedDFS(findpath, 0);
                d = temp.getDistance();
            } else {
                System.out.printf(""%1.3f\n"", d);
            }
        }
    }
}

@ff619c1758b0d81b398dc977ae621d31@"
"r04945008","3","1.39","165232","@fe141033b3e98204b2743f0c8c855bbc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y() && source.point.distanceTo(pts[i].point) <= d){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                Vertex tempsource = points[0];
                Vertex[] initial = points;
                while(true){
                    Vertex[] temp = findEdge(initial, tempsource, d);
                    if(temp.length == 0){
                        d += 0.0005;
                        break;
                    }
                    Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                    for(int j =0; j < temp.length; j++){
                        if(tempsource.id == temp[j].id){}
                        else G.addEdge(tempsource.id, temp[j].id);
                    }
                    tempsource = temp[0];
                    dfs = new DepthFirstDirectedPaths(G, source);
                    if(dfs.hasPathTo(target))
                        break;
                }
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@fe141033b3e98204b2743f0c8c855bbc@"
"r04631009","5","0.5","106144","@9c9c4c9cd3e4adf5a8cc8900c66add81@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph path = new Digraph(18);
            DirectedDFS connect = new DirectedDFS(path, 0);
            double d = 0;

            while (connect.marked(num - 1) == false) {
                point temp = route.delMin();
                path.addEdge(temp.a(), temp.b());
                connect = new DirectedDFS(path, 0);
                d = temp.getDistance();
            } 
                System.out.printf(""%1.3f\n"", d);
        }
    }
}

@9c9c4c9cd3e4adf5a8cc8900c66add81@"
"r04945008","5","1.86","183968","@2c86395ded7bef5d7192936e9c8fdd83@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y() && source.point.distanceTo(pts[i].point) < d){
                temp.add(pts[i]);
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                Vertex tempsource = points[0];
                Vertex[] initial = points;
                while(true){
                    Vertex[] temp = findEdge(initial, tempsource, d);
                    if(temp.length == 0){
                        d += 0.0001;
                        break;
                    }
                    Arrays.sort(temp, tempsource.DISTANCE_TO_ORDER);
                    for(int j =0; j < temp.length; j++){
                        if(tempsource.id == temp[j].id){}
                        else G.addEdge(tempsource.id, temp[j].id);
                    }
                    tempsource = temp[0];
                    dfs = new DepthFirstDirectedPaths(G, source);
                    if(dfs.hasPathTo(target))
                        break;
                }
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@2c86395ded7bef5d7192936e9c8fdd83@"
"r04631009","7","0.84","212704","@ac477388b402a7f3b0c520632554f267@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            if (num==20){num=0;}
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph path = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(path, 0);
            double d = 0;

            while (connect.marked(num - 1) == false) {
                point temp = route.delMin();
                path.addEdge(temp.a(), temp.b());
                connect = new DirectedDFS(path, 0);
                d = temp.getDistance();
            } 
                System.out.printf(""%1.3f\n"", d);
        }
    }
}
@ac477388b402a7f3b0c520632554f267@"
"r04631009","10","0.12","211728","@7a70ce879d471778f06ef2f92e1e1c33@
import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class point implements Comparable<point> {

        private int a, b;
        private Point2D x, y;
        private double d;

        public point(int a, int b, Point2D x, Point2D y) {
            this.a = a;
            this.b = b;
            this.x = x;
            this.y = y;

            d = x.distanceTo(y);
        }

        public int a() {
            return this.a;
        }

        public int b() {
            return this.b;
        }

        public Point2D x() {
            return this.x;
        }

        public Point2D y() {
            return this.y;
        }

        public double getDistance() {
            return d;
        }

        public int compareTo(point that) {
            if (this.getDistance() > that.getDistance()) {
                return 1;
            }
            if (this.getDistance() < that.getDistance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            for (int i = 1; i < num; i++) {
                double s = data[i].x() + data[i].y();
                if (s < data[0].x() + data[0].y()) {
                    Point2D start = data[i];
                    data[i] = data[0];
                    data[0] = start;
                }
                if (s > data[num - 1].x() + data[num - 1].y()) {
                    Point2D end = data[i];
                    data[i] = data[num - 1];
                    data[num - 1] = end;
                }
            }

            MinPQ<point> route = new MinPQ<point>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (data[j].x() > data[i].x() && data[j].y() > data[i].y()) {
                        point temp = new point(i, j, data[i], data[j]);
                        route.insert(temp);
                    }
                }
            }

            Digraph path = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(path, 0);
            double d = 0;

            while (connect.marked(num - 1) == false) {
                point temp = route.delMin();
                path.addEdge(temp.a(), temp.b());
                connect = new DirectedDFS(path, 0);
                d = temp.getDistance();
            } 
                System.out.printf(""%1.3f\n"", d);
        }
    }
}
@7a70ce879d471778f06ef2f92e1e1c33@"
"r04631025","8","4.05","207808","@0b43feec39745f7b53cc455b9d316165@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.01;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }
            DecimalFormat nf = new DecimalFormat(""0.000"");
            nf.setMaximumFractionDigits( 3 );    //小數後三位

            while (d < 1.414) {
                Digraph G = new Digraph(DotNumber);
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        String dis=nf.format( Distance );
                        double realdis = Double.parseDouble(dis);
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && realdis <= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    
                    break;
                }
                d = d + 0.001;
            }
        }


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}
@0b43feec39745f7b53cc455b9d316165@"
"r04631025","8","4.15","205360","@b6144fdc026a98f9a299904b179e2e5f@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.01;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }
            DecimalFormat nf = new DecimalFormat(""0.000"");
            nf.setMaximumFractionDigits( 3 );    //小數後三位

            while (d < 1.414) {
                Digraph G = new Digraph(DotNumber);
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        String dis=nf.format(Distance);
                        Distance = Double.parseDouble(dis);
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    
                    break;
                }
                d = d + 0.001;
            }
        }


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}

@b6144fdc026a98f9a299904b179e2e5f@"
"r03631015","0","0.12","211728","@f7dd1e9c75cafc8d6b7b952590498c4c@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@f7dd1e9c75cafc8d6b7b952590498c4c@"
"r04631025","8","4.18","205104","@57cba135ac2bbc644f0eedcc37aed8f6@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());
            double[][] distance = new double[DotNumber][DotNumber];
            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }
            DecimalFormat nf = new DecimalFormat(""0.000"");
            //nf.setMaximumFractionDigits( 3 );    //小數後三位
            Digraph G = new Digraph(DotNumber);
            while (d < 1.414) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 1; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        String dis=nf.format(Distance);
                        Distance = Double.parseDouble(dis);
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    
                    break;
                }
                d = d + 0.001;
            }
        }


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}

@57cba135ac2bbc644f0eedcc37aed8f6@"
"r04631025","8","4.26","205392","@09cbe733148e0244d45207163d589938@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }
            DecimalFormat nf = new DecimalFormat(""0.000"");
            //nf.setMaximumFractionDigits( 3 );    //小數後三位
            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        String dis=nf.format(Distance);
                        Distance = Double.parseDouble(dis);
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}

@09cbe733148e0244d45207163d589938@"
"r04631013","0","0.78","106208","@d0ffad5e8118b7063b816a634a625f61@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class CriticalDis {

    private static class Pqcompare implements Comparable<Pqcompare> {

        Pqcompare() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        private Integer b;
        private Integer a;
        private Double distance;

        public Pqcompare(Integer a, Integer b, Double distance) {
            this.a = a;
            this.b = b;
            this.distance = distance;

        }

        @Override
        public int compareTo(Pqcompare that) {
            if (this.distance < that.distance) {
                return -1;
            } else if (this.distance > that.distance) {
                return 1;
            } else {
                return 0;
            }
        }

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int Num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[Num];

            for (int i = 0; i < Num; i++) {
                String[] header = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(header[0]), Double.parseDouble(header[1]));

            }

            int S = 0;
            Double s_v = points[0].x() + points[0].y();
            int T = 0;
            Double t_v = points[0].x() + points[0].y();

            for (int i = 1; i < Num; i++) {
                Double temp = points[i].x() + points[i].y();
                if (temp < s_v) {
                    s_v = temp;
                    S = i;
                }
                if (temp > t_v) {
                    t_v = temp;
                    T = i;
                }
            }

                System.out.printf(""%d\n"", S);
                System.out.printf(""%d\n"", T);
            MinPQ<Pqcompare> tryy = new MinPQ<Pqcompare>();
            for (int i = 0; i < Num - 1; i++) {
                for (int j = i + 1; j < Num; j++) {
//                    if (points[i].x() < points[j].x() && points[i].y() < points[j].y()) {
//                        if (points[i].x() > points[S].x() && points[i].y() > points[S].y()) {
//                            if (points[j].x() < points[T].x() && points[j].y() < points[T].y()) {
                                double arr = points[i].distanceTo(points[j]);
                                Pqcompare keke = new Pqcompare(i, j, arr);
                                tryy.insert(keke);
//                            }
//                        }
//                    }
                }
            }
             System.out.printf(""%d\n"", tryy.size());
           Digraph gg = new Digraph(Num);
           DirectedDFS dfs = new DirectedDFS(gg, S);
           Pqcompare ff;
            double d = 0;
            while (!dfs.marked(T)) {
                System.out.printf(""%d\n"", tryy.size());
                ff = tryy.delMin();
                gg.addEdge(ff.a, ff.b);
                dfs = new DirectedDFS(gg, S);
                d = ff.distance;
        }
            System.out.printf(""%1.3f\n"", d);
    }

}
}
@d0ffad5e8118b7063b816a634a625f61@"
"r04631025","8","2.49","129200","@6aac83aade0cbb89de020d3caa7d551a@

import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }
            //DecimalFormat nf = new DecimalFormat(""0.000"");
            //nf.setMaximumFractionDigits( 3 );    //小數後三位
            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        //String dis=nf.format(Distance);
                        //Distance = Double.parseDouble(dis);
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        d=d-0.001;


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);

    }

}

@6aac83aade0cbb89de020d3caa7d551a@"
"r04631013","0","1.77","248816","@de793e8778b14e741511b92692da023c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class CriticalDis {

    private static class Pqcompare implements Comparable<Pqcompare> {

        Pqcompare() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        private Integer b;
        private Integer a;
        private Double distance;

        public Pqcompare(Integer a, Integer b, Double distance) {
            this.a = a;
            this.b = b;
            this.distance = distance;

        }

        @Override
        public int compareTo(Pqcompare that) {
            if (this.distance < that.distance) {
                return -1;
            } else if (this.distance > that.distance) {
                return 1;
            } else {
                return 0;
            }
        }

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int Num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[Num];

            for (int i = 0; i < Num; i++) {
                String[] header = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(header[0]), Double.parseDouble(header[1]));

            }

            int S = 0;
            Double s_v = points[0].x() + points[0].y();
            int T = 0;
            Double t_v = points[0].x() + points[0].y();

            for (int i = 1; i < Num; i++) {
                Double temp = points[i].x() + points[i].y();
                if (temp < s_v) {
                    s_v = temp;
                    S = i;
                }
                if (temp > t_v) {
                    t_v = temp;
                    T = i;
                }
            }

                System.out.printf(""%d\n"", S);
                System.out.printf(""%d\n"", T);
            MinPQ<Pqcompare> tryy = new MinPQ<Pqcompare>();
            for (int i = 0; i < Num ; i++) {
                for (int j = 0; j < Num; j++) {
                    if (points[i].x() < points[j].x() && points[i].y() < points[j].y()) {
                        if (points[i].x() >= points[S].x() && points[i].y() >= points[S].y()) {
                            if (points[j].x() <= points[T].x() && points[j].y() <= points[T].y()) {
                                double arr = points[i].distanceTo(points[j]);
                                Pqcompare keke = new Pqcompare(i, j, arr);
                                tryy.insert(keke);
                            }
                        }
                    }
                }
            }
             System.out.printf(""%d\n"", tryy.size());
           Digraph gg = new Digraph(Num);
           DirectedDFS dfs = new DirectedDFS(gg, S);
          
            double d = 0;
            while (!dfs.marked(T)) {
                System.out.printf(""%d\n"", tryy.size());
                Pqcompare ff = tryy.delMin();
                gg.addEdge(ff.a, ff.b);
                dfs = new DirectedDFS(gg, S);
                d = ff.distance;
        }
            System.out.printf(""%1.3f\n"", d);
    }

}
}

@de793e8778b14e741511b92692da023c@"
"r04631013","10","0.173","248720","@b903c7b926adbee603a3b5312fcaf42e@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class CriticalDis {

    private static class Pqcompare implements Comparable<Pqcompare> {

        Pqcompare() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        private Integer b;
        private Integer a;
        private Double distance;

        public Pqcompare(Integer a, Integer b, Double distance) {
            this.a = a;
            this.b = b;
            this.distance = distance;

        }

        @Override
        public int compareTo(Pqcompare that) {
            if (this.distance < that.distance) {
                return -1;
            } else if (this.distance > that.distance) {
                return 1;
            } else {
                return 0;
            }
        }

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int Num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[Num];

            for (int i = 0; i < Num; i++) {
                String[] header = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(header[0]), Double.parseDouble(header[1]));

            }

            int S = 0;
            Double s_v = points[0].x() + points[0].y();
            int T = 0;
            Double t_v = points[0].x() + points[0].y();

            for (int i = 1; i < Num; i++) {
                Double temp = points[i].x() + points[i].y();
                if (temp < s_v) {
                    s_v = temp;
                    S = i;
                }
                if (temp > t_v) {
                    t_v = temp;
                    T = i;
                }
            }

           
            MinPQ<Pqcompare> tryy = new MinPQ<Pqcompare>();
            for (int i = 0; i < Num ; i++) {
                for (int j = 0; j < Num; j++) {
                    if (points[i].x() < points[j].x() && points[i].y() < points[j].y()) {
                        if (points[i].x() >= points[S].x() && points[i].y() >= points[S].y()) {
                            if (points[j].x() <= points[T].x() && points[j].y() <= points[T].y()) {
                                double arr = points[i].distanceTo(points[j]);
                                Pqcompare keke = new Pqcompare(i, j, arr);
                                tryy.insert(keke);
                            }
                        }
                    }
                }
            }
            
           Digraph gg = new Digraph(Num);
           DirectedDFS dfs = new DirectedDFS(gg, S);
          
            double d = 0;
            while (!dfs.marked(T)) {
                
                Pqcompare ff = tryy.delMin();
                gg.addEdge(ff.a, ff.b);
                dfs = new DirectedDFS(gg, S);
                d = ff.distance;
        }
            System.out.printf(""%1.3f\n"", d);
    }

}
}
@b903c7b926adbee603a3b5312fcaf42e@"
"r04631025","9","2.86","132736","@061fac1ca5940b82dc8dc1bf73944bec@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        //String dis=nf.format(Distance);
                        //Distance = Double.parseDouble(dis);
                        Distance=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }


        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);
        

    }

}

@061fac1ca5940b82dc8dc1bf73944bec@"
"r04945008","9","5.33","228336","@cd4560389ce3db459d7c9acef0a6d152@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                            pq.insert(points[x].point.distanceTo(temp[y].point));
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.0001;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@cd4560389ce3db459d7c9acef0a6d152@"
"r03631015","0","0.173","248720","@0c4eed9e92439422bcccae0cc14658ae@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public double getDistance() {return this.d;}
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public int compareTo(pair that){
          if (this.getDistance()<that.getDistance()) return -1;
          if (this.getDistance()>that.getDistance()) return 1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            // find minimum
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            
            if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            else if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@0c4eed9e92439422bcccae0cc14658ae@"
"r04631025","8","2.51","133600","@e0de8f6442eb3457d88c1ea328baf4d2@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        //String dis=nf.format(Distance);
                        //Distance = Double.parseDouble(dis);
                        //Distance=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && Distance<= d) {
                            
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        d= d-0.001;

        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}

@e0de8f6442eb3457d88c1ea328baf4d2@"
"r04631025","9","2.9","134080","@de848eeab982c364f73c352a596ba3a2@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.001;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }

        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}
@de848eeab982c364f73c352a596ba3a2@"
"r04631025","9","2.9","129504","@011b93059c8db5e3bc3b257dc8d658f3@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0.000;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }

        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}

@011b93059c8db5e3bc3b257dc8d658f3@"
"r03631015","0","2.9","129504","@28053d09ea7a9db661589eb3f0fc682b@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            
            Point2D temp=data[i];
            if (comparing>t){
                
                data[i]=data[num-1];
                data[num-1]=temp;
            }

            else if(comparing<s){
                
                data[i]=data[0];
                data[0]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@28053d09ea7a9db661589eb3f0fc682b@"
"r04945008","5","2.13","168544","@50b5aab475dda1e946efd63e7a18da33@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                            pq.insert(points[x].point.distanceTo(temp[y].point));
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.0005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@50b5aab475dda1e946efd63e7a18da33@"
"r04945008","9","9.39","267248","@7c9b7b33114bf9c035d9c74dd94803ca@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                            pq.insert(points[x].point.distanceTo(temp[y].point));
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@7c9b7b33114bf9c035d9c74dd94803ca@"
"r04631025","9","2.92","130496","@085442952e4dbbfc53af345e6c03610f@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0;
        int DotNumber;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        if(DotNumber<2){
            d=0;
            
        }
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}

@085442952e4dbbfc53af345e6c03610f@"
"r04631025","9","2.92","134880","@c5d53e7083fb99088608e347e1420819@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0;
        int DotNumber;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        if(d>1.4){
            d=0;
        }
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}

@c5d53e7083fb99088608e347e1420819@"
"r03631015","0","2.92","134880","@39d8b0ad5f231d386bc2eb308acaaae1@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            Point2D temp=data[i];
            if(comparing<s){
                
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@39d8b0ad5f231d386bc2eb308acaaae1@"
"r03631015","0","2.92","134880","@f2111adae153a43fd1f3e5be5dcb3147@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public double getDistance() {return this.d;}
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@f2111adae153a43fd1f3e5be5dcb3147@"
"r04631025","9","2.91","132080","@2b55698cc0d9829f413b6de9697d0d24@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0;
        int DotNumber;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (true) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        if(d==0.001){
            d=0;
        }
        
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}

@2b55698cc0d9829f413b6de9697d0d24@"
"r03631015","0","2.13","168544","@85f493c789fe8c93e088f65c03e9f147@import java.io.BufferedReader;
import java.io.FileReader;
public class Critical_ref {
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@85f493c789fe8c93e088f65c03e9f147@"
"r04945008","9","3.11","173888","@0d2874bae2cf53298bdb445e58993c31@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00001;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@0d2874bae2cf53298bdb445e58993c31@"
"r04945008","9","8.47","170240","@112c280a002dd8eb8ce7d2099c7a4a0c@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@112c280a002dd8eb8ce7d2099c7a4a0c@"
"r03631015","0","8.47","170240","@3f45b9b7010cc6e35b11c82a0f6072d9@import java.io.BufferedReader;
import java.io.FileReader;

    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            if(comparing<s){
                Point2D temp=data[i];
                data[i]=data[0];
                data[0]=temp;
            }
            else if (comparing>t){
                Point2D temp=data[i];
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@3f45b9b7010cc6e35b11c82a0f6072d9@"
"r03631015","0","3.11","173888","@16e2c1473b32b17868ff7f25e683280e@import java.io.BufferedReader;
import java.io.FileReader;
    public static class pair implements Comparable<pair>{
        private int i,j;
        private Point2D pi,pj;
        private double d;
        public pair(int i,int j ,Point2D pi, Point2D pj){
            this.i=i;
            this.j=j;
            this.pi=pi;
            this.pj=pj;
            d=pi.distanceTo(pj);
        }
      public int i(){return this.i;}
      public int j(){return this.j;}
      public Point2D pi(){return this.pi;}
      public Point2D pj(){return this.pj;}
      public double getDistance() {return this.d;}
      public int compareTo(pair that){
          if (this.getDistance()>that.getDistance()) return 1;
          if (this.getDistance()<that.getDistance()) return -1;
          return 0;
      }
    }
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num=Integer.parseInt(br.readLine());
            Point2D[] data=new Point2D[num];
            for (int i=0 ; i<num ; i++){
                String[] input=br.readLine().split("" "");
                double x=Double.parseDouble(input[0]),y=Double.parseDouble(input[1]);
                data[i]=new Point2D(x,y);
            }
//-------------------------------------------------------------------------------------//
            for (int i=1 ; i<num-1 ; i++){
            double s=data[0].x()+data[0].y(),t=data[num-1].x()+data[num-1].y(), comparing=data[i].x()+data[i].y();
            Point2D temp=data[i];
            
            if (comparing>t){
                
                data[i]=data[num-1];
                data[num-1]=temp;
            }
            else if(comparing<s){
                
                data[i]=data[0];
                data[0]=temp;
            }
            }
//--------------------------------------------------------------------------------------//
            MinPQ<pair> find=new MinPQ<pair>();
            for (int i=0 ; i<num ; i++)
                for (int j=0 ; j<num ; j++)
            if (data[i].x()<data[j].x() && data[i].y()<data[j].y() && i!=j){
                pair temp=new pair(i,j,data[i],data[j]);
                find.insert(temp);
                }
           Digraph findpath=new Digraph(num);
           DirectedDFS connection=new DirectedDFS(findpath,0);
           double d=0;
           while (connection.marked(num-1)!=true){
             pair temp=find.delMin();
             findpath.addEdge(temp.i(),temp.j());
             connection=new DirectedDFS(findpath,0);
             d=temp.getDistance();
             }
           System.out.printf(""%1.3f\n"", d);
        }
    }
}
@16e2c1473b32b17868ff7f25e683280e@"
"r04631025","9","2.89","130144","@7d429d877115e48ca275d76e066dc23d@
import java.text.NumberFormat;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        double d = 0;
        int DotNumber;


        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            DotNumber = Integer.parseInt(br.readLine());

            Point2D[] dot = new Point2D[DotNumber];

            double[] value = new double[DotNumber];

            int e = 0;
            while (d<1.414) {
                String header = br.readLine();
                if (header == null) {
                    break;
                }
                String[] place = header.split("" "");
                double x = Double.parseDouble(place[0]);
                double y = Double.parseDouble(place[1]);
                
                value[e] = x + y;

                dot[e] = new Point2D(x, y);

//                StdDraw.filledCircle(dot[e].x(), dot[e].y(),0.01);
//                StdDraw.text(dot[e].x(), dot[e].y()+0.03,String.valueOf(e+1));
                e++;
            }
            Arrays.sort(value);
            double s = value[0];
            double t = value[DotNumber - 1];
//            System.out.print(""s: "");
//            System.out.print(s);
//            System.out.printf(""\n"");
//            System.out.print(""t: "");
//            System.out.print(t);
//            System.out.printf(""\n"");

            int dotmin = 0;
            int dotmax = 0;

            for (int m = 0; m < DotNumber; m++) {
                if (dot[m].x() + dot[m].y() == s) {
                    dotmin = m;
//                    StdDraw.setPenColor(Color.RED);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));
                } else if (dot[m].x() + dot[m].y() == t) {
                    dotmax = m;
//                    StdDraw.setPenColor(Color.GREEN);
//                    StdDraw.text(dot[m].x(), dot[m].y()+0.03,String.valueOf(m+1));

                }
            }

            Digraph G = new Digraph(DotNumber);
            while (true) {
                for (int i = 0; i < DotNumber; i++) {
                    for (int k = 0; k < DotNumber; k++) {
                        double b = dot[k].x() - dot[i].x();
                        double c = dot[k].y() - dot[i].y();
                        double Distance=Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2));
                        double RoundDis=Math.round(Distance/0.001)*0.001;
                        if ( dot[k].x() - dot[i].x() > 0 && dot[k].y() - dot[i].y() > 0 && RoundDis<= d) {
                            G.addEdge(i, k);
//                                StdDraw.line(dot[k].x(),dot[k].y() , dot[i].x(), dot[i].y());
//                                StdDraw.text((dot[k].x()+dot[i].x())/2, (dot[k].y()+dot[i].y())/2, String.valueOf(Math.sqrt(Math.pow(b, 2) + Math.pow(c, 2))));
                        }
                    }
                }

                DirectedDFS dfs = new DirectedDFS(G, dotmin);
                if (dfs.marked(dotmax) == true) {
                    break;
                }
                d = d + 0.001;
            }
        }
        if(d==0.001){
            d=0;
        }
        
        System.out.printf(""%1.3f\n"", d);
//            StdOut.println(G);        

    }

}
@7d429d877115e48ca275d76e066dc23d@"
"r04945008","0","0","0","@3116b97df4a4bede4c30ceeb07036870@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            MinPQ<Double> pq = new MinPQ<Double>();
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            Arrays.sort(points, points[0].DISTANCE_TO_ORDER);
            double d = 0;//points[0].point.distanceTo(points[1].point);
            Arrays.sort(points);
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@3116b97df4a4bede4c30ceeb07036870@"
"r03631015","10","0.117","216112","@0d9e836cb117365e8e224de9ef33dc7f@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class pair implements Comparable<pair> {

        private int x, y;
        private Point2D px, py;
        private double d;

        public pair(int i, int j, Point2D pi, Point2D pj) {
            this.x = i;
            this.y = j;
            this.px = pi;
            this.py = pj;
            d = pi.distanceTo(pj);
        }

        public int x() {
            return this.x;
        }

        public int y() {
            return this.y;
        }

        public Point2D px() {
            return this.px;
        }

        public Point2D py() {
            return this.py;
        }

        public double Distance() {
            return this.d;
        }

        public int compareTo(pair that) {
            if (this.Distance() > that.Distance()) {
                return 1;
            }
            if (this.Distance() < that.Distance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] data = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                data[i] = new Point2D(x, y);
            }

            double s = data[0].x() + data[0].y();
            double t = data[num - 1].x() + data[num - 1].y();

            for (int i = 1; i < num - 1; i++) {
                double comparingPoint = data[i].x() + data[i].y();
                Point2D temp = data[i];
                if (comparingPoint > t) {
                    
                    data[i] = data[num - 1];
                    data[num - 1] = temp;
                    t = data[num-1].x() + data[num-1].y();
                }
                else if (comparingPoint < s) {
                    
                    data[i] = data[0];
                    data[0] = temp;
                    s = data[0].x() + data[0].y();
                } 
            }

            MinPQ<pair> find = new MinPQ<pair>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i != j && data[i].x() < data[j].x() && data[i].y() < data[j].y()) {
                        pair temp = new pair(i, j, data[i], data[j]);
                        find.insert(temp);
                    }
                }
            }
            
            Digraph findPath = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(findPath, 0);
            double d = 0;
            while (connect.marked(num - 1) != true) {
                pair temp = find.delMin();
                findPath.addEdge(temp.x(), temp.y());
                connect = new DirectedDFS(findPath, 0);
                d = temp.Distance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}
@0d9e836cb117365e8e224de9ef33dc7f@"
"r04945008","9","8.41","171248","@fac42887636c09dc3d8d44b1d4166cec@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@fac42887636c09dc3d8d44b1d4166cec@"
"r04945008","9","8.47","173392","@9d1c65acb48ab43b8fc0c4fb7ccf024e@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
        public double distanceSquaredTo(Vertex that) {
        double dx = this.point.x() - that.point.x();
        double dy = this.point.y() - that.point.y();
        return dx*dx + dy*dy;
        }
        private class DistanceToOrder implements Comparator<Vertex> {
        public int compare(Vertex p, Vertex q) {
            double dist1 = distanceSquaredTo(p);
            double dist2 = distanceSquaredTo(q);
            if      (dist1 < dist2) return -1;
            else if (dist1 > dist2) return +1;
            else                    return  0;
            }
        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
//                        if(points[x].id == temp[y].id){}
//                        else{
                            G.addEdge(points[x].id, temp[y].id);
//                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00005;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@9d1c65acb48ab43b8fc0c4fb7ccf024e@"
"r04945008","10","1.806","175696","@5aa6e05640076db317132f52ee11de0f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
//        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
//        public double distanceSquaredTo(Vertex that) {
//        double dx = this.point.x() - that.point.x();
//        double dy = this.point.y() - that.point.y();
//        return dx*dx + dy*dy;
//        }
//        private class DistanceToOrder implements Comparator<Vertex> {
//        public int compare(Vertex p, Vertex q) {
//            double dist1 = distanceSquaredTo(p);
//            double dist2 = distanceSquaredTo(q);
//            if      (dist1 < dist2) return -1;
//            else if (dist1 > dist2) return +1;
//            else                    return  0;
//            }
//        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00002;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@5aa6e05640076db317132f52ee11de0f@"
"r04945008","9","3.29","176544","@9305498fb9cba81702f67b14bcbf4169@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
//        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
//        public double distanceSquaredTo(Vertex that) {
//        double dx = this.point.x() - that.point.x();
//        double dy = this.point.y() - that.point.y();
//        return dx*dx + dy*dy;
//        }
//        private class DistanceToOrder implements Comparator<Vertex> {
//        public int compare(Vertex p, Vertex q) {
//            double dist1 = distanceSquaredTo(p);
//            double dist2 = distanceSquaredTo(q);
//            if      (dist1 < dist2) return -1;
//            else if (dist1 > dist2) return +1;
//            else                    return  0;
//            }
//        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00001;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@9305498fb9cba81702f67b14bcbf4169@"
"r04945008","10","1.263","177360","@5382dfc1d9bf0b362e2fb5d859b6e41a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Comparator;

public class CriticalDis {
    private static class Vertex implements Comparable<Vertex>{
        private Point2D point;
        private int id;
//        public final Comparator<Vertex> DISTANCE_TO_ORDER = new DistanceToOrder();
        public Vertex(Point2D p, int i) {
            this.point = p;
            this.id = i;
        }
        public int compareTo(Vertex that) {
            double a = this.point.x()+this.point.y();
            double b = that.point.x()+that.point.y();
            if(a < b)   return -1;
            else        return +1;
        }
//        public double distanceSquaredTo(Vertex that) {
//        double dx = this.point.x() - that.point.x();
//        double dy = this.point.y() - that.point.y();
//        return dx*dx + dy*dy;
//        }
//        private class DistanceToOrder implements Comparator<Vertex> {
//        public int compare(Vertex p, Vertex q) {
//            double dist1 = distanceSquaredTo(p);
//            double dist2 = distanceSquaredTo(q);
//            if      (dist1 < dist2) return -1;
//            else if (dist1 > dist2) return +1;
//            else                    return  0;
//            }
//        }
    }
    public static Vertex[] findEdge(Vertex[] pts, Vertex source, double d){
        ArrayList<Vertex> temp = new ArrayList<Vertex>();
        for(int i = 0; i < pts.length; i++){
            if(source.point.distanceTo(pts[i].point) < d){
                if(source.point.x() < pts[i].point.x() && source.point.y() < pts[i].point.y()){
                    temp.add(pts[i]);
                }
            }
        }
        Vertex[] output = temp.toArray(new Vertex[temp.size()]);
        return output;
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String num = br.readLine();
            String in;
            Vertex[] points = new Vertex[Integer.parseInt(num)];
            int i = 0;
            while((in = br.readLine()) != null){
                String[] data = in.split("" "");
                points[i++] = new Vertex(new Point2D(Double.parseDouble(data[0]), Double.parseDouble(data[1])), i-1);
            }
            Arrays.sort(points);
            int source = points[0].id;
            int target = points[Integer.parseInt(num)-1].id;
            double d = 0;
            Digraph G = new Digraph(Integer.parseInt(num));
            DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, source);
            while(!(dfs.hasPathTo(target))){
                G = new Digraph(Integer.parseInt(num));
                for(int x = 0; x < points.length; x++){
                    Vertex[] temp = findEdge(points, points[x], d);
                    for(int y = 0; y < temp.length; y++){
                        if(points[x].id == temp[y].id){}
                        else{
                            G.addEdge(points[x].id, temp[y].id);
                        }
                    }
                }
                dfs = new DepthFirstDirectedPaths(G, source);
                if(!dfs.hasPathTo(target))
                    d += 0.00003;
            }
            System.out.printf(""%1.3f\n"", d);
//            for(int j = 0; j < points.length; j++)
//                System.out.printf(""%1.3f %1.3f\n"", points[j].point.x(), points[j].point.y());
        }
    }
}

@5382dfc1d9bf0b362e2fb5d859b6e41a@"
"r03631015","10","0.123","207216","@c0ec9de8be9d911702c2dd9e551e867d@import java.io.BufferedReader;
import java.io.FileReader;

public class CriticalDis {

    public static class pair implements Comparable<pair> {

        private int x, y;
        private Point2D px, py;
        private double d;

        public pair(int i, int j, Point2D pi, Point2D pj) {
            this.x = i;
            this.y = j;
            this.px = pi;
            this.py = pj;
            d = pi.distanceTo(pj);
        }

        public int x() {
            return this.x;
        }

        public int y() {
            return this.y;
        }

        public Point2D px() {
            return this.px;
        }

        public Point2D py() {
            return this.py;
        }

        public double Distance() {
            return this.d;
        }

        public int compareTo(pair that) {
            if (this.Distance() > that.Distance()) {
                return 1;
            }
            if (this.Distance() < that.Distance()) {
                return -1;
            }
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.parseInt(br.readLine());
            Point2D[] position = new Point2D[num];
            for (int i = 0; i < num; i++) {
                String[] input = br.readLine().split("" "");
                double x = Double.parseDouble(input[0]);
                double y = Double.parseDouble(input[1]);
                position[i] = new Point2D(x, y);
            }
            double t = position[num - 1].x() + position[num - 1].y();
            double s = position[0].x() + position[0].y();

            for (int i = 1; i < num - 1; i++) {
                double comparingPoint = position[i].x() + position[i].y();
                Point2D temp = position[i];
                if (comparingPoint > t) {
                    position[i] = position[num - 1];
                    position[num - 1] = temp;
                    t = position[num-1].x() + position[num-1].y();
                }
                else if (comparingPoint < s) {
                    position[i] = position[0];
                    position[0] = temp;
                    s = position[0].x() + position[0].y();
                } 
            }

            MinPQ<pair> find = new MinPQ<pair>();
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i != j && position[i].x() < position[j].x() && position[i].y() < position[j].y()) {
                        pair temp = new pair(i, j, position[i], position[j]);
                        find.insert(temp);
                    }
                }
            }
            
            Digraph findPath = new Digraph(num);
            DirectedDFS connect = new DirectedDFS(findPath, 0);
            double d = 0;
            while (connect.marked(num - 1) != true) {
                pair temp = find.delMin();
                findPath.addEdge(temp.x(), temp.y());
                connect = new DirectedDFS(findPath, 0);
                d = temp.Distance();
            }
            System.out.printf(""%1.3f\n"", d);
        }
    }
}
@c0ec9de8be9d911702c2dd9e551e867d@"
"r04921115","0","0.11","108208","@d0e4f41ae06fc147bf4f08ccc43be66b@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

import FindNeighbors.Event;

public class CriticalDis {
	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
		        // 1. read in the file containing N 2-dimentional points
	        	int N = Integer.parseInt(br.readLine());
	        	Point2D[] point = new Point2D[N];
	    		String temp =null;
	        	int i=0, j=0;
	        	while((temp = br.readLine())!=null){
		    		String[] coordinates = temp.split("" "");
		    		double x = Double.parseDouble(coordinates[0]);
		    		double y = Double.parseDouble(coordinates[1]);
		            point[i++] = new Point2D(x, y);
		        }
	        	Arrays.sort(point, Point2D.X_ORDER);
	    		
	        	double max;
	        	double min;
	        	double temp_max;
	        	double temp_min;
	        	int source = 0;
	        	int target = 0;
	        	max = point[0].x()+point[0].y();
	        	min = point[0].x()+point[0].y();
	        	for(i=0;i<point.length;i++){
	        		temp_max = point[i].x()+ point[i].y();
	        		temp_min = point[i].x()+ point[i].y();
	        		if(temp_max>max){
	        			target = i;
	        			max = temp_max;
	        		}
	        		if(temp_min<min){
	        			source = i;
	        			min = temp_min;
	        		}
	        	}
	        	System.out.println(source);
	        	System.out.println(target);
	    		MinPQ<Double> minpq = new MinPQ<Double>();			
	    		int newN = N;
				ArrayList<Point2D> pointarray = new ArrayList<Point2D>();
	    		for(i=0; i<point.length;i++){
					if(point[i].x() <= point[target].x() && point[i].y() <= point[target].y() && point[i].x() >= point[source].x() && point[i].y() >= point[source].y()){
						pointarray.add(point[i]);
					}
				}
	        	
	    		for(i=0; i<pointarray.size();i++){
	    			for(j=0; j!=i && j<pointarray.size();j++){
		    			double dist = pointarray.get(i).distanceTo(pointarray.get(j));
		    			minpq.insert(dist);
		    		}
	    		}
	    		
	    		double wantd = minpq.delMin();
	    		
	        	StdDraw.setPenColor(StdDraw.BLUE);
				for(i=0; i<point.length;i++){
					StdDraw.text(point[i].x(), point[i].y()+0.03, """"+i);
					StdDraw.filledCircle(point[i].x(), point[i].y(), 0.008);
				}
		        
		 }
	}
}
//System.out.printf(""%1.3f\n"", d);
@d0e4f41ae06fc147bf4f08ccc43be66b@"
"b01703032","0","0.106","101984","@2708d47a8de40d7be64693e41df66ad0@import java.util.ArrayList;
import java.util.Arrays;


public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int va = in.readInt();
        Point2D[] point = new Point2D[va];
        for (int i = 0 ; i < va ; i++) {
            point[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < point.length; i++) {
            Point2D p = point[i];
            Point2D s = point[source];
            Point2D t = point[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<Event> distanceArray = new ArrayList<Event>();
        for (int i = 0; i < point.length; i++) {
            Point2D p1 = point[i];
            for (int j = 0; j < point.length; j++) {
                Point2D p2 = point[j];
                if (p1.x() < p2.x() && p1.y() < p2.y()) {
                    distanceArray.add(new Event(p1.distanceTo(p2), i, j));
                }
            }
        }
        Event[] distanceEvents = distanceArray.toArray(new Event[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (Event distanceEvent:distanceEvents){
            digraph.addEdge(distanceEvent.i,distanceEvent.j);
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }
    }

    static class Event implements Comparable<Event>{
        double d;
        int i;
        int j;
        public Event(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Event o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}
@2708d47a8de40d7be64693e41df66ad0@"
"b01703032","0","0.106","101984","@5e55ddbfa7cf88e1cda119d47fce4d2e@import java.util.ArrayList;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int va = in.readInt();
        Point2D[] points = new Point2D[va];
        for (int i = 0 ; i < va ; i++) {
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<Distance> distanceArray = new ArrayList<Distance>();
        for (int i = 0; i < points.length; i++) {
            Point2D p1 = points[i];
            for (int j = 0; j < points.length; j++) {
                Point2D p2 = points[j];
                if (p1.x() < p2.x() && p1.y() < p2.y()) {
                    distanceArray.add(new Distance(p1.distanceTo(p2), i, j));
                }
            }
        }
        Distance[] distanceEvents = distanceArray.toArray(new Distance[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (Distance distanceEvent:distanceEvents){
            digraph.addEdge(distanceEvent.i,distanceEvent.j);
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }
    }

    static class Distance implements Comparable<Distance>{
        double d;
        int i;
        int j;
        public Distance(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(Distance o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}
@5e55ddbfa7cf88e1cda119d47fce4d2e@"
"b01703032","0","0.106","101984","@920c8245171d75bbe54ade15de3c911c@import java.util.ArrayList;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int va = in.readInt();
        Point2D[] points = new Point2D[va];
        for (int i = 0 ; i < va ; i++) {
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<DistanceEvent> distanceArray = new ArrayList<DistanceEvent>();
        for (int i = 0; i < points.length; i++) {
            Point2D p1 = points[i];
            for (int j = 0; j < points.length; j++) {
                Point2D p2 = points[j];
                if (p1.x() < p2.x() && p1.y() < p2.y()) {
                    distanceArray.add(new DistanceEvent(p1.distanceTo(p2), i, j));
                }
            }
        }
        DistanceEvent[] distanceEvents = distanceArray.toArray(new DistanceEvent[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (DistanceEvent distanceEvent:distanceEvents){
            digraph.addEdge(distanceEvent.i,distanceEvent.j);
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distanceEvent.d));
                break;
            }
        }
    }

    static class DistanceEvent implements Comparable<DistanceEvent>{
        double d;
        int i;
        int j;
        public DistanceEvent(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(DistanceEvent o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}

@920c8245171d75bbe54ade15de3c911c@"
"b01703032","10","0.186","230896","@ec7630b6cbceeab9b009ec203d98b413@import java.util.ArrayList;
import java.util.Arrays;

public class CriticalDis {

    public static void main(String[] args) {

        In in = new In(args[0]);
        int v = in.readInt();
        Point2D[] points = new Point2D[v];
        for (int i = 0 ; i < v ; i++) {
            points[i] = new Point2D(in.readDouble() , in.readDouble());
        }
        int source = 0;
        int target = 0;
        for (int i = 0; i < points.length; i++) {
            Point2D p = points[i];
            Point2D s = points[source];
            Point2D t = points[target];
            if (p.x() + p.y() < s.x() + s.y()) source = i;
            if (p.x() + p.y() > t.x() + t.y()) target = i;
        }
        ArrayList<DistanceEvent> distanceArray = new ArrayList<DistanceEvent>();
        for (int i = 0; i < points.length; i++) {
            Point2D p1 = points[i];
            for (int j = 0; j < points.length; j++) {
                Point2D p2 = points[j];
                if (p1.x() < p2.x() && p1.y() < p2.y()) {
                    distanceArray.add(new DistanceEvent(p1.distanceTo(p2), i, j));
                }
            }
        }
        DistanceEvent[] distanceEvents = distanceArray.toArray(new DistanceEvent[distanceArray.size()]);
        Arrays.sort(distanceEvents);

        Digraph digraph = new Digraph(v);
        for (DistanceEvent distance:distanceEvents){
            digraph.addEdge(distance.i,distance.j);
            DirectedDFS dfs = new DirectedDFS(digraph , source);
            if (dfs.marked(target)) {
                System.out.println(String.format(""%1.3f"",distance.d));
                break;
            }
        }
    }

    static class DistanceEvent implements Comparable<DistanceEvent>{
        double d;
        int i;
        int j;
        public DistanceEvent(double distance , int i , int j){
            this.d = distance;
            this.i = i;
            this.j = j;
        }

        @Override
        public int compareTo(DistanceEvent o) {
            if (this.d > o.d) return 1;
            else if (this.d < o.d) return -1;
            else return 0;
        }
    }

}

@ec7630b6cbceeab9b009ec203d98b413@"
