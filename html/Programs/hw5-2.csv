"r04945025","0","0","0","@4958a0a49295ac1c8acbb462b9587e33@import java.util.Arrays;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull{

    private static UF uf;
    private static Point2D[] points;
    private static HashMap<Integer, CC> ccs;
    private static HashMap<Point2D, Integer> id;

    private static class CC{
        private ArrayList<Point2D> pointsCC;


        public CC(Point2D point){
            pointsCC = new ArrayList<Point2D>();
            pointsCC.add(point);
        }

        public void addPoint(Point2D point){
            if(!pointsCC.contains(point)) pointsCC.add(point);
        }

        public Point2D[] getPoints(){
            Point2D[] temp = new Point2D[pointsCC.size()];
            return pointsCC.toArray(temp);
        }
    }

    private static int FindLowestPoint(Point2D[] points){
        int index = 0;
        double min = 1.0;
        for(int i = 0; i < points.length; i++) {
            if (points[i].y() < min) {
                min = points[i].y();
                index = i;
            }
        }

        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(points[index].x(), points[index].y() - 0.03, ""L"");
        return index;
    }

    private static Point2D[] sortByAngle(int index, Point2D[] p){
        Comparator<Point2D> cmp = p[index].ATAN2_ORDER;
        Arrays.sort(p, cmp);
        return p;
    }

    private static Point2D[] convexHull(Point2D[] p){
        Stack<Integer> st = new Stack<Integer>();

        for(int i = 0; i < p.length; i++){
            st.push(i);
            if(st.size() < 3){ continue; }
            else{
                int c = st.pop();
                int b = st.pop();
                int a = st.pop();
                while(Point2D.ccw(p[a], p[b], p[c]) == -1){
                    st.push(a);
                    st.push(c);
                    if(st.size() < 3) { break; }
                    c = st.pop();
                    b = st.pop();
                    a = st.pop();
                }
                st.push(a);
                st.push(b);
                st.push(c);
            }
        }
        int i = 0;
        if(st.size() < 3) { return null; }
        Point2D[] convexHullCC = new Point2D[st.size()];
        for(Integer idx: st){
            convexHullCC[i++] = p[idx];
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.MAGENTA);
            StdDraw.point(p[idx].x(), p[idx].y());
        }
        return convexHullCC;
    }


    public static double getDistance(int a, int b){
        return points[a].distanceTo(points[b]);
    }

    public static int[] ConvexHullVertex(Point2D[] a){

        int index = FindLowestPoint(a);
        a = sortByAngle(index, a);
        //System.out.printf(""%d\n"", a.length);
        a = convexHull(a);
        if(a == null) { return null; }
        int[] results = new int[a.length];
        int i = 0;
        for(Point2D point: a){
            results[i++] = id.get(point);
        }
        int[] rev = new int[results.length];
        for(i=0; i < results.length; i++){
            rev[results.length - i - 1] = results[i];
        }
        return rev;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StdDraw.setXscale(-0.1, 1.1);
            StdDraw.setYscale(-0.1, 1.1);

            int i = 0;
            double t = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

            uf = new UF(n);
            points = new Point2D[n];
            ccs = new HashMap<Integer, CC>();
            id = new HashMap<Point2D, Integer>();

            /*for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);

                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(0.01);
                StdDraw.point(x, y);

                Point2D point = new Point2D(x, y);

                if(id.containsKey(point)){
                    System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
                }
                else {
                    id.put(point, i);
                    StdDraw.setPenColor(StdDraw.GRAY);
                    StdDraw.text(point.x(), point.y() + 0.03, String.valueOf(i));
                }
                points[i++] = point;
            }

            int[] out = MyConvexHull.ConvexHullVertex(points);
            for(Integer idx: out){
                System.out.printf(""%d\n"", idx);
            }*/


            // Read Points into Array
            for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);

                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(0.01);
                StdDraw.point(x, y);

                Point2D point = new Point2D(x, y);

                if(id.containsKey(point)){
                    System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
                }
                else {
                    id.put(point, i);
                    StdDraw.setPenColor(StdDraw.GRAY);
                    StdDraw.text(point.x(), point.y() + 0.03, String.valueOf(i));
                }
                points[i++] = point;
            }

            // Union Points
            for(i = 0; i < n; i++){
                for(int j = i + 1; j < n; j++){
                    if(getDistance(i, j) <= t){
                        StdDraw.setPenRadius(0.001);
                        StdDraw.setPenColor(StdDraw.GRAY);
                        StdDraw.line(points[i].x(), points[i].y(), points[j].x(), points[j].y());
                        uf.union(i, j);
                    }
                }
            }

            // Construct CC Array
            for(i = 0; i < n; i++){
                int root = uf.find(i);
                Point2D point = points[i];
                if(ccs.containsKey(root)){
                    ccs.get(root).addPoint(point);
                }
                else{
                    CC cc = new CC(point);
                    ccs.put(root, cc);
                }
            }

            int count = 0;
            for(Integer key: ccs.keySet()){
                Point2D[] input = ccs.get(key).getPoints();
                int[] result = MyConvexHull.ConvexHullVertex(input);
                if(result == null) { continue; }
                count += result.length;
            }
            System.out.printf(""%d\n"", count);

            //System.out.printf(""\nProgram Completed\n"");
        }
    }
}
@4958a0a49295ac1c8acbb462b9587e33@"
"r04945025","5","0.096","106064","@31146cdc92603da4978db24796ffbed3@import java.util.Arrays;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull{

    private static UF uf;
    private static Point2D[] points;
    private static HashMap<Integer, CC> ccs;
    private static HashMap<Point2D, Integer> id;

    private static class CC{
        private ArrayList<Point2D> pointsCC;


        public CC(Point2D point){
            pointsCC = new ArrayList<Point2D>();
            pointsCC.add(point);
        }

        public void addPoint(Point2D point){
            if(!pointsCC.contains(point)) pointsCC.add(point);
        }

        public Point2D[] getPoints(){
            Point2D[] temp = new Point2D[pointsCC.size()];
            return pointsCC.toArray(temp);
        }
    }

    private static int FindLowestPoint(Point2D[] points){
        int index = 0;
        double min = 1.0;
        for(int i = 0; i < points.length; i++) {
            if (points[i].y() < min) {
                min = points[i].y();
                index = i;
            }
        }

        //StdDraw.setPenColor(StdDraw.BLACK);
        //StdDraw.text(points[index].x(), points[index].y() - 0.03, ""L"");
        return index;
    }

    private static Point2D[] sortByAngle(int index, Point2D[] p){
        Comparator<Point2D> cmp = p[index].ATAN2_ORDER;
        Arrays.sort(p, cmp);
        return p;
    }

    private static Point2D[] convexHull(Point2D[] p){
        Stack<Integer> st = new Stack<Integer>();

        for(int i = 0; i < p.length; i++){
            st.push(i);
            if(st.size() < 3){ continue; }
            else{
                int c = st.pop();
                int b = st.pop();
                int a = st.pop();
                while(Point2D.ccw(p[a], p[b], p[c]) == -1){
                    st.push(a);
                    st.push(c);
                    if(st.size() < 3) { break; }
                    c = st.pop();
                    b = st.pop();
                    a = st.pop();
                }
                st.push(a);
                st.push(b);
                st.push(c);
            }
        }
        int i = 0;
        if(st.size() < 3) { return null; }
        Point2D[] convexHullCC = new Point2D[st.size()];
        for(Integer idx: st){
            convexHullCC[i++] = p[idx];
            //StdDraw.setPenRadius(0.01);
            //StdDraw.setPenColor(StdDraw.MAGENTA);
            //StdDraw.point(p[idx].x(), p[idx].y());
        }
        return convexHullCC;
    }


    public static double getDistance(int a, int b){
        return points[a].distanceTo(points[b]);
    }

    public static int[] ConvexHullVertex(Point2D[] a){

        int index = FindLowestPoint(a);
        a = sortByAngle(index, a);
        //System.out.printf(""%d\n"", a.length);
        a = convexHull(a);
        if(a == null) { return null; }
        int[] results = new int[a.length];
        int i = 0;
        for(Point2D point: a){
            results[i++] = id.get(point);
        }
        int[] rev = new int[results.length];
        for(i=0; i < results.length; i++){
            rev[results.length - i - 1] = results[i];
        }
        return rev;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            //StdDraw.setXscale(-0.1, 1.1);
            //StdDraw.setYscale(-0.1, 1.1);

            int i = 0;
            double t = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

            uf = new UF(n);
            points = new Point2D[n];
            ccs = new HashMap<Integer, CC>();
            id = new HashMap<Point2D, Integer>();

            /*for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);

                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(0.01);
                StdDraw.point(x, y);

                Point2D point = new Point2D(x, y);

                if(id.containsKey(point)){
                    System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
                }
                else {
                    id.put(point, i);
                    StdDraw.setPenColor(StdDraw.GRAY);
                    StdDraw.text(point.x(), point.y() + 0.03, String.valueOf(i));
                }
                points[i++] = point;
            }

            int[] out = MyConvexHull.ConvexHullVertex(points);
            for(Integer idx: out){
                System.out.printf(""%d\n"", idx);
            }*/


            // Read Points into Array
            for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);

                //StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(0.01);
                //StdDraw.point(x, y);

                Point2D point = new Point2D(x, y);

                if(id.containsKey(point)){
                    System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
                }
                else {
                    id.put(point, i);
                    //StdDraw.setPenColor(StdDraw.GRAY);
                    //StdDraw.text(point.x(), point.y() + 0.03, String.valueOf(i));
                }
                points[i++] = point;
            }

            // Union Points
            for(i = 0; i < n; i++){
                for(int j = i + 1; j < n; j++){
                    if(getDistance(i, j) <= t){
                        //StdDraw.setPenRadius(0.001);
                        //StdDraw.setPenColor(StdDraw.GRAY);
                        //StdDraw.line(points[i].x(), points[i].y(), points[j].x(), points[j].y());
                        uf.union(i, j);
                    }
                }
            }

            // Construct CC Array
            for(i = 0; i < n; i++){
                int root = uf.find(i);
                Point2D point = points[i];
                if(ccs.containsKey(root)){
                    ccs.get(root).addPoint(point);
                }
                else{
                    CC cc = new CC(point);
                    ccs.put(root, cc);
                }
            }

            int count = 0;
            for(Integer key: ccs.keySet()){
                Point2D[] input = ccs.get(key).getPoints();
                int[] result = MyConvexHull.ConvexHullVertex(input);
                if(result == null) { continue; }
                count += result.length;
            }
            System.out.printf(""%d\n"", count);

            //System.out.printf(""\nProgram Completed\n"");
        }
    }
}
@31146cdc92603da4978db24796ffbed3@"
"r04447001","4","0.48","107344","@a8844436bfadf4c716cc57f38e40cc5d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, a.length, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            if (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        int[] finalindex = new int[finalnum];
        int currentindex = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(a[i])) {
                    finalindex[currentindex] = i;
                    currentindex++;
                }
            }
        }
        return finalindex;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@a8844436bfadf4c716cc57f38e40cc5d@"
"b02611019","0","0.48","107728","@472a918a3ed618134b1e6e0d57ab7893@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.HashMap;

public class MyConvexHull {

    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        for(int i=0;i<a.length;i++){
            map.put(a[i], i);
        }
        a = sortbyY(a);
        a = sortbyangle(a, 0);
        
        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);

        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }
        
        int[] an=new int[cvh.size()];
        int num=cvh.size();
        for (int i=0;i<num;i++){
            an[i]=map.get(a[cvh.pop()]);
//             StdOut.print(an[i]);
        }
        Arrays.sort(an);
        for (int i=0;i<an.length;i++){
//            StdOut.print(an[i]);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            map.put(points[i], i);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }

        ConvexHullVertex(points);

    }
}

@472a918a3ed618134b1e6e0d57ab7893@"
"r04447001","5","0.096","107488","@258e49da76160fc45df26dcc71d9e8dd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/*import edu.princeton.cs.algs4.Point2D;
import edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.UF;*/
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author jerry
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] original = a.clone();
        int N = a.length;
        Stack<Point2D> hull = new Stack<Point2D>();
        Arrays.sort(a);
        Arrays.sort(a, 1, N, a[0].POLAR_ORDER);

        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
        StdDraw.setPenColor(StdDraw.BLACK);*/
        
        //int count = 0;
        
        /*for (int i = 0; i < a.length; i++) {
            StdDraw.text(a[i].x(), a[i].y() + 0.01, String.valueOf(count));
            count++;
        }*/

        hull.push(a[0]);
        int k1;
        for (k1 = 1; k1 < N; k1++) {
            if (!a[0].equals(a[k1])) {
                break;
            }
        }
        if (k1 == N) {
            int[] last = {0};
            return last;
        }

        int k2;
        for (k2 = k1 + 1; k2 < N; k2++) {
            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) {
                break;
            }
        }
        hull.push(a[(k2 - 1)]);

        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        Stack<Point2D> finalhull = new Stack<Point2D>();
        int finalnum = 0;
        
        for (Point2D p : hull) {
            finalhull.push(p);
            finalnum++;
        }
        
        int[] finalindex = new int[finalnum];
        int currentpoint = 0;
        for (Point2D p : finalhull) {
            for (int i = 0; i < N; i++) {
                if (p.equals(original[i])) {
                    finalindex[currentpoint] = i;
                    currentpoint++;
                }
            }
        }
        
        /*for(int i = 0; i < finalnum; i++){
        System.out.print(finalindex[i]+"" "");
        System.out.println();
        }*/
        
        Arrays.sort(finalindex);
        
        return finalindex;
    }
    /*public static void main(String[] args) {
        Point2D[] test = new Point2D[10];
        for(int i = 0; i <10; i++){
        double x = StdRandom.uniform();
        double y = StdRandom.uniform();
        test[i] = new Point2D(x,y);
        }
        for(int i = 0; i < 10; i++){
            StdDraw.filledCircle(test[i].x(), test[i].y(), 0.01);
            StdDraw.text(test[i].x(), test[i].y()+0.05, String.valueOf(i));
        }
        int[] result = ConvexHullVertex(test);
        for(int i = 0; i < result.length; i++){
        System.out.print(result[i]+"" "");
        }
    }
    
}*/

           
    public static void main(String[] args) throws Exception {
        
        
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double distance = Double.parseDouble(data);
            data = br.readLine();
            int totalnum = Integer.parseInt(data);
            Point2D[] a = new Point2D[totalnum];
            double x, y;
            int currentcount = 0;

            for (String line = br.readLine(); line != null; line = br.readLine()) {
                String[] data2 = line.split("" "");
                x = Double.parseDouble(data2[0]);
                y = Double.parseDouble(data2[1]);
                a[currentcount] = new Point2D(x, y);
                currentcount++;
            }//read in datapoint
            
            UF PointsCC = new UF(totalnum);
            for(int i = 0; i < totalnum; i++){
                for(int j = i; j < totalnum; j++){
                    if (a[i].distanceTo(a[j]) <= distance){
                    PointsCC.union(i,j);
                    }//Checking all pairs to get the union
                }
            }
            
            int[] roots = new int[totalnum];
            for (int i = 0; i < totalnum; i++) {
                roots[PointsCC.find(i)]++;
            }//filling roots to the toal point counts per CC
            

            
            
            int result = 0;
            
            for (int i = 0; i < totalnum; i++) {
                if (roots[i] >= 3) {
                    Point2D[] Currentconvex = new Point2D[roots[i]];
                    int currentpoint = 0;
                    
                    for(int j = 0; j < totalnum; j++){
                        if(PointsCC.find(j) == i){
                            Currentconvex[currentpoint] = a[j];
                            currentpoint++;
                        }// adding selected Point2D to currentarray
                    }
                    
                    int[] currentresult = ConvexHullVertex(Currentconvex);
                    result += currentresult.length;
                }
            }
            System.out.print(result);
        }

    }
}

@258e49da76160fc45df26dcc71d9e8dd@"
"r04942099","5","0.096","108320","@a4017648398bbc512b14f009b8e102bc@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;



public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] points = new Point2D[a.length];
        for(int i=0;i<a.length;i++){
            points[i] = a[i];
        }
        
        
        Merge.sort(points);
        Arrays.sort(points, points[0].POLAR_ORDER);
        Stack<Point2D> vals = new Stack<Point2D>();
        
        int N = a.length;
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) return;        // all points equal
        vals.push(points[0]);
        vals.push(points[k1]);
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        vals.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = vals.pop();
            while (Point2D.ccw(vals.peek(), top, points[i]) <= 0) {
                top = vals.pop();
            }
            vals.push(top);
            vals.push(points[i]);
        }
        int number = vals.size();
        Point2D[] vertex = new Point2D[number];
        for(int u = 0;u<number;u++){
            vertex[u] = vals.pop();
        }
        int[] index = new int[number];
        int counter=0;
        for(int i=0;i<N;i++){
            for(int j=0;j<number;j++){
                if(a[i].equals(vertex[j])){
                    index[counter]=i;
                    counter++;
                } 
            }
        }
        
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            return index;
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String data = br.readLine();
            double connect = Double.parseDouble(data);
            String data2 = br.readLine();
            int size = Integer.parseInt(data2);
            Point2D[] points = new Point2D[size];
            String open;
            String [] temp = new String[2];
            for(int i=0;i<size;i++){
                open = br.readLine();
                temp = open.split("" "");
                points[i] = new Point2D(Double.parseDouble(temp[0]), Double.parseDouble(temp[1]));
            }
            
            QuickFindUF wei = new QuickFindUF(size);
            for(int i=0;i<size;i++){
                for(int j=0;j<size;j++){
                    if(!wei.connected(i, j)){
                        if(points[i].distanceTo(points[j])<=connect) wei.union(i, j);
                    }                        
                }
            }/*
            for(int i=0; i<size;i++){
                System.out.println(wei.find(i));
            }*/
            int[] num = new int[size];
            for(int i = 0;i<size;i++){
                num[i]=0;
            }
            Point2D[][] t = new Point2D[size][size];
            for(int i = 0;i<size;i++){
                t[wei.find(i)][num[wei.find(i)]]=points[i];
                num[wei.find(i)]++;
            }
            int result=0;
            int[] temp3 = new int[size];
            //Point2D[] t2 = new Point2D[size];
            for(int i=0;i<size;i++){
            if(num[i]>=3){
                Point2D[] t2 = new Point2D[num[i]];
                for(int j=0;j<num[i];j++) t2[j] = t[i][j];
                temp3 = MyConvexHull.ConvexHullVertex(t2);
                result = result+temp3.length;
            }
            //System.out.println(temp3.length);
            //System.out.println(num[i]);
        }
            System.out.println(result);
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
}

@a4017648398bbc512b14f009b8e102bc@"
"b02611019","5","0.098","105952","@b2c978a4e3cb0bd51b8f79bde227a81c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author S410
 */
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

public class MyConvexHull {

    static class CC {

        Point2D[] point;
        int index;
        int len = 0;

        void addcc(Point2D a) {
            point[len] = a;
            len++;
        }
    }
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();
    static int current;

    public static Point2D[] sortbyY(Point2D[] a) {
        Arrays.sort(a, Point2D.Y_ORDER);
        return a;
    }

    public static Point2D[] sortbyangle(Point2D[] a, int low) {
        Comparator<Point2D> cmp = a[low].ATAN2_ORDER;
        Arrays.sort(a, cmp);
        return a;
    }

    public static boolean ccw(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {
            return false; // clockwise
        } else if (area2 > 0) {
            return true; // counter-clockwise
        } else {
            return false; // collinear
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }
        a = sortbyY(a);
        a = sortbyangle(a, 0);

        for (int i = 0; i < a.length; i++) {
//            StdDraw.text(a[i].x(), a[i].y() + 0.03, Integer.toString(i));
        }

        //找covexhull
        Stack<Integer> cvh = new Stack<Integer>();
        cvh.push(0);
        cvh.push(1);
        current = 2;
        while (1 > 0) {
//            StdOut.print(current);
            int p1 = current;
            int p2 = cvh.pop();
            int p3 = cvh.pop();
            if (ccw(a[p3], a[p2], a[p1])) {
                cvh.push(p3);
                cvh.push(p2);
                cvh.push(p1);
                current++;

                //最後一次回到原點且完成
                if (p1 == 0) {
                    cvh.pop();
                    break;
                }
            } else {
                cvh.push(p3);
            }
            if (current == a.length) {
                current = 0;
            }
        }

        int[] an = new int[cvh.size()];
        int num = cvh.size();
        for (int i = 0; i < num; i++) {
            an[i] = map.get(a[cvh.pop()]);
        }
        Arrays.sort(an);
        for (int i = 0; i < an.length; i++) {
//            StdOut.print(an[i]);
//            StdOut.print(an.length);
        }
        return an;

    }

    public static void main(String[] args) throws Exception {

        //讀檔，前兩行
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String maxlength = br.readLine();
        double maxlen = Double.parseDouble(maxlength);
        String number = br.readLine();
        int N = Integer.parseInt(number);

        //讀進所有點，畫出來並標記index
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            String[] coor = br.readLine().split("" "");
            points[i] = new Point2D(Double.parseDouble(coor[0]), Double.parseDouble(coor[1]));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
        }
        //做CC
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        int[] ID = new int[N];
        for (int i = 0; i < N; i++) {
            ID[i] = i;
        }
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                if (points[i].distanceTo(points[j]) <= maxlen) {
                    uf.union(ID[i], ID[j]);
//                    StdDraw.line(points[i].x(), points[i].y(), points[j].x(), points[j].y());
                }
            }
        }

        for (int i = 0; i < N; i++) {
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(uf.find(ID[i])));
        }

        HashMap<Integer, Integer> mapcc = new HashMap<Integer, Integer>();
        HashMap<Integer, ArrayList<Point2D>> mapccc = new HashMap<Integer, ArrayList<Point2D>>();
        for (int i = 0; i < N; i++) {
            if (mapccc.containsKey(uf.find(ID[i]))) {
                mapccc.get(uf.find(ID[i])).add(points[i]);
//                int a=mapcc.get(uf.find(ID[i]));
//                mapcc.remove(uf.find(ID[i]));
//                mapcc.put(uf.find(ID[i]), ++a);
            } else {
//                mapcc.put(uf.find(ID[i]),1);
                mapccc.put(uf.find(ID[i]), new ArrayList<Point2D>());
                mapccc.get(uf.find(ID[i])).add(points[i]);
            }
        }
        int ans =0;
        for (int a : mapccc.keySet()) {
//            StdOut.print(i);
            if (mapccc.get(a).size() >= 3) {
//                mapccc.remove(mapccc.get(i));
                Point2D[] aa = mapccc.get(a).toArray(new Point2D[mapccc.get(a).size()]);
                ans+=(ConvexHullVertex(aa).length);
            }
        }
        StdOut.print(ans);
        for (int i = 0; i < N; i++) {
//            StdOut.print(st.get(uf.find(i)));
        }

    }
}

@b2c978a4e3cb0bd51b8f79bde227a81c@"
"r04546032","0","0","0","@efccfc95bfce70384c0448f740be74d6@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
    protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            double max = 1;int index = 0;double [] angle = new double[a.length];
            int[] indices; List<Integer> temp = new ArrayList<Integer>();
            Stack<Point2D> order = new Stack<Point2D>();
            for(int i = 0; i < a.length ;i++) // find the lowest y
            {
                if(a[i].y() < max)
                {
                    max = a[i].y(); index = i ; 
                }
            }
            for(int j = 0; j < a.length;j++)
            {
                angle[j] = a[j].theta();
            }
     
          order.push(a[0]);
        for(int k = 0; k < a.length;k++)  
        {
           if(Point2D.ccw(order.peek(),a[k+1], a[k+2]) == -1) 
           {
               order.push(a[k]);
           }
           else if(Point2D.ccw(order.peek(),a[k+1], a[k+2]) != -1)
           {
             
           }
        }
           indices = new int[temp.size()];
         
            return null;
    }

    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(""data.txt""))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < count[i];k++)
                {
                    GroupPoints[mark][k] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@efccfc95bfce70384c0448f740be74d6@"
"r04546032","2","0.19","106112","@7de14353143ba5d4be5894ba87bd8655@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
    protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            double max = 1;int index = 0;double [] angle = new double[a.length];
            int[] indices; List<Integer> temp = new ArrayList<Integer>();
            Stack<Point2D> order = new Stack<Point2D>();
            for(int i = 0; i < a.length ;i++) // find the lowest y
            {
                if(a[i].y() < max)
                {
                    max = a[i].y(); index = i ; 
                }
            }
            for(int j = 0; j < a.length;j++)
            {
                angle[j] = a[j].theta();
            }
     
          order.push(a[0]);
        for(int k = 0; k < a.length;k++)  
        {
           if(Point2D.ccw(order.peek(),a[k+1], a[k+2]) == -1) 
           {
               order.push(a[k]);
           }
           else if(Point2D.ccw(order.peek(),a[k+1], a[k+2]) != -1)
           {
             
           }
        }
           indices = new int[temp.size()];
         
            return null;
    }

    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = AllPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@7de14353143ba5d4be5894ba87bd8655@"
"r04921104","5","0.106","107632","@8e26e72a361daacc9cd9fafc61174736@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@8e26e72a361daacc9cd9fafc61174736@"
"b03611023","5","0.096","108064","@3036e96c12421b9f57a085b49bfd7429@import java.util.Arrays;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {
      public static int[] ConvexHullVertex(Point2D[] a) {
          int size = 0;
           int k = 0;
           size = a.length;
         
           int[] point = new int[size];
           int i = 0;
          for(i = 0;i<size;i++){
              point[i] = i;
          }
          Point2D[] copy = new Point2D[size];
          for(int j = 0;j<size;j++){
              copy[j] = new Point2D(a[j].x(), a[j].y());
          }
        
        /*   while(a[k]. !=null){
               k++;
               size++;
           }*/
          
                  
               
         //  int[] z = new int[10];
           Arrays.sort(a, Point2D.Y_ORDER);
        
        
          // System.out.print(a[0].y());
            
           Point2D p = new Point2D(a[0].x(),a[0].y());
          // StdDraw.setPenColor(StdDraw.RED);
           // StdDraw.setPenRadius(.02);
           //  p.draw();
           Arrays.sort(a, p.POLAR_ORDER);
           
         
          //  StdDraw.setPenRadius();
       // StdDraw.setPenColor(StdDraw.BLUE);
         /* for(int i =0 ;i<size;i++){
             
                   
                p.drawTo(a[i]);
            StdDraw.show(100);
            //System.out.print(a[i].y());           
           }*/
       
           Stack<Point2D> hull = new Stack<>();
           
           
         
           
           hull.push(a[0]);         
           hull.push(a[1]);
          
           
           for( i = 2;i<size;i++){
           Point2D top = hull.pop();         
           while(Point2D.ccw(hull.peek(), top, a[i])<=0){
               top = hull.pop();               
           }
              hull.push(top);          
              hull.push(a[i]);             
           }
          i = hull.size();
          int[] ans = new int[i];
          Point2D[] ww = new Point2D[i];
         for(int j =0;j<i;j++){
             ww[j] = hull.pop();
          }         
         for(int j = 0;j<i;j++){
               for(int l = 0;l<size;l++){
                   if(ww[j].equals(copy[l])){
                       ans[j] = l;
                       break;
                   }
               }
             //  System.out.print(a[j].y());
              // System.out.print(copy[j].y());
              // System.out.print(ans[j]);
           }
       /*   for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
     /*   Arrays.sort(ans);
          for (int number : ans) {
   System.out.println(""Number = "" + number);
   }*/
      
      
     
      return ans;
    }
        public static void main(String[] args) throws Exception{
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
             String n = br.readLine();
             double d = Double.parseDouble(n);
             n = br.readLine();
             int N = Integer.parseInt(n);
             
             int i = 0;
             String[] point;
             Point2D[] input = new Point2D[N];
             for(i = 0;i<N;i++){
                 point = br.readLine().split("" "");
                 double x = Double.parseDouble(point[0]);
                 double y = Double.parseDouble(point[1]);
                 input[i] = new Point2D(x,y);                 
             }
        /* int size = N;
         int[] root = new int[N];
         for(i = 0;i<N;i++){
             root[i] = i;
         }*/
           QuickUnionUF qf = new QuickUnionUF(N);
         for(i = 0;i<N;i++){
             for(int j = i+1;j<N;j++){
                 if(input[i].distanceTo(input[j])<=d){
                     qf.union(j,i);                     
                 }
             }
         }
         int[] parent = new int[qf.count()];
         
        int j = 0;
         for(i = 0;i<N;i++){
             if(qf.find(i) == i){
                 parent[j] = i;
                 //System.out.print(i);
                 j++;
             }
             
         }
         int len = 0;
         for(i = 0;i<qf.count();i++){
             int t = 0;
             for(j = 0;j<N;j++){
                 if(qf.find(j) == parent[i]){
                     t++;
                     //  System.out.print(t);
                 }
            
             }
            // System.out.print(t);
             if(t>=3){
                 Point2D[] cc = new Point2D[t];
                 int m = 0;
                 for(int o = 0;o<N;o++){
                     if(qf.find(o) == parent[i]){
                         cc[m] = new Point2D(input[o].x(),input[o].y());
                        // System.out.print(input[o].x());
                         m++;
                     }
                 }
                 
                 int[] g;
                 g = MyConvexHull.ConvexHullVertex(cc);
                 len +=g.length;        
             }
         }
         
         
         System.out.print(len);
         
         
         
         
         }
        
         
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

    }
      
}
                  

@3036e96c12421b9f57a085b49bfd7429@"
"r04546032","4","0.48","107728","@860bb318c88b37e9eac16e615a41c72a@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
          //  Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                      //  Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@860bb318c88b37e9eac16e615a41c72a@"
"r04945025","0","0","0","@fd30f366f24f4c08441753478ea49a54@import java.util.Arrays;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull{

    private static UF uf;
    private static Point2D[] points;
    private static HashMap<Integer, CC> ccs;
    private static HashMap<Point2D, Integer> id;

    private static class CC{
        private ArrayList<Point2D> pointsCC;


        public CC(Point2D point){
            pointsCC = new ArrayList<Point2D>();
            pointsCC.add(point);
        }

        public void addPoint(Point2D point){
            if(!pointsCC.contains(point)) pointsCC.add(point);
        }

        public Point2D[] getPoints(){
            Point2D[] temp = new Point2D[pointsCC.size()];
            return pointsCC.toArray(temp);
        }
    }

    private static int FindLowestPoint(Point2D[] points){
        int index = 0;
        double min = 1.0;
        for(int i = 0; i < points.length; i++) {
            if (points[i].y() < min) {
                min = points[i].y();
                index = i;
            }
        }

        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(points[index].x(), points[index].y() - 0.03, ""L"");
        return index;
    }

    private static Point2D[] sortByAngle(int index, Point2D[] p){
        Comparator<Point2D> cmp = p[index].ATAN2_ORDER;
        Arrays.sort(p, cmp);
        return p;
    }

    private static Point2D[] convexHull(Point2D[] p){
        Stack<Integer> st = new Stack<Integer>();

        for(int i = 0; i < p.length; i++){
            st.push(i);
            if(st.size() < 3){ continue; }
            else{
                int c = st.pop();
                int b = st.pop();
                int a = st.pop();
                while(Point2D.ccw(p[a], p[b], p[c]) == -1){
                    st.push(a);
                    st.push(c);
                    if(st.size() < 3) { break; }
                    c = st.pop();
                    b = st.pop();
                    a = st.pop();
                }
                st.push(a);
                st.push(b);
                st.push(c);
            }
        }
        int i = 0;
        if(st.size() < 3) { return null; }
        Point2D[] convexHullCC = new Point2D[st.size()];
        for(Integer idx: st){
            convexHullCC[i++] = p[idx];
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.MAGENTA);
            StdDraw.point(p[idx].x(), p[idx].y());
        }
        return convexHullCC;
    }


    public static double getDistance(int a, int b){
        return points[a].distanceTo(points[b]);
    }

    public static int[] ConvexHullVertex(Point2D[] a){
        id = new HashMap<Point2D, Integer>();
        int i = 0;
        for(Point2D point: a){
            if(id.containsKey(point)){
                System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
            }
            else {
                id.put(point, i++);
            }
        }

        int index = FindLowestPoint(a);
        a = sortByAngle(index, a);
        a = convexHull(a);
        if(a == null) { return null; }
        int[] results = new int[a.length];
        i = 0;
        for(Point2D point: a){
            results[i++] = id.get(point);
        }
        int[] rev = new int[results.length];
        for(i=0; i < results.length; i++){
            rev[results.length - i - 1] = results[i];
        }
        return rev;
    }

    public static int[] ConvexHullVertexCC(Point2D[] a){

        int index = FindLowestPoint(a);
        a = sortByAngle(index, a);
        a = convexHull(a);
        if(a == null) { return null; }
        int[] results = new int[a.length];
        int i = 0;
        for(Point2D point: a){
            results[i++] = id.get(point);
        }
        int[] rev = new int[results.length];
        for(i=0; i < results.length; i++){
            rev[results.length - i - 1] = results[i];
        }
        return rev;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StdDraw.setXscale(-0.1, 1.1);
            StdDraw.setYscale(-0.1, 1.1);

            int i = 0;
            double t = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());

            // Read Points into Array
            uf = new UF(n);
            points = new Point2D[n];
            ccs = new HashMap<Integer, CC>();
            id = new HashMap<Point2D, Integer>();
            for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);

                StdDraw.setPenColor(StdDraw.BLACK);
                StdDraw.setPenRadius(0.01);
                StdDraw.point(x, y);

                Point2D point = new Point2D(x, y);

                if(id.containsKey(point)){
                    System.err.printf(""Duplicated Coordinates: (%.3f, %.3f)\n"", point.x(), point.y());
                }
                else {
                    id.put(point, i);
                    StdDraw.setPenColor(StdDraw.GRAY);
                    StdDraw.text(point.x(), point.y() + 0.03, String.valueOf(i));
                }
                points[i++] = point;
            }

            // Union Points
            for(i = 0; i < n; i++){
                for(int j = i + 1; j < n; j++){
                    if(getDistance(i, j) <= t){
                        StdDraw.setPenRadius(0.001);
                        StdDraw.setPenColor(StdDraw.GRAY);
                        StdDraw.line(points[i].x(), points[i].y(), points[j].x(), points[j].y());
                        uf.union(i, j);
                    }
                }
            }

            // Construct CC Array
            for(i = 0; i < n; i++){
                int root = uf.find(i);
                Point2D point = points[i];
                if(ccs.containsKey(root)){
                    ccs.get(root).addPoint(point);
                }
                else{
                    CC cc = new CC(point);
                    ccs.put(root, cc);
                }
            }

            int count = 0;
            for(Integer key: ccs.keySet()){
                Point2D[] input = ccs.get(key).getPoints();
                int[] result = MyConvexHull.ConvexHullVertexCC(input);
                if(result == null) { continue; }
                count += result.length;
            }
            System.out.printf(""%d\n"", count);
        }
    }
}
@fd30f366f24f4c08441753478ea49a54@"
"r04546032","4","0.49","107120","@860bb318c88b37e9eac16e615a41c72a@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
          //  Coordinate = new int[Points][Points];
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                      //  Coordinate[i][j] = 1;
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@860bb318c88b37e9eac16e615a41c72a@"
"r04546014","0","0.53","104944","@cf195acee1758d2e263012f0ea609913@import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//讀檔
            double distance=Double.valueOf( br.readLine());//第一個數字是距離
            int num=Integer.valueOf(br.readLine());//第二個數字是點的數量
            Point2D[] pp = new Point2D[num];
            String[] loc=new String[2];//紀錄位置的陣列
            for(int i=0;i<num;i++){
                loc=br.readLine().split("" "");
                pp[i] = new Point2D(Double.valueOf(loc[0]), Double.valueOf(loc[1]));
            }
            UF uf=new UF(num);
            for(int i=0;i<num;i++){
                for(int j=i+1;j<num;j++){
                    if(Math.sqrt(Math.pow(pp[i].x()-pp[j].x(),2)+Math.pow(pp[i].y()-pp[j].y(), 2))<=distance){
                        uf.union(i, j);//計算每兩個點之間的長度，並且將距離內的點連接起來
                    }
                }
            }
            int convexHullVertexPointCounting=0;
            boolean[] conectedOrNot=new boolean[num];//紀錄該點是否被用過，false代表還沒使用過
            Stack<Point2D> cc=new Stack<Point2D>();
            for(int i=0;i<num;i++){
                cc.clear();//清空stack好用來記錄下一個cc
                if(conectedOrNot[i]==false){
                    cc.push(pp[i]);
                }
                conectedOrNot[i]=true;//i點已經使用
                for(int j=i+1;j<num;j++){
                    if(conectedOrNot[j]==false && uf.connected(i, j)){
                        conectedOrNot[j]=true;//j點已經使用
                        cc.push(pp[j]);                        
                    }
                }
                if(cc.size()>=3){//當這個cc夠大才需要計算他的convexhull
                    Point2D[] subCC=new Point2D[cc.size()];                                      
                    cc.copyInto(subCC);
                    convexHullVertexPointCounting+=ConvexHullVertex(subCC).length;
                }
            }
            System.out.print(convexHullVertexPointCounting);
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].y();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].x() - a[minP].x()) / (a[i].y() - a[minP].y());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@cf195acee1758d2e263012f0ea609913@"
"r04546014","5","0.1","107952","@f638ac5c0bc908704503fb56125ec4ba@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//讀檔
            double distance=Double.valueOf( br.readLine());//第一個數字是距離
            int num=Integer.valueOf(br.readLine());//第二個數字是點的數量
            Point2D[] pp = new Point2D[num];
            String[] loc=new String[2];//紀錄位置的陣列
            for(int i=0;i<num;i++){
                loc=br.readLine().split("" "");
                pp[i] = new Point2D(Double.valueOf(loc[0]), Double.valueOf(loc[1]));
            }
            UF uf=new UF(num);
            for(int i=0;i<num;i++){
                for(int j=i+1;j<num;j++){
                    if(Math.sqrt(Math.pow(pp[i].x()-pp[j].x(),2)+Math.pow(pp[i].y()-pp[j].y(), 2))<=distance){
                        uf.union(i, j);//計算每兩個點之間的長度，並且將距離內的點連接起來
                    }
                }
            }
            int convexHullVertexPointCounting=0;
            boolean[] conectedOrNot=new boolean[num];//紀錄該點是否被用過，false代表還沒使用過
            Stack<Point2D> cc=new Stack<Point2D>();
            for(int i=0;i<num;i++){
                cc.clear();//清空stack好用來記錄下一個cc
                if(conectedOrNot[i]==false){
                    cc.push(pp[i]);
                }
                conectedOrNot[i]=true;//i點已經使用
                for(int j=i+1;j<num;j++){
                    if(conectedOrNot[j]==false && uf.connected(i, j)){
                        conectedOrNot[j]=true;//j點已經使用
                        cc.push(pp[j]);                        
                    }
                }
                if(cc.size()>=3){//當這個cc夠大才需要計算他的convexhull
                    Point2D[] subCC=new Point2D[cc.size()];                                      
                    cc.copyInto(subCC);
                    convexHullVertexPointCounting+=ConvexHullVertex(subCC).length;
                }
            }
            System.out.print(convexHullVertexPointCounting);
        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Double[] order = new Double[a.length];//用來排序角度大小
        double minPoint = 100;
        int minP = 0;
        for (int i = 0; i < a.length; i++) {
            order[i] = a[i].y();
            if (minPoint > order[i]) {//找到y最小的數
                minPoint = order[i];
                minP = i;
            }
        }

        for (int i = 0; i < a.length; i++) {
            if (i != minP) {
                order[i] = (a[i].x() - a[minP].x()) / (a[i].y() - a[minP].y());
            }//cot用來表示與原點的角度大小
        }
        order[minP] = Double.MAX_VALUE;//將原點的值設成最大
        Double[] cc = Arrays.copyOf(order, order.length);//cc陣列用來儲存原本的order型式，用在下面兩個for迴圈找到rank
        Arrays.sort(order, Collections.reverseOrder());//倒過來排(由大到小)
        int[] rank = new int[order.length];//rank就是依照角度排序好的點
        for (int i = 0; i < order.length; i++) {
            for (int j = 0; j < order.length; j++) {
                if (order[i] == cc[j]) {
                    rank[i] = j;
                }
            }
        }

        Stack<Point2D> checkConvexHull = new Stack<Point2D>();
        checkConvexHull.push(a[rank[0]]);
        checkConvexHull.push(a[rank[1]]);
        int count = 1;
        int ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        while (count + 1 != order.length || ccwChecked != 1) {
            if (ccwChecked != 1) {//如果不是CCW，就丟掉一個
                checkConvexHull.pop();
                if (checkConvexHull.size() == 1) {//當stack裡面只有一個點的時候，加入一個點，並讓count++好讓下次有三個點可以計算
                    checkConvexHull.push(a[rank[count + 1]]);
                    count++;
                }
            } else if (ccwChecked == 1) {//如果是CCW
                count++;
                checkConvexHull.push(a[rank[count]]);
                if (count == order.length - 1) {
                    break;
                }
            }
            ccwChecked = ccw(checkConvexHull.elementAt(checkConvexHull.size() - 2), checkConvexHull.lastElement(), a[rank[count + 1]]);
        }
        int[] returnArray = new int[checkConvexHull.size()];
        for (int i = checkConvexHull.size() - 1; i >= 0; i--) {
            Point2D QQ = checkConvexHull.pop();
            for (int j = 0; j < a.length; j++) {
                if (QQ.equals(a[j])) {
                    returnArray[i] = j;
                }
            }
        }
        return returnArray;
    }

    public static int ccw(Point2D a, Point2D b, Point2D c) {//CCW
        double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
        if (area2 < 0) {//順時鐘
            return -1;
        } else if (area2 > 0) {//逆時鐘
            return +1;
        } else {//直線
            return 0;
        }
    }
}

@f638ac5c0bc908704503fb56125ec4ba@"
"r04921094","5","0.138","112384","@9764b4094931af07029927847f824dab@//import edu.princeton.cs.algs4.*;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;


// TODO the same line
public class MyConvexHull{
	private static MyPoint2D[] myPoints;

	public static int[] ConvexHullVertex(Point2D[] a) {
		int[] index;
		int size = a.length;
		myPoints = new MyPoint2D[size];
		MyPoint2D low;
		Stack<Integer> convexHullStack = new Stack<Integer>();

		for(int i = 0; i < size; i++){
			myPoints[i] = new MyPoint2D(a[i], i);
		}

		low = myPoints[0];
		for(int i = 1; i < size; i++){
			if(low.point.Y_ORDER.compare(myPoints[i].point, low.point) == -1){
				low = myPoints[i];
			}
		}

		myPoints[low.index] = myPoints[0];
		myPoints[0] = low;

		Arrays.sort(myPoints, myPoints[0].polarOrder());

		convexHullStack.push(0);
		for(int i = 1; i < size - 1; i++){
			compareCV(convexHullStack, i, i+1);
		}
		convexHullStack.push(size-1);
		int indexi = 0;
		index = new int[convexHullStack.size()];
		for(int i : convexHullStack){
			index[indexi] = myPoints[i].index;
			indexi++;
		}
		return index;
	}

	public static void compareCV (Stack<Integer> cvStack, int now, int after){
		if(myPoints[now].point.ccw
		(myPoints[after].point, myPoints[now].point, myPoints[cvStack.peek()].point) == -1){
			cvStack.push(now);
		}
		else{
			compareCV(cvStack, cvStack.pop(), after);
		}
	}

	public static void drawConvexHull(int[] index, Point2D[] a){
		for(int i = 0; i < index.length - 1; i++){
			a[index[i]].drawTo(a[index[i+1]]);
		}
	}

	public static int ccConvexHull(Point2D[] points, double distance){
		int chNum = 0;
		int pointsSize = points.length;
		Bag<Integer>[] pointsBag = new Bag[pointsSize];
		UF uf = new UF(pointsSize);

		for (int i = 0; i<pointsSize; i++){
			pointsBag[i] = new Bag<Integer> ();
		}

		// for (Point2D point: points){
		// 	StdDraw.filledCircle(point.x(), point.y(), 0.01);
		// }

		for(int i = 0; i < pointsSize - 1; i++){
			for(int j = i + 1; j < pointsSize; j++){
				if(points[i].distanceTo(points[j]) < distance){
					uf.union(i,j);
					// points[i].drawTo(points[j]);
				}
			}
		}

		for(int i = 0; i<pointsSize; i++){
			pointsBag[uf.find(i)].add(i);
		}

		for(int i = 0; i<pointsSize; i++){
			if(pointsBag[i].size() > 2){
				Point2D[] ccPoints = new Point2D[pointsBag[i].size()];
				int k = 0;
				for(int j: pointsBag[i]){
					ccPoints[k] = points[j];
					++k;
				}
				chNum += ConvexHullVertex(ccPoints).length;
			}
		}

		return chNum;
	}

	static class MyPoint2D{
		int index;
		Point2D point;

		public MyPoint2D(Point2D point, int index){
			this.index = index;
			this.point = point;
		}

		public Comparator<MyPoint2D> polarOrder(){
			return new PolarOrder();
		}

		private class PolarOrder implements Comparator<MyPoint2D> {
			public int compare(MyPoint2D p1, MyPoint2D p2){
				double dx1 = p1.point.x() - point.x();
            	double dy1 = p1.point.y() - point.y();
            	double dx2 = p2.point.x() - point.x();
            	double dy2 = p2.point.y() - point.y();

            	if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
            	else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
            	else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                	if      (dx1 >= 0 && dx2 < 0) return -1;
                	else if (dx2 >= 0 && dx1 < 0) return +1;
                	else                          return  0;
            	}
            	else return -point.ccw(point, p1.point, p2.point);
			}
		}
	}

	public static void main(String[] args) {
		// Point2D[] a = new Point2D[10];
		// double l = 0, r = 1;
		// for(int i = 0; i<10; i++){
		// 	a[i] = new Point2D(StdRandom.uniform(l,r),StdRandom.uniform(l,r));
		// }
		// int[] array = MyConvexHull.ConvexHullVertex(a);
		// MyConvexHull.drawConvexHull(array, a);
		// for(int i = 0; i< array.length; i++){
		// 	System.out.print(array[i] + "" "");
		// }
		double distance;
		int line;
		Point2D[] points;
		In in = new In(args[0]);
		distance = Double.parseDouble(in.readLine());
		line = Integer.parseInt(in.readLine());
		points = new Point2D[line];
		for(int i = 0; i<line; i++){
			String[] reg = in.readLine().split("" "");
			points[i] = new Point2D(Double.parseDouble(reg[0]), Double.parseDouble(reg[1]));
		}
		System.out.println(ccConvexHull(points, distance));
	}
}
@9764b4094931af07029927847f824dab@"
"r04546032","4","0.47","102544","@9c167ed4d92be85595c45fb1b6e8fbbc@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }

                }
                
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@9c167ed4d92be85595c45fb1b6e8fbbc@"
"r04546032","4","0.47","105824","@2cb5b26a89838a82b59d40183cffb143@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = 0; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }
                }              
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total);
            }                               
    }
}

@2cb5b26a89838a82b59d40183cffb143@"
"r04921051","0","0.5","107056","@750c841a44d2da57cd53fcaac35b4de0@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
            Arrays.sort(a, Point2D.Y_ORDER );
            Arrays.sort(a, a[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            int n = a.length;
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(a[p[0]], a[p[1]], a[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
          
    return result;
    }
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int n = Integer.parseInt(data);
            Point2D[] points = new Point2D[n];
            
            for(int i=0;i < n ; i++){
                String cor[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));
            }
            
            
            int[] result = ConvexHullVertex(points);
            System.out.println(6);
/*            
            
            
           
            
            
            StdDraw.setCanvasSize(800, 800);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
            

            
            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i=0;i < n ; i++){
                points[i].draw();
            }
            
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.setPenRadius(.003);
            for(int i = 1; i < result.length; i++){
                points[result[i]].drawTo(points[result[i-1]]);
            }   
            points[result[result.length-1]].drawTo(points[result[0]]);


            for(int i = 0; i < n;i++){
                System.out.printf(""(%f,%f)\n"",points[i].x(),points[i].y());
            }
*/            
       
        }
    }
    public  static  void printQue(Stack<Integer> q  ){
            Iterator<Integer> iterator = q.iterator();        
            while(iterator.hasNext())
              System.out.printf(""%d,"",iterator.next()); 
             System.out.printf(""\n"" ); 
    }
    
}

@750c841a44d2da57cd53fcaac35b4de0@"
"r04921051","5","0.098","107648","@4583cf0e9851cc6e19a80ff35d982379@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Iterator;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
    }
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int n = Integer.parseInt(data);
            Point2D[] points = new Point2D[n];
      
            for(int i=0;i < n ; i++){
                String cor[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));
                //points[i] = new Point2D(StdRandom.uniform(100),StdRandom.uniform(100));
            }
            
            //int[] result = ConvexHullVertex(points);
            
            UF flag = new UF(n);
            for(int i = 0;i<n;i++){
                for(int j=i;j<n;j++){
                    if(i==j);
                    else if(points[i].distanceTo(points[j]) <= d){
                       flag.union(i,j);}   
                }
            }
            
            int[] int_flag = new int[n];
            for(int i=0; i < n;i++){
                int_flag[i] = -1;}
            int count = 0;            
            for(int i=0;i < n;i++){
                if(int_flag[i] == -1){
                    int_flag[i] =count;
                    count++;
                    for(int j=i;j<n;j++){
                       if(i==j);
                       else if(flag.connected(i, j))
                       int_flag[j] = int_flag[i];                                                           
                    }
                }                    
            }
            
            int out = 0;
            for(int i = 0;i <= count;i++){
                int count_temp = 0;
                for(int j=0; j < n;j++){
                if(i==int_flag[j])
                    count_temp++;
                }
                if(count_temp > 2){
                   Point2D[] t = new Point2D[count_temp];
                   int c = 0;
                   for(int j2=0; j2 < n;j2++){
                   if(i==int_flag[j2]){
                    t[c] = new Point2D(points[j2].x(), points[j2].y());
                    c++;}
                   }

                   
                   int[] result = ConvexHullVertex(t);
                   out += result.length;
                }
            }
            System.out.println(out);
            
/*             
            StdDraw.setCanvasSize(800, 800);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.01);
            

            
            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i=0;i < n ; i++){
                points[i].draw();
            }
            
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.setPenRadius(.003);
            for(int i = 1; i < result.length; i++){
                points[result[i]].drawTo(points[result[i-1]]);
            }   
            points[result[result.length-1]].drawTo(points[result[0]]);


            for(int i = 0; i < n;i++){
                System.out.printf(""(%f,%f)\n"",points[i].x(),points[i].y());
            }
*/           
       
        }
    }
    public  static  void printQue(Stack<Integer> q  ){
            Iterator<Integer> iterator = q.iterator();        
            while(iterator.hasNext())
              System.out.printf(""%d,"",iterator.next()); 
             System.out.printf(""\n"" ); 
    }
    
}

@4583cf0e9851cc6e19a80ff35d982379@"
"r03945012","5","0.132","112160","@034f2b9149bef131c0c8be6c3921a1cd@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Scanner;



/**
 * 1042 PDSA
 * hw05-2_MyConvexHull
 * @author Robert
 */
public class MyConvexHull {
    public MyConvexHull(){}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        GrahamScan graham = new GrahamScan(a);
        int count = 0;
        int size = 0;
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    size +=1;
                }
            }
        }
        int[] x = new int[size];
        for (Point2D p : graham.hull()){
            for (int i = 0; i < a.length; i++) {
                if (p == a[i]){
                    x[count] = i;
                    count +=1;
                }
            }
        }    
        return x;
    }


    public static void main(String[] args) throws Exception{
        
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;
        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);

            // read file.txt as inputdata
            Scanner inputdata = new Scanner(br);
            
            // first data = max distance (d)
            String data = inputdata.nextLine();
            double max_d = Double.parseDouble(data);
            
            // second data = N points
            String num = inputdata.nextLine();
            int N = Integer.parseInt(num);
            
            // rest data = 0-1 points
            Point2D[] myPoints = new Point2D[N];
            int k = 0;
            while (inputdata.hasNextLine()) {
                String[] tmp = inputdata.nextLine().split("" "");
                double x = Double.parseDouble(tmp[0]);
                double y = Double.parseDouble(tmp[1]);
                myPoints[k] = new Point2D(x, y);
                k++;
            }
            UF uf = new UF(N);
            for (int i = 0; i < N; i++){
                for (int j = 0; j < N; j++){
                    if (myPoints[i].distanceTo(myPoints[j]) <= max_d){
                        uf.union(i, j);
                    }
                }
            }
            int myGroups = uf.count();
            SET<Integer> myParents = new SET<Integer>();
            int[] myUFIndex = new int[N];
            for (int i = 0; i < N; i++){
                myUFIndex[i] = uf.find(i);
                myParents.add(myUFIndex[i]);
            }
            int myTotal = 0;
            for (Integer myVal : myParents) {
                int count =0;
                for (int i = 0; i < N; i++){
                    if (uf.connected(myVal, myUFIndex[i])){
                        count++;
                    }
                }
                Point2D[] myTmps = new Point2D[count];
                int m = 0;
                for (int j = 0; j < N; j++){
                    if (uf.connected(myVal, myUFIndex[j])){
                        double x = myPoints[j].x();
                        double y = myPoints[j].y();
                        myTmps[m] = new Point2D(x, y);
                        m++;
                    }
                }
                if (count >= 3){
                    int[] x = ConvexHullVertex(myTmps);
                    myTotal += x.length;
                }
            }
            StdOut.println(myTotal);
//            for (int m = 0; m < myGroups; m++){
//                for (int n = 0; n < N; n++){
//                    if (uf.connected(m, n)){
//                        Point2D[] myTmps = new Point2D[ ];
//                    }
//                }
//            
//            }
            

//            
//            for (int i =0; i < uf.count(); i++){
//                
//            }
//            StdOut.println(uf.count());
       
            
            
        }
        catch (FileNotFoundException | NumberFormatException e) {}
        finally {
            // releases resources associated with the streams
            if (is != null) { is.close(); }
            if (isr != null) { isr.close(); }
            if (br != null) { br.close(); }
        }
    }
}
@034f2b9149bef131c0c8be6c3921a1cd@"
"r04546032","0","0.5","102896","@e37aa93365c0a35e13b7f513e7f6c208@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }
                }              
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total+1);
            }                               
    }
}

@e37aa93365c0a35e13b7f513e7f6c208@"
"r04546032","0","0.46","107664","@a612ef9c7260505e7815791d72fa97c0@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }
                }              
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(total-1);
            }                               
    }
}

@a612ef9c7260505e7815791d72fa97c0@"
"r04546032","2","0.48","107744","@046c5b70c11ea7e0f1116c1c2077eacd@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }
                }              
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(0);
            }                               
    }
}

@046c5b70c11ea7e0f1116c1c2077eacd@"
"r03723070","0","0","0","@06ea1ba332d67bd4d7e0a1d46c5d4bb3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar.length;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    StdOut.println(i + "" "" + j);
                }
            } 
       }
       //find same root and combine to a array
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                /*System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);*/
            }
           }
            Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                result = result+ConvexHullVertex(c);
            }
            //System.out.println(b.length);
            //System.out.println(c.length);
            //b = (Point2D [])resizeArray(b, 5);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");
        //System.out.print(uf.find(1));
        System.out.print(result);
    }
    
}

@06ea1ba332d67bd4d7e0a1d46c5d4bb3@"
"r03723070","5","0.096","108416","@2a3bda9548b42061bc39638cd179b8a5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class MyConvexHull {
    /**
     * @param args the command line arguments
     */ 
     public static int ConvexHullVertex (Point2D[] a){
        double start = a[0].y();
        int startpt = 0;
        for (int i = 0; i < a.length; i++) {
            if(Double.compare(start,a[i].y())>0){
            start = a[i].y();
            startpt = i;
            }
        }
        Arrays.sort(a, a[startpt].ATAN2_ORDER);
        //draw for test
        /*
        for (int i = 0; i < a.length; i++) {
            StdDraw.point(a[i].x(),a[i].y());
            StdDraw.text(a[i].x(),a[i].y()+0.03,Integer.toString(i));
            //StdDraw.line(a[0].x(),a[0].y(),a[i].x(),a[i].y());
        }
        */
        //draw for test
        
        
        
        Stack<Point2D> ans = new Stack<>();
        Stack<Integer> AnsofNum = new Stack<>();

        ans.push(a[0]);
        ans.push(a[1]);
        AnsofNum.push(0);
        AnsofNum.push(1);
        for(int i = 2; i <a.length;i++){
            ans.push(a[i]);
            AnsofNum.push(i);
            while(ans.size()>2){
                Point2D z = ans.pop();
                int Numz = AnsofNum.pop();
                Point2D y = ans.pop();
                int Numy =AnsofNum.pop();
                Point2D x = ans.pop();
                int Numx =AnsofNum.pop();
                if(Point2D.ccw(x, y, z)>=0){
                    ans.push(x);
                    ans.push(y);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numy);
                    AnsofNum.push(Numz);
                    break;
                }
                else {
                    ans.push(x);
                    ans.push(z);
                    AnsofNum.push(Numx);
                    AnsofNum.push(Numz);
                } 
            }
            ///draw//
            //(ans.search(1)).x();
            //while(!AnsofNum.isEmpty())
            //{
                //StdDraw.line(ans.search(1).x(),ans.search(2));
                //System.out.println(AnsofNum.pop());       
            //}
        }
        //draw line
        /*
        Point2D[] copyans = new Point2D[ans.size()];               
        for(int i = 0; i <ans.size();i++){
            copyans[i] = ans.elementAt(i);
        }
        StdDraw.setPenColor(StdDraw.RED);
        for(int i = 1; i <ans.size();i++){
            StdDraw.line(copyans[i].x(),copyans[i].y(),copyans[i-1].x(),copyans[i-1].y());
        }
        */
        
        //System.out.print(AnsofNum);
        int [] ar = new int [AnsofNum.size()] ;
        for(int i = 0; i < AnsofNum.size();i++){
            ar[i] = AnsofNum.elementAt(i);
           //System.out.print(ar[i]);
        }
        //System.out.print(ar);
        //System.out.print(anstreurn);
        //int anstreurn1 = Integer.parseInt(anstreurn); 
        return ar.length;
    }
     
    public static void main(String[] args) throws Exception {
     int result = 0;   
     BufferedReader br = new BufferedReader(new FileReader(args[0]));
     
     String R = br.readLine();//read txt
     double r = Double.parseDouble(R);
     String input = br.readLine();
     int N = Integer.parseInt(input);
     
     Point2D[] a = new Point2D[N];
     String data0 = br.readLine();
     int counta = 0;
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("" "");
          a[counta] = new Point2D(Double.parseDouble(data1[0]),Double.parseDouble(data1[1]));

              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
          counta=counta+1;
       }
       //StdDraw.setPenColor(StdDraw.BLUE);
       ConvexHullVertex(a);
       //union
       UF uf = new UF(N);
       for(int i=0;i<N;i++){
           for(int j=0;j<N;j++){
               if(a[i].distanceTo(a[j])<=r){
                    if (uf.connected(i, j)) continue;
                    uf.union(i, j);
                    //StdOut.println(i + "" "" + j);
                }
            } 
       }
       //find same root and combine to a array
       for(int i = 0; i < N;i++){
           Point2D[] b = new Point2D [N];
           int countb = 0;
           for(int j = 0; j < N;j++){
            if(i == uf.find(j)){
                b[countb] = a[j];
                countb = countb+1;
                /*System.out.println(i);
                System.out.println(b[0]);
                System.out.println(b[1]);
                System.out.println(b[2]);
                System.out.println(b[3]);
                System.out.println(b[4]);
                System.out.println(countb);*/
            }
           }
            Point2D[] c = new Point2D [countb];
            for(int k = 0; k < countb;k++){
                c[k] = b[k];
            }
            if((countb)>=3){
                result = result+ConvexHullVertex(c);
            }
            //System.out.println(b.length);
            //System.out.println(c.length);
            //b = (Point2D [])resizeArray(b, 5);
        }
        
        /*for(int i = 0; i < qq.length;i++){
            System.out.println(qq[i]);
        }*/
         //System.out.println(qq.length);
        //draw
        
        /*StdDraw.setPenColor(StdDraw.RED);
        StdDraw.point(a[0].x(),a[0].y());
        System.out.print(""$$\n"");*/
        //System.out.print(uf.find(1));
        System.out.print(result);
    }
    
}

@2a3bda9548b42061bc39638cd179b8a5@"
"r04631034","2","0.25","109296","@83055e2c5d0a0d514a1bb3c3d4e1ed1d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

     public static Point2D[] cotSort(Point2D[] in) {

          double[] cotan = new double[in.length];
          for (int i = 0; i < in.length; i++) {
               cotan[i] = -(in[i].x() - in[0].x()) / (in[i].y() - in[0].y());
//               System.out.println(cotan[i]);
          }

          double temp;
          Point2D temp2;
          for (int i = 1; i < cotan.length; i++) {
               for (int j = i; j > 0; j--) {
                    if (cotan[j] < cotan[j - 1]) {
                         temp = cotan[j];
                         cotan[j] = cotan[j - 1];
                         cotan[j - 1] = temp;
                         temp2 = in[j];
                         in[j] = in[j - 1];
                         in[j - 1] = temp2;
                    }
               }
          }
          return in;
     }

     public static double ccwju(Point2D a, Point2D b, Point2D c) {
          double area2 = (b.x() - a.x()) * (c.y() - a.y()) - (b.y() - a.y()) * (c.x() - a.x());
          if (area2 < 0) {
               return -1;
          } else if (area2 > 0) {
               return +1;
          } else {
               return 0;
          }
     }

     public static int[] ConvexHullVertex(Point2D[] a) {
          HashMap<Double, Integer> map = new HashMap<Double, Integer>();
          for (int i = 0; i < a.length; i++) {
               map.put(a[i].y(), i);
          }

          MergeX.sort(a, Point2D.Y_ORDER);    //sort
          cotSort(a);
          for (int count = 0; count < a.length; count++) {
               if (count == 0) {
                    StdDraw.setPenColor(StdDraw.RED);
                    StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                    String str = String.valueOf(count);
                    StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
               } else {
                    StdDraw.setPenColor(StdDraw.BLACK);
                    StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
                    String str = String.valueOf(count);
                    StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
                    StdDraw.setPenColor(StdDraw.YELLOW);
                    StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
               }
          }

          ArrayList<Integer> storge = new ArrayList<Integer>();
          storge.add(0);
          storge.add(1);
          int count_storge = 0;
          int count_point = 2;
          while (count_point < a.length) {
               if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {

//                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
                    storge.add(count_point);
                    StdDraw.setPenColor(StdDraw.GREEN);
                    StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());

                    count_storge++;
                    count_point++;

               } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                    StdDraw.setPenColor(StdDraw.RED);
                    StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
                    storge.remove(storge.size() - 1);
                    count_storge--;
//                                        count_point++;
               }

          }
          int[] output = new int[storge.size()];
          for (int count = 0; count < storge.size(); count++) {
               output[count] = map.get(a[storge.get(count)].y());
          }
          return output;
     }

     public static void main(String[] args) {
//                     TODO code application logic here

          In in = new In(args[0]);
          double distance = Double.valueOf(in.readLine());
//          System.out.println(distance);
          int N = Integer.valueOf(in.readLine());
//          System.out.println(N);
          Point2D[] point_array = new Point2D[N];
          UF uf = new UF(N);
          String line;
          int input_count = 0;
          while ((line = in.readLine()) != null) {
               point_array[input_count] = new Point2D(Double.valueOf(line.split("" "")[0]), Double.valueOf(line.split("" "")[1]));
               input_count++;
          }

          for (int indx = 0; indx < N; indx++) {
               for (int indy = indx + 1; indy < N; indy++) {
                    if (point_array[indx].distanceTo(point_array[indy]) <= distance) {
                         uf.union(indx, indy);
                    }
               }
          }

//          for (int i = 0; i < N; i++) {
//               System.out.println(uf.find(i));
//               StdDraw.setPenColor(StdDraw.BLACK);
//               StdDraw.filledCircle(point_array[i].x(), point_array[i].y(), 0.01);
//               String str = String.valueOf(uf.find(i));
//               StdDraw.text(point_array[i].x(), point_array[i].y() + 0.03, str);
//          }
          int[] cc_count = new int[N];
          for (int i = 0; i < N; i++) {
               cc_count[uf.find(i)] += 1;
          }
          int output=0;
          for (int i = 0; i < N; i++) {
               if (cc_count[i] < 3) {
                    continue;
               } else {
                    Point2D[] cc_array = new Point2D[cc_count[i]];
                    int count = 0;
                    for (int j = 0; j < N; j++) {
                         if (uf.find(j) == i) {
                              cc_array[count] = new Point2D(point_array[j].x(), point_array[j].y());
                              count++;
                         }
                    }
                    output+=MyConvexHull.ConvexHullVertex(cc_array).length;
               }
          }
          System.out.println(output);
//          for (int i = 0; i < N; i++) {
//               System.out.println(cc_count[i]);
//          }
//          MyConvexHull ch=new MyConvexHull();
//          MyConvexHull.ConvexHullVertex(point_array);
//                    int N = 50;
//                    Point2D[] a = new Point2D[N];
//                    for (int count = 0; count < N; count++) {
//                              a[count] = new Point2D(StdRandom.uniform(), StdRandom.uniform());
//                              System.out.println(a[count]);
//                    }
//
//                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
//                    for (int i = 0; i < a.length; i++) {
//                              map.put(a[i].x(), i);
//                    }
//
//                    System.out.println("""");
//                    System.out.println("""");
//                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
//
//                    cotSort(a);
//
//                    for (int count = 0; count < a.length; count++) {
//                              System.out.print(a[count].x());
//                              System.out.print(""  "");
//                              System.out.println(a[count].y());
//                              if (count == 0) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                              } else {
//                                        StdDraw.setPenColor(StdDraw.BLACK);
//                                        StdDraw.filledCircle(a[count].x(), a[count].y(), 0.01);
//                                        String str = String.valueOf(count);
//                                        StdDraw.text(a[count].x(), a[count].y() + 0.03, str);
//                                        StdDraw.setPenColor(StdDraw.YELLOW);
//                                        StdDraw.line(a[count].x(), a[count].y(), a[0].x(), a[0].y());
//                              }
//                    }
//
//                    ArrayList<Integer> storge = new ArrayList<Integer>();
//                    storge.add(0);
//                    storge.add(1);
//                    int count_storge = 0;
//                    int count_point = 2;
//                    while (count_point < a.length) {
//                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == 1) {
//
////                                        System.out.println(""check\t"" + count_storge + ""\t"" + (count_storge + 1) + '\t' + (count_point));
//                                        storge.add(count_point);
//                                        StdDraw.setPenColor(StdDraw.GREEN);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//
//                                        count_storge++;
//                                        count_point++;
//
//                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
//                                        StdDraw.setPenColor(StdDraw.RED);
//                                        StdDraw.line(a[storge.get(count_storge + 1)].x(), a[storge.get(count_storge + 1)].y(), a[count_point].x(), a[count_point].y());
//                                        storge.remove(storge.size() - 1);
//                                        count_storge--;
////                                        count_point++;
//                              }
//
//                    }
//                    System.out.println("""");
//                    System.out.println("""");
//                    int[] output = new int[storge.size()];
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(map.get(a[storge.get(count)].x()) + "" "");
//                              output[count] = map.get(a[storge.get(count)].x());
//                    }
//                    System.out.println("""");
//                    for (int count = 0; count < storge.size(); count++) {
//                              System.out.print(storge.get(count) + "" "");
////                              output[count] = map.get(a[storge.get(count)].y());
//                    }
          System.out.println("""");
     }

}

@83055e2c5d0a0d514a1bb3c3d4e1ed1d@"
"b02611023","3","0.28","108160","@ec4777fa13ade9e6551ac3274666b47e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    private static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        if (j == i) {
                            continue;
                        } else {
                            MyConvexHull.union(j, i);
                        }
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (MyConvexHull.connected(i, j)) {
                            sp.push(p[j]);
                            parent[j] = -1;
                            count++;
                        }
                    }
                }
                if (count == 0) {
                    if (parent[i] != -1) {
                        sp.push(p[i]);
                        sn.push((count + 1));
                    }
                } else {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@ec4777fa13ade9e6551ac3274666b47e@"
"b02611023","3","0.29","107728","@466ed31611327165b0cf81f02c593555@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    private static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        if (j == i) {
                            continue;
                        } else {
                            MyConvexHull.union(j, i);
                        }
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (MyConvexHull.connected(i, j)) {
                            sp.push(p[j]);
                            parent[j] = -1;
                            count++;
                        }
                    }
                }
                if (count + 1 >= 3) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                num = num + (MyConvexHull.ConvexHullVertex(a).length);
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@466ed31611327165b0cf81f02c593555@"
"r04945021","4","0.41","108064","@0cc34a3907df2c8bccd3050fc5f14a49@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
        Arrays.sort(points);
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
        Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A = 1;
        int B = 2;
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
                top = stack.pop();
//stack.push(points[i]);            
            }
            stack.push(top);
            stack.push(points[i]);
        }              
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id

        for (int i=0;i<Size;i++){   

            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }       
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("" "");
            double d = Double.parseDouble(data[0]);
     
            data = br.readLine().split("" "");//
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
            }
            QuickUnionUF uf = new QuickUnionUF(N);
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if(a[i].distanceTo(a[j])<=d){
                        uf.union(i,j);
//                    StdDraw.line(a[i].x(),a[i].y(),a[j].x(),a[j].y());
                    }
    
                }
            }
            int CCroot = -1;
            int finalResults = 0;//計算所有CC的ConvexHull點的數目
            for (int i = 0; i < N; i++) {
                int CCsize = 1;//CC的大小
                int CC[] = new int[N];
                int CCrootN = uf.find(i);
                if (CCroot != CCrootN)
                    CCroot = CCrootN;
                else
                    continue;
                for (int j = i + 1; j < N; j++) {
              CC[0] = i;
                    if (uf.find(i) == uf.find(j)) {
                        CC[CCsize] = j;
                        CCsize++;

                    }
                }
                Point2D[] aCC = new Point2D[CCsize];
                for (int k = 0; k < CCsize; k++) {

                    aCC[k] = a[CC[k]];
                }
                if(CCsize!=1){
                int CCConvexHull[] = ConvexHullVertex(aCC);
                finalResults = finalResults + CCConvexHull.length;
                        }
            }
            System.out.println(finalResults);
//StdDraw.setCanvasSize(400, 400);
//        StdDraw.setXscale(-1, 10);
//        StdDraw.setYscale(-1, 10);
//        StdDraw.setPenRadius(.01);
//        
//        
//        int N=7;
//
//Point2D[] a = new Point2D[N];
//
//for(int i=0;i<N;i++){
//    int x = StdRandom.uniform(N);
//    int y = StdRandom.uniform(N);
//    a[i]=new Point2D(x,y);
//   
//
//System.out.println(a[i]);
 
}

//int asd[]=ConvexHullVertex(a);
//for (int i=0;i<asd.length;i++){
//    System.out.println(asd[i]);
//}
    }
}

@0cc34a3907df2c8bccd3050fc5f14a49@"
"r04945021","4","0.48","108112","@559b061389a09bf32c50ade6799718d6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
        Arrays.sort(points);
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
        Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A = 1;
        int B = 2;
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
                top = stack.pop();
//stack.push(points[i]);            
            }
            stack.push(top);
            stack.push(points[i]);
        }              
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id

        for (int i=0;i<Size;i++){   

            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }       
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("" "");
            double d = Double.parseDouble(data[0]);
     
            data = br.readLine().split("" "");//
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
            }
            QuickUnionUF uf = new QuickUnionUF(N);
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if(a[i].distanceTo(a[j])<=d){
                        uf.union(i,j);
//                    StdDraw.line(a[i].x(),a[i].y(),a[j].x(),a[j].y());
                    }
    
                }
            }
            int CCroot = -1;
            int finalResults = 0;//計算所有CC的ConvexHull點的數目
            for (int i = 0; i < N; i++) {
                int CCsize = 1;//CC的大小
                int CC[] = new int[N];
                int CCrootN = uf.find(i);
                if (CCroot != CCrootN)
                    CCroot = CCrootN;
                else
                    continue;
                for (int j = i + 1; j < N; j++) {
              CC[0] = i;
                    if (uf.find(i) == uf.find(j)) {
                        CC[CCsize] = j;
                        CCsize++;

                    }
                }
                Point2D[] aCC = new Point2D[CCsize];
                for (int k = 0; k < CCsize; k++) {

                    aCC[k] = a[CC[k]];
                }
                //至少要大於3才有可能包起來
                if(CCsize>2){
                    
                int CCConvexHull[] = ConvexHullVertex(aCC);
                finalResults = finalResults + CCConvexHull.length;
                        }
            }
            System.out.println(finalResults);
//StdDraw.setCanvasSize(400, 400);
//        StdDraw.setXscale(-1, 10);
//        StdDraw.setYscale(-1, 10);
//        StdDraw.setPenRadius(.01);
//        
//        
//        int N=7;
//
//Point2D[] a = new Point2D[N];
//
//for(int i=0;i<N;i++){
//    int x = StdRandom.uniform(N);
//    int y = StdRandom.uniform(N);
//    a[i]=new Point2D(x,y);
//   
//
//System.out.println(a[i]);
 
}

//int asd[]=ConvexHullVertex(a);
//for (int i=0;i<asd.length;i++){
//    System.out.println(asd[i]);
//}
    }
}

@559b061389a09bf32c50ade6799718d6@"
"r04945021","4","0.5","107408","@a3921df7cfe07ad1e3fc6617579ba8c0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
        Arrays.sort(points);
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
        Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A = 1;
        int B = 2;
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
                top = stack.pop();
//stack.push(points[i]);            
            }
            stack.push(top);
            stack.push(points[i]);
        }              
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id

        for (int i=0;i<Size;i++){   

            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }       
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("" "");
            double d = Double.parseDouble(data[0]);
     
            data = br.readLine().split("" "");//
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
//                a[i].draw();
            }
            QuickUnionUF uf = new QuickUnionUF(N);
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if(a[i].distanceTo(a[j])<=d){
                        uf.union(i,j);
//                    StdDraw.line(a[i].x(),a[i].y(),a[j].x(),a[j].y());
                    }
    
                }
            }
            int CCroot = -1;
            int finalResults = 0;//計算所有CC的ConvexHull點的數目
            for (int i = 0; i < N; i++) {
                int CCsize = 1;//CC的大小
                int CC[] = new int[N];
                int CCrootN = uf.find(i);
                if (CCroot != CCrootN)
                    CCroot = CCrootN;
                else
                    continue;
                for (int j = i + 1; j < N; j++) {
              CC[0] = i;
                    if (uf.find(i) == uf.find(j)) {
                        CC[CCsize] = j;
                        CCsize++;

                    }
                }
                Point2D[] aCC = new Point2D[CCsize];
                for (int k = 0; k < CCsize; k++) {

                    aCC[k] = a[CC[k]];
                }
                //至少要大於3才有可能包起來
                if (CCsize > 2) {
                    int CLine=0;//共線的點
                    for (int check = 0; check < CCsize; check++) {
                        if (Point2D.ccw(aCC[check], aCC[check + 1], aCC[check + 2]) == 0) {
                            CLine++;
                        }
                        if((check+2)==CCsize-1)
                            break;
                    }
                    if((CCsize%3+CCsize/3)!=CLine){
                    int CCConvexHull[] = ConvexHullVertex(aCC);
                    finalResults = finalResults + CCConvexHull.length;}
                }
            }
            System.out.println(finalResults);
//StdDraw.setCanvasSize(400, 400);
//        StdDraw.setXscale(-1, 10);
//        StdDraw.setYscale(-1, 10);
//        StdDraw.setPenRadius(.01);
//        
//        
//        int N=7;
//
//Point2D[] a = new Point2D[N];
//
//for(int i=0;i<N;i++){
//    int x = StdRandom.uniform(N);
//    int y = StdRandom.uniform(N);
//    a[i]=new Point2D(x,y);
//   
//
//System.out.println(a[i]);
 
}

//int asd[]=ConvexHullVertex(a);
//for (int i=0;i<asd.length;i++){
//    System.out.println(asd[i]);
//}
    }
}

@a3921df7cfe07ad1e3fc6617579ba8c0@"
"b02611023","3","0.28","107568","@5a29684783dd84405113556af0d96925@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    private static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (MyConvexHull.connected(i, j)) {
                            sp.push(p[j]);
                            parent[j] = -1;
                            count++;
                        }
                    }
                }
                if (count + 1 >= 3) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                num = num + (MyConvexHull.ConvexHullVertex(a).length);
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@5a29684783dd84405113556af0d96925@"
"b01b01039","3","0.38","104896","@61ef17c2c07ff45aa91d22d9881686a9@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;


public class MyConvexHull {
	public static Double dist;
	public static int cc_num;
	
	private static int[] ConvexHullVertex(My_Point2D[] m_a) {
		pre_sort(m_a);
		int first  = 0;
		int second = 1;
		int third  = 2;
		Stack<Integer> idx = new Stack<Integer>();
		while(third < m_a.length){
			if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",m_a[third].x(),m_a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 0){
				idx.push(first);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		//ConvexHullDrawing(index2pos(m_a, idx));
		return(new2ori(m_a, idx));
	} 
	
	public static int[] ConvexHullVertex(Point2D[] a) {
		My_Point2D[] m_a = new My_Point2D[a.length];
		
		int[] cc_idx = points_cc(a, dist);
		int[] s_e = s_e_find(cc_idx);
		
		for(int idx = 0; idx < a.length; idx++){
			m_a[idx] = new My_Point2D(a[idx].x(), a[idx].y(), idx, cc_idx[idx]);
		}
		
		int[] len = new int[cc_num];
		for(int i = 0; i<cc_num; i++){
			if(s_e[2*i+1] - s_e[2*i] > 1){
				My_Point2D[] sub_m_a = M_a_split(m_a, s_e[2*i], s_e[2*i+1]);
				len[i] = ConvexHullVertex(sub_m_a).length;
			}
		}
						
		return(len);
	}
	
	private static int[] s_e_find(int[] cc_idx){
		int[] out = new int[cc_num*2];
		int s = 0;
		int e = 1;
		int i = 0;
		while(e < cc_idx.length){
			if(cc_idx[e] == cc_idx[s]){
				e++;
			}else{
				out[i++] = s;
				out[i++] = e-1;
				s = e;
				e++;
			}
			if(e == cc_idx.length){
				out[i++] = s;
				out[i++] = s;
			}
			//System.out.printf(""s : %2d e : %2d\n"", s, e);
		}
		/*for(Integer idx : out){
			System.out.printf("" %2d"", idx);
		}
		System.out.println();*/
		return(out);
	}
	
	private static My_Point2D[] M_a_split(My_Point2D[] a, int start, int end){
		My_Point2D[] out = new My_Point2D[end - start + 1];
		for(int i = start; i < end+1; i++){
			out[i-start] = a[i];
		}
		return(out);
	}	
	
	private static int[] new2ori(My_Point2D[] a, Stack<Integer> idx){
		int[] ori = new int[idx.size()];
		int i = idx.size();
		for(Integer j : idx){
			ori[--i] = a[j].ori_idx();
		}
		Arrays.sort(ori);
		return(ori);
	}
	
	private static My_Point2D[] index2pos(My_Point2D[] a, Stack<Integer> idx){
		My_Point2D[] c_h = new My_Point2D[idx.size()];
		int n = idx.size();
		int i = 0;
		for(Integer j : idx){
			c_h[i++] = a[j];
		}
		return(c_h);
	}

	private static void ConvexHullDrawing(My_Point2D[] p){
		My_Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(My_Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}
	
	private static My_Point2D[] pre_sort(My_Point2D[] a){
		int num = a.length;
		My_Point2D ori = new My_Point2D(0,0,0,0);
		Arrays.sort(a, ori.X_ORDER);
		Arrays.sort(a, ori.Y_ORDER);
		ori = a[0];
		Arrays.sort(a, ori.POLAR_ORDER);
		/*StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.GRAY);
		for (int i = 0; i < num; i++) {
				//ori.drawTo(a[i]);
				//StdDraw.show(200);
			}
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius(.01);
		ori.draw();*/
		return(a);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] points_cc(Point2D[] a, Double dist){
		int num = a.length;
		My_QF cc = new My_QF(num);
		for(int i=0; i < num ; i++){
			for(int j = i+1; j < num; j++){
				if(a[i].distanceTo(a[j]) < dist){
					cc.union(i,j);
					//a[i].drawTo(a[j]);
				}
			}
		}
			
		/*for(Integer i : cc.id_array()){
			System.out.printf("" %2d"", i);
		}*/
		//System.out.printf(""\n"");
		cc_num = cc.count();
		return(cc.id_array());
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			
			/*StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(550, 550);
			StdDraw.setXscale(0, 1);
			StdDraw.setYscale(0, 1);
			StdDraw.setPenRadius(.005);*/
			
			
			for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				points[row] = new Point2D(x, y);
			}
			
			/*for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(75)+12;
				int y = StdRandom.uniform(75)+12;
				points[i] = new Point2D(x, y);
				//points[i].draw();
			}*/
					
			
			int sum = 0;
			for(Integer i : ConvexHullVertex(points)){
				sum += i;
			}
			
			
			System.out.println(sum);
			
		}
    }
}

class My_Point2D extends Point2D{
	private int ori_idx;
	private int cc_idx;
	
	public My_Point2D(double x, double y, int idx, int cc){
		super(x, y);
		ori_idx = idx;
		cc_idx = cc;
	}
	
	public int ori_idx(){
		return(ori_idx);
	}
	
	public int cc_idx(){
		return(cc_idx);
	}
}

class My_QF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components
    
	public My_QF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

    public int[] id_array(){
		return(id);
	}
	
	public int count() {
        return count;
    }
	
    public int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + N);
        }
    }

    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
    public void union(int p, int q) {
        if (connected(p, q)) return;
        int pid = id[p];
        for (int i = 0; i < id.length; i++)
            if (id[i] == pid) id[i] = id[q]; 
        count--;
    }
}
@61ef17c2c07ff45aa91d22d9881686a9@"
"r04945039","4","0.52","106400","@986ffbf4e7f552b1051b5b0730bb0d18@import java.awt.Point;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a)){
           //System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
        catch (Exception error){
            //continue;
        }
        
        
    }
}

    
    


@986ffbf4e7f552b1051b5b0730bb0d18@"
"r04945039","0","0.49","107792","@05c3b07071dbd4a656f9a5ae34a614cf@import java.awt.Point;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a)){
           //System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result+1);
            
        }
        catch (Exception error){
            //continue;
        }
        
        
    }
}

    
    


@05c3b07071dbd4a656f9a5ae34a614cf@"
"r04945039","4","0.5","107600","@fae59702eb2fb8b265c83db871b93c90@import java.awt.Point;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a)){
           //System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
        catch (Exception error){
            //continue;
        }
        
        
    }
}

    
    


@fae59702eb2fb8b265c83db871b93c90@"
"b02611023","3","0.29","105776","@3427d1f0c3871d591f6836f5b91fe09c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    private static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (MyConvexHull.connected(i, j)) {
                            sp.push(p[j]);
                            parent[j] = -1;
                            count++;
                        }
                    }
                }
                if (count == 0) {
                    if (parent[i] != -1) {
                        sp.push(p[i]);
                        sn.push((count + 1));
                    }
                } else {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                parent[i] = -1;
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if(a.length >= 3){
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@3427d1f0c3871d591f6836f5b91fe09c@"
"r04945039","4","0.5","107408","@cdd81f2f08c2d7d2c117c67aa834a5e6@import java.awt.Point;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a)){
           //System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
        catch (Exception error){
            //continue;
        }
        
        
    }
}

    
    


@cdd81f2f08c2d7d2c117c67aa834a5e6@"
"r04631041","3","0.5","107760","@72ce2d6bfda23ad581d6a44373967cad@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
            }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int temp=0,ans=0;    
      for (int i=0 ; i<N ; i++){
          if(i==connectimformation[i]){
              connectimformation[i]=temp;
              for (int j=i ; j<N ; j++)
                  if (connectimformation[j]==i)
                      connectimformation[j]=temp;
          temp++;
          }
        }
   
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (counter3>1){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@72ce2d6bfda23ad581d6a44373967cad@"
"b02611023","3","0.3","107664","@afca8d489a7b570dbb263bcfc11e6f77@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            Point2D[] p2 = p.clone();
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
                p[i] = null;
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (MyConvexHull.connected(i, j)) {
                            sp.push(p2[j]);
                            parent[j] = -1;
                            count++;
                        }
                    }
                }
                if (count == 0) {
                    if (parent[i] != -1) {
                        sp.push(p2[i]);
                        sn.push((count + 1));
                    }
                } else {
                    sp.push(p2[i]);
                    sn.push((count + 1));
                }
                parent[i] = -1;
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@afca8d489a7b570dbb263bcfc11e6f77@"
"b01b01039","0","0","0","@1b137deeec6451e5032053e29224a0ab@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;


public class MyConvexHull {
	public static Double dist;
	public static int cc_num;
	
	private static int[] ConvexHullVertex(My_Point2D[] m_a) {
		pre_sort(m_a);
		int first  = 0;
		int second = 1;
		int third  = 2;
		Stack<Integer> idx = new Stack<Integer>();
		while(third < m_a.length){
			if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",m_a[third].x(),m_a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 0){
				idx.push(first);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		ConvexHullDrawing(index2pos(m_a, idx));
		return(new2ori(m_a, idx));
	} 
	
	public static int[] ConvexHullVertex(Point2D[] a) {
		My_Point2D[] m_a = new My_Point2D[a.length];
		
		int[] cc_idx = points_cc(a, dist);
		
		for(int idx = 0; idx < a.length; idx++){
			m_a[idx] = new My_Point2D(a[idx].x(), a[idx].y(), idx, cc_idx[idx]);
		}
		My_Point2D ori = new My_Point2D(0,0,0,0);
		Arrays.sort(m_a, ori.cc_ORDER);
		int[] s_e = s_e_find(m_a);
				
		int[] len = new int[cc_num];
		for(int i = 0; i<cc_num; i++){
			if(s_e[2*i+1] - s_e[2*i] > 1){
				My_Point2D[] sub_m_a = M_a_split(m_a, s_e[2*i], s_e[2*i+1]);
				len[i] = ConvexHullVertex(sub_m_a).length;
			}
		}
						
		return(len);
	}
	
	private static int[] s_e_find(My_Point2D[] a){
		int[] out = new int[cc_num*2];
		int s = 0;
		int e = 1;
		int i = 0;
		System.out.println(""Test"");
		System.out.println(a[e].ori_idx());
		while(e < a.length){
			if(a[e].cc_idx() == a[s].cc_idx()){
				e++;
			}else{
				out[i++] = s;
				out[i++] = e-1;
				s = e;
				e++;
			}
			if(e == a.length){
				out[i++] = s;
				out[i++] = s;
			}
			System.out.printf(""s : %2d e : %2d\n"", s, e);
		}
		for(Integer idx : out){
			System.out.printf("" %2d"", idx);
		}
		System.out.println();
		return(out);
	}
	
	private static My_Point2D[] M_a_split(My_Point2D[] a, int start, int end){
		My_Point2D[] out = new My_Point2D[end - start + 1];
		for(int i = start; i < end+1; i++){
			out[i-start] = a[i];
		}
		return(out);
	}	
	
	private static int[] new2ori(My_Point2D[] a, Stack<Integer> idx){
		int[] ori = new int[idx.size()];
		int i = idx.size();
		for(Integer j : idx){
			ori[--i] = a[j].ori_idx();
		}
		Arrays.sort(ori);
		return(ori);
	}
	
	private static My_Point2D[] index2pos(My_Point2D[] a, Stack<Integer> idx){
		My_Point2D[] c_h = new My_Point2D[idx.size()];
		int n = idx.size();
		int i = 0;
		for(Integer j : idx){
			c_h[i++] = a[j];
		}
		return(c_h);
	}

	private static void ConvexHullDrawing(My_Point2D[] p){
		My_Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(My_Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}
	
	private static My_Point2D[] pre_sort(My_Point2D[] a){
		int num = a.length;
		My_Point2D ori = new My_Point2D(0,0,0,0);
		Arrays.sort(a, ori.X_ORDER);
		Arrays.sort(a, ori.Y_ORDER);
		ori = a[0];
		Arrays.sort(a, ori.POLAR_ORDER);
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.GRAY);
		for (int i = 0; i < num; i++) {
				ori.drawTo(a[i]);
				StdDraw.show(200);
			}
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius(.01);
		ori.draw();
		return(a);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] points_cc(Point2D[] a, Double dist){
		int num = a.length;
		My_QF cc = new My_QF(num);
		for(int i=0; i < num ; i++){
			for(int j = i+1; j < num; j++){
				if(a[i].distanceTo(a[j]) < dist){
					cc.union(i,j);
					a[i].drawTo(a[j]);
				}
			}
		}
			
		for(Integer i : cc.id_array()){
			System.out.printf("" %2d"", i);
		}
		System.out.printf(""\n"");
		cc_num = cc.count();
		return(cc.id_array());
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			
			StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(550, 550);
			StdDraw.setXscale(0, 100);
			StdDraw.setYscale(0, 100);
			StdDraw.setPenRadius(.005);
			
			
			/*for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				points[row] = new Point2D(x, y);
			}*/
			
			for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(75)+12;
				int y = StdRandom.uniform(75)+12;
				points[i] = new Point2D(x, y);
				points[i].draw();
			}
					
			
			int sum = 0;
			for(Integer i : ConvexHullVertex(points)){
				sum += i;
			}
			
			
			System.out.println(sum);
			
		}
    }
}

class My_Point2D extends Point2D{
	private int ori_idx;
	private int cc_idx;
	
	public My_Point2D(double x, double y, int idx, int cc){
		super(x, y);
		ori_idx = idx;
		cc_idx = cc;
	}
	
	public int ori_idx(){
		return(ori_idx);
	}
	
	public int cc_idx(){
		return(cc_idx);
	}
	
	public static final Comparator<My_Point2D> cc_ORDER = new ccOrder();
	
	private static class ccOrder implements Comparator<My_Point2D> {
        public int compare(My_Point2D p, My_Point2D q) {
            if (p.cc_idx < q.cc_idx) return -1;
            if (p.cc_idx > q.cc_idx) return +1;
            return 0;
        }
    }
}

class My_QF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components
    
	public My_QF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

    public int[] id_array(){
		return(id);
	}
	
	public int count() {
        return count;
    }
	
    public int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + N);
        }
    }

    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
    public void union(int p, int q) {
        if (connected(p, q)) return;
        int pid = id[p];
        for (int i = 0; i < id.length; i++)
            if (id[i] == pid) id[i] = id[q]; 
        count--;
    }
}
@1b137deeec6451e5032053e29224a0ab@"
"b01b01039","4","0.52","107424","@982c2f7e810def3c2a81dd7a58fd4aea@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Comparator;


public class MyConvexHull {
	public static Double dist;
	public static int cc_num;
	
	private static int[] ConvexHullVertex(My_Point2D[] m_a) {
		pre_sort(m_a);
		int first  = 0;
		int second = 1;
		int third  = 2;
		Stack<Integer> idx = new Stack<Integer>();
		while(third < m_a.length){
			if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 1){	
				//System.out.printf(""I first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""push x : %.3f  y : %.3f\n"",m_a[third].x(),m_a[third].y());
				idx.push(first);
				idx.push(second);
				idx.push(third++);
			}else if(Point2D.ccw(m_a[first], m_a[second], m_a[third]) == 0){
				idx.push(first);
				idx.push(third++);
			}else{
				//System.out.printf(""O first : %2d  second : %2d third : %2d\n"",first, second, third);
				//System.out.printf(""pop  x : %.3f  y : %.3f\n"",e.x(), e.y());
				idx.push(first);
			}
			second = idx.pop();
			first =  idx.pop();
		}
		idx.push(first);
		idx.push(second);
		//index_print(idx);
		//ConvexHullDrawing(index2pos(m_a, idx));
		return(new2ori(m_a, idx));
	} 
	
	public static int[] ConvexHullVertex(Point2D[] a) {
		My_Point2D[] m_a = new My_Point2D[a.length];
		
		int[] cc_idx = points_cc(a, dist);
		
		for(int idx = 0; idx < a.length; idx++){
			m_a[idx] = new My_Point2D(a[idx].x(), a[idx].y(), idx, cc_idx[idx]);
		}
		My_Point2D ori = new My_Point2D(0,0,0,0);
		Arrays.sort(m_a, ori.cc_ORDER);
		int[] s_e = s_e_find(m_a);
				
		int[] len = new int[cc_num];
		for(int i = 0; i<cc_num; i++){
			if(s_e[2*i+1] - s_e[2*i] > 1){
				My_Point2D[] sub_m_a = M_a_split(m_a, s_e[2*i], s_e[2*i+1]);
				len[i] = ConvexHullVertex(sub_m_a).length;
			}
		}
						
		return(len);
	}
	
	private static int[] s_e_find(My_Point2D[] a){
		int[] out = new int[cc_num*2];
		int s = 0;
		int e = 1;
		int i = 0;
		while(e < a.length){
			if(a[e].cc_idx() == a[s].cc_idx()){
				e++;
			}else{
				out[i++] = s;
				out[i++] = e-1;
				s = e;
				e++;
			}
			if(e == a.length){
				out[i++] = s;
				out[i++] = s;
			}
			//System.out.printf(""s : %2d e : %2d\n"", s, e);
		}
		/*for(Integer idx : out){
			System.out.printf("" %2d"", idx);
		}*/
		//System.out.println();
		return(out);
	}
	
	private static My_Point2D[] M_a_split(My_Point2D[] a, int start, int end){
		My_Point2D[] out = new My_Point2D[end - start + 1];
		for(int i = start; i < end+1; i++){
			out[i-start] = a[i];
		}
		return(out);
	}	
	
	private static int[] new2ori(My_Point2D[] a, Stack<Integer> idx){
		int[] ori = new int[idx.size()];
		int i = idx.size();
		for(Integer j : idx){
			ori[--i] = a[j].ori_idx();
		}
		Arrays.sort(ori);
		return(ori);
	}
	
	private static My_Point2D[] index2pos(My_Point2D[] a, Stack<Integer> idx){
		My_Point2D[] c_h = new My_Point2D[idx.size()];
		int n = idx.size();
		int i = 0;
		for(Integer j : idx){
			c_h[i++] = a[j];
		}
		return(c_h);
	}

	private static void ConvexHullDrawing(My_Point2D[] p){
		My_Point2D source = p[p.length-1];
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.BLUE);
		for(My_Point2D sink : p){
			source.drawTo(sink);
			//System.out.printf(""x : %.3f  y : %.3f\n"", sink.x(), sink.y());
			source = sink;
			StdDraw.show(100);
		}
	}
	
	private static My_Point2D[] pre_sort(My_Point2D[] a){
		int num = a.length;
		My_Point2D ori = new My_Point2D(0,0,0,0);
		Arrays.sort(a, ori.X_ORDER);
		Arrays.sort(a, ori.Y_ORDER);
		ori = a[0];
		Arrays.sort(a, ori.POLAR_ORDER);
		/*StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius();
		StdDraw.setPenColor(StdDraw.GRAY);
		for (int i = 0; i < num; i++) {
				ori.drawTo(a[i]);
				StdDraw.show(200);
			}
		StdDraw.setPenColor(StdDraw.RED);
		StdDraw.setPenRadius(.01);
		ori.draw();*/
		return(a);
	}
	
	private static void index_print(Stack<Integer> idx){
		for(Integer i : idx){
			System.out.println(i);
		}
	}
	
	private static int[] points_cc(Point2D[] a, Double dist){
		int num = a.length;
		My_QF cc = new My_QF(num);
		for(int i=0; i < num ; i++){
			for(int j = i+1; j < num; j++){
				if(a[i].distanceTo(a[j]) < dist){
					cc.union(i,j);
					//a[i].drawTo(a[j]);
				}
			}
		}
			
		/*for(Integer i : cc.id_array()){
			System.out.printf("" %2d"", i);
		}
		System.out.printf(""\n"");*/
		cc_num = cc.count();
		return(cc.id_array());
	}
	
    public static void main(String[] args) throws Exception {
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            dist = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
			
			/*
			StdDraw.setPenColor(StdDraw.BLUE);
			StdDraw.setCanvasSize(550, 550);
			StdDraw.setXscale(0, 100);
			StdDraw.setYscale(0, 100);
			StdDraw.setPenRadius(.005);
			*/
			
			for(int row = 0; row < num; row++) {
				String[] s = br.readLine().split("" "");
				Double x = Double.parseDouble(s[0]);
				Double y = Double.parseDouble(s[1]);
				points[row] = new Point2D(x, y);
			}
			
			/*for (int i = 0; i < num; i++) {
				int x = StdRandom.uniform(75)+12;
				int y = StdRandom.uniform(75)+12;
				points[i] = new Point2D(x, y);
				points[i].draw();
			}*/
					
			
			int sum = 0;
			for(Integer i : ConvexHullVertex(points)){
				sum += i;
			}
			
			
			System.out.println(sum);
			
		}
    }
}

class My_Point2D extends Point2D{
	private int ori_idx;
	private int cc_idx;
	
	public My_Point2D(double x, double y, int idx, int cc){
		super(x, y);
		ori_idx = idx;
		cc_idx = cc;
	}
	
	public int ori_idx(){
		return(ori_idx);
	}
	
	public int cc_idx(){
		return(cc_idx);
	}
	
	public static final Comparator<My_Point2D> cc_ORDER = new ccOrder();
	
	private static class ccOrder implements Comparator<My_Point2D> {
        public int compare(My_Point2D p, My_Point2D q) {
            if (p.cc_idx < q.cc_idx) return -1;
            if (p.cc_idx > q.cc_idx) return +1;
            return 0;
        }
    }
}

class My_QF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components
    
	public My_QF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

    public int[] id_array(){
		return(id);
	}
	
	public int count() {
        return count;
    }
	
    public int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + N);
        }
    }

    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
    public void union(int p, int q) {
        if (connected(p, q)) return;
        int pid = id[p];
        for (int i = 0; i < id.length; i++)
            if (id[i] == pid) id[i] = id[q]; 
        count--;
    }
}
@982c2f7e810def3c2a81dd7a58fd4aea@"
"b02611023","4","0.38","105808","@6627d4d46b4875718848d307b04287a7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (parent[j] != -1) {
                            if (MyConvexHull.connected(i, j)) {
                                sp.push(p[j]);
                                parent[j] = -1;
                                count++;
                            }
                        }
                    }
                }
                if (count == 0) {
                    if (parent[i] != -1) {
                        sp.push(p[i]);
                        sn.push((count + 1));
                    }
                } else {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                parent[i] = -1;
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@6627d4d46b4875718848d307b04287a7@"
"b02611023","4","0.39","105744","@838c0f0888ea632916e5e9160d9956a8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (parent[j] != -1) {
                            if (MyConvexHull.connected(i, j)) {
                                sp.push(p[j]);
                                parent[j] = -1;
                                count++;
                            }
                        }
                    } else {
                        break;
                    }
                }

                if (parent[i] != -1) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                parent[i] = -1;
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@838c0f0888ea632916e5e9160d9956a8@"
"b02611023","4","0.38","106080","@1d5d2ed105912e23d6166376734d702c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (parent[j] != -1) {
                            if (MyConvexHull.connected(parent[i], parent[j])) {
                                sp.push(p[j]);
                                parent[j] = -1;
                                count++;
                            }
                        }
                    } else {
                        break;
                    }
                }

                if (parent[i] != -1) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                }
                parent[i] = -1;
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@1d5d2ed105912e23d6166376734d702c@"
"b02611023","4","0.37","105808","@0875d56fd2801b814c18efb22ad2a5a3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(parent[j], parent[i]);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (parent[i] != -1) {
                        if (parent[j] != -1) {
                            if (MyConvexHull.connected(parent[i], parent[j])) {
                                sp.push(p[j]);
                                parent[j] = -1;
                                count++;
                            }
                        }
                    } else {
                        break;
                    }
                }

                if (parent[i] != -1) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                    parent[i] = -1;
                }
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@0875d56fd2801b814c18efb22ad2a5a3@"
"b03704074","0","0","0","@770663f48fdd4dbf62914ef9ef21dd4c@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String datas[] = br.readLine().split("","");
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 1;i < N;i++){
                if(A[i] == null)continue;
                for(int j = i;j > 0;j--){
                    if(A[j] == null)continue;
                    int k = j - 1;
                    while(A[k] == null){
                        k--;}
                    if(Math.pow((A[j].x()-A[k].x()),2)+Math.pow((A[j].y()-A[k].y()), 2)<=Math.pow(d, 2)){
                        B[h] = A[j];h++;}}}
            for(int i = 0;i < B.length;i++){
                for(int j = 0;j < N;j++){
                    if(B[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(B);
            count = count + plus.length;System.out.println(count);}
        System.out.println(count);
}
}
@770663f48fdd4dbf62914ef9ef21dd4c@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","0","0","0","@ab6f54daa53e7c7877ba1bd7b16abf36@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@ab6f54daa53e7c7877ba1bd7b16abf36@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","0","0","0","@302d7f6dcbe733f9cc7528f97182f28f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@302d7f6dcbe733f9cc7528f97182f28f@"
"b03704074","4","0.65","112448","@074e97427c95c418c90301eab7fe7fcf@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>2){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@074e97427c95c418c90301eab7fe7fcf@"
"b03704074","4","0.66","112448","@1d134014dd8725217b3bfe2955671c02@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@1d134014dd8725217b3bfe2955671c02@"
"b03704074","4","0.64","112496","@ac022c81bab420bbc5d75c4215558c9f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        float d = Float.parseFloat(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@ac022c81bab420bbc5d75c4215558c9f@"
"b03704074","4","0.63","112384","@ae1acb474b25aaeeea2b8081e73e324e@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@ae1acb474b25aaeeea2b8081e73e324e@"
"b03704074","4","0.64","115936","@768568c363ac1f6f16375e321071cb19@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@768568c363ac1f6f16375e321071cb19@"
"b03704074","4","0.64","112368","@d1977ba50b587e4dddc9a0b178fea3bc@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@d1977ba50b587e4dddc9a0b178fea3bc@"
"b03704074","4","0.62","112288","@934760802174170348d5de01db8957d9@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>=0){
                
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@934760802174170348d5de01db8957d9@"
"b02611023","5","0.098","105952","@88f28b7903ad3f765f8a157f07df000e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

        if (a.length == 0) {
            throw new NullPointerException();
        }
        Point2D[] origin = a.clone();
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p = new Point2D(a[0].x(), a[0].y());

        Arrays.sort(a, p.POLAR_ORDER);

        Point2D A = new Point2D(0.0, 0.0);
        Point2D B = A;
        Point2D C = A;
        int count = 0;
        int n_count = 0;
        int k0 = 0;
        Point2D[] point = new Point2D[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            point[i] = a[i];
        }
        if (a.length > 2) {
            point[a.length] = a[0];
        }
        for (int i = 2; i < a.length + 1; i++) {
            for (int j = 0; j <= i - 2; j++) {
                for (int k = j + 1; k <= i; k++) {
                    if (point[j] != null) {
                        A = new Point2D(point[j].x(), point[j].y());
                        if (point[k] != null) {
                            if (count <= 0) {
                                B = new Point2D(point[k].x(), point[k].y());
                                count++;
                                k0 = k;
                            } else {
                                C = new Point2D(point[k].x(), point[k].y());
                                count++;
                            }
                        }
                        if (count == 2 && Point2D.ccw(A, B, C) <= 0) {
                            if (j == 0) {
                                point[k] = null;
                                j = 0;
                                n_count++;
                            } else {
                                point[k0] = null;
                                j = 0;
                                n_count = n_count + 1;
                            }
                        }
                    } else {
                        break;
                    }
                }
                count = 0;
            }

        }

        int[] index = new int[a.length - n_count];
        int l = 0;
        for (int m = 0; m < a.length; m++) {
            for (int n = 0; n < a.length; n++) {
                if (point[m] != null) {
                    if (point[m] == origin[n]) {
                        index[l] = n;
                        l++;
                        break;
                    }
                }
            }
            if (l > (index.length - 1)) {
                break;
            }
        }
        Arrays.sort(index);
        return index;
    }

    public static int[] parent;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            Point2D[] p = new Point2D[N];
            int temp = 0;

            while (br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                p[temp] = new Point2D(x, y);
                temp++;
            }

            Arrays.sort(p, Point2D.Y_ORDER);
            parent = new int[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    Point2D X = p[i];
                    Point2D Y = p[j];
                    if (Y.distanceTo(X) <= d) {
                        MyConvexHull.union(j, i);
                    }
                }
            }

            int count = 0;
            Stack<Point2D> sp = new Stack<Point2D>();
            Stack<Integer> sn = new Stack<Integer>();
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (p[i] != null) {
                        if (p[j] != null) {
                            if (MyConvexHull.connected(i, j)) {
                                sp.push(p[j]);
                                p[j] = null;
                                count++;
                            }
                        }
                    } else {
                        break;
                    }
                }

                if (p[i] != null) {
                    sp.push(p[i]);
                    sn.push((count + 1));
                    p[i] = null;
                }
                count = 0;
            }

            int num = 0;
            while (!sp.isEmpty()) {
                int size = sn.pop();
                Point2D[] a = new Point2D[size];
                for (int i = 0; i < size; i++) {
                    a[i] = sp.pop();
                }
                if (a.length >= 3) {
                    num = num + (MyConvexHull.ConvexHullVertex(a).length);
                }
            }
            System.out.println(num);
        }
    }

    public static int find(int p) {
        while (p != parent[p]) {
            p = parent[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        parent[rootP] = rootQ;
    }

    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

@88f28b7903ad3f765f8a157f07df000e@"
"r04945021","5","0.096","106288","@f1b0fc26f35f97f05bd8b2817ab5b09a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//copy a
        Point2D[] points = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = a[i];
//            StdDraw.textLeft(points[i].x(),points[i].y(),Integer.toString(i));
        }
        Arrays.sort(points);
//           StdDraw.setPenColor(StdDraw.RED);
//           points[0].draw();
        Arrays.sort(points, 1, a.length, points[0].POLAR_ORDER);

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        Stack<Point2D> stack = new Stack<Point2D>();
        stack.push(points[0]);//從0開始
        int A = 1;
        int B = 2;
        stack.push(points[B - 1]);

        for (int i = B; i < a.length; i++) {
            Point2D top = stack.pop();
            //not ccw,pop next point
            while (Point2D.ccw(stack.peek(), top, points[i]) < 0) {
                top = stack.pop();
//stack.push(points[i]);            
            }
            stack.push(top);
            stack.push(points[i]);
        }              
      int Size=stack.size();
      int[] Convex = new int[Size];//紀錄a的id

        for (int i=0;i<Size;i++){   

            for(int j=0;j<a.length;j++){

                if(stack.peek().equals(a[j])){
                   
                    Convex[Size-1-i]=j;
                    stack.pop();
                    break;
                }
            }
        }       
        return Convex;
    }

    // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("" "");
            double d = Double.parseDouble(data[0]);
     
            data = br.readLine().split("" "");//
            int N = Integer.parseInt(data[0]);
            Point2D[] a = new Point2D[N];
    //讀N個點
            for (int i=0;i<N;i++) {
                String[] DataPoint = br.readLine().split("" "");
                Double x = Double.parseDouble(DataPoint[0]);
                Double y = Double.parseDouble(DataPoint[1]);
                a[i]=new Point2D(x,y);
                //a[i].draw();
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            }
            QuickUnionUF uf = new QuickUnionUF(N);
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if(a[i].distanceTo(a[j])<=d){
                        uf.union(i,j);
//                    StdDraw.line(a[i].x(),a[i].y(),a[j].x(),a[j].y());
                    }
    
                }
            }

      int finalResults = 0;//計算所有CC的ConvexHull點的數目
            for (int i = 0; i < N; i++) {
                int CCsize = 0;//CC的大小
                int CC[] = new int[N];
                for (int j = 0; j < N; j++) {
                    if (i == uf.find(j)) {
                        CC[CCsize] = j;
                        CCsize++;

   
                    }

                }   

                Point2D[] aCC = new Point2D[CCsize];
                for (int k = 0; k < CCsize; k++) {

                    aCC[k] = a[CC[k]];
                }
                //至少要大於3才有可能包起來
                if (CCsize > 2) {
//                    int CLine=0;//共線的點
//                    for (int check = 0; check < CCsize; check++) {
//                        if (Point2D.ccw(aCC[check], aCC[check + 1], aCC[check + 2]) == 0) {
//                            CLine++;
//                        }
//                        if((check+2)==CCsize-1)
//                            break;
//                    }
//                    if((CCsize%3+CCsize/3)!=CLine){
                    int CCConvexHull[] = ConvexHullVertex(aCC);
         
                    finalResults = finalResults + CCConvexHull.length;}
                }
            
        
            System.out.println(finalResults);
}
 }
}



@f1b0fc26f35f97f05bd8b2817ab5b09a@"
"b03704074","4","0.65","111648","@934760802174170348d5de01db8957d9@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>=0){
                
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@934760802174170348d5de01db8957d9@"
"b03704074","4","0.65","112480","@6dacdcb41dbbdd27301f72927bbfa90e@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@6dacdcb41dbbdd27301f72927bbfa90e@"
"r04945039","4","0.48","107648","@4ad21c945f08c94b6dcd184bee30b579@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a)){
           //System.out.println(alreadyCC(a));
           idmap[b]=idmap[a];
           
           if (alreadyCC(b)) idmap[a]=idmap[b];
        }
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
      
        
    }
}

    
    


@4ad21c945f08c94b6dcd184bee30b579@"
"b03704074","2","0.64","112352","@ed80a74816a8ab3b4f4c5c4429f8e165@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@ed80a74816a8ab3b4f4c5c4429f8e165@"
"r04945039","4","0.47","107648","@27effd233475c0e1ff7d37f39cd1190d@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                CalaculateCC(a, b);                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(int a,int b) {
                
        if(alreadyCC(a))   idmap[b]=idmap[a];
        if (alreadyCC(b)) idmap[a]=idmap[b];
        else{
            idmap[a]=CC;
            idmap[b]=CC;
            CC++;           
        }          
    }    
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        UnionFilter(a);
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            
            for (int itr=1;itr<CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
      
        
    }
}

    
    


@27effd233475c0e1ff7d37f39cd1190d@"
"b03704074","4","0.63","112416","@f67d2e9718937e092bbc4795b0277dbd@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@f67d2e9718937e092bbc4795b0277dbd@"
"b03704074","4","0.66","112336","@fff77359782c147d85f670dba0ba2125@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 && first == 0){
                a[middle] = null;
                //first維持
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
                
            }
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@fff77359782c147d85f670dba0ba2125@"
"b03704074","4","0.65","112304","@1789b3f724c0d48b8388a24fe1f8c5b9@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 && first == 0){
                a[middle] = null;
                //first維持
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
                
            }
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            float a = Float.parseFloat(datas[0]);
            float b = Float.parseFloat(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@1789b3f724c0d48b8388a24fe1f8c5b9@"
"b03704074","4","0.64","112384","@fff77359782c147d85f670dba0ba2125@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 && first == 0){
                a[middle] = null;
                //first維持
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
                
            }
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@fff77359782c147d85f670dba0ba2125@"
"b03704074","4","0.64","112528","@fff77359782c147d85f670dba0ba2125@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 && first == 0){
                a[middle] = null;
                //first維持
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
                
            }
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@fff77359782c147d85f670dba0ba2125@"
"r04945039","3","0.53","105904","@d2ebafae860d90599e82d102d733e069@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                                
            }          
        }        
    }    
}
    
    public static void CalaculateCC() {
        idmap[0]=CC;
        for (int i=0;i<readtimes-1;i++) {
            for(int j=i+1;j<readtimes;j++){
                if (uf.connected(i, j) && alreadyCC(i))
                    idmap[j]=idmap[i];
                if (!alreadyCC(i) && !alreadyCC(j))
                        {CC++;
                        idmap[i]=CC;
                        idmap[j]=CC;
                        
                        }
                
            }
        }
    }
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        
        UnionFilter(a);
        
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            CalaculateCC();
            
            for (int itr=1;itr<=CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {
                        iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
      
        
    }
}

    
    

@d2ebafae860d90599e82d102d733e069@"
"r04945039","3","0.5","108800","@d2c323d0b071989929513fa5d3d0260e@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                                
            }          
        }        
    }    
}
    
    public static void CalaculateCC() {
        idmap[0]=CC;
        for (int i=0;i<readtimes-1;i++) {
            for(int j=i+1;j<readtimes;j++){
                if (uf.connected(i, j) && alreadyCC(i))
                    idmap[j]=idmap[i];
                if (!alreadyCC(i) && !alreadyCC(j) && uf.connected(i, j))
                        {CC++;
                        idmap[i]=CC;
                        idmap[j]=CC;
                        
                        }              
            }
        }
    }
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];
        
        UnionFilter(a);
        
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            CalaculateCC();
            
            for (int itr=1;itr<=CC;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();
                
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {
                        iArr.add(x);
                    //System.out.println(""This CC contains ID : "" + x);
                    }
                }
                
                if (iArr.size()<3) break;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
      
        
    }
}

    
    

@d2c323d0b071989929513fa5d3d0260e@"
"b99611017","0","0.65","113776","@b9391c4f4fda4a83958a5fdc6ee477ed@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ansl = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ansl.enqueue(p);
        }
        int[] an=new int[ansl.size()];
        int count = 0;
        for(int i=0;i<a.length;i++)
        {
            for (Point2D p: preans.hull()){
                if (p == a[i]){
                    an[count] = i;
                    count ++;
                }
            }
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        
       try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];

//            StdDraw.setCanvasSize(500, 500);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(0.015);

            for (int i = 0; i < N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                
            }
            int[] ans=ConvexHullVertex(points);

            UF excute=new UF(points.length);
            
            for(int i=0;i<points.length;i++)
            {
                for(int j=i+1;j<points.length;j++)
                {
                    if(points[i].distanceTo(points[j])<=d)
                    {
                        excute.union(i, j);
                    }
                }
            }
            Stack<Point2D> intermid=new Stack<Point2D>();
            int[] groups=new int[excute.count()];
            int k=0;
            int size1=0;
            int size2=0;
            for(int i=0;i<points.length;i++)
            {
                for(int j=0;j<points.length;j++)
                {
                    if(i==excute.find(j))
                    {
                        intermid.push(points[j]);
                        groups[k]++;
                        size2++;
                    }
                }
                if(size2!=size1)
                {
                    k++;
                    size1=size2;
                }
            }
            int report=0;
            for(int i=excute.count()-1;i>=0;i--)
            {
                Point2D[] finale=new Point2D[groups[i]];
                        
                for(int j=0;j<groups[i];j++)
                {
                    finale[j]=intermid.pop();
                }
                report=report+ConvexHullVertex(finale).length;
                
            }
            System.out.print(report);
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@b9391c4f4fda4a83958a5fdc6ee477ed@"
"b03704074","4","0.65","112432","@8af9d3f1e8919a303664d0fbe0f235a2@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}
                else if(a[j].x() == a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j-1].y()<a[j].y())a[j-1] = null;
                    else a[j] = null;
                }}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 && first == 0){
                a[middle] = null;
                //first維持
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
                
            }
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@8af9d3f1e8919a303664d0fbe0f235a2@"
"b03704074","4","0.65","112240","@7b46a4749ce9c55f24007d095ffdfb46@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                 
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}
                else if(a[j].x() == a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j-1].y()<a[j].y())a[j-1] = null;
                    else a[j] = null;
                }}}
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                if(last+1==a.length && (((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0)){
                    a[last] = null;
                }
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            
            else {
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@7b46a4749ce9c55f24007d095ffdfb46@"
"r04945039","5","0.1","105872","@4ec043f232013c77ffc5e76527efba5c@import java.io.FileReader;
import java.io.BufferedReader;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
        
public class MyConvexHull {
    private static int readtimes;
    private static Double distance;
    private static WeightedQuickUnionUF uf;
    private static Point2D[] PointsArray;
    private static HashMap<Point2D,Integer> vertex;
    private static int[] idmap; 
    private static int CC =1;
    private static int CCnum;
    public static int sum=0;
    private static int result;
    
    
    private class CC {
    private ArrayList<Integer> cc= new ArrayList<Integer>();
    
    }
  
    public static int[] convertIntegers(List<Integer> integers){
    int[] ret = new int[integers.size()];
    Iterator<Integer> iterator = integers.iterator();
    for (int i = 0; i < ret.length; i++)
    {
        ret[i] = iterator.next().intValue();
    }
    return ret;
}
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        //setID(a);
        ArrayList<Integer> ans = new ArrayList<>();       
        GrahamScan graham = new GrahamScan(a);
       
        for (Point2D p : graham.hull()){
           ans.add(vertex.get(p));}
        
        int [] A = new int[ans.size()];
        
        A=convertIntegers(ans);
        Arrays.sort(A);
        
        
        return A;
    }   
    
    private static void setID (Point2D[] c){
        int index = 0;
        int len = c.length;
        vertex= new HashMap<Point2D, Integer>();
        for(int times=0;times<len;times++){
        vertex.put(c[times], index);
        index++;
        }
    }
    
    private static int getID (Point2D x){
        int id = vertex.get(x);
        return id;
    }

    private static void UnionFilter(Point2D[] m){   
    uf = new WeightedQuickUnionUF(readtimes);   
    for (int i=0;i<readtimes-1;i++) {
        for(int j=i+1;j<readtimes;j++){
            //System.out.println(m[i].distanceTo(m[j]));
            if(m[i].distanceTo(m[j])<=distance) {
                //System.out.println(m[i].distanceTo(m[j]));
                
                int a=vertex.get(m[i]);
                int b=vertex.get(m[j]);
                //System.out.println(a+"",""+b);
                uf.union(a, b);
                                
            }          
        }        
    }    
}
    
    public static void CalaculateCC(/*Point2D[] a*/) {
       
        for (int u=0;u<readtimes;u++){
            idmap[u]=uf.find(u);
        }
//        HashMap<Integer,Integer> ccid = new  HashMap<Integer,Integer>();
//        
//        for(Point2D a: points){
//            int ida = uf.find(getID(a));
//            if (!ccid.containsKey(ida)) { cc=new CC(); }
//            else { ;
//                    
//                    }
//            
//        }
        
    }
    
    private static boolean alreadyCC(int x){
       return idmap[x]!=0;      
}

    private static void PointArrayProcessor(Point2D[] a){
        setID(a);
        idmap= new int[readtimes];       
        UnionFilter(a);
        
        
    }
    
    public static Point2D[] reverseHash2Point2Darray(ArrayList<Integer> n){
        int size = n.size();
        Point2D[] ConIn = new Point2D[size];
        for (int q=0;q<size;q++){
            Point2D p = PointsArray[n.get(q)];
            ConIn[q]=p;
        }
        return ConIn;
    }

    private static int SumConvexPoint (int[] R){
        
        sum=sum+R.length;
        return sum;
    }
   

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
            
            
            distance = Double.parseDouble(br.readLine());
            readtimes = Integer.parseInt(br.readLine());
            PointsArray= new Point2D[readtimes];
            int pos=0;
            
            for(String coordinate;( coordinate = br.readLine()) != null; ){
                String[] cor=coordinate.split("" "");
                Double x = Double.parseDouble(cor[0]);
                Double y = Double.parseDouble(cor[1]);
                Point2D p = new Point2D(x, y);
                PointsArray[pos]=p;
                pos++;
            }
            PointArrayProcessor(PointsArray);
            CalaculateCC();
            
            for (int itr=0;itr<readtimes;itr++){
                ArrayList<Integer> iArr = new ArrayList<Integer>();   
               // System.out.println(itr);
                for (int x=0;x<idmap.length;x++){
                    int y = idmap[x];
                    if (y==itr) {
                        iArr.add(x);
                   // System.out.println(""This CC contains rootID : "" + x);
                    }
                }
                
                if (iArr.size()<3) continue;
                //System.out.println(""Change CC"");
                int result;
                result=SumConvexPoint(ConvexHullVertex(reverseHash2Point2Darray(iArr)));
                MyConvexHull.result=result;
            }
        
                System.out.println(result);
            
        }
      
        
    }
}

    
    


@4ec043f232013c77ffc5e76527efba5c@"
"b03704074","4","0.63","112288","@615440285ae62c5ff1100601261b84c0@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){
                if(a[j].x()>a[j-1].x()){
                    if(a[j].y() == a[j-1].y() && a[j-1].y() == a[0].y()){
                        break;
                    }
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
                //System.out.println(""last=""+last);
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    //System.out.println(""first=""+first);
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;//System.out.println(""i=""+i);
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@615440285ae62c5ff1100601261b84c0@"
"b03704074","4","0.62","112752","@9906e658d3dcbef54da55427f95e9bda@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){    
                    if(a[j].y() == a[j-1].y() && a[j-1].y() == a[0].y()){   
                        break;
                    }
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@9906e658d3dcbef54da55427f95e9bda@"
"b03704074","4","0.66","112240","@c3135f7bcd6b03f527e97025036c6ddb@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@c3135f7bcd6b03f527e97025036c6ddb@"
"b03704074","4","0.62","110816","@c3135f7bcd6b03f527e97025036c6ddb@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@c3135f7bcd6b03f527e97025036c6ddb@"
"b03611033","1","0.29","105888","@8805265fcdb42b0595098beda8671d11@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        for (int copy = 0; copy < a.length; copy++) {
            b[copy] = a[copy];
        }

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);
        
        /*
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        min.draw();
        StdOut.println(""==="" + min);

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            b[h].draw();
            //StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
      */
        int cc1,cc2,cc3,num=2;
        Stack<Integer> index1 = new Stack<>();
/*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
*/

        index1.push(0);
        index1.push(1);
        
        while (true) {
            index1.push(num);
            cc3=index1.pop();
            cc2=index1.pop();
            cc1=index1.pop();        
            
            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2=cc1;
                        cc1=index1.pop();
                    }
                }
            } else {
/*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
*/
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if(cc3==0) break;
            num++;
            if(num == b.length){
                num=0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();
        
        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
        */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int N = Integer.parseInt(data);
/*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1.2);
            StdDraw.setYscale(0, 1.2);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            int i = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                //StdDraw.text(x + 0.02, y + 0.02, """" + i);
                //points[i].draw();
                i++;
            }
            Stack<Integer> index = new Stack<>();
            int index1[] = new int[N];
            for (i = 0; i < N; i++) {
                index1[i] = i;
            }

            int sum=0;
            
            i = 0;
            while(i<N){
            while(index1[i] != i) i++;   
            index.push(i);
            for (int l = i + 1; l < N; l++) {
                if (points[i].distanceTo(points[l]) <= d) {
                    index.push(l);
                    index1[l] = i;
                }
            }
            for (int j=0;j < N && index.size()>1;j++) {
                if (index1[j] == i) {
                    for (int l = j + 1; l < N; l++) {
                        if (index1[l] != i) {
                            if (points[j].distanceTo(points[l]) <= d) {
                                index.push(l);
                                index1[l] = i;
                            }
                        }
                    }
                }
            }
            /*
            StdOut.println(index);
            for (i = 0; i < N; i++) {
                StdOut.println(index1[i]);
            }
            */
            MyConvexHull mch = new MyConvexHull();
            int length = index.size();
            if (length >= 3) {
                Point2D[] input = new Point2D[length];
                for (int copy = 0; copy < length; copy++) {
                    input[copy] = points[index.pop()];
                }
                sum+=(mch.ConvexHullVertex(input)).length;
                //StdOut.println(sum);
            }
            i++;
            }
            StdOut.println(sum);
            // 
            //MyConvexHull.ConvexHullVertex(points);
            // 1. read in the file containing N 2-dimentional points
            // 2. create an edge for each pair of points with a distance <= d
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
}

@8805265fcdb42b0595098beda8671d11@"
"b03611033","1","0.48","106112","@bffc849be45ea70e952e3ecce0d97fc1@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        System.arraycopy(a, 0, b, 0, a.length);

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);
        
        /*
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        min.draw();
        StdOut.println(""==="" + min);

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            b[h].draw();
            //StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
      */
        int cc1,cc2,cc3,num=2;
        Stack<Integer> index1 = new Stack<>();
/*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
*/

        index1.push(0);
        index1.push(1);
        
        while (true) {
            index1.push(num);
            cc3=index1.pop();
            cc2=index1.pop();
            cc1=index1.pop();        
            
            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2=cc1;
                        cc1=index1.pop();
                    }
                }
            } else {
/*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
*/
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if(cc3==0) break;
            num++;
            if(num == b.length){
                num=0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();
        
        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
        */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int N = Integer.parseInt(data);
/*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1.2);
            StdDraw.setYscale(0, 1.2);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            int i = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[i] = new Point2D(x, y);

                //StdDraw.text(x + 0.02, y + 0.02, """" + i);
                //points[i].draw();
                i++;
            }
                   Stack<Integer> index = new Stack<>();

        int index1[] = new int[N];

        for (int k = 0; k < N; k++) {
            index1[k] = k;
        }

        int sum = 0;

        i = 0;
        while (i < N) {
            while (i < N && index1[i] != i) i++;
            if (i >= N) break;
            
            index.push(i);
            for (int l = i + 1; l < N; l++) {
                if (points[i].distanceTo(points[l]) <= d) {
                    index.push(l);
                    index1[l] = i;
                }
            }
            
            for (int j = 1; j < N && index.size() > 1; j++) {
                if (index1[j] == i) {
                    for (int l = j + 1; l < N; l++) {
                        if (index1[l] != i) {
                            if (points[j].distanceTo(points[l]) <= d) {
                                index.push(l);
                                index1[l] = i;
                            }
                        }
                    }
                }
            }

            /*
            StdOut.println(index);
            for (i = 0; i < N; i++) {
                StdOut.println(index1[i]);
            }
             */

            int length = index.size();
            if (length >= 3) {
                Point2D[] input = new Point2D[length];
                for (int copy = 0; copy < length; copy++) {
                    input[copy] = points[index.pop()];
                }
                sum += (MyConvexHull.ConvexHullVertex(input)).length;
                //StdOut.println(sum);
            }
            i++;
        }
        StdOut.println(sum);
    }
    }
}

@bffc849be45ea70e952e3ecce0d97fc1@"
"b02611016","2","0.51","110064","@f38c2e47c3528128eedcd13ccf8792cd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
  /*         for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[i].distanceTo(a[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]>=2){
           
           
            for(int i=z+1;i<a.length;i++)  {
                if(uf.connected(z,i)){
               int c=i+1;
              for(int j=c;j<a.length;j++){
                  if(uf.connected(z,i)){
              if(d[z].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  }
                  }
              k=k+1;
              }
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          }
          //  k=k+1;
       }
        // System.out.println(k);
     }
     int[]e=new int[1];
     e[0]=k+1;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 /*           for(int t=0;t<q+1;t++)
           {  for(int y=t+1;y<q+1;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
        
         //      System.out.println(f);
           }*/
             // System.out.println(f);
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@f38c2e47c3528128eedcd13ccf8792cd@"
"b02611016","3","0.5","107616","@e3d2a3f6876d7dda21c1fd0cfc64a2e4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
  /*         for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[i].distanceTo(a[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
           
           
            for(int i=z+1;i<a.length;i++)  {
                if(uf.connected(z,i)){
               int c=i+1;
              for(int j=c;j<a.length;j++){
                  if(uf.connected(z,i)){
              if(d[z].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  }
                  }
              k=k+1;
              }
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          }
          //  k=k+1;
       }
         //System.out.println(k);
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 /*           for(int t=0;t<q+1;t++)
           {  for(int y=t+1;y<q+1;y++) 
           {if(e[t]>e[y])
           {temp=e[t]; e[t]=e[y];e[y]=temp;}
               } 
        
         //      System.out.println(f);
           }*/
             // System.out.println(f);
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@e3d2a3f6876d7dda21c1fd0cfc64a2e4@"
"b02611016","3","0.48","107728","@f0b53fc0741e8b40d95afbc775391bc0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[i].distanceTo(a[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
           
           //int c=z;
            for(int i=z;i<a.length;i++)  {
                int c=i+1;
                if(uf.connected(z,i)){
               
              for(int j=i+1;j<a.length;j++){
                  if(uf.connected(z,i)){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  }
            // k=k+1;
                  }
              i=c;
              k=k+1;
              if(i==a.length){k=k+1;}
              }
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          }
          //  k=k+1;
       }
         //System.out.println(k);
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@f0b53fc0741e8b40d95afbc775391bc0@"
"b99611017","4","0.64","115776","@8a3c66a3e2abc5c0fba9bfab33155965@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ansl = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ansl.enqueue(p);
        }
        int[] an=new int[ansl.size()];
        int count = 0;
        for(int i=0;i<a.length;i++)
        {
            for (Point2D p: preans.hull()){
                if (p == a[i]){
                    an[count] = i;
                    count ++;
                }
            }
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {



        
       try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];



            for (int i = 0; i < N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                
            }


            UF excute=new UF(points.length);
            
            for(int i=0;i<points.length;i++)
            {
                for(int j=i+1;j<points.length;j++)
                {
                    if(points[i].distanceTo(points[j])<=d)
                    {
                        excute.union(i, j);
                    }
                }
            }
            Stack<Point2D> intermid=new Stack<Point2D>();
            int[] groups=new int[excute.count()];
            int k=0;
            int size1=0;
            int size2=0;
            for(int i=0;i<points.length;i++)
            {
                for(int j=0;j<points.length;j++)
                {
                    if(i==excute.find(j))
                    {
                        intermid.push(points[j]);
                        groups[k]++;
                        size2++;
                    }
                }
                if(size2!=size1)
                {
                    k++;
                    size1=size2;
                }
            }

      
            int report=0;
            for(int i=excute.count()-1;i>=0;i--)
            {
                Point2D[] finale=new Point2D[groups[i]];
           
                for(int j=0;j<groups[i];j++)
                {
                    
                    finale[j]=intermid.pop();
                }
                if(ConvexHullVertex(finale).length==1)
                {
                    ;
                }
                else
                report=report+ConvexHullVertex(finale).length;
                
            }
            System.out.println(report);
            
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@8a3c66a3e2abc5c0fba9bfab33155965@"
"r04228002","4","0.47","105808","@1c109c1526d63a6b00f6642a0ed5db99@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.ArrayList;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        if (N==1){
            int[] IndexList=new int[1];
            IndexList[0]=0;
            return(IndexList);
        }
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.POLAR_ORDER);
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            while(CCW!=1){
                Second=First;
                First=CHP.pop();
                CCW=Point2D.ccw(First, Second, CurrentP);
            }
            CHP.push(First);
            CHP.push(Second);
            CHP.push(CurrentP);
            /*
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            else if (CCW==-1){
                
            }
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            */
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) throws Exception{
        // TODO code application logic here
        FileReader FileIn = new FileReader(args[0]);
        BufferedReader br = new BufferedReader(FileIn);
        String row = br.readLine();
        double Dis = Double.parseDouble(row); //Get distance
        row = br.readLine();
        int N = Integer.parseInt(row);//Get N
        
        //Below is to get Data
        Point2D[] PList=new Point2D[N];
        for (int i=0;i<N;i++){
            String[] row2 = br.readLine().split("" "");
            double X = Double.parseDouble(row2[0]);
            double Y = Double.parseDouble(row2[1]);
            Point2D P = new Point2D(X,Y);
            PList[i]=P;
        }
        
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        for (int i=0;i<N;i++){
            Point2D CP= PList[i];
            for (int j=i+1;j<N;j++){
                double dt = CP.distanceTo(PList[j]);
                if (dt <= Dis && !uf.connected(i, j)){
                    uf.union(i, j);
                }
            }
        }
        
        int CHP_Number = 0;
        //Dictionary ClusterDic = new  Hashtable();
        ArrayList<Integer> RootList= new ArrayList<Integer>();
        for (int i=0;i<N;i++){
            int root = uf.find(i);
            if (RootList.contains(root)){
                continue;
            }
            else{
                RootList.add(root);
                ArrayList<Point2D> cluster = new ArrayList<Point2D>();
                cluster.add(PList[i]);
                for (int j=i+1;j<N;j++){
                    if (uf.connected(i, j)){
                        cluster.add(PList[j]);
                    }
                }
                int n =cluster.size();
                //System.out.println(n);
                //System.out.println(""stop"");
                Point2D[] cluster2 = cluster.toArray(new Point2D[n]);
                //System.out.println(Arrays.toString(cluster2));
                //System.out.println(""stop"");
                int[] CHP_Index = ConvexHullVertex(cluster2);
                int New_Number=Array.getLength(CHP_Index);
                if (New_Number==1){
                    New_Number=0;
                }
                
                //System.out.println(New_Number);
                CHP_Number=CHP_Number+New_Number;
            }
            
        }
        System.out.println(CHP_Number);
        
        
        
        /*
        int N=1;
        Point2D[] a = new Point2D[N];
        StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = StdRandom.uniform();
            Double y = StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        
        System.out.println(Arrays.toString(R));
        
        int RR=R.length;
        
        int done = 0;
        for (int i=0;i<N;i++){
            for (int j =0;j<RR;j++){
                if (i==R[j]){
                    StdDraw.setPenColor(Color.red);
                    StdDraw.circle(a[i].x(), a[i].y(), 0.01);
                    done=1;
                    break;
                }
                
            }
            if (done==0){
                StdDraw.setPenColor(Color.black);
                StdDraw.circle(a[i].x(), a[i].y(), 0.01);
            }
            done=0;
        }
        */
        
        
    }
    
}

@1c109c1526d63a6b00f6642a0ed5db99@"
"b01502105","5","0.096","104304","@c5abb8f614706de7c8355e2a78c0699d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.Iterator;


public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] point){
        
        Stack<Point2D> hull = new Stack<Point2D>();
        int N = point.length;
        Point2D origin[] = new Point2D[N];
        System.arraycopy(point, 0, origin, 0, N);
        
        sort(point, Point2D.Y_ORDER);
        sort(point, point[0].POLAR_ORDER);
        
        hull.push(point[0]);
        hull.push(point[1]); 
        
        for(int i=2;i<N;i++){
            Point2D top = hull.pop();
            while ( (Point2D.ccw(hull.peek(),top,point[i])) <= 0 ){
                top = hull.pop();
            }
            hull.push(top);
            hull.push(point[i]);
        }
        
        int[] index = new int[hull.size()];
        int a=0;
        
        Iterator<Point2D> j = hull.iterator();
        while (j.hasNext()){
            Point2D P = j.next();
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.MAGENTA);
//            P.draw();
            for(int i=0;i<N;i++){
                if(origin[i].equals(P)){
                    index[a]=i;
                    a++;
//                    System.out.printf(i+"" "");
                }
            }
        }
//        System.out.printf(""\n"");
        Arrays.sort(index);
        return index;
    }
       
    public static void main(String[] args) throws Exception {
        
        Stopwatch stopwatch = new Stopwatch();

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine()); //first num
            while ((line = br.readLine()) != null) {
                everything.append("","");       //split elements by "",""
                everything.append(line);
            }
            String[] data = everything.toString().split("","");
            double distance = Double.parseDouble(data[0]);
            int N = Integer.parseInt(data[1]);
            Point2D[] point = new Point2D[N];
            QuickFindUF uf = new QuickFindUF(N);
            int vertice_num = 0;
//            System.out.printf(""distance = "" + distance + ""\n"");
//            System.out.printf(""num = "" + N + ""\n"");
//            StdDraw.setCanvasSize(600, 600);
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.BLACK);
            
            for(int i=0;i<N;i++){
                String[] given = data[i+2].split("" "");
                point[i] = new Point2D(Double.parseDouble(given[0]), Double.parseDouble(given[1]));
//                point[i].draw();
//                StdDraw.text(Double.parseDouble(given[0]), Double.parseDouble(given[1])-0.02, point[i].toString());
            }
            
//            sort(point, Point2D.Y_ORDER);
//            StdDraw.setPenColor(StdDraw.BLUE);
//            for(int i=0;i<N;i++){
//                StdDraw.text(point[i].x(), point[i].y()-0.05, Integer.toString(i));
//            }
//            StdDraw.setPenRadius(0.001);
//            StdDraw.setPenColor(StdDraw.GRAY);
            for(int i=0;i<N;i++){
                for(int j=i+1;j<N;j++){
                    if( (point[i].distanceTo(point[j]))<= distance){
                        uf.union(j, i);
//                        point[i].drawTo(point[j]);
                    }
                }
            }
            int[] origin_root = new int[N];
            int[] root = new int[N];
            for(int i=0;i<N;i++){
                origin_root[i] = uf.find(i);
            }
            System.arraycopy(origin_root, 0, root, 0, N);
//            System.out.printf(Arrays.toString(root)+""\n"");
            Arrays.sort(root);
//            System.out.printf(Arrays.toString(root)+""\n"");
            //identify the group_num and their elements
            int[][] temp = new int[N][2];//[root][element_number]
            int count=0;
            int group_num = 0;
            for(int i=0;i<N-1;i++){
                if(root[i]==root[i+1]){
                    count++;
                    if(count==2){ temp[group_num][0]=root[i]; group_num++; }
                    if(count>=2){ temp[group_num-1][1]=count+1; }
                }
                else{count=0;}    
            }       
            int[][] group_index = new int[group_num][2];
            for(int i=0;i<group_num;i++) {
                group_index[i][0]=temp[i][0];
                group_index[i][1]=temp[i][1];
//                System.out.printf(group_index[i][0]+"" ""+group_index[i][1]+""\n"");
            }
            
            for(int i=0;i<group_num;i++){
                Point2D[] input_point = new Point2D[group_index[i][1]];
                int flag = 0;
                for(int j=0;j<N;j++){
                    if(origin_root[j] == group_index[i][0]){
                        input_point[flag] = point[j];
//                        System.out.printf(input_point[flag].toString() + "" "");
                        flag++;
                    }
                }
//                System.out.printf(""\n"");
                int[] index = ConvexHullVertex(input_point);
                vertice_num += index.length;
            }
//            System.out.printf(""ConvexHullVertex_num = "");
            System.out.print(vertice_num + ""\n"");
        }
//        double time = stopwatch.elapsedTime();
//        System.out.printf(""run time = "" + time + ""(s)\n"");
    }
    
}

@c5abb8f614706de7c8355e2a78c0699d@"
"b03611033","4","0.38","105648","@656e82f8256eab221485eee486aa51f1@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        System.arraycopy(a, 0, b, 0, a.length);

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);
        
        /*
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        min.draw();
        StdOut.println(""==="" + min);

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            b[h].draw();
            //StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
      */
        int cc1,cc2,cc3,num=2;
        Stack<Integer> index1 = new Stack<>();
/*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
*/

        index1.push(0);
        index1.push(1);
        
        while (true) {
            index1.push(num);
            cc3=index1.pop();
            cc2=index1.pop();
            cc1=index1.pop();        
            
            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2=cc1;
                        cc1=index1.pop();
                    }
                }
            } else {
/*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
*/
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if(cc3==0) break;
            num++;
            if(num == b.length){
                num=0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();
        
        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
        */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int N = Integer.parseInt(data);
/*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1.2);
            StdDraw.setYscale(0, 1.2);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            int m = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[m] = new Point2D(x, y);

                //StdDraw.text(x + 0.02, y + 0.02, """" + i);
                //points[i].draw();
                m++;
            }
                   Stack<Integer> index = new Stack<>();
        int[] indexself = new int[N];
        boolean[] unused = new boolean[N];

        for (int k = 0; k < N; k++) {
            indexself[k] = k;
            unused[k]=true;
        }

        int sum = 0;

        int i = 0;
        while (i < N) {
            while (i < N && indexself[i] != i) i++;
            if (i >= N) break;
            
            unused[i]=false;
            index.push(i);
            for (int l = i + 1; l < N; l++) {
                if (points[i].distanceTo(points[l]) <= d) {
                    index.push(l);
                    indexself[l] = i;
                    unused[l]=false;
                }
            }
            
            for (int j = 1; j < N && index.size() > 1; j++) {
                if (indexself[j] == i) {
                    for (int l = j + 1; l < N; l++) {
                        if (unused[l]) {
                            if (points[j].distanceTo(points[l]) <= d) {
                                index.push(l);
                                indexself[l] = i;
                            }
                        }
                    }
                }
            }

            /*
            StdOut.println(index);
            for (i = 0; i < N; i++) {
                StdOut.println(indexself[i]);
            }
            */

            int length = index.size();
            if (length >= 3) {
                Point2D[] input = new Point2D[length];
                for (int copy = 0; copy < length; copy++) {
                    input[copy] = points[index.pop()];
                }
                sum += (MyConvexHull.ConvexHullVertex(input)).length;
            }
            else{
                for(int n=0;n<length;n++){
                    index.pop();
                }
            }
            i++;
        }
        StdOut.println(sum);
    }
    }
}

@656e82f8256eab221485eee486aa51f1@"
"r04228002","5","0.094","105760","@bb82c915b718ec325a7f96f578a7bf64@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.ArrayList;
/**
 *
 * @author Lenovo
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    
    public static int[] ConvexHullVertex(Point2D[] a){
        int N = a.length;
        if (N==1){
            int[] IndexList=new int[1];
            IndexList[0]=0;
            return(IndexList);
        }
        Point2D[] PList= new Point2D[N];
        for (int i = 0; i < N; i++){
            PList[i]=a[i];
        }
        Double minx=PList[0].x();
        Double miny=PList[0].y();
        Point2D MP = new Point2D(minx,miny);
        for (int i=0;i<N;i++){
            Double cx=PList[i].x();
            Double cy=PList[i].y();
            if (cy < miny){
                //edu.princeton.cs.algs4.StdDraw.circle(minx,miny,0.01);
                minx=cx;
                miny=cy;
                MP = new Point2D(cx,cy);
                PList[i]=PList[0];
                PList[0]=MP;
            }
            /*
            else{
                edu.princeton.cs.algs4.StdDraw.circle(cx,cy,0.01);        
            }
                    */
        }
        Arrays.sort(PList,MP.POLAR_ORDER);
        
        Stack<Point2D> CHP = new Stack<Point2D>();
        CHP.push(PList[0]);
        CHP.push(PList[1]);
        for (int i=2;i<N;i++){
            Point2D CurrentP=PList[i];
            Point2D Second=CHP.pop();
            Point2D First=CHP.pop();
            int CCW=Point2D.ccw(First, Second, CurrentP);
            while(CCW!=1){
                Second=First;
                First=CHP.pop();
                CCW=Point2D.ccw(First, Second, CurrentP);
            }
            CHP.push(First);
            CHP.push(Second);
            CHP.push(CurrentP);
            /*
            if (CCW==1){
                CHP.push(First);
                CHP.push(Second);
                CHP.push(CurrentP);
            }
            else if (CCW==-1){
                
            }
            else{
                CHP.push(First);
                CHP.push(CurrentP);
            }
            */
        }
        
        int N2=CHP.size();
        //Iterator I = CHP.iterator();
        Point2D[] CHPList = new Point2D[N2];
        for (int i=0;i<N2;i++){
            CHPList[i]=CHP.pop();
        }
        
        int[] IndexList = new int[N2];
        int key = 0;
        for (int i=0;i<N;i++){
            if (key!=N2){
                for (int j=0;j<N2;j++){
                if (a[i].equals(CHPList[j])){ //Plist=a
                    IndexList[key]=i;
                    key++;
                    break;
                    }
                }
            }
            else{
                break;
            } 
        }
        return IndexList;
    }
    public static void main(String[] args) throws Exception{
        // TODO code application logic here
        FileReader FileIn = new FileReader(args[0]);
        BufferedReader br = new BufferedReader(FileIn);
        String row = br.readLine();
        double Dis = Double.parseDouble(row); //Get distance
        row = br.readLine();
        int N = Integer.parseInt(row);//Get N
        
        //Below is to get Data
        Point2D[] PList=new Point2D[N];
        for (int i=0;i<N;i++){
            String[] row2 = br.readLine().split("" "");
            double X = Double.parseDouble(row2[0]);
            double Y = Double.parseDouble(row2[1]);
            Point2D P = new Point2D(X,Y);
            PList[i]=P;
        }
        
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        for (int i=0;i<N;i++){
            Point2D CP= PList[i];
            for (int j=i+1;j<N;j++){
                double dt = CP.distanceTo(PList[j]);
                if (dt <= Dis && !uf.connected(i, j)){
                    uf.union(i, j);
                }
            }
        }
        
        int CHP_Number = 0;
        //Dictionary ClusterDic = new  Hashtable();
        ArrayList<Integer> RootList= new ArrayList<Integer>();
        for (int i=0;i<N;i++){
            int root = uf.find(i);
            if (RootList.contains(root)){
                continue;
            }
            else{
                RootList.add(root);
                ArrayList<Point2D> cluster = new ArrayList<Point2D>();
                cluster.add(PList[i]);
                for (int j=i+1;j<N;j++){
                    if (uf.connected(i, j)){
                        cluster.add(PList[j]);
                    }
                }
                int n =cluster.size();
                //System.out.println(n);
                //System.out.println(""stop"");
                Point2D[] cluster2 = cluster.toArray(new Point2D[n]);
                //System.out.println(Arrays.toString(cluster2));
                //System.out.println(""stop"");
                int[] CHP_Index = ConvexHullVertex(cluster2);
                int New_Number=Array.getLength(CHP_Index);
                if (New_Number==1||New_Number == 2){
                    New_Number=0;
                }
                
                //System.out.println(New_Number);
                CHP_Number=CHP_Number+New_Number;
            }
            
        }
        System.out.println(CHP_Number);
        
        
        
        /*
        int N=1;
        Point2D[] a = new Point2D[N];
        StdRandom.setSeed(N);
        
        for (int i = 1; i < N+1; i++){
            Double x = StdRandom.uniform();
            Double y = StdRandom.uniform();
            //System.out.println(x);
            //System.out.println(y);
            //System.out.println(""stop"");
            Point2D P = new Point2D(x,y);
            a[i-1]=P;
        }
        int[] R = ConvexHullVertex(a);
        
        System.out.println(Arrays.toString(R));
        
        int RR=R.length;
        
        int done = 0;
        for (int i=0;i<N;i++){
            for (int j =0;j<RR;j++){
                if (i==R[j]){
                    StdDraw.setPenColor(Color.red);
                    StdDraw.circle(a[i].x(), a[i].y(), 0.01);
                    done=1;
                    break;
                }
                
            }
            if (done==0){
                StdDraw.setPenColor(Color.black);
                StdDraw.circle(a[i].x(), a[i].y(), 0.01);
            }
            done=0;
        }
        */
        
        
    }
    
}

@bb82c915b718ec325a7f96f578a7bf64@"
"b02611016","3","0.39","105808","@0c7bbef4c850902ce4ead5e3820dd2bb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[i].distanceTo(a[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
             k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=a[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
        //      System.out.println(b[0]);
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
              for(int j=i+1;j<b.length;j++){
                  if(uf.connected(z,i)){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  }
            // k=k+1;
                  }
              i=c;
              k=k+1;
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
         //   System.out.println(k);
         
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@0c7bbef4c850902ce4ead5e3820dd2bb@"
"b02611016","4","0.39","105824","@56cbb7c15ad6d8756cc5649bf0c6fea9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[j].distanceTo(a[i])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
             k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=a[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
              for(int j=i+1;j<b.length;j++){
                  
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
         //   System.out.println(k);
         
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@56cbb7c15ad6d8756cc5649bf0c6fea9@"
"b02611016","4","0.4","105792","@cb9c1b12cd28af34ff9a5bf540873f65@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[j].distanceTo(a[i])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
             k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=a[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
              for(int j=i+1;j<b.length;j++){
                  
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1||d[i].POLAR_ORDER.compare(d[c],d[j])==0)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
         //   System.out.println(k);
         
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@cb9c1b12cd28af34ff9a5bf540873f65@"
"b99611017","5","0.124","115840","@bb9c730f6ab1336b1f05e18de53f0719@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.*;
import java.util.Scanner;
import java.util.Arrays;

/**
 *
 * @author 許志鵬
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Queue ansl = new Queue();
        GrahamScan preans = new GrahamScan(a);
        for (Point2D p : preans.hull()) {
            ansl.enqueue(p);
        }
        int[] an=new int[ansl.size()];
        int count = 0;
        for(int i=0;i<a.length;i++)
        {
            for (Point2D p: preans.hull()){
                if (p == a[i]){
                    an[count] = i;
                    count ++;
                }
            }
        }
        return an;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {



        
       try {
            InputStream is = new FileInputStream(args[0]);
            
            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");
            
            BufferedReader br = new BufferedReader(isr);
            
            Scanner sn = new Scanner(br);
            
            StringBuilder buf = new StringBuilder();
            
            while (sn.hasNext()) {
                
                buf.append(sn.next()).append(""\n"");
                
            }
            
            String str = buf.toString();
            
            String[] token = str.split(""\n"");
            
            double d = Double.parseDouble(token[0]);
            
            int N = Integer.parseInt(token[1]);
            
            Point2D[] points = new Point2D[N];



            for (int i = 0; i < N; i++) {
                
                double x = Double.parseDouble(token[i * 2 + 2]);
                double y = Double.parseDouble(token[i * 2 + 3]);
                points[i] = new Point2D(x, y);
                
            }


            UF excute=new UF(points.length);
            
            for(int i=0;i<points.length;i++)
            {
                for(int j=i+1;j<points.length;j++)
                {
                    if(points[i].distanceTo(points[j])<=d)
                    {
                        excute.union(i, j);
                    }
                }
            }
            Stack<Point2D> intermid=new Stack<Point2D>();
            int[] groups=new int[excute.count()];
            int k=0;
            int size1=0;
            int size2=0;
            for(int i=0;i<points.length;i++)
            {
                for(int j=0;j<points.length;j++)
                {
                    if(i==excute.find(j))
                    {
                        intermid.push(points[j]);
                        groups[k]++;
                        size2++;
                    }
                }
                if(size2!=size1)
                {
                    k++;
                    size1=size2;
                }
            }

      
            int report=0;
            for(int i=excute.count()-1;i>=0;i--)
            {
                Point2D[] finale=new Point2D[groups[i]];
           
                for(int j=0;j<groups[i];j++)
                {
                    
                    finale[j]=intermid.pop();
                }
                if(ConvexHullVertex(finale).length<3)
                {
                    ;
                }
                
                else
                report=report+ConvexHullVertex(finale).length;
                
            }
            System.out.println(report);
            
        } catch (RuntimeException e) {
            
            throw e;
        }
    }
}

@bb9c730f6ab1336b1f05e18de53f0719@"
"b02611016","4","0.4","105824","@c76928d1414920424aef5bb16e20409d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
       HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[j].distanceTo(a[i])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
             k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=a[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1||d[i].POLAR_ORDER.compare(d[c],d[j])==0)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              if(c==b.length){break;
              }
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
         //   System.out.println(k);
         
     }
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("","");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@c76928d1414920424aef5bb16e20409d@"
"r04921012","0","0","0","@db8d277b752f4c94e30dc5db3e9eba28@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
//import WeightedQuickUnionUF;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {
    
    
    
    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    
                    if (dy1==0 && dy2==0) return 0;
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] a){
        /*java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x(),alg4_a.y()) ;
        }*/
        
        
        boolean[] b=new boolean[a.length];
        double[] x=new double[a.length];
        double[] y=new double[a.length];
        Integer[] yIndex=new Integer [a.length];
        for(int i=0;i<a.length;i++){
            x[i]=a[i].getX();
            y[i]=a[i].getY();
            yIndex[i]=i;
        }

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        


        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(a[0]);
        

        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.index);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2].p);
        st2.push(A[0].index);
        st2.push(A[1].index);
        //st2.push(A[2].index);
        int j=2;
        while (j<a.length){
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) throws Exception {
        /*Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);*/
        //for (int item : v_arr){System.out.println(item);}
        MyConvexHull myconvexhull=new MyConvexHull();
        float d ;
        int N;
        Point2D[] input;
        WeightedQuickUnionUF qf;
        boolean[] b;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               d=Float.parseFloat(br.readLine());
               N=Integer.parseInt(br.readLine());
               input=new Point2D[N];
               qf=new WeightedQuickUnionUF(N);
               b= new boolean[N];
            for (int i=0;i<N;i++){
                String[] temp=br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                input[i] = new Point2D.Double(x,y);
                
            }
        }
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (input[i].distance (input[j])<d)
                        qf.union(i,j);
            }
        }
            int count=0;
            for (int i=0;i<N;i++){
                if (b[i]){}
                else{
                    ArrayList<Point2D> temp=new ArrayList<Point2D>();
                    for (int j=0;j<N;j++){
                        if (qf.connected(i,j)){
                            b[i]=true;
                            b[j]=true;
                            temp.add(input[j]);
                        }
                    }
                    Point2D[] tempArray=new Point2D[temp.size()];
                    count=myconvexhull.ConvexHullVertex(tempArray).length+count;
                }
            }
        System.out.println(count);
    }
}

@db8d277b752f4c94e30dc5db3e9eba28@"
"b02611016","4","0.38","107696","@703add83af083e21380aa688027e6f60@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(a[i].distanceTo(a[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
         //uf.union(1,0);
        // for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
             k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              if(c==b.length){break;
              }
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
         //   System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@703add83af083e21380aa688027e6f60@"
"b02611016","0","0.4","105472","@4508f3d7af853f4e5f8d036a408d15c3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
         //uf.union(1,0);
        // for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              if(c==b.length){break;
              }
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
            System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@4508f3d7af853f4e5f8d036a408d15c3@"
"b02611016","4","0.39","103920","@5110200becf2a4ea44eff6ab79253ed3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
         //uf.union(1,0);
        // for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              if(c==b.length){break;
              }
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@5110200becf2a4ea44eff6ab79253ed3@"
"b02611016","4","0.42","108080","@83082d8a3aa79819f21116ce71242b88@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=0;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  uf.union(1,0);
      //   for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=z;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              //if(c==b.length){break;}
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@83082d8a3aa79819f21116ce71242b88@"
"b02611016","4","0.38","105824","@1e04403e5a08ca87bd065fecb409009d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=0;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1; }
                 
             }
         }
             
         }
       //  uf.union(1,0);
      //   for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=0;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              //if(c==b.length){break;}
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@1e04403e5a08ca87bd065fecb409009d@"
"b02611016","4","0.38","107744","@51e4cca43e962c6618e5e2734705b085@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=0;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(!uf.connected(i,j)){uf.union(j,i); 
            if(i<j) { label[uf.find(i)]=label[uf.find(i)]+1;}
             else if(i>j){label[uf.find(i)]=label[uf.find(j)]+1; label[uf.find(j)]=0; }
             }
                 
             }
         }
             
         }
       //  uf.union(1,0);
     //    for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=0;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              //if(c==b.length){break;}
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@51e4cca43e962c6618e5e2734705b085@"
"b02611016","4","0.38","106864","@140d69e70d9dab6d5b03d491240b1c83@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(uf.find(j)==j){
                 if(!uf.connected(i,j)){uf.union(j,i); 
             label[uf.find(i)]=label[uf.find(i)]+1;}
             }
             
             else{if(!uf.connected(i,j)){uf.union(i,j);
             label[uf.find(j)]=label[uf.find(j)]+1+label[uf.find(i)]; label[uf.find(i)]=0;}
             }
             
             }
                 
             }
         }
             
         
       //  uf.union(1,0);
        // for(int i=0;i<a.length;i++){System.out.println(label[i]);}
      int k=0;
     for(int z=0;z<a.length;z++){
         if(label[z]==2){k=k+3;}
         else if(label[z]>2){
             Point2D[] b=new Point2D[label[z]+1];
             int g=0;
            // k=k+1;
           for(int u=0;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
           /* for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              //if(c==b.length){break;}
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@140d69e70d9dab6d5b03d491240b1c83@"
"r04631041","3","0.5","107424","@cc819e6329f843d84fd5eee6e0d80662@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]); 
        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int temp=0,ans=0;    
      for (int i=0 ; i<N ; i++){
          if(i==connectimformation[i]){
              connectimformation[i]=temp;
              for (int j=0 ; j<N ; j++)
                  if (connectimformation[j]==i)
                      connectimformation[j]=temp;
          temp++;
          }
        }
      //for (int i=0 ; i<N ; i++)
      //    System.out.print(connectimformation[i]+""\t"");
      //    System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (counter3>1){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@cc819e6329f843d84fd5eee6e0d80662@"
"r04631021","3","0.53","113760","@9cbbd8a41bc940d5293d5aabde41f050@import java.util.Arrays;
import java.util.Comparator;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
/**
 *
 * @author 林康維
 */
public class MyConvexHull {
    
     public static int ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
         
         Point2D[] temp1 = new Point2D [a.length] ;
         Comparable[] comp = new  Comparable[a.length];
         Comparable[] comp1 = new  Comparable[a.length];
         for(int i = 0 ; i < a.length ; i++){
             comp[i] = a[i].y();
             temp1[i] = a[i] ;
             comp1[i] = a[i].y();
         }
         for(int i = 0 ; i < a.length ; i++){
             
                //System.out.println(comp[i]);
                // System.out.println(comp1[i]);
         }
         Merge.sort(comp);
         for(int i = 0 ; i < a.length ; i++){                 
                 //System.out.println(comp[i]);
                 //System.out.println(comp1[i]);
             for (int j = 0 ; j < a.length ; j ++){
                 //int result = comp[i].compareTo(comp1[j]);
                 //System.out.println(result) ;
                 if (comp[i].compareTo(comp1[j])==0){
                 a[i] = temp1 [j] ;
                 }
             }
         }
         /*for(int i = 0 ; i < a.length ; i++){
            
         System.out.println(a[i].x());
         System.out.println(a[i].y());
         }*/
         Point2D orig = new Point2D(a[0].x() , a[0].y()) ;
         Point2D temp2 = new Point2D(a[0].x() , a[0].y()) ; 
         //此時temp2 為原點
         double theta = 0 ;
         
         int convexhullvertex = 1 ;
         Arrays.sort (a,temp2.POLAR_ORDER) ;
         //由小到大排列
         
         double dy = a[1].y()-temp2.y() ;
         double dx = a[1].x()-temp2.x() ;
         theta = Math.atan2(dy,dx)*180 / 3.1415926 ;
         temp2 = a[1] ;
         //此時temp2為第一個出去的點
         
         //System.out.println(theta) ;
         convexhullvertex ++ ;
        
         
         while(true){
             if(theta <= 180 && theta >0){
                  Arrays.sort (a,temp2.POLAR_ORDER) ;
                  double dy1 = a[1].y() - temp2.y() ;
                  double dx1 = a[1].x() - temp2.x() ;
                  theta = Math.atan2(dy1, dx1) *180 / 3.1415926 ;
                  temp2 = a[1] ;
                  convexhullvertex ++ ;
                  //System.out.println(theta) ;
                  //System.out.println(convexhullvertex+""nope"") ;
             }
             else if( orig.x()==temp2.x() && orig.y()==temp2.y()){
                              convexhullvertex-- ;
                              break ;
                         }
             else if(theta < 0 ){
                 
                 MergeX.sort (a,temp2.POLAR_ORDER) ; 
                 /*for(int k = 0 ; k <a.length; k++){
                    double dy2 = a [k]. y() -temp2 .y();
                     double dx2 = a [k] .x() -temp2 .x() ;
                     double theta2 = Math.atan2(dy2, dx2);
                     System.out.println(theta2) ;    
                 }*/
                 /*theta -= theta2 ;
                     temp2 = a[1] ;
                     convexhullvertex ++ ;
                  System.out.println(theta) ;
                  System.out.println(convexhullvertex) ;*/
                 for (int i = 0 ; i < a.length ; i++){
                     double dy2 = a [i]. y() -temp2 . y();
                     double dx2 = a [i] .x() -temp2 . x() ;
                     if(Math.atan2(dy2, dx2) < 0){
                         temp2 = a[i] ;
                         theta = Math.atan2(dy2,dx2) *180 / 3.1415926 ;
                         convexhullvertex ++;
                         //System.out.println(theta) ;                         
                         //System.out.println(convexhullvertex) ;
                     }
                 }
             }
         }
         return convexhullvertex ;
        
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        File file = new File ( args[0] ) ;
        try{
        Scanner file_in = new Scanner( file ) ;
        
        String data1 = file_in.nextLine();
        double distance = Double.parseDouble(data1) ;
        
        String data2 = file_in.nextLine() ;
        int number = Integer.parseInt(data2) ;
        
        Point2D[] points = new Point2D [ number ] ;
        
        UF uf = new UF ( number ) ;
        double[][] matrix = new double [ number ][ 2 ] ;
        int count = 0 ;
        while(file_in.hasNextLine()){
            
            String[] data3 = file_in.nextLine().split("" "") ;
            double x = Double.parseDouble(data3[0]) ;
            double y = Double.parseDouble(data3[1]) ;
            matrix [count][0] = x ;
            matrix [count][1] = y ;
            points [ count ] = new Point2D (x,y) ;
            //StdDraw.setPenRadius(0.01) ;
            //points[count] . draw() ;
            for (int i = 0 ; i < count ; i++){
                if(points[count].distanceTo(points[i]) <= distance){
                    //StdDraw.setPenRadius(0.001) ;
                    //points[count].drawTo(points[i]) ;
                    uf.union(i,count);
                }
            }
            //System.out.print(uf.find(count)+"" "");
            count ++ ;
        }
        //System.out.println(uf.find(1)) ;
        int final_number = 0 ;
        int i = 0 ;
        while(i!=number-1){
            int counter = 0 ;
            Point2D[] yeee = new Point2D[number] ;
            for(int j = i ; j < number ; j++){
                if (uf.connected(i,j)){
                    yeee[counter] = points[j] ;
                    counter ++ ;
                }
                
            }
            if(counter >=3){
                    Point2D[] yee = new Point2D[counter] ;
                    for(int k = 0; k < counter ; k++){
                        yee[k] = yeee[k] ;
                        }
                    final_number += ConvexHullVertex(yee);
                }
             i += counter ;   
            }
                
        System.out.print(final_number) ;
        /*Comparable [] a = new Comparable [number] ;
        
        for(int i = 0 ; i < number ; i++){
                a[i] = matrix [i][1] ;
            
        }
        Merge . sort ( a ) ;
        
        
        StdDraw.setPenRadius(0.01) ;
        for(int i = 0 ; i < number ; i++){
            StdDraw . point (matrix[i][0],matrix[i][1]) ;
        }
        for(int i = 0 ; i < number ; i++){
            for (int j = i ; j <number ; j++){
                double x1_x0 = Math.pow(matrix[i][0]-matrix[j][0],2);
                double y1_y0 = Math.pow(matrix[i][1]-matrix[j][1],2);
                if(Math.sqrt( x1_x0 + y1_y0 ) < distance){
                    StdDraw.setPenRadius(0.002) ;
                    StdDraw.line(matrix[i][0],matrix[i][1],matrix[j][0],matrix[j][1]) ;
                }
            }
        }
        int count1 = 0 ;
        for(int i = 0 ; i <number ; i++){
        if( a[0] . compareTo ( matrix[i][1] ) == 0){
            count1 = i ;
            StdDraw.setPenRadius(0.01) ;
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(matrix[i][0], matrix[i][1]);
            break;
                          }
                  }*/
        
        }
        catch(IOException e){
            System.out.println(""error!"");
        }
        // TODO code application logic here
    }
    
}

@9cbbd8a41bc940d5293d5aabde41f050@"
"r04631041","3","0.48","104512","@ac6c9c0ecb7c85ef29fd344d82d10286@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int temp=0,ans=0;    
      for (int i=0 ; i<N ; i++){
          if(i==connectimformation[i]){
              connectimformation[i]=temp;
              for (int j=0 ; j<N ; j++)
                  if (connectimformation[j]==i)
                      connectimformation[j]=temp;
          temp++;
          }
        }
      //for (int i=0 ; i<N ; i++)
      //    System.out.print(connectimformation[i]+""\t"");
      //    System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (counter3>1){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@ac6c9c0ecb7c85ef29fd344d82d10286@"
"r04631041","3","0.5","108496","@a7a53fea60f77a0a158e4ac92f21f21b@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (counter3>1){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@a7a53fea60f77a0a158e4ac92f21f21b@"
"b02611016","5","0.102","107904","@25bd88beb61dcb3def31fdf92203fdcf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.*;
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
        public static int[] ConvexHullVertex(Point2D[] a,double distance) {

           //StdRandom.uniform();
       Point2D[] d=a;
       QuickUnionUF uf=new QuickUnionUF(a.length);
    /*   HashMap hm=new HashMap(); 
       for(int i=0;i<a.length;i++)
       {hm.put(a[i],i);
  
       }*/
         //   System.out.println(hm);
       Insertion.sort(d);
      Arrays.sort(d,d[0].POLAR_ORDER );
      
     /*      for(int i=0;i<a.length;i++){   System.out.println(d[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);
               StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(d[i].x(), d[i].y(), 0.01);}
              StdDraw.text(d[i].x(), d[i].y()+0.03,Integer.toString(i) );
               }*/
     int[] label=new int[a.length];
     int count=0;
         for(int i=0;i<a.length;i++) 
         {for(int j=i+1;j<a.length;j++)
         {if(d[i].distanceTo(d[j])<=distance)
             {if(uf.find(j)==j){
                 if(!uf.connected(i,j)){uf.union(j,i); 
           //  label[uf.find(i)]=label[uf.find(i)]+1;
                 }
             }
             
             else{if(!uf.connected(i,j)){uf.union(i,j);
            // label[uf.find(j)]=label[uf.find(j)]+1+label[uf.find(i)]; label[uf.find(i)]=0;
             }
             }
             
             }
                 
             }
         }
             
         
       //  uf.union(1,0);
      //   for(int i=0;i<a.length;i++){System.out.println(uf.find(i));}
      int k=0;
     for(int z=0;z<a.length;z++){
         int cou=0;
          for(int u=0;u<a.length;u++)
           {if(uf.find(u)==z){cou=cou+1;}}
          //System.out.println(cou);
         if(cou==3){k=k+3;}
         else if(cou>3){
             
             int g=0;
            
            // k=k+1;
            
            Point2D[] b=new Point2D[cou];
           for(int u=0;u<a.length;u++)
           {if(uf.connected(z,u)){b[g]=d[u];g=g+1;}}
           //int c=z;
           Insertion.sort(b);
           Arrays.sort(b,b[0].POLAR_ORDER );
          /*  for(int j=0;j<b.length;j++){   System.out.println(b[j]);}
                       for(int i=0;i<b.length;i++){   System.out.println(b[i]);
               if(i==0){StdDraw.setPenColor(StdDraw.RED);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);
               StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }
         else{
             StdDraw.setPenColor(StdDraw.BLACK);
             StdDraw.filledCircle(b[i].x(), b[i].y(), 0.01);}
              StdDraw.text(b[i].x(), b[i].y()+0.03,Integer.toString(i) );
               }*/
            for(int i=0;i<b.length;i++)  {
                int c=i+1;
                
              for(int j=c+1;j<b.length;j++){
                  
              if(b[i].POLAR_ORDER.compare(b[c],b[j])==1)
              {c=j;}
            //  k=k+1;
                  
            // k=k+1;
                  }
              i=c-1;
              k=k+1;
              //if(c==b.length){break;}
             // if(i==a.length){k=k+1;}
              
              
              
             // b[q]=c;
      //       System.out.println(k);
    //         System.out.println(c);
           //    k=k+1;
          
          //  k=k+1;
       }
        
      
           }
           // System.out.println(k);
         
     }
     
     
     int[]e=new int[1];
     e[0]=k;
     /*         int q=0;
            int[] b=new int[k];
            b[q]=0;
          
                 for(int i=0;i<a.length;i++)  {
               int c=i+1;
               if(c!=a.length){
              for(int j=c+1;j<a.length;j++){
              if(d[i].POLAR_ORDER.compare(d[c],d[j])==1)
              {c=j;}
              }
              
              q=q+1;
              b[q]=c;
 //            System.out.println(c);
             //System.out.println(q);
               i=c-1;}
               if(c==a.length){break;
              }
              //Point2D temp=new Point2D(0,0);
        }*/
          // hm.get(b[0]);
        
  /*         for(int t=0;t<q+1;t++)
           {   e[t]= (int)hm.get(d[b[t]]);
                   
       //        System.out.println(e[t]);
           }*/
 
        return  e;
    }

    
    
public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("" "");
            
            // store the first integer in variable stringCount (number of announced strings)
            double distance =Double.parseDouble(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
               String[] data1 = br.readLine().split("" "");
              int num = Integer.parseInt(data1[0]);
              Point2D[] a=new Point2D[num];
              
         for(int i=0;i<num;i++){
            String[] data2 = br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(data2[0]),Double.parseDouble(data2[1]));
          //  System.out.println(a[i]);
         }
         int[] b=ConvexHullVertex(a,distance);
        System.out.println(b[0]);
        }
}
}
@25bd88beb61dcb3def31fdf92203fdcf@"
"r04631041","3","0.5","108288","@09963cd2b6d7c7f2945a8da3a11060e7@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@09963cd2b6d7c7f2945a8da3a11060e7@"
"r04921012","0","0.51","109344","@a7fc07ce185c016350688d1f24aef222@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
//import WeightedQuickUnionUF;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {
    
    
    
    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    double dx1=t1.p.getX()-startPoint.getX();
                    double dx2=t2.p.getX()-startPoint.getX();
                    
                    if (dy1==0 && dy2==0){
                        if      (dx1 >= 0 && dx2 < 0) return -1;
                        else if (dx2 >= 0 && dx1 < 0) return +1;
                        else                          return  0;
                    }
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] a){
        /*java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x(),alg4_a.y()) ;
        }*/
        
        
        boolean[] b=new boolean[a.length];

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        
        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(A[0].p);
        
        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2]);

        int j=2;
        while (j<a.length){
            //
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) throws Exception {
        /*Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);*/
        //for (int item : v_arr){System.out.println(item);}
        MyConvexHull myconvexhull=new MyConvexHull();
        float d ;
        int N;
        Point2D[] input;
        WeightedQuickUnionUF qf;
        boolean[] b;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               d=Float.parseFloat(br.readLine());
               N=Integer.parseInt(br.readLine());
               input=new Point2D[N];
               qf=new WeightedQuickUnionUF(N);
               b= new boolean[N];
            for (int i=0;i<N;i++){
                String[] temp=br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                input[i] = new Point2D.Double(x,y);
                
            }
        }
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (input[i].distance (input[j])<d)
                        qf.union(i,j);
            }
        }
            int count=0;
            for (int i=0;i<N;i++){
                //System.out.println(""For Looping..."");
                if (b[i]){}
                else{
                    ArrayList<java.awt.geom.Point2D> temp=new ArrayList<java.awt.geom.Point2D>();
                    for (int j=0;j<N;j++){
                        if (qf.connected(i,j)){
                            b[i]=true;
                            b[j]=true;
                            temp.add(input[j]);
                        }
                    }
                    //
                    for (Point2D item : temp){System.out.println(item);}
                    if (temp.size()>2){
                        java.awt.geom.Point2D[] tempArray=new java.awt.geom.Point2D[temp.size()];
                        count=myconvexhull.ConvexHullVertex(temp.toArray(tempArray)).length+count;
                        //System.out.println(count);
                    }
                }
            }
        System.out.println(count);
    }
}

@a7fc07ce185c016350688d1f24aef222@"
"r04921012","5","0.096","108736","@8fd54be54e5ac31c51360a86c187a2c6@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
//import WeightedQuickUnionUF;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {
    
    
    
    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    double dx1=t1.p.getX()-startPoint.getX();
                    double dx2=t2.p.getX()-startPoint.getX();
                    
                    if (dy1==0 && dy2==0){
                        if      (dx1 >= 0 && dx2 < 0) return -1;
                        else if (dx2 >= 0 && dx1 < 0) return +1;
                        else                          return  0;
                    }
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] a){
        /*java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x(),alg4_a.y()) ;
        }*/
        
        
        boolean[] b=new boolean[a.length];

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        
        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(A[0].p);
        
        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2]);

        int j=2;
        while (j<a.length){
            //
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) throws Exception {
        /*Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);*/
        //for (int item : v_arr){System.out.println(item);}
        MyConvexHull myconvexhull=new MyConvexHull();
        float d ;
        int N;
        Point2D[] input;
        WeightedQuickUnionUF qf;
        boolean[] b;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               d=Float.parseFloat(br.readLine());
               N=Integer.parseInt(br.readLine());
               input=new Point2D[N];
               qf=new WeightedQuickUnionUF(N);
               b= new boolean[N];
            for (int i=0;i<N;i++){
                String[] temp=br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                input[i] = new Point2D.Double(x,y);
                
            }
        }
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (input[i].distance (input[j])<d)
                        qf.union(i,j);
            }
        }
            int count=0;
            for (int i=0;i<N;i++){
                //System.out.println(""For Looping..."");
                if (b[i]){}
                else{
                    ArrayList<java.awt.geom.Point2D> temp=new ArrayList<java.awt.geom.Point2D>();
                    for (int j=0;j<N;j++){
                        if (qf.connected(i,j)){
                            b[i]=true;
                            b[j]=true;
                            temp.add(input[j]);
                        }
                    }
                    //
                    //for (Point2D item : temp){System.out.println(item);}
                    if (temp.size()>2){
                        java.awt.geom.Point2D[] tempArray=new java.awt.geom.Point2D[temp.size()];
                        count=myconvexhull.ConvexHullVertex(temp.toArray(tempArray)).length+count;
                        //System.out.println(count);
                    }
                }
            }
        System.out.println(count);
    }
}

@8fd54be54e5ac31c51360a86c187a2c6@"
"r04546032","1","0.48","107584","@8a07731beee059db672809dc4747e08e@import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Deque;
import java.util.List;
/**
 *
 * @author CHIN LUNG
 */
public class MyConvexHull {
    protected static double[][]vertices;
    protected static double MD;
    protected static Point2D[] AllPoint;
    protected static Point2D[] GroupPoint ;
    protected static Point2D[][] GroupPoints ;
   // protected static int [][]Coordinate;
    protected static WeightedQuickUnionUF wuf;
    protected static Stack<Point2D> hull = new Stack<Point2D>();
        public static int[] ConvexHullVertex(Point2D[] a) {          
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
            // defensive copy
        int N = a.length;    int [] indices ;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
        {  
            points[i] = a[i];
        }

        // preprocess so that points[0] has lowest y-coordinate; break ties by x-coordinate
        // points[0] is an extreme point of the convex hull
        // (alternatively, could do easily in linear time)
        Arrays.sort(points);

        // sort by polar angle with respect to base point points[0],
        // breaking ties by distance to points[0]
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);

        hull.push(points[0]);       // p[0] is first extreme point

        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        if (k1 == N) return null;        // all points equal

        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point

        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        indices = new int [hull.size()];
        Point2D[] temp = new Point2D[indices.length];
        for(int i = indices.length-1; i >=0 ;i--)
        {
            temp[i] = hull.pop();
        }
        //check thier original indices
        for(int i = 0 ; i < temp.length;i++)
        {
            for(int j = 0; j < a.length;j++)
            {
                if(temp[i].equals(a[j]) == true)
                {
                    indices[i] = j;
                }
            }
        }
        
        return indices;
    }
         public static Iterable<Point2D> hull() {
        Stack<Point2D> s = new Stack<Point2D>();
        for (Point2D p : hull) s.push(p);
        return s;
    }

    // check that boundary of hull is strictly convex
    private static boolean isConvex() {
        int N = hull.size();
        if (N <= 2) return true;

        Point2D[] points = new Point2D[N];
        int n = 0;
        for (Point2D p : hull()) {
            points[n++] = p;
        }

        for (int i = 0; i < N; i++) {
            if (Point2D.ccw(points[i], points[(i+1) % N], points[(i+2) % N]) <= 0) {
                return false;
            }
        }
        return true;
    }

         


    public static void main(String[] args)throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            MD = Double.parseDouble(br.readLine().trim()) ;
            int Points = Integer.parseInt(br.readLine().trim());
            vertices = new double[Points][2]; AllPoint = new Point2D[Points];int [] parent = new int [Points];
            int [] copyParent = new int [Points];
            // 1. read in the file containing N 2-dimentional points
            for(int i = 0 ; i < Points;i++)
            {
                String[] data= br.readLine().split("" "");
                vertices[i][0] = Double.parseDouble(data[0]) ;
                vertices[i][1] = Double.parseDouble(data[1]) ;
                Point2D p2 = new Point2D(vertices[i][0],vertices[i][1]) ;
                //StdDraw.circle(p2.x(), p2.y(), 0.01);
                AllPoint[i] = p2;
            }
            // 2. create an edge for each pair of points with a distance <= d
            wuf = new WeightedQuickUnionUF(Points);
            for(int i = 0; i < AllPoint.length;i++)
            {
                for(int j = i+1 ; j < AllPoint.length;j++)
                {
                    if(AllPoint[i].distanceTo(AllPoint[j]) <= MD)
                    {
                        wuf.union(i, j);
                    }
                }
            } 
        // 3. find connected components (CCs) with a size >= 3
            int mark = 0;  ;int []count = new int[Points];//共有幾個cc是大於3個ㄉ 
            int Count = 0; int index = 0;
            for(int i = 0; i < Points;i++)
            {
                parent[i] = wuf.find(i);
                copyParent[i] = parent[i];
            }
          GroupPoint = new Point2D[Points];
            for(int i = 0; i < parent.length;i++)
            {  
               for(int j = i; j < copyParent.length;j++)
                {
                    if(parent[i] == copyParent[j])
                    {
                        copyParent[j] = -1;
                        GroupPoint[j]=AllPoint[j];
                        count[i]++;
                    }
                }              
            }

        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                Count++;
            }
        }
        GroupPoints = new Point2D[Count][];
        for(int i = 0; i < count.length;i++)
        {
            if(count[i]>=3)
            {             
                GroupPoints[mark] = new Point2D[count[i]];
                for(int k = index; k < index+count[i];k++)
                {
                    GroupPoints[mark][k-index] = GroupPoint[k];                  
                }
               mark++;  index = count[i];
            }
        }
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int total = 0;
            for(int i = 0; i < Count;i++)
            {
                total+=ConvexHullVertex(GroupPoints[i]).length;
            }
        // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(4);
            }                               
    }
}

@8a07731beee059db672809dc4747e08e@"
"r04631034","5","0.13","115760","@aec033ac9bf6faad7bada44bdb532a0f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;
//import edu.princeton.cs.algs4.*;

/**
 *
 * @author user
 */
public class MyConvexHull {

         public static int[] ConvexHullVertex(Point2D[] a) {
                    HashMap<Double, Integer> map = new HashMap<Double, Integer>();
                    for (int i = 0; i < a.length; i++) {
                              map.put((a[i].x()*100+a[i].y()), i);
                    }
                    MergeX.sort(a, Point2D.Y_ORDER);    //sort
                    Point2D p = new Point2D(a[0].x(),a[0].y());
                    MergeX.sort(a,p.POLAR_ORDER);
                    ArrayList<Integer> storge = new ArrayList<Integer>();
                    storge.add(0);
                    storge.add(1);
                    int count_storge = 0;
                    int count_point = 2;
                    while (count_point < a.length) {
                              if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) != -1) {
                                        storge.add(count_point);
                                        count_storge++;
                                        count_point++;
                              } else if (Point2D.ccw(a[storge.get(count_storge)], a[storge.get(count_storge + 1)], a[count_point]) == -1) {
                                        storge.remove(storge.size() - 1);
                                        count_storge--;
                              }

                    }
                    int[] output = new int[storge.size()];
                    for (int count = 0; count < storge.size(); count++) {
                              output[count] = map.get((a[storge.get(count)].x()*100)+a[storge.get(count)].y());
                    }
                    return output;
          }

          public static void main(String[] args) {
//                     TODO code application logic here
                 In in = new In(args[0]);
          double distance = Double.valueOf(in.readLine());
//          System.out.println(distance);
          int N = Integer.valueOf(in.readLine());
//          System.out.println(N);
          Point2D[] point_array = new Point2D[N];
          UF uf = new UF(N);
          String line;
          int input_count = 0;
          while ((line = in.readLine()) != null) {
               point_array[input_count] = new Point2D(Double.valueOf(line.split("" "")[0]), Double.valueOf(line.split("" "")[1]));
               input_count++;
          }

          for (int indx = 0; indx < N; indx++) {
               for (int indy = indx + 1; indy < N; indy++) {
                    if (point_array[indx].distanceTo(point_array[indy]) <= distance) {
                         uf.union(indx, indy);
                    }
               }
          }

//          for (int i = 0; i < N; i++) {
//               System.out.println(uf.find(i));
//               StdDraw.setPenColor(StdDraw.BLACK);
//               StdDraw.filledCircle(point_array[i].x(), point_array[i].y(), 0.01);
//               String str = String.valueOf(uf.find(i));
//               StdDraw.text(point_array[i].x(), point_array[i].y() + 0.03, str);
//          }
          int[] cc_count = new int[N];
          for (int i = 0; i < N; i++) {
               cc_count[uf.find(i)] += 1;
          }
          int output=0;
          for (int i = 0; i < N; i++) {
               if (cc_count[i] < 3) {
                    continue;
               } else {
                    Point2D[] cc_array = new Point2D[cc_count[i]];
                    int count = 0;
                    for (int j = 0; j < N; j++) {
                         if (uf.find(j) == i) {
                              cc_array[count] = new Point2D(point_array[j].x(), point_array[j].y());
                              count++;
                         }
                    }
                    output+=MyConvexHull.ConvexHullVertex(cc_array).length;
               }
          }
          System.out.println(output);
//                    System.out.println("""");
          }

}

@aec033ac9bf6faad7bada44bdb532a0f@"
"b03611033","5","0.098","105968","@fc1fed80896240d3d9385fa3f68a23ec@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        System.arraycopy(a, 0, b, 0, a.length);

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);
        
        /*
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        min.draw();
        StdOut.println(""==="" + min);

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            b[h].draw();
            //StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
      */
        int cc1,cc2,cc3,num=2;
        Stack<Integer> index1 = new Stack<>();
/*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
*/

        index1.push(0);
        index1.push(1);
        
        while (true) {
            index1.push(num);
            cc3=index1.pop();
            cc2=index1.pop();
            cc1=index1.pop();        
            
            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2=cc1;
                        cc1=index1.pop();
                    }
                }
            } else {
/*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
*/
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if(cc3==0) break;
            num++;
            if(num == b.length){
                num=0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();
        
        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
        */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int N = Integer.parseInt(data);
/*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1.2);
            StdDraw.setYscale(0, 1.2);
            StdDraw.setPenRadius(.01);
*/
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            int m = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[m] = new Point2D(x, y);

                //StdDraw.text(x + 0.02, y + 0.02, """" + i);
                //points[i].draw();
                m++;
            }
                   WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        boolean[] unused = new boolean[N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (points[i].distanceTo(points[j]) <= d) {
                    uf.union(i, j);
                }
            }
            unused[i] = true;
        }

        Stack<Integer> index = new Stack<>();
        int sum = 0;
        for (int i = 0; i < N; i++) {
            if (unused[i]) {
                for (int j = 0; j < N; j++) {
                    if (uf.find(j) == i) {
                        index.push(j);
                        unused[j] = false;
                    }
                }

                int length = index.size();
                
                if (length >= 3) {
                    Point2D[] input = new Point2D[length];
                    for (int copy = 0; copy < length; copy++) {
                        input[copy] = points[index.pop()];
                    }
                    sum += (MyConvexHull.ConvexHullVertex(input)).length;
                } else {
                    for (int n = 0; n < length; n++) {
                        index.pop();
                    }
                }
            }
        }
        StdOut.println (sum);
    }
    }   
}

@fc1fed80896240d3d9385fa3f68a23ec@"
"b03611003","4","0.48","107632","@f1063f1a76db5e5104b9d41a3143183d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public void DrawingPratice3() {
        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

//        a[0].drawTo(a[1]);
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

//            top.drawTo(a[i]);
//            StdDraw.show(10);
//            StdDraw.text(a[i].x(), a[i].y()+0.02, """"+i);
            hull.push(top);
            hull.push(a[i]);
        }

//        StdDraw.setPenColor(Color.red);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//
//        StdDraw.setPenRadius(.001);
//        StdDraw.setPenColor(Color.green);
//        for (int i = 1; i < a.length; i++) {
//            a[i].drawTo(a[0]);
//
//            StdDraw.show(10);
//        }
//        StdDraw.setPenColor(Color.BLUE);
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

//            begin.drawTo(end);
//            StdDraw.show();
            begin = end;
        }

        Arrays.sort(Convex);

        return Convex;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }
           
            int leng = 0;
            
            for(int i =0; i < k; i++){
                
                int count = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        count++;
                    }
                }
                
                
                Point2D[] convex = new Point2D[count];
                
                int num = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }
            

//            System.out.print(UF.count());
            
                System.out.print(leng);
            

        }
    }

}

@f1063f1a76db5e5104b9d41a3143183d@"
"b03611015","4","0.49","107680","@d7d6dd7a37fc17bbcf6fc23a7590344f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }

//            System.out.print(UF.count());
            System.out.print(leng);

        }
    }
}

@d7d6dd7a37fc17bbcf6fc23a7590344f@"
"r04921028","2","0.4","106192","@d4c4d762ddb20bd9791b166990ba2b4d@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
//            System.out.println(lans);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
//            System.out.println(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                System.out.println(x+"" ""+y);
                points[count] = new Point2D(x, y);
                count++;
            }
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            
            int hold = 0;
            
            int cccount = 0;
            int cccount3 = 0;
            int cccountmax = 0;
            
            
            String hccarray[];
            hccarray = new String[n];
            
            
            
            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
//                System.out.println(hccarray[i]);
            }
            
            
            Quick.sort(hccarray);
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               if(cccount3>cccountmax){
                   cccountmax = cccount3;
               }
            }
//            System.out.println();
//            System.out.println(cccount);
//            System.out.println(cccountmax);
//            
//            System.out.println();
//            System.out.println(leadpoint.pop());
//            System.out.println(leadpoint.pop());
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            
            int counter = 0;
             Stack<Integer> cc = new Stack<Integer>();
             int ans = 0;
            for(int i=0;i<cccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(i);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                int b = cc.pop();
                for(int z=0;z<counter;z++){
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                
                counter = 0;
                
            }
            
            System.out.println(ans);
            
            
            // 1. read in the file containing N 2-dimentional points
            // 2. create an edge for each pair of points with a distance <= d
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    
}

@d4c4d762ddb20bd9791b166990ba2b4d@"
"r03222054","5","0.096","107552","@b31dd242c5f60e942252587f3317588d@
//import edu.princeton.cs.algs4.StdRandom;
//import edu.princeton.cs.algs4.StdIn;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.Point2D;
import java.awt.Point;
import java.awt.Color;
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Vector;
import java.util.List;
//import edu.princeton.cs.algs4.UF;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Array;
//import java.awt.geom.Point2D;
//import edu.princeton.cs.algs4.Point2D;



public class MyConvexHull 
{      
    //private Point2D[] array;
    //private boolean[][] connectArray;
    
    static public double cross( Point2D o, Point2D a, Point2D b)
    {
          return (a.x()- o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
    }

   static boolean  compare(Point2D a, Point2D b)
  {
      return (a.y() < b.y()) || (a.y() == b.y() && a.x() < b.x());
  }

    static boolean compare_angle(Point2D origin, Point2D a, Point2D b)
  {
      // 加入角度相同時，距離長度的判斷。
        double c = cross(origin, a, b);
      return c > 0 ||
              (c == 0 && origin.distanceTo(a) < origin.distanceTo( b));
  }

    static boolean far(Point2D o, Point2D a, Point2D b)
  {
      return o.distanceTo(a) > o.distanceTo(b);
  }
    
    public static int[] ConvexHullVertex(Point2D[] a)
    {
       int[] sequence = new int[a.length] ;
       
       int count = 0;// verte/*x number
        int start = 0;
        for (int i=0; i<a.length; i++)
        {
            if(compare(a[i], a[start]))
                start = i;
        }
        count++;
        sequence[0] = start;
        
        int next = start;
        while(true)//until the vertex back to origin
        {
            for( int i = 0; i<a.length; i++)
            {
                double angle = cross(a[sequence[count-1]], a[i], a[next]);
                if (angle > 0 ||angle == 0 && far(a[sequence[count-1]], a[i], a[next]))
                next = i;
            }
             if (next == start) 
             {
                // System.out.print(count + ""shit\n"");
                 break;
             }
                    // 繞一圈後回到起點了
             else
                sequence[count] = next; 
            count++;
        }
        
        int[] answer = Arrays.copyOf(sequence, count);      
        
        return answer;       
        }
    public static UF connected(Point2D[] a, double distance)
    {
        boolean[][] connectArray = new boolean[a.length][a.length];
        UF unionArray = new UF(a.length);
        for(int i =0; i<a.length; i++)
        {
            for(int j =a.length-1; j>i; j--)
            {
                if(a[i].distanceTo(a[j]) <= distance)
                {
                    connectArray[i][j] = true;
                    unionArray.union(i,j);
                }
            }
        }
        return unionArray;
        
    }

    
    
    
    
    public static void main(String[] argv) throws Exception
    {
        BufferedReader br = new BufferedReader(new FileReader(argv[0]));
        String line = br.readLine();
         double distance= Double.parseDouble(line);
         //Double.pa
         line = br.readLine();
         int number = Integer.parseInt(line);
         Point2D[] array = new Point2D[number];
         
         for(int i =0; i<number ;i++)
         {
             String[]data = br.readLine().split("" "");
             array[i] = new Point2D( Double.parseDouble(data[0]), Double.parseDouble(data[1]));
         }
        
         
        UF union= connected(array,distance);
        
       // int count =0;//number of groups
        
        
        
        //int[] sequence =ConvexHullVertex(array);
        //for (int i =0; i<sequence.length ;i++)
        //System.out.print(union.count());
        List<Integer> root = new ArrayList<Integer>();
        List<Integer> parent = new ArrayList<Integer>();
        for (int i =0; i< number; i++)
        {
            root.add (union.find(i)); 
        }
        //System.out.print(root.size());
        
        List<List<Integer>> indexArray= new ArrayList<List<Integer>>();
        for(int i =0; i<root.size(); i++)
        {
            //int index;
            if(!parent.contains(root.get(i)))
            {
                parent.add(root.get(i));
                indexArray.add(new ArrayList<Integer>());
            }
            int index = parent.indexOf(root.get(i));
           
            indexArray.get(index).add(i);
         //   System.out.print(index);
        }
        //System.out.print(""\n"");
        // System.out.print(indexArray.size());
        
       int count =0;
        
        for(int i =0 ; i<indexArray.size(); i++)
        {
            
            if(indexArray.get(i).size()>=3)
            {
              //  System.out.print(i + ""\n"");
                 Point2D[] vertexArray =new Point2D[indexArray.get(i).size()];
                for(int j =0; j< indexArray.get(i).size(); j++)
                {
                    vertexArray[j] = array[indexArray.get(i).get(j)];
                   // System.out.print(indexArray.get(i).get(j));
                }
              //  System.out.print(""\n"");
                count+=ConvexHullVertex(vertexArray).length;
               // System.out.print(ConvexHullVertex(vertexArray).length+""\n"");
                
            }
        }
        
        System.out.print(count); 
        
        }
    }

   
@b31dd242c5f60e942252587f3317588d@"
"r04921028","3","0.42","106096","@8483827534d9bb6b48ac7ae032c90a6c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
//            System.out.println(lans);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
//            System.out.println(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                System.out.println(x+"" ""+y);
                points[count] = new Point2D(x, y);
                count++;
            }
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            
            int hold = 0;
            
            int cccount = 0;
            int cccount3 = 0;
            int cccountmax = 0;
            
            
            String hccarray[];
            hccarray = new String[n];
            
            
            
            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
//                System.out.println(hccarray[i]);
            }
            
            
            Quick.sort(hccarray);
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               if(cccount3>cccountmax){
                   cccountmax = cccount3;
               }
            }
//            System.out.println();
//            System.out.println(cccount);
//            System.out.println(cccountmax);
//            
//            System.out.println();
//            System.out.println(leadpoint.pop());
//            System.out.println(leadpoint.pop());
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            
            int counter = 0;
             Stack<Integer> cc = new Stack<Integer>();
             int ans = 0;
            for(int i=0;i<cccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                
                Point2D[] point1s = new Point2D[counter];
                
                
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
//                for(int z=0;z<counter;z++){
//                    System.out.print(index[z]);
//                }
//                System.out.println();
                counter = 0;
                
            }
            
            System.out.println(ans);
            
            
            // 1. read in the file containing N 2-dimentional points
            // 2. create an edge for each pair of points with a distance <= d
            // 3. find connected components (CCs) with a size >= 3
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    
}

@8483827534d9bb6b48ac7ae032c90a6c@"
"r04921028","0","0.108","107920","@e952a686e02689366a56dd0fa1b6d25c@public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount = 0;
            int cccount3 = 0;
            
            
            String hccarray[];
            hccarray = new String[n];
            
            
            
            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
            }
            
            
            Quick.sort(hccarray);
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               
            }
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
             Stack<Integer> cc = new Stack<Integer>();
             int ans = 0;
            for(int i=0;i<cccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
                
            }
            
            System.out.println(ans);
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    
}

@e952a686e02689366a56dd0fa1b6d25c@"
"r04921028","3","0.42","107904","@37149c8a45085cc0818255d755e7a9d4@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount = 0;
            int cccount3 = 0;
            
            
            String hccarray[];
            hccarray = new String[n];
            
            
            
            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
            }
            
            
            Quick.sort(hccarray);
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               
            }
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
             Stack<Integer> cc = new Stack<Integer>();
             int ans = 0;
            for(int i=0;i<cccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
                
            }
            
            System.out.println(ans);
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    
}

@37149c8a45085cc0818255d755e7a9d4@"
"r04921028","3","0.41","106160","@412d3da8c5f8f91125b7827fe138d716@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount = 0;
            int cccount3 = 0;

            String hccarray[];
            hccarray = new String[n];

            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
            }

            Quick.sort(hccarray);
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               
            }
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=cccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
                
            }
            
            System.out.println(ans);
            // 5. count the number of points in N serving as a convex hull vertex, print it
        }
    }
    
}

@412d3da8c5f8f91125b7827fe138d716@"
"r04921028","3","0.38","107600","@c2d6691b2282d45ffcf096a97f81892e@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount = 0;
            int cccount3 = 0;

            
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(uf.find(i))){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(uf.find(i))&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(uf.find(i)); 
               
            }
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=cccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
                
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);
            
        }
    }
    
}

@c2d6691b2282d45ffcf096a97f81892e@"
"f02631008","3","0.68","111824","@93887464395a610da32d8d9b0c3928a4@import java.io.*;
import java.util.Scanner;
import java.io.IOException;
import java.util.Arrays;
/**
 *
 * @author philip
 */
public class MyConvexHull {
    /**
     * @param args the command line arguments
     */
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        _parent[j] = i;
        _rank[j]++;
        /*if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }*/
    }
    public MyConvexHull(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }
    
    
    public static double angle(double x1, double y1, double x2, double y2)
    {
        double dx=x2-x1,dy=y2-y1, PI=(double)Math.PI;
        double angle=0.0;
        
        if(dx==0)
           if(dy==0)angle=0;
           else if(dy>0)angle=PI/2;
           else angle=PI*3/2;
        else if(dy==0)
           if(dx>0)angle=0;
           else angle=PI;
        else if(dx<0)angle=Math.atan(dy/dx)+PI;
        else if(dy<0)angle=Math.atan(dy/dx)+(2*PI);
        else angle=Math.atan(dy/dx);

        return (double)angle*180/PI;
    }
    
    
    public static double ccwd(Point2D a, Point2D b, Point2D c) {
        double area2 = (b.x()-a.x())*(c.y()-a.y()) - (b.y()-a.y())*(c.x()-a.x());
        if      (area2 < 0) return -1;
        else if (area2 > 0) return +1;
        else                return  0;
    }
    
//    public static int[] ConvexHullVertex(Point2D[] a) {
//
//        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
//        return index;
//    }
    
     
    public static void main(String[] args) {
        File file = new File(args[0]);
        try{
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            double MinDis = Double.parseDouble(line_1);
//            System.out.println(MinDis);
            
            String line_2 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_2);
//            System.out.println(ArrNum);
            
            int Ai = 0;
            Point2D[] pts = new Point2D[ArrNum];
            
            while (File_in.hasNextLine())
            {
                String line_3 = File_in.nextLine();
                String[] GivePoint = line_3.split("" "");
                double Px = Double.parseDouble(GivePoint[0]);
                double Py = Double.parseDouble(GivePoint[1]);
                
                pts[Ai] = new Point2D(Px ,Py);
                Ai++;
            }
//            System.out.println(pts[3].x());
//            System.out.println(Points[3][1]);
            double Distance = 0.0;
            MyConvexHull uf = new MyConvexHull(ArrNum);
            //Distance = Math.sqrt(Math.pow(Points[0][0]-Points[1][0],2)+Math.pow(Points[0][1]-Points[1][1],2));
//            System.out.println(Distance);
                      
            
            for(int i = 0; i < ArrNum; i++){
                for(int j = 0; j < ArrNum; j++){
                    if(i != j ){
//                        StdDraw.setPenRadius(0.01);
//                        StdDraw.setPenColor(StdDraw.BLACK);
//                        StdDraw.point(pts[i].x(), pts[i].y());
//                        StdDraw.point(pts[j].x(), pts[j].y());
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.text(pts[i].x()+0.02, pts[i].y(),  Integer.toString(i));
                        
                        Distance = Math.sqrt(Math.pow(pts[i].x()-pts[j].x(),2)+Math.pow(pts[i].y()-pts[j].y(),2));

                        if(Distance <= MinDis){
                            //System.out.println(Distance);
//                            StdDraw.setPenRadius(0.001);
//                            StdDraw.setPenColor(StdDraw.GREEN);
//                            StdDraw.line(pts[i].x(), pts[i].y(), pts[j].x(), pts[j].y());
                            
                            if(pts[i].y() < pts[j].y()){
                                uf.union(i,j);
                            }
                            else{
                                uf.union(j,i);
                            }
                        }
                    }
                }
            }
//            System.out.println(uf);
            

            
            
            int[] RedArr = new int[ArrNum];
            for(int i = 0; i < ArrNum; i++){
                RedArr[i] = -1;
            }
            
            int RedFlag = 0;
            for(int i = 0; i < ArrNum; i++){
                int ParCount = 0;
                for(int j = 0; j < ArrNum; j++){
                    if(uf._parent[j] == i){
                        ParCount++;  
                        if(ParCount >= 3){
                            if(RedFlag == 0){
                                RedArr[i] = i;
                                RedFlag = 1;
                            }
//                            StdDraw.setPenColor(StdDraw.RED);
//                            StdDraw.point(pts[i].x(), pts[i].y());
//                            System.out.println(i);
                        }
                    }
                }
                RedFlag = 0;
            }
            
//            System.out.println(RedArr[3]);
            
            int ArrSiz = 0;
            int Pt2count = 0;
            for(int i = 0; i < ArrNum; i++){
                if(RedArr[i] != -1){
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            ArrSiz++;
                        }
                    }
                    Point2D[] pts2 = new Point2D[ArrSiz];
                    for(int j = 0; j < ArrNum; j++){
                        if(uf._parent[j] == i){
                            pts2[Pt2count] = pts[j];
                            Pt2count++;
                        }
                    }
                }
            }
//            System.out.println(pts2[0].x());
            
            
            
//            System.out.println(uf);
//            double [] AngleArr = new double[ArrNum];
//            int [] AngleArrI = new int[ArrNum]; 
            int minAng = 360;
            int lastAng = 0;
            int NxtPt = 0;
            int NxtPt0 = 0;
            int EndPtFlag = 0;
            int ifflag = 0;
            int CX = 0;
            
            for(int i = 0; i < ArrNum; i++){
                ifflag = 0;
                lastAng = 0;
                NxtPt = 0;
                NxtPt0 = 0;
                if(RedArr[i] != -1 && ifflag == 0){
                    NxtPt = RedArr[i];
                    while(EndPtFlag == 0){
                        double [] AngleArr = new double[ArrNum];
                        int [] AngleArrI = new int[ArrNum]; 
                        minAng = 360;
//                        System.out.println(NxtPt);
                        for(int j = 0; j < ArrNum; j++){
                            if(uf._parent[j] == RedArr[i]){
                                AngleArr[j] = angle(pts[NxtPt].x(),pts[NxtPt].y(),pts[j].x(),pts[j].y());
                                AngleArrI[j] = (int)AngleArr[j];
                                if(AngleArrI[j]-lastAng > 0 && AngleArrI[j]-lastAng < minAng){
                                    minAng = AngleArrI[j]-lastAng;
                                    NxtPt0 = j;
                                }
                            }
                        }
                        NxtPt = NxtPt0;
                        lastAng = minAng;
//                        System.out.println(NxtPt);
                        CX++;
//                        System.out.println(lastAng);
                        
                        if(NxtPt == RedArr[i]){
                            EndPtFlag = 1;
                            break;
                        }
                    }
                    ifflag = 1;
                }
                EndPtFlag=0;
            }
            
            System.out.println(CX);
//            System.out.println(minang);
//            System.out.println(NxtPt);
//            System.out.println((int)angle(pts[3].x(),pts[3].y(),pts[4].x(),pts[4].y()));
//            System.out.println((int)angle(pts[4].x(),pts[4].y(),pts[0].x(),pts[0].y()));
//            System.out.println((int)angle(pts[1].x(),pts[1].y(),pts[0].x(),pts[0].y()));
//            System.out.println((int)angle(pts[1].x(),pts[1].y(),pts[4].x(),pts[4].y()));
//            System.out.println((int)angle(pts[0].x(),pts[0].y(),pts[3].x(),pts[3].y()));
//            System.out.println((int)angle(pts[3].x(),pts[3].y(),pts[0].x(),pts[0].y()));
//            for(int i = 0; i < ArrNum; i++){
//                System.out.println(RedArr[i]);
//            }
//            System.out.println(angle(pts[4].x(),pts[4].y(),pts[1].x(),pts[1].y()));
//            System.out.println(angle(pts[1].x(),pts[1].y(),pts[0].x(),pts[0].y()));
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.BLACK);
//            StdDraw.point(0.1, 0.5);
            
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@93887464395a610da32d8d9b0c3928a4@"
"b03611035","5","0.098","105376","@66ea40e25dce1406b5cc441ecf2e2b24@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //StdDraw.setPenColor(Color.red);
        //StdDraw.setPenRadius(0.00187);
        
        double d=Double.parseDouble(br.readLine());
        int N=Integer.parseInt(br.readLine());
        
        Point2D[] a=new Point2D[N];
        for(int i=0;i<N;i++){
            String readd[]=br.readLine().split("" "");
            a[i]=new Point2D(Double.parseDouble(readd[0]),Double.parseDouble(readd[1]));
        }
        
        //先做connected component，編號和讀檔進來的順序相同
        QuickUnionUF gg=new QuickUnionUF(N);
        //暴力法，N^2感覺很爛>>現在N^2/2應該好一點??
        for(int i=0;i<N;i++){
            for(int j=i+1;j<N;j++){
                if(a[i].distanceTo(a[j])<=d){
                    gg.union(i,j);
                }
            }
        }
        
        //有幾個label
        int count=gg.count();
        
        //做成Point2D Stack
        Stack group[]=new Stack[count];
        for(int i=0;i<count;i++){
            group[i]=new <Point2D>Stack();            
        }
        
        //labelG[]為每個label的值
        int label[]=new int[a.length];
        //直接弄a個labelG
        int labelG[]=new int[a.length];
        for(int i=0;i<a.length;i++){
                labelG[i]=0;
        }
        
        //找到每個a[i]的label 
        for(int i=0;i<a.length;i++){
            label[i]=gg.find(i);
            //a[i] label多少，給該labelG++ //我猜label=0會有bug
            for(int j=0;j<a.length;j++){
                if(gg.find(i)==j) labelG[j]++;
            }
        }
            
        //  System.out.println(""GG3be0"");  
        
        //把label一樣的存到同一個Stack，同一個labelG一次會掃完
        int k=0;
        for(int i=0;i<a.length;i++){           
            if(labelG[i]!=0){
                for(int j=0; j<a.length; j++){
                    if(label[j]==i)
                    group[k].push(a[j]);
                }
                k++;
            }            
        }
        
        //逐一檢視每個group，若N=1,2就不管了，N=3直接+3，N>3.5則傳到CVH，answer是答案
        int answer=0;
        for(int i=0; i<group.length; i++){
            if((group[i].size()==1)||(group[i].size()==2))
                ;
            else if(group[i].size()==3)
                answer+=3;
            else if(group[i].size()>3){//將該group一一pop出來
                Point2D[] send=new Point2D[group[i].size()];
                k=0;
                while(!group[i].isEmpty()){
                    send[k]=(Point2D) group[i].pop();
                    k++;
                }
                answer+=ConvexHullVertex(send);       
            }
        }
        
        System.out.println(answer);
        }
    }
    //第一題是int[]
     public static int ConvexHullVertex(Point2D[] a) {

        Point2D[] b=new Point2D[a.length];
        Point2D ymin=a[0];
        for(int i=0;i<a.length;i++){//弄一個b，不然a會變成錯誤的形狀
            b[i]=new Point2D(a[i].x(),a[i].y());
            if(b[i].compareTo(ymin)==-1) ymin=b[i];//找到y最小的點
        }
        Arrays.sort(b,ymin.ATAN2_ORDER);//把b變成atan的形狀
        for (int i = 0; i < a.length-1; i++) {
           //b[i].drawTo(b[i+1]);
          // StdDraw.show(187);
        }
        
        Stack <Point2D>vertex=new Stack();//vertex stack
        vertex.push(b[0]);
        vertex.push(b[1]);
        int count=2;//前兩點一定是vertex
      
        for(int i=2;i<b.length;i++){        
            Point2D x=vertex.pop();
            Point2D y=vertex.pop();
            while(Point2D.ccw(y,x,b[i])!=1){
                x=y;
                y=vertex.pop();
                count--;
            }
            vertex.push(y);
            vertex.push(x);
            vertex.push(b[i]);
            count++;
            }        
            return count;
/*下面是第一題才要用到的
        int index[]=new int [count];
        for(int i=0;i<count;i++){
            Point2D temp=vertex.pop();
            for(int j=0;j<a.length;j++){
                if(temp.equals(a[j])){
                    index[i]=j;
                    //System.out.println(index[i]);
                }
            }
        }
        Arrays.sort(index);
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        
        return index;
*/
    }

}
@66ea40e25dce1406b5cc441ecf2e2b24@"
"b03611015","4","0.49","106368","@563d88dceec94db056c085ab63971ea8@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}


@563d88dceec94db056c085ab63971ea8@"
"b03611015","4","0.47","103552","@d8285f31292200d40a73196a2ffe6964@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}


@d8285f31292200d40a73196a2ffe6964@"
"b03611015","4","0.46","105840","@d8285f31292200d40a73196a2ffe6964@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < i; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}


@d8285f31292200d40a73196a2ffe6964@"
"b03611015","4","0.49","107632","@563d88dceec94db056c085ab63971ea8@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}


@563d88dceec94db056c085ab63971ea8@"
"b03611015","2","0.48","106624","@7d4dc36bdba73e0f17edc56c50cf297b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(""0"");

        }
    }
}




@7d4dc36bdba73e0f17edc56c50cf297b@"
"b03611015","4","0.49","107616","@9e74bb61118f24f72d0a7966844ee58c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}




@9e74bb61118f24f72d0a7966844ee58c@"
"b03611015","4","0.46","106368","@df060dee6623023fdb885cfca07ea93b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            
           UF UF = new UF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()+1];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}





@df060dee6623023fdb885cfca07ea93b@"
"r04921028","3","0.3","103840","@d4a46e64eaf867ab8eb6ae9c4a9bb1f9@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount = 0;
            int cccount3 = 0;
            
            String hccarray[];
            hccarray = new String[n];

            for(int i=0;i<n;i++){
                hccarray[i] = String.valueOf(uf.find(i));
//                System.out.println(hccarray[i]);
            } 
            Quick.sort(hccarray);
            
            Stack<Integer> leadpoint = new Stack<Integer>();
            
            for(int i=0;i<n;i++){
               if(hold == Integer.valueOf(hccarray[i])){
                   cccount3++;
               }
               else if(hold != Integer.valueOf(hccarray[i])&&cccount3>=2){
                   leadpoint.push(hold);
                   cccount3 = 0;
                   cccount++;
               }
               if(i==n-1&&cccount3>=2){
                   cccount3 = 0;
                   cccount++;
               }
               hold =  Integer.valueOf(hccarray[i]);
            }
            
            int cclead[];
            cclead = new int[cccount];
            for(int i=0;i<cccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=cccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
    
}

@d4a46e64eaf867ab8eb6ae9c4a9bb1f9@"
"b03611015","4","0.47","106320","@7cb1eb2a09190e620b427da3bcfa199d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }
	if(UF.count()==0)
		System.out.print(""0"");
	else{

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }

//            System.out.print(UF.count());
            System.out.print(leng);
}

        }
    }
}



@7cb1eb2a09190e620b427da3bcfa199d@"
"r04921028","1","0.38","106608","@d84caed0c33e7220e0ab910358eb16f7@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            

            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint.push(uf.find(i));
               }
            }
            
            for(int i=0;i<leadpoint.size();i++){
                hold = leadpoint.pop();
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold); 
                }
                cccount3 = 0;
            }
            int cccount = leadpoint.size();
            int cclead[];
            cclead = new int[leadpoint.size()];
            for(int i=leadpoint.size()-1;i>0;i--){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=cccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
    
}

@d84caed0c33e7220e0ab910358eb16f7@"
"r04921028","1","0.38","107616","@24f087f68f7bfa21e5b4fb645394bb76@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            //System.out.println(leadcccount);
            
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
                //System.out.println(cclead[i]);
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
    
}

@24f087f68f7bfa21e5b4fb645394bb76@"
"r04921028","1","0.41","105808","@0ba19c0c50a54d15e1a82495c4cd984d@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            //System.out.println(leadcccount);
            
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
                //System.out.println(cclead[i]);
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
    
}
@0ba19c0c50a54d15e1a82495c4cd984d@"
"b02611028","5","0.096","107984","@1fa269df58852b3a1e7442717be5c4c4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int ConvexHullVertex(Point2D[] a) {
        /*int[] seed=new int[10];
         int min=-1000;
         int max=1000;
         for (int i=0;i<10;i++){
         seed[i]=(int) StdRandom.uniform(min, max);
         System.out.print(""seed=""+seed[i]);
         System.out.printf(""%n"");
         }*/
        Point2D[] b = new Point2D[a.length];
        for (int i = 0; i < b.length; i++) {
            b[i] = a[i];
        }
        int N = a.length;

        double miny = 0.0;
        //Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {

            if (i == 0) {
                miny = a[0].y();
            } else {
                miny = Math.min(miny, a[i].y());
            }

        }
        //draw and find point0's angle

        Point2D point0 = new Point2D(0.0, 0.0);

        for (int i = 0; i < N; i++) {
            if (a[i].y() == miny) {
                //StdDraw.setPenColor(StdDraw.RED);
                // StdDraw.setPenRadius(.01);
                //a[i].draw();
                point0 = a[i];
                a[i] = a[0];
                a[0] = point0;
                //StdDraw.setPenColor(StdDraw.BLACK);
                /*System.out.print(point0);
                 System.out.printf(""%n"");
                 point0angle=points[i].theta();
                 System.out.print(point0angle);*/
            } else {
                // StdDraw.setPenColor(StdDraw.BLACK);
                //StdDraw.setPenRadius(.01);
                // a[i].draw();
            }
        }

        Arrays.sort(a, a[0].POLAR_ORDER);//sort array
        for (int i = 0; i < N; i++) {
            // StdDraw.setPenRadius(.001);
            // StdDraw.text(a[i].x(), a[i].y() + 1, Integer.toString(i));
            //  StdDraw.line(point0.x(), point0.y(), a[i].x(), a[i].y());
        }
        //System.out.print(Point2D.ccw(points[1], points[2], points[3]));
        //draw convexhull
        Stack<Point2D> p = new Stack<Point2D>();
        for (int i = 0; i < N; i++) {
            p.push(a[N - 1 - i]);
        }
        Point2D[] convex = new Point2D[3];
        Stack<Point2D> pp = new Stack<Point2D>();

        while (true) {
            if (p.isEmpty()) {
                break;
            }
            convex[0] = p.pop();
            convex[1] = p.pop();
            convex[2] = p.pop();
            if (Point2D.ccw(convex[0], convex[1], convex[2]) == 1) {
                if (pp.isEmpty()) {
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    pp.push(convex[2]);
                } else {
                    pp.push(convex[2]);
                }
                if (!p.isEmpty()) {
                    p.push(convex[2]);
                    p.push(convex[1]);
                }
            } else {
                if (Point2D.ccw(convex[0], convex[1], convex[2]) == -1) {
                    p.push(convex[2]);
                    pp.pop();
                    convex[1] = pp.pop();
                    convex[0] = pp.pop();
                    pp.push(convex[0]);
                    pp.push(convex[1]);
                    p.push(convex[1]);
                    p.push(convex[0]);
                    //System.out.print(1);
                }
            }
        }
        /*for (int i=0;i<N;i++){
         System.out.print(p.pop());
         System.out.printf(""%n"");
         }*/
        
        int s = pp.size();
        
        return s;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double distant=Double.parseDouble(br.readLine());
            int Num = Integer.parseInt(br.readLine());
            Point2D[] a = new Point2D[Num];
            /*StdDraw.setCanvasSize(800, 800);
             StdDraw.setXscale(0, 100);
             StdDraw.setYscale(0, 100);
             StdDraw.setPenRadius(.01);*/
            int k=0;
            //for (int i = 0; i < 10; i++) {
            //int x = StdRandom.uniform(100);
            //int y = StdRandom.uniform(100);
            for (int i=0;i<Num;i++){
                String[] s=br.readLine().split("" "");
                a[i]=new Point2D(Double.parseDouble(s[0]),Double.parseDouble(s[1]));
            }
            int[] id =new int[Num];
            for (int i=0;i<Num;i++){
                id[i]=i;
            }
            UF uf = new UF(Num);
            for(int i=0;i<Num;i++){
                for(int j=i+1;j<Num;j++){
                    if(Math.sqrt(Math.pow(a[i].x()-a[j].x(),2)+(Math.pow(a[i].y()-a[j].y(),2)))<=distant){
                        uf.union(id[i], id[j]);
                    }
                }
            }
            int idindex=0;
            while(idindex!=id.length){
                
                Stack<Point2D> s=new Stack<Point2D>();
                //for(int i=0;i<Num;i++){
                    
                    for(int j=0;j<Num;j++){
                        if(uf.find(id[j])==idindex){
                            s.push(a[j]);
                        }
                    }
                    idindex=idindex+1;
                    Point2D[] lengthofid= new Point2D[s.size()];
                    int size=s.size();
                    
                    if(size<3)continue;
                    for(int j=0;j<size;j++){
                        lengthofid[j]=s.pop();
                    }
                    
                    k=k+ConvexHullVertex(lengthofid);
                    
                //}
            }
            
            //System.out.print(a[i]);
            //System.out.printf(""%n"");
            //}
            //int[] b = ConvexHullVertex(a);
            
                
            System.out.print(k);
            //System.out.print(uf.count());
        }
    }
}

@1fa269df58852b3a1e7442717be5c4c4@"
"r04631004","5","0.094","107696","@f1fda299ec494ee8396f356b964d5d78@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min_y = 10000.0;
        int temp_i = 0;
        for (int i = 0; i < a.length; i++) { //找y最小的點作為頂點
            if (a[i].y() < min_y) {
                min_y = a[i].y();
                temp_i = i;
            }
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.01);
//        a[temp_i].draw();
        double[] angle = new double[a.length];
        for (int i = 0; i < a.length; i++) { //算角度
            if (i != temp_i) {
                angle[i] = Math.acos((a[i].x() - a[temp_i].x()) / Math.sqrt(Math.pow(a[i].x() - a[temp_i].x(), 2) + Math.pow(a[i].y() - a[temp_i].y(), 2))) * 180 / 3.1415;
            } else {
                angle[i] = 0;
            }
        }

        double[] angle_sort = Arrays.copyOf(angle, a.length);
        Arrays.sort(angle_sort);  //把算出來的角度做sorting

        int[] temp_index = new int[a.length];
        int[] index = new int[a.length]; //將sorting後的點與原array做比較，並將index做sorting
        for (int i = 0; i < angle_sort.length; i++) {
            for (int j = 0; j < angle.length; j++) {
                if (angle_sort[i] == angle[j] && temp_index[j] == 0) {
                    index[i] = j;
                    temp_index[j] = 1;
                    break;
                }
            }
        }
        Stack<Integer> convexhull = new Stack<Integer>();
        convexhull.push(index[0]);
        convexhull.push(index[1]);
        convexhull.push(index[2]);

        int O = 0;
        int A = 0;
        int B = 0;
        for (int i = 3; i < angle_sort.length; i++) { //逆時針去計算外積，若為正值即為外凸點
            B = index[i];
            A = convexhull.pop();
            O = convexhull.pop();
            if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                convexhull.push(O);
                convexhull.push(A);
                convexhull.push(B);
            } else {
                for (int j = convexhull.size() + 2; j > 2; j--) {
                    A = O;
                    O = convexhull.pop();
                    if ((a[A].x() - a[O].x()) * (a[B].y() - a[O].y()) - (a[A].y() - a[O].y()) * (a[B].x() - a[O].x()) >= 0) {
                        convexhull.push(O);
                        convexhull.push(A);
                        convexhull.push(B);
                        break;
                    }
                }
            }

        }

        int[] Vertex = new int[convexhull.size()];
        for (int i = 0; i < Vertex.length; i++) {
            Vertex[i] = convexhull.pop();
        }
        Arrays.sort(Vertex);   //將結果依照小至大sorting
        return Vertex;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader convexhull_file = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data;
            data = convexhull_file.readLine().split("","");
            if (data != null) {
                double d = Double.parseDouble(data[0]);
                data = convexhull_file.readLine().split("" "");
                int N = Integer.parseInt(data[0]);
                double[][] input_coord = new double[N][2];
                int n = 0;
                while (n < N) //add coord to grid  //讀取input座標
                {
                    data = convexhull_file.readLine().split("" "");
                    input_coord[n][0] = Double.parseDouble(data[0]);
                    input_coord[n][1] = Double.parseDouble(data[1]);
                    //System.out.println(input_coord[n][0] + "" "" + input_coord[n][1]);
                    n++;
                }

                WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF(N);
                for (int i = 0; i < N; i++) {  //將距離<=d的兩點做相連
                    for (int j = i + 1; j < N; j++) {
                        if (Math.sqrt(Math.pow(input_coord[i][0] - input_coord[j][0], 2) + Math.pow(input_coord[i][1] - input_coord[j][1], 2)) <= d) {
                            ufstruct.union(i, j);
                        }
                    }
                }
                int[] point_find = new int[N]; //將各個點的find存入point_find中
                for (int i = 0; i < N; i++) {
                    point_find[i] = ufstruct.find(i);
                    //System.out.println(point_find[i]);
                }

                int temp = 0;
                int count = 1;
                double[] temp_x = new double[N];
                double[] temp_y = new double[N];
                int NumofConvexhull = 0;

                for (int i = 0; i < N; i++) {
                    temp = point_find[i];
                    if (temp == -1) {
                    } else {
                        point_find[i] = -1;
                        temp_x[0] = input_coord[i][0];
                        temp_y[0] = input_coord[i][1];
                        for (int j = i + 1; j < N; j++) {
                            if (point_find[j] == temp) {
                                point_find[j] = -1;
                                temp_x[count] = input_coord[j][0];
                                temp_y[count] = input_coord[j][1];
                                count++;
                            }
                        }
                        if (count == 3) {
                            NumofConvexhull = NumofConvexhull + 3;
                        } else if (count > 3) {
                            Point2D[] points = new Point2D[count];
                            for (int j = 0; j < count; j++) {
                                double x = temp_x[j];
                                double y = temp_y[j];
                                points[j] = new Point2D(x, y);
                            }
                            int[] result = ConvexHullVertex(points);
                            NumofConvexhull = NumofConvexhull + result.length;
                        }
                    }
                    count=1;
                }
                System.out.println(NumofConvexhull);
            }
        }
    }

//    public static void main(String[] args) {
//        //StdDraw.setCanvasSize(200, 200);
//        //StdDraw.setXscale(0, 5);
//        //StdDraw.setYscale(0, 5);
//        Point2D[] points = new Point2D[10];
//        // TODO code application logic here
//        for (int i = 0; i < 10; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            //StdDraw.setPenColor(StdDraw.RED);
//            //System.out.println(x+"" ""+y);
//            //StdDraw.setPenRadius(.01);
//            points[i] = new Point2D(x, y);
//            //points[i].draw();
//        }
//
//        int[] result = ConvexHullVertex(points);
////        for (int i = 0; i < result.length; i++) {
////            System.out.println(result[i]);
////        }
//
//    }
}

@f1fda299ec494ee8396f356b964d5d78@"
"r04921028","1","0.38","105760","@aee15c4668f646f546dcb31b4dc99d25@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.line(a[index[o-1]].x()/100, a[index[o-1]].y()/100,a[index[o]].x()/100, a[index[o]].y()/100); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x()/100, a[index[convexsize-1]].y()/100,minx/100, miny/100); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x()/100,a[index[0]].y()/100);
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count] = new Point2D(x, y);
                count++;
            }
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=leadcccount-1;i>=0;i--){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=counter-1;z>=0;z--){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
                int index[] =  ConvexHullVertex(point1s);
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
    
}
@aee15c4668f646f546dcb31b4dc99d25@"
"b03611011","0","0","0","@6a6710cfc21eb16106733eabcd994217@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        min = point[0];
        for (Point2D point1 : point) {
            switch (point1.compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point1;
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.textLeft(point[i].x(), point[i].y() + 2, word);

        }
        if (N < 2) {
            return null;
        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                    int fin =0;
            int M = 0;
            double L = 0;
            int count = 0;
            String data;
            String[] data1;
            Point2D min = new Point2D(1, 1);
            while (count < 2) {
                if (count == 0) {
                    String fund = br.readLine();
                    L = Double.parseDouble(fund);
                    count++;
                }
                if (count == 1) {
                    String fund = br.readLine();
                    M = Integer.parseInt(fund);
                    StdDraw.setCanvasSize(500, 500);
                    StdDraw.setXscale(0, 1);
                    StdDraw.setYscale(0, 1);
                    StdDraw.setPenRadius(.005);
                    count++;
                }
            }
            Point2D[] points = new Point2D[M];
            count = 0;
            while ((data = br.readLine()) != null) {
                String fund[] = data.split("" "");
                double x = Double.parseDouble(fund[0]);
                double y = Double.parseDouble(fund[1]);
                points[count] = new Point2D(x, y);
                String word = Integer.toString(count);
                StdDraw.setPenColor(StdDraw.BLUE);
                points[count].draw();
                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            UF c = new UF(M);
            for (int i = 0; i < M; i++) {
                for (int j = i; j < M; j++) {
                    if (points[i].distanceSquaredTo(points[j]) <= L * L) {
                        c.union(i, j);
                        points[i].drawTo(points[j]);
                    }
                }
            }
            MyConvexHull t = new MyConvexHull();
            int[][] cal = new int[M][M];
            int[] where = new int[M];
            int w = 0;
            int j;
            int[] x;
            for (int i = 0; i < M; i++) {
                count = 0;
                for (j = 0; j < M; j++) {
                    if (c.find(j) == i) {
                        cal[i][count] = j;
                        count++;
                    }
                }
                if (count >= 1) {
                    where[w] = i;
                    w++;
                }
                Point2D[] cals = new Point2D[count];
                if (count > 0) {
                    for (int k = 0; k < count; k++) {
                        cals[k] = points[cal[i][k]];
                    }
                    x = t.ConvexHullVertex(cals);
                    if (x == null) {
                    } else {
                        fin=fin+x.length;
                    }
                }
                j = 0;

            }
            System.out.println(fin);
        }
    }
}

@6a6710cfc21eb16106733eabcd994217@"
"b03611011","5","0.1","108480","@5e0f22c04e9c2d31c902e3e22391692c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] point) {
        int N = point.length;
        Point2D[] ww = new Point2D[N];
        Point2D[] cc = new Point2D[N];
        Point2D min = new Point2D(N, N);
        min = point[0];
        for (Point2D point1 : point) {
            switch (point1.compareTo(min)) {
                case 1:
                    break;
                case 0:
                    break;
                case -1:
                    min = point1;
                    break;
            }
        }
        cc = point.clone();
        Point2D p = new Point2D(min.x(), min.y());
        Arrays.sort(point, p.ATAN2_ORDER);
        for (int i = 0; i < N; i++) {
            String word = Integer.toString(i);
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.textLeft(point[i].x(), point[i].y() + 2, word);

        }
        if (N < 2) {
            return null;
        }
        if (point[0].y() == point[1].y() && point[0].x() > point[1].x()) {
            ww[0] = point[1];
            ww[1] = point[0];
//            ww[0].drawTo(ww[1]);
        } else {
            ww[0] = point[0];
            ww[1] = point[1];
//            ww[0].drawTo(ww[1]);
        }
        int j = 2;
        int i = 0;
        if (N == 2) {
            return null;
        }
        while (i < N - 2) {
            ww[j] = point[i + 2];
            switch (Point2D.ccw(ww[j - 2], ww[j - 1], ww[j])) {
                case -1:
                    j--;
                    break;
                case 0:
//                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
                case 1:
//                    ww[j - 1].drawTo(ww[j]);
                    j++;
                    i++;
                    break;
            }
        }
//        ww[j - 1].drawTo(ww[0]);
        int[] out = new int[j];
        int count = 0;
        for (int k = 0; k < N; k++) {
            for (i = 0; i < j; i++) {
                if (cc[k] == ww[i]) {
                    out[count] = k;
                    count++;
                    break;
                }
            }
        }

        return out;

    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                    int fin =0;
            int M = 0;
            double L = 0;
            int count = 0;
            String data;
            Point2D min = new Point2D(1, 1);
            while (count < 2) {
                if (count == 0) {
                    String fund = br.readLine();
                    L = Double.parseDouble(fund);
                    count++;
                }
                if (count == 1) {
                    String fund = br.readLine();
                    M = Integer.parseInt(fund);
//                    StdDraw.setCanvasSize(500, 500);
//                    StdDraw.setXscale(0, 1);
//                    StdDraw.setYscale(0, 1);
//                    StdDraw.setPenRadius(.005);
                    count++;
                }
            }
            Point2D[] points = new Point2D[M];
            count = 0;
            while ((data = br.readLine()) != null) {
                String fund[] = data.split("" "");
                double x = Double.parseDouble(fund[0]);
                double y = Double.parseDouble(fund[1]);
                points[count] = new Point2D(x, y);
                String word = Integer.toString(count);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                points[count].draw();
//                StdDraw.text(x, y - 0.05, word);
                count++;
            }
            UF c = new UF(M);
            for (int i = 0; i < M; i++) {
                for (int j = i; j < M; j++) {
                    if (points[i].distanceSquaredTo(points[j]) <= L * L) {
                        c.union(i, j);
//                        points[i].drawTo(points[j]);
                    }
                }
            }
            MyConvexHull t = new MyConvexHull();
            int[][] cal = new int[M][M];
            int[] where = new int[M];
            int w = 0;
            int j;
            int[] x;
            for (int i = 0; i < M; i++) {
                count = 0;
                for (j = 0; j < M; j++) {
                    if (c.find(j) == i) {
                        cal[i][count] = j;
                        count++;
                    }
                }
                if (count >= 1) {
                    where[w] = i;
                    w++;
                }
                Point2D[] cals = new Point2D[count];
                if (count > 0) {
                    for (int k = 0; k < count; k++) {
                        cals[k] = points[cal[i][k]];
                    }
                    x = t.ConvexHullVertex(cals);
                    if (x == null) {
                    } else {
                        fin=fin+x.length;
                    }
                }
                j = 0;

            }
            System.out.println(fin);
        }
    }
}

@5e0f22c04e9c2d31c902e3e22391692c@"
"r04921028","3","0.49","105760","@505ca85085fd5591af9edf4df4e6fb83@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    else if(convexpoint.size()>=3){
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           if(icounter>N) break;
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3); 
                           if(convexpoint.size()<3){icounter++;}
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            //===============================
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(a[index[o-1]].x(), a[index[o-1]].y(),a[index[o]].x(), a[index[o]].y()); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x(), a[index[convexsize-1]].y(),a[index[0]].x(), a[index[0]].y()); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x(),a[index[0]].y());
            //===============================
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
//                //===============================
                points[count] = new Point2D(x, y);
                count++;
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
//                System.out.println(""input size: ""+point1s.length);
                int index[] =  ConvexHullVertex(point1s);
                
//                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
//                //===================================
                if(index.length<3)break;
                ans = ans+index.length;
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}
@505ca85085fd5591af9edf4df4e6fb83@"
"r04228027","5","0.102","111472","@cf9644143469ddc6f2b0f0c6e317615e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
// import edu.princeton.cs.algs4.Point2D;
// import edu.princeton.cs.algs4.StdDraw;
// import edu.princeton.cs.algs4.StdRandom;
// import edu.princeton.cs.algs4.Stack;
// import edu.princeton.cs.algs4.UF;
// import edu.princeton.cs.algs4.MergeX;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import java.util.Comparator;
import java.util.List;

public class MyConvexHull {

    public static class Custom_Point2D implements Comparable<Custom_Point2D> {

        public static final Comparator<Custom_Point2D> X_ORDER = new XOrder();

        public static final Comparator<Custom_Point2D> Y_ORDER = new YOrder();

        public static final Comparator<Custom_Point2D> R_ORDER = new ROrder();

        public static final Comparator<Custom_Point2D> ccId_ORDER = new ccIdOrder();

        private final double x;    // x coordinate
        private final double y;    // y coordinate
        public final int id;
        public int ccid;

        public Custom_Point2D(double x, double y, int num) {
            if (Double.isInfinite(x) || Double.isInfinite(y)) {
                throw new IllegalArgumentException(""Coordinates must be finite"");
            }
            if (Double.isNaN(x) || Double.isNaN(y)) {
                throw new IllegalArgumentException(""Coordinates cannot be NaN"");
            }
            if (x == 0.0) {
                this.x = 0.0;  // convert -0.0 to +0.0
            } else {
                this.x = x;
            }

            if (y == 0.0) {
                this.y = 0.0;  // convert -0.0 to +0.0
            } else {
                this.y = y;
            }

            this.id = num;
        }

        public double x() {
            return x;
        }

        public double y() {
            return y;
        }

        public double r() {
            return Math.sqrt(x * x + y * y);
        }

        public double theta() {
            return Math.atan2(y, x);
        }

        private double angleTo(Custom_Point2D that) {
            double dx = that.x - this.x;
            double dy = that.y - this.y;
            return Math.atan2(dy, dx);
        }

        public static int ccw(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
            if (area2 < 0) {
                return -1;
            } else if (area2 > 0) {
                return +1;
            } else {
                return 0;
            }
        }

        public static double area2(Custom_Point2D a, Custom_Point2D b, Custom_Point2D c) {
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }

        public double distanceTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        public double distanceSquaredTo(Custom_Point2D that) {
            double dx = this.x - that.x;
            double dy = this.y - that.y;
            return dx * dx + dy * dy;
        }

        public int compareTo(Custom_Point2D that) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return +1;
            }
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return +1;
            }
            return 0;
        }

        public Comparator<Custom_Point2D> polarOrder() {
            return new PolarOrder();
        }

        public Comparator<Custom_Point2D> atan2Order() {
            return new Atan2Order();
        }

        public Comparator<Custom_Point2D> distanceToOrder() {
            return new DistanceToOrder();
        }

        private static class XOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.x < q.x) {
                    return -1;
                }
                if (p.x > q.x) {
                    return +1;
                }
                return 0;
            }
        }

        private static class YOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                if (p.y < q.y) {
                    return -1;
                }
                if (p.y > q.y) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ROrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = (p.x * p.x + p.y * p.y) - (q.x * q.x + q.y * q.y);
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private static class ccIdOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double delta = p.ccid - q.ccid;
                if (delta < 0) {
                    return -1;
                }
                if (delta > 0) {
                    return +1;
                }
                return 0;
            }
        }

        private class Atan2Order implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double angle1 = angleTo(q1);
                double angle2 = angleTo(q2);
                if (angle1 < angle2) {
                    return -1;
                } else if (angle1 > angle2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        private class PolarOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D q1, Custom_Point2D q2) {
                double dx1 = q1.x - x;
                double dy1 = q1.y - y;
                double dx2 = q2.x - x;
                double dy2 = q2.y - y;

                if (dy1 >= 0 && dy2 < 0) {
                    return -1;    // q1 above; q2 below
                } else if (dy2 >= 0 && dy1 < 0) {
                    return +1;    // q1 below; q2 above
                } else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
                    if (dx1 >= 0 && dx2 < 0) {
                        return -1;
                    } else if (dx2 >= 0 && dx1 < 0) {
                        return +1;
                    } else {
                        return 0;
                    }
                } else {
                    return -ccw(Custom_Point2D.this, q1, q2);     // both above or below
                }
                // Note: ccw() recomputes dx1, dy1, dx2, and dy2
            }
        }

        private class DistanceToOrder implements Comparator<Custom_Point2D> {

            public int compare(Custom_Point2D p, Custom_Point2D q) {
                double dist1 = distanceSquaredTo(p);
                double dist2 = distanceSquaredTo(q);
                if (dist1 < dist2) {
                    return -1;
                } else if (dist1 > dist2) {
                    return +1;
                } else {
                    return 0;
                }
            }
        }

        @Override
        public boolean equals(Object other) {
            if (other == this) {
                return true;
            }
            if (other == null) {
                return false;
            }
            if (other.getClass() != this.getClass()) {
                return false;
            }
            Custom_Point2D that = (Custom_Point2D) other;
            return this.x == that.x && this.y == that.y;
        }

        @Override
        public String toString() {
            return ""("" + x + "", "" + y + "")"";
        }

        @Override
        public int hashCode() {
            int hashX = ((Double) x).hashCode();
            int hashY = ((Double) y).hashCode();
            return 31 * hashX + hashY;
        }

        public void draw() {
            StdDraw.point(x, y);
        }

        public void drawTo(Custom_Point2D that) {
            StdDraw.line(this.x, this.y, that.x, that.y);
        }
    }

    public static int[] ConvexHullVertex(Custom_Point2D[] a) {

        Custom_Point2D[] points = new Custom_Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            points[i] = new Custom_Point2D(a[i].x(), a[i].y(), i);
        }

        MergeX.sort(points, Custom_Point2D.Y_ORDER);
        MergeX.sort(points, points[0].polarOrder());

        Stack<Integer> record = new Stack<>();

        int k = 2;
        int j = 1;
        int i = 0;
        while (k < points.length) {
            if (Custom_Point2D.ccw(points[i], points[j], points[k]) == 1) {
                record.push(i);
                //StdOut.println(i);
                i = j;
                j = k;
                k++;
            } else {
                j = i;
                i = (int) record.pop();
            }
        }
        record.push(i);
        record.push(j);

        int[] res = new int[record.size()];
        int l = 0;

        while (!record.isEmpty()) {
            res[res.length - 1 - l] = points[(int) record.pop()].id;
            l++;
        }

//        for(int n=0;n<res.length;n++){
//            StdOut.println(res[n]);
//        }
        return res;
    }

    public static void main(String[] args) {
        ////input////

        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                info.add(sCurrentLine.split("" ""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        double thr = Double.parseDouble(info.get(0)[0]);
        int N =Integer.parseInt(info.get(1)[0]);
        Point2D[] points = new Point2D[N];
//        StdDraw.setScale();
        for (int i = 0; i < N; i++) {
            points[i] = new Point2D(Double.parseDouble(info.get(i+2)[0]),Double.parseDouble(info.get(i+2)[1]));
//            StdOut.println(i + "": "" + points[i].x() + "" "" + points[i].y());
//            StdDraw.text(points[i].x(), points[i].y() + 0.025, String.valueOf(i));
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
        }
        ////input////

        ////cc + convexhull////
        Custom_Point2D[] custom_points = new Custom_Point2D[points.length];
        for (int i = 0; i < points.length; i++) {
            custom_points[i] = new Custom_Point2D(points[i].x(), points[i].y(), i);
        }

//        int[] index_res = ConvexHullVertex(custom_points);

//        for (int i = 0; i < index_res.length-1; i++) {
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(points[index_res[i]].x(), points[index_res[i]].y(), points[index_res[i + 1]].x(), points[index_res[i + 1]].y());
//        }
//        StdDraw.line(points[index_res[index_res.length-1]].x(), points[index_res[index_res.length-1]].y(), points[index_res[0]].x(), points[index_res[0]].y());
        ////////////cc + convexhull/////////////
        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);

        UF cc = new UF(custom_points.length);
//        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < custom_points.length - 1; i++) {
            for (int j = 1; j < custom_points.length - i; j++) {
                if (custom_points[i].distanceTo(custom_points[i + j]) <= thr) {
                    cc.union(i, i + j);
//                    StdDraw.line(custom_points[i].x(), custom_points[i].y(), custom_points[i + j].x(), custom_points[i + j].y());
//                    custom_points[i].drawTo(custom_points[i + j]);
                } else if (custom_points[i + j].y() - custom_points[i].y() > thr) {
                    break;
                }
            }
        }

        for (int i = 0; i < custom_points.length; i++) {
            custom_points[i].ccid = cc.find(i);
        }

        MergeX.sort(custom_points, Custom_Point2D.Y_ORDER);
        MergeX.sort(custom_points, Custom_Point2D.ccId_ORDER);

//        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(custom_points[i].ccid);
//        }
        Stack<Custom_Point2D> points_stack = new Stack();
        int current_id = custom_points[0].ccid;
        Custom_Point2D[] current_points;
        int res = 0;
        for (int i = 0; i < custom_points.length; i++) {
//            StdOut.println(""now:"" + custom_points[i].id);
            if (custom_points[i].ccid == current_id) {
                points_stack.push(custom_points[i]);
                //StdOut.println(current_id);
            }
            if (custom_points[i].ccid != current_id || i == custom_points.length - 1) {
                ////process current cc points////
                if (points_stack.size() >= 3) {
                    current_points = new Custom_Point2D[points_stack.size()];
                    int k = points_stack.size() - 1;
                    //StdOut.println(""size:""+points_stack.size());
                    while (!points_stack.isEmpty()) {
                        current_points[k] = points_stack.pop();
                        //StdOut.println(current_points[k].id);
                        k--;
                    }
                    //StdOut.println("""");
                    MergeX.sort(current_points, current_points[0].polarOrder());
                    //StdOut.println(custom_points[0].id);
                    int[] current_index_res = ConvexHullVertex(current_points);
                    //StdOut.println(current_index_res[0]);
                    res = res + current_index_res.length;
                    //StdOut.println(current_index_res.length +"" ""+ res);
                }
                ////process current cc points////

                while (!points_stack.isEmpty()) {
                    points_stack.pop();
                }
                current_id = custom_points[i].ccid;
                points_stack.push(custom_points[i]);
            }
        }
        StdOut.println(res);
        ////cc + convexhull////

    }

}

@cf9644143469ddc6f2b0f0c6e317615e@"
"r04921105","5","0.094","107824","@8448d91d00eda1b9dab727bbe9c93f5d@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Random;
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull{
     public static int[] ConvexHullVertex(Point2D[] a) {
         int n= a.length;       
         Point2D[] point = new Point2D[n];
         for(int i = 0; i < n;i++){
            point[i] = new Point2D(a[i].x(), a[i].y());    
        }
         
         Arrays.sort(point, Point2D.Y_ORDER);
         Arrays.sort(point, point[0].POLAR_ORDER);
         
       Stack<Integer> stack = new Stack<Integer>(); 
       int p0=0,p1=1,p2=2;
       
       for(int i=2;i<n;){
           int x = Point2D.ccw(point[p0],point[p1],point[p2]);
           if(x==1){
                stack.push(p0);
                p0=p1;p1=p2;p2=i+1;
                i++;
           }
           else{
               p1=p0;
               p0=stack.pop();
            
           }     
       }
       stack.push(p0);
       stack.push(p1);
       
       int[] array=new int[stack.size()];
       int s = stack.size();
       for(int x=0;x<s;x++){
           array[x]=stack.pop();
           //System.out.println(array[x]);
           
       }
       int[] result =new int[s];
       
       for(int i=0;i<s;i++){
           for(int j=0;j<n;j++){
               if(point[array[i]].equals(a[j])){
                   result[i]=j;
                }
           }
       }
       //System.out.print(""\n"");
       //for(int x=0;x<s;x++){
           //System.out.println(result[x]);
           
      // }
       /*
           System.out.println(""======="");
           System.out.println(s);
           System.out.println(array[0]);
           System.out.println(array[s-1]);
       */
        return result;
       
    }
/*
    public static int[] ConvexHullVertex2(Point2D[] a) {
        
        int n = a.length;
        Point2D[] points = new Point2D[n];
        
        for(int i = 0; i < n;i++){
        points[i] = new Point2D(a[i].x(), a[i].y());    
        }
        
            Arrays.sort(points, Point2D.Y_ORDER );
            Arrays.sort(points, points[0].POLAR_ORDER );
            
            Stack<Integer> hull = new Stack<Integer>();
            int[] p = new int[3];
            p[0] = 0;p[1] = 1;p[2] = 2;
            
            
            
            int counter = 2;
            while(counter < n){               
               if(Point2D.ccw(points[p[0]], points[p[1]], points[p[2]]) == 1){
                   hull.push(p[0]);
                   counter++; 
                   p[0] = p[1];
                   p[1] = p[2];
                   p[2] = counter; 
               }
               else{
                   p[1] = p[0];
                   p[0] = hull.pop();               
               }              
            }
            
            for(int i = 0; i<2;i++){
                hull.push(p[i]);
            }
            
            int size = hull.size();
            int[] result = new int[size];
            int[] result2 = new int[size];
            
            for(int i = 0; i < size; i++){
                result[i] = hull.pop();
            }
    
    for(int i=0;i < size;i++){
        for(int j=0;j < n;j++){
            if(points[result[i]].equals(a[j])){
                result2[i] = j;
            }
        }
    }
        
            
    return result2;
    }
    */
    public static void main(String[] args) throws Exception{
           try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               String data = br.readLine();
               double r = Double.parseDouble(data);
               //System.out.print(r);
               //System.out.print(""\n"");
               
               String data2 =br.readLine();
               int n = Integer.parseInt(data2);
               //System.out.print(n);
              // System.out.print(""\n"");
               
               Point2D[] points = new Point2D[n];
               for(int i=0;i < n ; i++){
                    String cor[] = br.readLine().split("" "");
                    points[i] = new Point2D(Double.parseDouble(cor[0]), Double.parseDouble(cor[1]));                
                }
               
             UF flag = new UF(n);
             for(int i = 0;i<n;i++){
                for(int j=i;j<n;j++){
                    if(i==j);
                    else if(points[i].distanceTo(points[j]) <= r){
                       flag.union(i,j);}   
                }
            }
            int[] int_flag = new int[n];
            for(int i=0; i < n;i++){
                int_flag[i] = -1;}
            int count = 0;            
            for(int i=0;i < n;i++){
                if(int_flag[i] == -1){
                    int_flag[i] =count;
                    count++;
                    for(int j=i;j<n;j++){
                       if(i==j);
                       else if(flag.connected(i, j))
                       int_flag[j] = int_flag[i];                                                           
                    }
                }                    
            }
            int out = 0;
            for(int i = 0;i <= count;i++){
                int count_temp = 0;
                for(int j=0; j < n;j++){
                if(i==int_flag[j])
                    count_temp++;
                }
                if(count_temp > 2){
                   Point2D[] t = new Point2D[count_temp];
                   int c = 0;
                   for(int j2=0; j2 < n;j2++){
                   if(i==int_flag[j2]){
                    t[c] = new Point2D(points[j2].x(), points[j2].y());
                    c++;}
                   }

                   
                   int[] result = ConvexHullVertex(t);
                   out += result.length;
                }
            }
            System.out.println(out);
             
               
            /*  
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenRadius(.02);
            for(int i =0;i<n;i++){
                points[i].draw();
            } 
               

            int n =100;
            Point2D[] points = new Point2D[n];
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1200);
            StdDraw.setYscale(0, 1200);
            StdDraw.setPenRadius(.01);
         
             for (int i = 0; i < n; i++) {
            int x = StdRandom.uniform(1000);
            int y = StdRandom.uniform(1000);
            points[i] = new Point2D(x, y);
            points[i].draw();
                }
             int[] result = ConvexHullVertex(points);
             //int[] result2 = ConvexHullVertex2(points);
             
           System.out.println(""======="");
             
             StdDraw.setPenColor(StdDraw.BLUE);
             for (int i=0; i < result.length;i++){
                 System.out.print(result[i]);
             points[result[i]].draw();    
             }
             /*
                 System.out.println(""~~~"");
             StdDraw.setPenColor(StdDraw.RED);
             for (int i=0; i < result2.length;i++){
                 System.out.print(result2[i]);
             points[result2[i]].draw();    
             }
            */   
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        }
    }
    
}

@8448d91d00eda1b9dab727bbe9c93f5d@"
"r03522809","1","0.1","101472","@da316dca950537aea73333a545fb1a6c@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickFindUF uf = new QuickFindUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=0; j<N; j++){
                if(data[i].distanceTo( data[j]) < D){
                    uf.union(j, i);
                StdDraw.setPenColor(StdDraw.BLACK);         
                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
                StdDraw.setPenColor(StdDraw.GREEN);
                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
            int m =0,n=0;
            for(int i=0;i<N;i++){
                if(k==uf.find(i)){
                    m++;

                    n=1;
                }
            }

            if(n==1){

//                System.out.println("" "");
//                System.out.println(m);
//                System.out.println(cc);

                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }
                else if(m==2){
//                    ans=ans+2;
                }
                else if(m==1){
//                    ans=ans+1;
                }
               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}

@da316dca950537aea73333a545fb1a6c@"
"r03522809","4","0.4","105856","@eb6db8376cc9bd30b1427887dbe8544c@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickFindUF uf = new QuickFindUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=0; j<N; j++){
                if(data[i].distanceTo( data[j]) < D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
            int m =0,n=0;
            for(int i=0;i<N;i++){
                if(k==uf.find(i)){
                    m++;

                    n=1;
                }
            }

            if(n==1){

                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}
@eb6db8376cc9bd30b1427887dbe8544c@"
"r03522809","4","0.38","106624","@dac7272441e8a7a2c7c4f608a7f154dd@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickFindUF uf = new QuickFindUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=0; j<N; j++){
                if(data[i].distanceTo( data[j]) < D){
                    uf.union(j, i);

            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){

                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);

                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            

            
        

        
        
    }
    }
}
@dac7272441e8a7a2c7c4f608a7f154dd@"
"r04522627","1","0.1","104784","@bc4ecc1963b70aebe313acfb03bce08c@import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Ted
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//        StdDraw.setPenRadius(0.01);
        Point2D[] b = a.clone();
        Arrays.sort(b, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        b[0].draw();
//        StdDraw.text(b[0].x(), 0.03 + b[0].y(),String.valueOf(0));
//        StdDraw.setPenColor(StdDraw.BLACK);
        
        Arrays.sort(b, b[0].POLAR_ORDER);
        
        for(int i = 1; i < b.length ;i++)
        {
//            b[i].draw();
//            StdDraw.text(b[i].x(), 0.03 + b[i].y(),String.valueOf(i));
        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(b[0]);
        _stack.push(b[1]);
        _stack.push(b[2]);
        int k = 3;
        int ccw = 0;
        while(k != b.length)
        {
            Point2D p3 = b[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }        
//         StdDraw.setPenColor(Color.yellow);
//         StdDraw.setPenRadius(.005);
         
        int[] id = new int[_stack.size()];
        int index = 0;
         
         Point2D d1 = _stack.pop();
         Point2D op = d1;
         int i = -1;
         while(!a[++i].equals(op))
         {
         }
         id[index++] = i;
       
         do
         {
             Point2D d2 = _stack.pop();
             i = -1;
             while(!a[++i].equals(d2))
             {
             }
             id[index++] = i;
//             StdDraw.line(d1.x(), d1.y(),d2.x(), d2.y());
             d1 = d2;
         }while(!(_stack.size() == 0));
//         StdDraw.line(d1.x(), d1.y(),op.x(), op.y());
         
         Arrays.sort(id);
       
        return id;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
         try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
             
//            String datastream = br.readLine();
//            String[] data = datastream.split("","");
            double distance = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            
            Point2D[] a = new Point2D[n];
            UF uf = new UF(n);
            int[][] ccIndex = new int[n][];
            for(int i = 0 ;i < n ;i++)
            {
                ccIndex[i] = new int[1];
                ccIndex[i][0] = -1;
            }
            
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.2, 1.2);
//            StdDraw.setYscale(-0.2, 1.2);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i = 0; i < n ;i++)
            {
                String datastream = br.readLine();
                String[] data = datastream.split("" "");
                a[i] = new  Point2D(Double.parseDouble(data[0]),Double.parseDouble(data[1]));
//                StdDraw.text(a[i].x()+0.03 , 0.03 + a[i].y(),String.valueOf(i));
            }
//            StdDraw.setPenRadius(.001);
//            StdDraw.setPenColor(StdDraw.GRAY);
            for(int i=0; i < n ;i++)
            {
                for(int j = i+1; j < n;j++)
                {
                    if(a[i].distanceTo(a[j])  <= distance)
                    {
//                        StdDraw.line(a[i].x(), a[i].y(), a[j].x(), a[j].y());
                        uf.union(i, j);
                    }
                }
            }
            
//            int ncc = uf.count();
            int ncc = 0;
            int[] cc_pointnum = new int[4];
            for(int i = 0;i<4;i++)
            {
                cc_pointnum[i] = 0;
            }
            while( ncc != uf.count())
            {
                for(int i = 0; i < n;i++)
                {
                    if(ccIndex[i][0] == -1)
                    {
                        ccIndex[i][0] = ncc++;
                        for(int j = 0; j < n;j++)
                        {
                             if(uf.connected(i, j))
                             {
                                ccIndex[j][0] =  ccIndex[i][0];
                                cc_pointnum[ncc-1]++;
                             }
                        }
                    }
                }
            }
            
            
            int totalnum = 0;
            for(int i = 0;i < uf.count();i++)
            {
                if(cc_pointnum[i] >= 3)
                {
                    Point2D[] temp = new Point2D[cc_pointnum[i]];
                    int k = 0;
                    for(int j = 0;j < n;j++)
                    {
                        if(ccIndex[j][0] == i)
                        {
                            temp[k++] = a[j];
                        }
                    }
                    totalnum += ConvexHullVertex(temp).length;
                }
            }
           
            System.out.printf(String.valueOf(totalnum));
        }
        
    }
    
}

@bc4ecc1963b70aebe313acfb03bce08c@"
"r03525008","4","0.5","104608","@f34c77eee4d83b965ed95d3a368c2ede@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Created by Yang Chi-Chang on 2016/4/11.
 */
public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());
            Point2D[] points = new Point2D[num];
            for(int i = 0  ; i < num ; i++){
                String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
            }

//            for(Point2D p: points)
//                System.out.println(String.format(""(%.3f,%.3f)"",p.x(),p.y()));



            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = i+1 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        parents[j] = getRoot(parents , i);
                    }
                }
            }
//            printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }


            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
//                System.out.println(entry.getKey() + "":"" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    int[] convex = ConvexHullVertex(pointGroup);
//                    System.out.println(entry.getKey() + "":"" + convex.length);
                    totalConvexHull += convex.length;
                }
            }
            System.out.println(totalConvexHull);

            
//            StdDraw.setPenRadius(0.02);
//            for(int i = 0 ; i < num ; i++) {
//                Point2D p1 = points[i];
//                p1.draw();
//                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , parents[i]+"""");
//            }



        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@f34c77eee4d83b965ed95d3a368c2ede@"
"r03525008","4","0.51","107824","@363a299227b6c0642dc2b8d802a71767@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Created by Yang Chi-Chang on 2016/4/11.
 */
public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

//            distance = 0.5;
//            num = 10;
            Point2D[] points = new Point2D[num];


            for(int i = 0  ; i < num ; i++){
                String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                points[i] = new Point2D(Math.random(),Math.random());
            }

//            for(Point2D p: points)
//                System.out.println(String.format(""(%.3f,%.3f)"",p.x(),p.y()));



            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = i+1 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
                }
            }
//            printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }


//            StdDraw.setCanvasSize(800,800);
//            StdDraw.setXscale(-0.1,1.1);
//            StdDraw.setYscale(-0.1,1.1);
//            StdDraw.setPenRadius(0.02);
//            for(int i = 0 ; i < num ; i++) {
//                Point2D p1 = points[i];
//                p1.draw();
//                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , i+""(""+parents[i]+"")"");
//            }
//            StdDraw.setPenColor(StdDraw.MAGENTA);

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
//                System.out.println(entry.getKey() + "":"" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    int[] convex = ConvexHullVertex(pointGroup);
//                    System.out.println(entry.getKey() + "":"" + convex.length);
                    totalConvexHull += convex.length;
//                    for(int i:convex){
//                        pointGroup[i].draw();
//                    }
                }
            }
            System.out.println(totalConvexHull);






        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@363a299227b6c0642dc2b8d802a71767@"
"r03228006","4","0.38","103616","@a26f9f798f1c15be5e1e6e362c43fbb3@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        int[]id = new int[a.length];
        for (int i = 0; i<a.length;i++){
            id[i]=i;
        }
        Point2D[] a0=a;
        Arrays.sort(a, Point2D.Y_ORDER);
        Point2D p0 = a[0];
        Arrays.sort(a, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a.length);i++){
            int check=0;
            for(int k=i+1;k<(a.length);k++){
                if(Point2D.ccw(a[precv],a[i],a[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
            for(int j = 0; j<a0.length;j++){
              if(p1.equals(a0[j])){vindex[i] =j;}//如果找到與原本的a0相符，就記下a0的index
        }}
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
    }
    
   public static void main(String[] args)throws Exception {
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
//                    for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();}
                        //System.out.println(ccindex[k]);
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@a26f9f798f1c15be5e1e6e362c43fbb3@"
"r03522826","3","0.4","107600","@830f48bb20ef5509ea275d638fc13537@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
//        int[] v = new int [N];
//        Point2D[] pcc = new Point2D [N];
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < 6; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
//            System.out.print(next);
//            System.out.print(i);
        }
        
        System.out.print(pts);
        
        
        
//        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@830f48bb20ef5509ea275d638fc13537@"
"r03522809","4","0.37","107440","@f6f95a4712a537ac660f31875c556928@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickUnionUF uf = new QuickUnionUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=0; j<N; j++){
                if(data[i].distanceTo( data[j]) < D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){

                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}

@f6f95a4712a537ac660f31875c556928@"
"r03522826","3","0.38","107616","@8b85ebafe0c4a2ce99868289f41f5d36@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickUnionUF uf = new QuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < 6; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
//            System.out.print(next);
//            System.out.print(i);
        }
        
        System.out.print(pts);
        
        
        
//        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@8b85ebafe0c4a2ce99868289f41f5d36@"
"r03522826","3","0.4","105840","@2bda6626577bd8ce4b06b247fcbc3a49@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < 6; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
//            System.out.print(next);
//            System.out.print(i);
        }
        
        System.out.print(pts);
        
        
        
//        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@2bda6626577bd8ce4b06b247fcbc3a49@"
"r03522826","3","0.4","107760","@1f9e12e3299c54df72f3acd77e1c2189@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        UF uf = new UF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < 6; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
//            System.out.print(next);
//            System.out.print(i);
        }
        
        System.out.print(pts);
        
        
        
//        System.out.print(uf.count());
//        for(int i = 0; i < N; i++)
//        {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//            p[i] = new Point2D(points[i].x(),points[i].y());
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//            StdDraw.text(points[i].x(), points[i].y() + 0.03, Integer.toString(i));
//            
//        }
//        
//       
//       
//        int [] v = ConvexHullVector(points);
//        for (int i = 0; i < v.length; i++)
//        {
//            System.out.print(Integer.toString(v[i])+""\n"");
//            StdDraw.setPenColor(StdDraw.BOOK_BLUE);
//            if(i > 0)
//            StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[i-1]].x(), points[v[i-1]].y());
//            if(i == (v.length - 1))
//                StdDraw.line(points[v[i]].x(), points[v[i]].y(), points[v[0]].x(), points[v[0]].y());
//        }
//        
//        
//        
//        
      
        }
    }
    
}

@1f9e12e3299c54df72f3acd77e1c2189@"
"r03522809","4","0.39","105872","@84d0ea635e67399c113b5201c9293c87@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickUnionUF uf = new QuickUnionUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=0; j<N; j++){
                if(data[i].distanceTo( data[j]) <= D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){

                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}
@84d0ea635e67399c113b5201c9293c87@"
"r03228006","4","0.37","107696","@0ba61bba5381abff733291591b16655f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a1= new Point2D[a.length];
        for(int i=0;i<a.length;i++){//如果直接a1=a，會連參照位置一起相等
        a1[i]=a[i];}
        Arrays.sort(a1, Point2D.Y_ORDER);
        Point2D p0 = a1[0];
        Arrays.sort(a1, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a1.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a1.length);i++){
            int check=0;
            for(int k=i+1;k<(a1.length);k++){
                if(Point2D.ccw(a1[precv],a1[i],a1[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a1[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[id[i]]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            //if (i<j){
            id[j] = i; sz[i] += sz[j]; sz[j]=0;
            //}
            //else if (j>i){
            //id[i] = j; sz[j] += sz[i]; sz[i]=0;}
    }
    
   public static void main(String[] args)throws Exception {
//       //test
//       Point2D [] test=new Point2D[10];
//       for (int i=0;i<10;i++){
//           double x = StdRandom.uniform();
//           double y = StdRandom.uniform();
//           StdDraw.text(x,y,String.valueOf(i));
//           test[i] = new Point2D(x, y);}
//        int [] ccindex2 = ConvexHullVertex(test);
//                    for (int k =0;k<ccindex2.length;k++){
////                        StdDraw.setPenColor(StdDraw.RED);
////                        StdDraw.setPenRadius(.02);
////                        cc[ccindex[k]].draw();
//                          System.out.println(ccindex2[k]);}
       //test end
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    //StdDraw.text(t0,t1,String.valueOf(ii));
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i+1;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@0ba61bba5381abff733291591b16655f@"
"r03228006","0","0","0","@fa35e086249d480f7036b6c8d550b7a9@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a1= new Point2D[a.length];
        for(int i=0;i<a.length;i++){//如果直接a1=a，會連參照位置一起相等
        a1[i]=a[i];}
        Arrays.sort(a1, Point2D.Y_ORDER);
        Point2D p0 = a1[0];
        Arrays.sort(a1, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a1.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a1.length);i++){
            int check=0;
            for(int k=i+1;k<(a1.length);k++){
                if(Point2D.ccw(a1[precv],a1[i],a1[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a1[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[id[i]]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (i<j){
            id[j] = i; sz[i] += sz[j]; sz[j]=0;}
            else if (j<i){
            id[i] = j; sz[j] += sz[i]; sz[i]=0;}
    }
    
   public static void main(String[] args)throws Exception {
//       //test
//       Point2D [] test=new Point2D[10];
//       for (int i=0;i<10;i++){
//           double x = StdRandom.uniform();
//           double y = StdRandom.uniform();
//           StdDraw.text(x,y,String.valueOf(i));
//           test[i] = new Point2D(x, y);}
//        int [] ccindex2 = ConvexHullVertex(test);
//                    for (int k =0;k<ccindex2.length;k++){
////                        StdDraw.setPenColor(StdDraw.RED);
////                        StdDraw.setPenRadius(.02);
////                        cc[ccindex[k]].draw();
//                          System.out.println(ccindex2[k]);}
       //test end
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(""input12.txt""))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    //StdDraw.text(t0,t1,String.valueOf(ii));
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i+1;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@fa35e086249d480f7036b6c8d550b7a9@"
"r03228006","4","0.39","105856","@ee71883af68e6f19d6d4ce45127c1b84@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a1= new Point2D[a.length];
        for(int i=0;i<a.length;i++){//如果直接a1=a，會連參照位置一起相等
        a1[i]=a[i];}
        Arrays.sort(a1, Point2D.Y_ORDER);
        Point2D p0 = a1[0];
        Arrays.sort(a1, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a1.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a1.length);i++){
            int check=0;
            for(int k=i+1;k<(a1.length);k++){
                if(Point2D.ccw(a1[precv],a1[i],a1[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a1[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[id[i]]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (i<j){
            id[j] = i; sz[i] += sz[j]; sz[j]=0;}
            else if (j<i){
            id[i] = j; sz[j] += sz[i]; sz[i]=0;}
    }
    
   public static void main(String[] args)throws Exception {
//       //test
//       Point2D [] test=new Point2D[10];
//       for (int i=0;i<10;i++){
//           double x = StdRandom.uniform();
//           double y = StdRandom.uniform();
//           StdDraw.text(x,y,String.valueOf(i));
//           test[i] = new Point2D(x, y);}
//        int [] ccindex2 = ConvexHullVertex(test);
//                    for (int k =0;k<ccindex2.length;k++){
////                        StdDraw.setPenColor(StdDraw.RED);
////                        StdDraw.setPenRadius(.02);
////                        cc[ccindex[k]].draw();
//                          System.out.println(ccindex2[k]);}
       //test end
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    //StdDraw.text(t0,t1,String.valueOf(ii));
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i+1;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(id[i]==id[j]){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@ee71883af68e6f19d6d4ce45127c1b84@"
"r03228006","5","0.104","107600","@41cfffc7ce6805ba96d41d6b82bcdfec@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;
//import java.util.StdRandom;

public class MyConvexHull {
    private static int[] id;
    private static int[] sz;    
    
    public static int[] ConvexHullVertex(Point2D[] a) {
//        int[]id1 = new int[a.length];
//        for (int i = 0; i<a.length;i++){
//            id1[i]=i;
//        }
        Point2D[] a1= new Point2D[a.length];
        for(int i=0;i<a.length;i++){//如果直接a1=a，會連參照位置一起相等
        a1[i]=a[i];}
        Arrays.sort(a1, Point2D.Y_ORDER);
        Point2D p0 = a1[0];
        Arrays.sort(a1, p0.POLAR_ORDER);
        Point2D[] cvh= new Point2D[a1.length];
        cvh[0]=p0;
        int Ncvh=1;
        int precv=0;//最接近的前一個convex vertex
        for(int i=1;i<(a1.length);i++){
            int check=0;
            for(int k=i+1;k<(a1.length);k++){
                if(Point2D.ccw(a1[precv],a1[i],a1[k])<=0) {//non-counterclock
                    check++;
                }}
            if(check==0){//大家都是counterclock
                cvh[Ncvh]=a1[i];
                Ncvh++;//紀錄vertex數
                precv=i;}//記錄新的最近vertex
        }
        //找出vertex的原始id
        int[] vindex = new int[Ncvh];
        for(int i = 0;i<Ncvh;i++){
            Point2D p1=cvh[i];
           // for(int j = 0; j<a0.length;j++){
              int j =0;
              while(p1.distanceTo(a[j])!=0)
              {j++;}
              vindex[i] =j;//如果找到與原本的a0相符，就記下a0的index
        }
        Arrays.sort(vindex);
        return vindex;
    }
    
    
    private double x;    // x coordinate
    private double y;    // y coordinate
    public void draw() {
        StdDraw.point(x, y);
    }
    
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
    private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[id[i]]];
            return i;
        }
    
    public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (i<j){
            id[j] = i; sz[i] += sz[j]; sz[j]=0;}
            else if (j<i){
            id[i] = j; sz[j] += sz[i]; sz[i]=0;}
    }
    
   public static void main(String[] args)throws Exception {
//       //test
//       Point2D [] test=new Point2D[10];
//       for (int i=0;i<10;i++){
//           double x = StdRandom.uniform();
//           double y = StdRandom.uniform();
//           StdDraw.text(x,y,String.valueOf(i));
//           test[i] = new Point2D(x, y);}
//        int [] ccindex2 = ConvexHullVertex(test);
//                    for (int k =0;k<ccindex2.length;k++){
////                        StdDraw.setPenColor(StdDraw.RED);
////                        StdDraw.setPenRadius(.02);
////                        cc[ccindex[k]].draw();
//                          System.out.println(ccindex2[k]);}
       //test end
        //args[0] is  just for juged system, ""input12.txt"" 
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        // read first line number as vector
            String [] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            String [] data2 = br.readLine().split("","");
            int N = Integer.parseInt(data2[0]);
            //System.out.println(data);
            //StdDraw.setCanvasSize(100, 100);
            //StdDraw.setXscale(0, 1);
            //StdDraw.setYscale(0, 1);
            
            String temp = null;
            Point2D[] points = new Point2D[N];
            int ii=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split(""\\s+"");
                    Double t0 = Double.parseDouble(temp2[0]);
                    Double t1 = Double.parseDouble(temp2[1]);
                    points[ii] = new Point2D(t0, t1);
                    //System.out.println(t0);
                    //System.out.println(t1);
                    //points[ii].draw();
                    //StdDraw.text(t0,t1,String.valueOf(ii));
                    ii++;
                    }
            //把點連起來
            QuickUnionUF(N);
            //StdDraw.setPenRadius(.001);
            //StdDraw.setPenColor(StdDraw.BLUE);
            for (int i = 0; i < N; i++) {
                for(int j=i+1;j<N;j++){
                    Point2D pp=points[i];
                    if(pp.distanceTo(points[j])<=d){
                        //pp.drawTo(points[j]);
                        union(i,j);
                    }
                    //StdDraw.show(100);
                }
            }
            //for(int i=0;i<N;i++){
            //System.out.println(id[i]);}
//            for(int i=0;i<N;i++){
//            System.out.println(sz[i]);}
            int lengthv = 0;
            for(int i=0;i<N;i++){
                if(sz[i]>2){
                    int iii=0;
                    Point2D[] cc = new Point2D[sz[i]];//用來放connected components，重複使用
                    //System.out.println(sz[i]);
                    for(int j=0;j<N;j++){
//                        StdDraw.setPenColor(StdDraw.BLUE);
//                        StdDraw.setPenRadius(.01);
                        if(root(i)==root(j)){cc[iii]=points[j] ;
                    //                     points[j].draw();
                                         iii++;}}
                    int [] ccindex = ConvexHullVertex(cc);
                    lengthv += ccindex.length;
                    ///for (int k =0;k<ccindex.length;k++){
//                        StdDraw.setPenColor(StdDraw.RED);
//                        StdDraw.setPenRadius(.02);
//                        cc[ccindex[k]].draw();
                          ///System.out.println(ccindex[k]);}
                    //System.out.println(ccindex.length);
                }}

            System.out.println(lengthv);
           // 
        //public static void main(String[] args) {

        
//        Point2D[] point = new Point2D[10];
        //Point2D[][] parray = new Point2D()[10][10];
//        for (int i=0;i<10;i++){
//            int x = StdRandom.uniform(-5, 5);
//            int y = StdRandom.uniform(-5, 5);
//            point[i] = new Point2D(x, y);
//            point[i].draw();
//        } 
        //Point2D p = new Point2D(-5, -5);
        //Arrays.sort(point, p.POLAR_ORDER);
//        Arrays.sort(point, Point2D.Y_ORDER);
//        Point2D p1= point[0];
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.setPenRadius(.02);
//        p1.draw();


        // draw line segments from p to each point, one at a time, in polar order
//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        Arrays.sort(point, p1.POLAR_ORDER);
//        for (int i = 0; i < 10; i++) {
//            p1.drawTo(point[i]);
//            StdDraw.show(100);
//        Point2D.ccw(point[0],point[1],point[2]);

//            

//            

            //System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));

        }}}

    

@41cfffc7ce6805ba96d41d6b82bcdfec@"
"b03704074","4","0.66","112176","@038e767c68d593a11f0936c183d2bd11@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0){A[i] = null;break;}
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@038e767c68d593a11f0936c183d2bd11@"
"b03704074","4","0.63","112336","@038e767c68d593a11f0936c183d2bd11@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 && A[i] == null)break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0){A[i] = null;break;}
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;break;}}}
            
            int[] plus = ConvexHullVertex(C);
            //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@038e767c68d593a11f0936c183d2bd11@"
"b03704074","4","0.63","112096","@f47d437765e7eb3b7354e20dad0228f5@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           // System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@f47d437765e7eb3b7354e20dad0228f5@"
"b03704074","4","0.67","112208","@a06dd7a9a0d0c450ca9e4797e57ea0dc@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d+0.0000001){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@a06dd7a9a0d0c450ca9e4797e57ea0dc@"
"b03704074","4","0.64","112224","@63111cb006b95cba1805e304a552ff9f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.0000001){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@63111cb006b95cba1805e304a552ff9f@"
"b03704074","3","0.62","112320","@17ff10ce8a93bafdd8451808271fc0fa@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d+0.1){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@17ff10ce8a93bafdd8451808271fc0fa@"
"b03704074","4","0.63","109552","@aeaf1e95587d49b0204fc8efbd053f3c@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.01){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@aeaf1e95587d49b0204fc8efbd053f3c@"
"b03704074","4","0.63","112192","@aeaf1e95587d49b0204fc8efbd053f3c@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.01){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@aeaf1e95587d49b0204fc8efbd053f3c@"
"b03704074","4","0.65","112288","@e53ed4020cf1ee6c3d634515136b7c1c@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.02){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@e53ed4020cf1ee6c3d634515136b7c1c@"
"b03704074","4","0.65","110416","@d50f9a3e81991d2eace2277caa44ad5b@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.03){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@d50f9a3e81991d2eace2277caa44ad5b@"
"b03704074","4","0.63","112288","@d8a472b04a4b5f02ea946f1d8fb07b85@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.04){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@d8a472b04a4b5f02ea946f1d8fb07b85@"
"b03704074","3","0.65","112704","@99fee7cd17910b1713133751ee2e46ce@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d-0.05){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@99fee7cd17910b1713133751ee2e46ce@"
"b03704074","4","0.62","112256","@3312c8d8da7f3314075fc8498155402f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@3312c8d8da7f3314075fc8498155402f@"
"b03704074","2","0.63","112336","@202b6fc8ba70bc5f4ff5cf041502a136@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=0){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@202b6fc8ba70bc5f4ff5cf041502a136@"
"b03704074","1","0.66","111776","@07b3e551d848321ce31b43c5677905d6@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=100){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@07b3e551d848321ce31b43c5677905d6@"
"b03704074","4","0.62","112080","@3312c8d8da7f3314075fc8498155402f@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            for(int i = 0;i < N;i++){
                if(A[i] == null)continue;
                for(int j = 0;j < B.length;j++){
                    if(B[j] == null)break;
                    //System.out.println(""d=""+d*d);
                    //System.out.println(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2));
                    if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)==0)break;
                    else if(Math.pow((B[j].x()-A[i].x()),2)+Math.pow((B[j].y()-A[i].y()), 2)<=d*d){
                        B[h] = A[i];//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;break;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            for(int i = 0;i < C.length;i++){
                for(int j = 0;j < N;j++){
                    if(C[i] == A[j]){
                        A[j] = null;}}}
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}
        System.out.println(count);
}
}
@3312c8d8da7f3314075fc8498155402f@"
"r04945008","5","0.1","108256","@ca6fed884f16a3a91fe8de837bf58122@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
    
public class MyConvexHull {private Stack<Point2D> hull = new Stack<Point2D>();

    public static int[] ConvexHullVertex(Point2D[] pts) {
        Stack<Point2D> hull = new Stack<Point2D>();
        // defensive copy
        int N = pts.length;
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++)
            points[i] = pts[i];
        Arrays.sort(points);
        Arrays.sort(points, 1, N, points[0].POLAR_ORDER);
        hull.push(points[0]);       // p[0] is first extreme point
        // find index k1 of first point not equal to points[0]
        int k1;
        for (k1 = 1; k1 < N; k1++)
            if (!points[0].equals(points[k1])) break;
        //if (k1 == N) {vertex[0]=N-1; return vertex;}        // all points equal
        // find index k2 of first point not collinear with points[0] and points[k1]
        int k2;
        for (k2 = k1 + 1; k2 < N; k2++)
            if (Point2D.ccw(points[0], points[k1], points[k2]) != 0) break;
        hull.push(points[k2-1]);    // points[k2-1] is second extreme point
        // Graham scan; note that points[N-1] is extreme point different from points[0]
        for (int i = k2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, points[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(points[i]);
        }
        
        int[] vertex = new int[hull.size()];
        Point2D[] temp = new Point2D[hull.size()];
        int i=0;
        while (hull.size() > 0) {
            temp[i++]=hull.pop();
        }
        
        int k=0;
        for( i=0; i < temp.length; i++)
            for (int j = 0; j < N; j++) {
                if (pts[j] == temp[i]) {
                    vertex[k++]=j;
                }
            }
        Arrays.sort(vertex);
        return vertex;
    }
    public static void main(String[] args) throws Exception {
//        int N = 10;
//        Point2D[] points = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            points[i] = new Point2D(x, y);
//        }
//
//        int[] A=ConvexHullVertex(points);
//        for (int i = 0; i < A.length; i++) {
//            System.out.printf(""%d\n"",A[i]);
//            StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//        }
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            double d = Double.parseDouble(data[0]);
            data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j =0; int A = 0;
            double x,y;
            Point2D [] pts = new Point2D[N];
            WeightedQuickUnionUF  uf = new WeightedQuickUnionUF (N);

            while((line = br.readLine()) != null){
                broken_line = line.split("" "");
                x = Double.parseDouble(broken_line[0]);
                y = Double.parseDouble(broken_line[1]);
                pts[i++] = new Point2D(x, y);
            }

            for(i = 0; i < N; i++) {
                for(j = 0; j < N; j++) {
                    if(pts[i].distanceTo(pts[j])<=d ) {
                        uf.union(i,j);
                    }
                }
            }
            
            for(i = 0; i < N; i++) {
                int k=0;
                for(j = 0; j < N; j++) 
                    if(uf.find(j) == i) 
                        k++;
                if(k>=3){
                    Point2D[] temp=new Point2D[k];k=0;
                    for(j = 0; j < N; j++) 
                        if(uf.find(j) == i)
                            temp[k++]=pts[j];
                    A+=ConvexHullVertex(temp).length;  
                }  
            }
   
//            int[] A=ConvexHullVertex(pts);
//            for ( i = 0; i < pts.length; i++) {
//            System.out.printf(""%d\n"",length[i]);
//            StdDraw.filledCircle(pts[i].x(), pts[i].y(), 0.01);
//            }
            System.out.printf(""%d\n"",A);
        }
    }
}
            

@ca6fed884f16a3a91fe8de837bf58122@"
"r03522826","4","0.52","108128","@d032fc25e38b8db5b12e413dd197e9ba@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        UF uf = new UF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@d032fc25e38b8db5b12e413dd197e9ba@"
"b03611015","4","0.48","105552","@1b7530de96fc497fab88ec4d0dff84c5@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }


            System.out.print(leng);

        }
    }
}



@1b7530de96fc497fab88ec4d0dff84c5@"
"r02b48003","5","0.132","112608","@d2ef0ee120225b7a2c915d21c38ca3e9@import java.awt.Font;
import java.io.File;
import java.util.Arrays;
import java.util.Comparator;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class MyConvexHull {
    private static final double radius = 0.01; // point radius for plotting
    
    public static class MyUF extends WeightedQuickUnionUF {
        private final int count; // number of items
        
        public MyUF (int N) {
            /* execute WeightedQuickUnionUF constructor and 
               assign number of items*/
            super(N);
            count = N;
        } // end constructor
        
        public int[] getRoots() {
            /* The function gets all the roots */
            // initialization
            Stack<Integer> rootStack = new Stack<>(); // roots container
            
            // find roots and push to the container
            for (int node = 0; node < count; node++) {
                if (node == find(node)) { // if the root of a node is itself
                    rootStack.push(node);     // push to the container
                } // end if
            } // end loop
            
            // extract the roots from container and return
            int[] roots = stack2array(rootStack);
            return roots;
        } // end func getRoots
        
        public Stack<int[]> getCC() {
            /* get connected components */
            // initialization
            int[] roots = getRoots();           // get all the roots
            Stack<int[]> ccStack = new Stack<>(); // cc container
            
            // each root extract a connected component
            for (int root : roots){
                // loop initialization
                Stack<Integer> cc = new Stack<>();
                
                // element in connected component is connected to the root
                for (int node = 0; node < count; node++) {
                    if (root == find(node)) { cc.push(node); }
                } // end inner loop
                
                // collect each connected component
                ccStack.push(stack2array(cc));
            } // end outer loop
            
            return ccStack;
        } // end func getCC
        
        public int[] stack2array(Stack<Integer> stack){
            /* helper function:
               convert stack into array by popping all items into array */
            // initialization
            int[] arr = new int[stack.size()];
            
            // pop element and collect to an array
            for (int idx = 0; idx < arr.length; idx++) {
                arr[idx] = stack.pop();
            } // end loop
            
            return arr;
        } // end func stack2array
    } // end class myUF
    
    public static Point2D[] idx2points (Point2D[] points, int[] index) {
        /* helper function: 
           input an array of Point2D element and an array of index,
           return an array of Point2D where each element is matched the index 
           of the input array */
        // initialization
        int N = index.length;
        Point2D[] pts = new Point2D[N];
        
        // get the element based on the index array
        for (int i = 0; i < N; i++) {
            int idx = index[i];
            pts[i] = points[idx];
        } // end loop
        
        return pts;
    } // end func idx2point
    
    public static Stack<int[]> distUnionPoints (Point2D[] points, double dist) {
        /* union points and return stack of connected components */
        // initialization
        int N = points.length;
        MyUF uf; 
        
        // double for loop to compare each two points
        uf = new MyUF(N);
        for (int idx1 = 0; idx1 < N; idx1++) {
            for (int idx2 = idx1; idx2 < N; idx2++) {
                // union the points if the distance between points <= distance
                if (points[idx1].distanceTo(points[idx2]) <= dist) {
                    uf.union(idx1, idx2);
                } // end if
            } // end inner loop
        } // end outer loop
        
        return uf.getCC();
    } // end func unionPoints
    
    /**
     * 
     * @param points
     * @return 
     */
    public static int[] ConvexHullVertex(Point2D[] points) {
	// check size
	int N = points.length;  // number of points
	if (N < 3) { return new int[0]; }

	// initialization
        Integer[] vex = new Integer[N]; // vertex: idx of points
	Point2D[] pts = new Point2D[N]; // all points
        
        for (int i = 0; i < N; i++) {
	    vex[i] = i;
	    pts[i] = new Point2D(points[i].x(),
				 points[i].y());
	} // end loop
        
        // initialize index
        Stack<Integer> convex = new Stack<Integer>(); // store index
	convex.push(0);
	convex.push(1);
	convex.push(2);
	
	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by Y axis
	sortByXYaxis(pts, vex);

	// show points before sort
	// show(pts, vex);
        // plot(pts, vex);
	
	// sort points by angle
	sortByAngle(pts, vex);
	
	// show points after sort
	// show(pts, vex);
        // plot(pts, vex);
	// plot(points);
	// plot(pts);
	
	// solve convex hull problem
	//*
	int idx = 2;
	while (true) {
	    
	    if (checkCCW(pts, convex)) {
		// update index
		idx += 1;
		idx %= N;
		
		// if index run through a cycle, break
		if (idx == 1) { break; }

		// push index into stack
		convex.push(idx);
	    } else {
		// skip a index by
		// pop two index & push current index
		convex.pop();
		convex.pop();
		convex.push(idx);
	    } // end if-else
	} // end loop

	// return answer
	int size = convex.size()-1;
        
	int[] ans = new int[size];
        for (int i = 0; i < size; i++) {
            ans[i] = vex[convex.pop()];
        } // end loop
        
	//plot(pts, ans1);
	//StdDraw.show(100);
	//StdDraw.clear();
	//plot(points, ans2);
	//*/
	return ans;
    } // end func ConvexHullVertex
    
    public static boolean checkCCW (Point2D[] points, Stack<Integer> index) {
        /* check whether the top 3 points form a counter clockwise angle */
	// get the top three index of the stack
	int idx3 = index.pop();
	int idx2 = index.pop();
	int idx1 = index.pop();

	// get three corresponding points
	Point2D p1 = points[idx1];
	Point2D p2 = points[idx2];
	Point2D p3 = points[idx3];

	// push back the index
	index.push(idx1);
	index.push(idx2);
	index.push(idx3);

	// return false if clockwise turn; return true otherwise
	//StdOut.println(idx1+"" ""+idx2+"" ""+idx3+"" ""+Point2D.ccw(p1, p2, p3));
	return Point2D.ccw(p1, p2, p3) != -1;
    } // end func checkCCW
    
    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by X and Y axis
     * @param points
     * @param vertex
     */
    public static void sortByXYaxis(Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        // first sort points by X axis
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.X_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
	// then sort points by Y axis
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && less(Point2D.Y_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
    } // end class sortByYaxis

    /**
     * Helper Function for ConvexHullVertex
     * Apply insertion sort to sort the points by angle to the reference point
     * The reference point is the first point in the array
     * @param points
     * @param vertex
     */
    public static void sortByAngle(Point2D[] points, Integer[] vertex) {
	// initialization
	int N = points.length;
        Point2D refPoint = points[0];
        Point2D[] pts = new Point2D[N];

	/* first sort points by radius in reversed order
	for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && more(Point2D.R_ORDER, points[j], points[j-1]);
		 j--) {
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop */
        
	// next shift points so that the reference point is at the origin
        double xi, yi, x0, y0;
	x0 = refPoint.x();
	y0 = refPoint.y();
	for (int i = 0; i < N; i++) {
	    xi = points[i].x();
	    yi = points[i].y();
	    //StdOut.println(xi + "" "" + yi + "" | "" + x0 + "" "" + y0);
	    pts[i] = new Point2D(xi - x0, yi - y0);
        } // end loop
        
        //System.out.println(""Inner:"");
        //show(pts, vertex);
	// then sort points by angle
        for (int i = 0; i < N; i++) {
	    for (int j = i;
		 j > 0 && lessAngle(pts[j], pts[j-1]);
                 //j > 0 && less(refPoint.polarOrder(), points[j], points[j-1]);
		 j--) {
                exch(pts, j, j-1);
		exch(points, j, j-1);
		exch(vertex, j, j-1);
	    } // end inner loop
	} // end outer loop
        
    } // end func sortByAngle
    
    /**
     * @param v
     * @param w
     */
    private static boolean lessAngle (Point2D v, Point2D w) {
	return Double.compare(v.theta(), w.theta()) < 0;
    } // end func less
    
    /**
     * This method compare whether v < w
     * @param v The first object with comparable implemented
     * @param w The second object with comparable implemented
     * @return bool true if v is less than w
     */
    private static boolean less (Comparator c, Object v, Object w) {
	return c.compare(v, w) < 0;
    } // end func less

    /**
     * 
     * @param c
     * @param v
     * @param w
     * @return 
     */
    private static boolean more (Comparator c, Object v, Object w) {
	return c.compare(v, w) > 0;
    } // end func more

    /**
     * This method swap the position of a[idx01] and a[idx02]
     * @param a an array of elements with comparable implemented
     * @param idx01 the first index
     * @param idx02 the second index
     */
    private static void exch (Object[] a, int idx01, int idx02) {
	Object swap = a[idx01];
	a[idx01] = a[idx02];
	a[idx02] = swap;
    } // end func exch
    
    /**
     * 
     * @param points an array of elements with comparable implemented
     * @return
     */
    public static boolean isSortedXYaxis (Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].y() == points[idx+1].y()) {
                if (points[idx].x() > points[idx+1].x()) {
                    return false;
                } // end inner if
            } // end outer if
            
            if (points[idx].y() > points[idx+1].y()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedXYaxis
    
    /**
     * @param points
     * @return 
     */
    public static boolean isSortedAngle(Point2D[] points){
        for (int idx = 0; idx < points.length-1; idx++) {
            if (points[idx].theta() > points[idx+1].theta()) {
                return false;
            } // end if
        } // end loop
        return true;
    } // end func isSortedAngle
    
    /**
     * show the points with point ID
     * @param points
     * @param vertex
     */
    public static void show (Point2D[] points, Integer[] vertex) {
        // initialization
	int N = points.length;
        
        StdOut.println(""ID | X     | Y     | R     | Theta"");
	for (int i = 0; i < N; i++) {
	    StdOut.printf("" %d | %.3f | %.3f | %.3f | %.3f)\n"",
			  vertex[i],
			  points[i].x(),
			  points[i].y(),
                          points[i].r(),
			  points[i].theta());
	} // end loop
	StdOut.println(""------------"");
    } // end func show
    
    public static void plotSet () {
        // set scale
	StdDraw.setXscale(-1.2, 1.2);
	StdDraw.setYscale(-1.2, 1.2);
	
	// set coordinate
	StdDraw.setPenColor(StdDraw.GRAY);
        StdDraw.line(-1.1, 0, 1.1, 0);
	StdDraw.line(0, -1.1, 0, 1.1);
	
	// set Font
        Font font = new Font(""Consolas"", Font.BOLD, 15); 
	StdDraw.setFont(font);
    }
    /**
     * plot the points with point order
     * @param points
     */
    public static void plot (Point2D[] points) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop
    } // end func plot
    
    /**
     * plot the points with point ID
     * @param points
     * @param vertex
     */
    public static void plot (Point2D[] points, Integer[] vertex) {
        plotSet();
        
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = vertex[i];
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// label the first point
	StdDraw.setPenColor(StdDraw.RED);
	StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint

    /**
     * 
     * @param points
     * @param ans 
     */
    public static void plotConvex (Point2D[] points, int[] ans) {
        plotSet();
	
	// plot each point
        int N = points.length;
	StdDraw.setPenColor(StdDraw.BLACK);
	for (int i = 0; i < N; i++) {
	    int     v = i;
	    Point2D p = points[i];
	    StdDraw.filledCircle(p.x(), p.y(), radius);
	    StdDraw.text(p.x() + 0.03, p.y() + 0.03,
			 """" + v);
	} // end for loop

	// plot lines
	StdOut.println("""");
	StdDraw.setPenColor(StdDraw.BLUE);
	for (int i = 0; i < ans.length; i++) {
	    int     v1 = ans[i];
	    int     v2 = ans[(i+1) % ans.length];
	    Point2D p1 = points[v1];
	    Point2D p2 = points[v2];
	    StdDraw.line(p1.x(), p1.y(), p2.x(), p2.y());
	    //StdOut.println(v1 + "" "" + v2);
	} // end loop

	// label the first point
	// StdDraw.setPenColor(StdDraw.RED);
	// StdDraw.filledCircle(points[0].x(), points[0].y(), radius);
    } // end func plotPoint
    
    public static void main(String[] args) {
        Stack<Point2D> pointStack = new Stack<>();
        File file = new File(args[0]);
        In input = new In(file);
        String line;
        
        // read in the threshold distance
        line = input.readLine();
        Double dist = Double.parseDouble(line);
        
        // read in the number of points
        line = input.readLine();
        Integer N = Integer.parseInt(line);
        
        // check
        // StdOut.println(""D: "" + dist + ""\nN: "" + N);
        
        // read in the file containing N 2-dimentional points 
        while (!input.isEmpty()) {
            //double x = StdIn.readDouble();  
            //double y = StdIn.readDouble();           // Read pair to connect.
            //points.push(new Point2D(x, y));
            //StdOut.println(x   + "" "" + y);       //   and print connection.
            line = input.readLine();
            String[] pos = line.split("" ""); // position
            Point2D point = new Point2D(
                    Double.parseDouble(pos[0]), 
                    Double.parseDouble(pos[1]));
            pointStack.push(point);
        } // end while loop 
        
        // get the points into array
        Point2D[] points = new Point2D[pointStack.size()];
        for (int idx = 0; idx < points.length; idx++) {
            points[idx] = pointStack.pop();
            //StdOut.printf(""%.3f, %.3f\n"", points[idx].x(), points[idx].y());
        } // end loop
        
        // show the result of ConvexHullVertex of input points
        //int[] convex = MyConvexHull.ConvexHullVertex(points);
        //MyConvexHull.plotConvex(points, convex);
        //System.out.println(Arrays.toString(convex));
        
        // find connected components (CCs) with a size >= 3
        // for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        int ans = 0;
        for (int[] cc : MyConvexHull.distUnionPoints(points, dist)) {
            // loop through each connected components, where 
            // each connected components, which contain points 
            // connected based on distance specified
            Point2D[] pts = MyConvexHull.idx2points(points, cc);
            int[] vertex = MyConvexHull.ConvexHullVertex(pts);
            //System.out.println(Arrays.toString(vertex));
            
            // sum the number of points in the convex hull
            ans += vertex.length;
        } // end loop
        
        // count the number of points in N serving as a convex hull vertex, print it
        //MyConvexHull.plot(points);
        System.out.println(ans);
    } // end func main
} // end class MyConvexHull

@d2ef0ee120225b7a2c915d21c38ca3e9@"
"b03611041","3","0.31","105792","@7a2b27aababdea9bacb0a38107b12620@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();
            int vetexNum = 0;
            int temp = n + 1;
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
//                    if(now!=temp)
                    if (now == uf.find(j) && temp != now) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }
//                System.out.println(now);
                temp = uf.find(i);
//                System.out.println(temp);

                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }
//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    vetexNum += ConvexHullVertex(ccPoints).length;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3){
            int[] v3=new int[3];
            v3[0]=0;
            v3[1]=1;
            v3[2]=2;
            return v3;
        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@7a2b27aababdea9bacb0a38107b12620@"
"b03611041","3","0.28","108336","@f62d408759faaa1d95672bda05d332a2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();
            int vetexNum = 0;
            int temp = n + 1;
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
//                    if(now!=temp)
                    if (now == uf.find(j) && temp != now) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }
//                System.out.println(now);
                temp = uf.find(i);
//                System.out.println(temp);
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }
//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    vetexNum += ConvexHullVertex(ccPoints).length;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        }
//        }else if(points.length==2){
//            int[] v2=new int[3];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@f62d408759faaa1d95672bda05d332a2@"
"b03611041","3","0.29","107632","@f62d408759faaa1d95672bda05d332a2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);

//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();
            int vetexNum = 0;
            int temp = n + 1;
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
//                    if(now!=temp)
                    if (now == uf.find(j) && temp != now) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }
//                System.out.println(now);
                temp = uf.find(i);
//                System.out.println(temp);
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }
//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    vetexNum += ConvexHullVertex(ccPoints).length;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        }
//        }else if(points.length==2){
//            int[] v2=new int[3];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@f62d408759faaa1d95672bda05d332a2@"
"b03611041","3","0.28","108064","@0accb45b63b1d4b87566e2e5b95edf57@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);
//
//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();
            int vetexNum = 0;
            Stack<Integer> temp=new Stack<>();
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
//                    if(now!=temp)
                    if (now == uf.find(j) && !temp.contains(now)) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }

//                System.out.println(now);
                temp.push(uf.find(i));
//                System.out.println(temp);
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }
//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    vetexNum += ConvexHullVertex(ccPoints).length;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        }
//        }else if(points.length==2){
//            int[] v2=new int[3];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@0accb45b63b1d4b87566e2e5b95edf57@"
"r04921115","0","0","0","@078ad4b21ab85f2fca7ea2f5598b645a@import java.util.*;
import java.io.*;
import java.lang.*;
//Hw 5-2
public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int[] out = new int[hull.size()];
		//System.out.println(""hullsize:""+hull.size());
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						//System.out.println(""j""+j);
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
		        // 1. read in the file containing N 2-dimentional points
	        	double d = Double.parseDouble(br.readLine());
	        	int N = Integer.parseInt(br.readLine());
	        	Point2D[] point = new Point2D[N];
	            UF uf = new UF(N);
	            int n = uf.count();
	            System.out.println(n);
	            int i, j, k;
	        	i=0;
	        	String temp;
	        	while((temp = br.readLine())!=null){
		    		String[] coordinates = temp.split("" "");
		    		double x = Double.parseDouble(coordinates[0]);
		    		double y = Double.parseDouble(coordinates[1]);
		            point[i++] = new Point2D(x, y);
		        }
				
	        	
	        	StdDraw.setPenColor(StdDraw.BLUE);
				for(i=0; i<point.length;i++){
					StdDraw.text(point[i].x(), point[i].y()+0.03, """"+i);
					StdDraw.filledCircle(point[i].x(), point[i].y(), 0.008);
				}
		        // 2. create an edge for each pair of points with a distance <= d
				StdDraw.setPenColor(StdDraw.GREEN);
				
				for(i=0; i<point.length;i++){
					Point2D[] t = new Point2D[point.length];
					k=0;
					//Stack<Point2D> uni = new Stack<Point2D>();
					//uni.push(point[i]);
					for(j=0; j<point.length;j++){
						if(point[i].distanceTo(point[j])<=d){
							point[i].drawTo(point[j]);
							uf.union(i, j);
							//t[k++] = new Point2D(point[j].x(), point[j].y());
							//uni.push(point[j]);
						}
					}
					
//					int[] m = new int[k];
//					MyConvexHull ch = new MyConvexHull();
//					m = ch.ConvexHullVertex(t);
//					System.out.println(m.length);
				}
				int un=-1;
				k=0;
				for(i =0;i<uf.count() && uf.find(i)!=un;i++){
					Point2D[] t = new Point2D[point.length];
					for(j =0;j<uf.count();j++){
						if(uf.find(i)==uf.find(j)){
							t[k++] = new Point2D(point[j].x(), point[j].y());							
						}
					}
					un=uf.find(i);

					int[] m = new int[k];
					MyConvexHull ch = new MyConvexHull();
					m = ch.ConvexHullVertex(t);
					System.out.println(m.length);
				}

		        // 3. find connected components (CCs) with a size >= 3
//				Stack<Point2D> uni = new Stack<Point2D>();
//				int[] forcount = new int[N];
//				int[] record = new int[N];
//				int rec = 0;
//				int z=-2;
//				int z_prev=-1;
//				int size;
//				Stack<Point2D> stack = new Stack<Point2D>();
//				Point2D[] temppoint;
//				for(i=0;i<N;i++){
//					z=uf.find(i);
//					if(z_prev!=z){
//						for(j=0;j<N;j++){
//							z=uf.find(i);
//							if(z==uf.find(j)){
//								if(!stack.isEmpty()){
//									if(stack.peek().equals(point[j])){
//										stack.push(point[j]);
//									}
//								}
//							}
//						}
//						size=stack.size();
//						temppoint = new Point2D[size];
//						for(k=0; k<size;k++){
//							temppoint[k]=stack.pop();
//						}
//						if(size>=3){
//							int[] m = new int[size];
//							MyConvexHull ch = new MyConvexHull();
//							m = ch.ConvexHullVertex(temppoint);
//							System.out.println(m.length);
//						}
//					}
//					z_prev=z;
//				}
				
		}
	}
}







/* Assignment: HW5-1 (below)

import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int[] out = new int[hull.size()];
		//System.out.println(""hullsize:""+hull.size());
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						//System.out.println(""j""+j);
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
			//System.out.print(m[i]+"" "");
		}
	}
}

*/
@078ad4b21ab85f2fca7ea2f5598b645a@"
"r03522826","4","0.51","103776","@5fba163633f122b53c40c638f4fc2573@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickFindUF uf = new QuickFindUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@5fba163633f122b53c40c638f4fc2573@"
"r03522826","4","0.51","108112","@25fe2489c71178698c60dd4b5b39a739@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        QuickUnionUF uf = new QuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@25fe2489c71178698c60dd4b5b39a739@"
"r03522826","4","0.49","108192","@c628df035c2a5ba86e9028c717624e59@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@c628df035c2a5ba86e9028c717624e59@"
"r03522826","4","0.49","102976","@c628df035c2a5ba86e9028c717624e59@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@c628df035c2a5ba86e9028c717624e59@"
"r03522826","4","0.49","108160","@c628df035c2a5ba86e9028c717624e59@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@c628df035c2a5ba86e9028c717624e59@"
"r04522627","5","0.096","109440","@50546c5c04764e97bbb91b3ada79a41a@import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.Random;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Ted
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {

//        StdDraw.setPenRadius(0.01);
        Point2D[] b = a.clone();
        Arrays.sort(b, Point2D.Y_ORDER);
//        StdDraw.setPenColor(StdDraw.RED);
//        b[0].draw();
//        StdDraw.text(b[0].x(), 0.03 + b[0].y(),String.valueOf(0));
//        StdDraw.setPenColor(StdDraw.BLACK);
        
        Arrays.sort(b, b[0].POLAR_ORDER);
        
        for(int i = 1; i < b.length ;i++)
        {
//            b[i].draw();
//            StdDraw.text(b[i].x(), 0.03 + b[i].y(),String.valueOf(i));
        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(b[0]);
        _stack.push(b[1]);
        _stack.push(b[2]);
        int k = 3;
        int ccw = 0;
        while(k != b.length)
        {
            Point2D p3 = b[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }        
//         StdDraw.setPenColor(Color.yellow);
//         StdDraw.setPenRadius(.005);
         
        int[] id = new int[_stack.size()];
        int index = 0;
         
         Point2D d1 = _stack.pop();
         Point2D op = d1;
         int i = -1;
         while(!a[++i].equals(op))
         {
         }
         id[index++] = i;
       
         do
         {
             Point2D d2 = _stack.pop();
             i = -1;
             while(!a[++i].equals(d2))
             {
             }
             id[index++] = i;
//             StdDraw.line(d1.x(), d1.y(),d2.x(), d2.y());
             d1 = d2;
         }while(!(_stack.size() == 0));
//         StdDraw.line(d1.x(), d1.y(),op.x(), op.y());
         
         Arrays.sort(id);
       
        return id;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
         try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
             
            double distance = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            
            Point2D[] a = new Point2D[n];
            UF uf = new UF(n);
            int[][] ccIndex = new int[n][];
            for(int i = 0 ;i < n ;i++)
            {
                ccIndex[i] = new int[1];
                ccIndex[i][0] = -1;
            }
            
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.2, 1.2);
//            StdDraw.setYscale(-0.2, 1.2);
//            StdDraw.setPenRadius(.01);
//            StdDraw.setPenColor(StdDraw.BLUE);
            for(int i = 0; i < n ;i++)
            {
                String datastream = br.readLine();
                String[] data = datastream.split("" "");
                a[i] = new  Point2D(Double.parseDouble(data[0]),Double.parseDouble(data[1]));
//                StdDraw.text(a[i].x()+0.03 , 0.03 + a[i].y(),String.valueOf(i));
            }
//            StdDraw.setPenRadius(.001);
//            StdDraw.setPenColor(StdDraw.GRAY);
            for(int i=0; i < n ;i++)
            {
                for(int j = i+1; j < n;j++)
                {
                    if(a[i].distanceTo(a[j])  <= distance)
                    {
//                        StdDraw.line(a[i].x(), a[i].y(), a[j].x(), a[j].y());
                        uf.union(i, j);
                    }
                }
            }
            
            int ncc = 0;
            int[] cc_pointnum = new int[uf.count()];
            for(int i = 0;i<uf.count();i++)
            {
                cc_pointnum[i] = 0;
            }
            while( ncc != uf.count())
            {
                for(int i = 0; i < n;i++)
                {
                    if(ccIndex[i][0] == -1)
                    {
                        ccIndex[i][0] = ncc++;
                        for(int j = 0; j < n;j++)
                        {
                             if(uf.connected(i, j))
                             {
                                ccIndex[j][0] =  ccIndex[i][0];
                                cc_pointnum[ncc-1]++;
                             }
                        }
                    }
                }
            }
            
            
            int totalnum = 0;
            for(int i = 0;i < uf.count();i++)
            {
                if(cc_pointnum[i] >= 3)
                {
                    Point2D[] temp = new Point2D[cc_pointnum[i]];
                    int k = 0;
                    for(int j = 0;j < n;j++)
                    {
                        if(ccIndex[j][0] == i)
                        {
                            temp[k++] = a[j];
                        }
                    }
                    totalnum += ConvexHullVertex(temp).length;
                }
            }
           
            System.out.printf(String.valueOf(totalnum));
        }
        
    }
    
}

@50546c5c04764e97bbb91b3ada79a41a@"
"r03522809","4","0.4","104464","@8f632ae1c9659e41095d686f113df1e0@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickUnionUF uf = new QuickUnionUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=i; j<N; j++){
                if(data[i].distanceTo( data[j]) <= D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){
//               System.out.println("" "");                
//               System.out.println(m);
//               System.out.println(cc); 
                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}
@8f632ae1c9659e41095d686f113df1e0@"
"b03611041","0","0","0","@37a105c40efc777fcc5bbfb61175061f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);
//
            StdDraw.setCanvasSize(700, 700);
            StdDraw.setXscale(0, 1);
            StdDraw.setYscale(0, 1);
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();

            int vetexNum = 0;
            Stack<Integer> temp=new Stack<>();
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
                    if (now == uf.find(j) && !temp.contains(now)) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }

                temp.push(uf.find(i));
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }


//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    int CL=ConvexHullVertex(ccPoints).length;
                    if(CL>2) vetexNum +=CL;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3 && Point2D.ccw(points[0],points[1],points[2])!=0) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        }

//        }else if(points.length==2){
//            int[] v2=new int[3];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@37a105c40efc777fcc5bbfb61175061f@"
"b03611041","3","0.29","106832","@5cfd5ac3a96d8dcca9e172b37ac8faab@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);
//
//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();

            int vetexNum = 0;
            Stack<Integer> temp=new Stack<>();
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
                    if (now == uf.find(j) && !temp.contains(now)) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }

                temp.push(uf.find(i));
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }


//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    int CL=ConvexHullVertex(ccPoints).length;
                    if(CL>2) vetexNum +=CL;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3 && Point2D.ccw(points[0],points[1],points[2])!=0) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        }

//        }else if(points.length==2){
//            int[] v2=new int[3];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@5cfd5ac3a96d8dcca9e172b37ac8faab@"
"r04631027","0","0.4","104464","@c161957a09f38c0b35ee3f7e03e3e56c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import com.sun.xml.internal.bind.v2.runtime.unmarshaller.XsiNilLoader;
import edu.princeton.cs.algs4.Merge;
import edu.princeton.cs.algs4.Point2D;
import static edu.princeton.cs.algs4.Point2D.area2;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.UF;



import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        
        
        try {
            Point2D[] a = null;
           
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            a = new Point2D[lengths];
            int i = 0;
            //StdDraw.setPenColor(StdDraw.BLACK);
          //  StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
              // StdDraw.point(a[i].x(), a[i].y());
              // StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);                
                 }
                    
                 }
         System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
       
        Point2D v;
        Point2D[] b;
       
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
     Arrays.sort(a,v.atan2Order());  
      int[] index;
        index = new int[a.length];
        index[0] = 0;
        index[1]=1;
       
      
     int co =0;
     
     while(co!=(a.length-1)){
         double area = area2(a[index[co]], a[index[co+1]],a[index[co+1]+1] );
            for (int i =co+2;i<a.length;i++) {
                
                double areaa = area2(a[index[co]], a[index[co+1]],a[i] );
              // System.out.println(i+""= ""+areaa);
                
                if (areaa>area)
                {
                    index[co+2] = i;
                  //  System.out.println(""= ""+i+""co""+co+2);
                area = areaa;
               
                }
              
            }
            
            co++;
             // System.out.println(""co+2 =="" +co);
//           /* if (index[co+2]!=a.length-1)
//            {   
           // System.out.println(co+""             231546453"");
//            else
//                break;*/
                           
}
int count = 0;
   for(int i =(index.length)-1;i>0;i--)
   { if (index[i]!=0)
   {count =i;
  // System.out.println(count+""count"");
   break;
  }
   }
   
        return count+2;
    }

}

@c161957a09f38c0b35ee3f7e03e3e56c@"
"b03611041","4","0.39","104112","@d66b9646af622481a0a0910673de5501@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);
//
//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();

            int vetexNum = 0;
            Stack<Integer> temp=new Stack<>();
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
                    if (now == uf.find(j) && !temp.contains(now)) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }

                temp.push(uf.find(i));
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }


//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    int CL=ConvexHullVertex(ccPoints).length;
                    if(CL>2) vetexNum +=CL;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
        if(points.length==3 && Point2D.ccw(points[0],points[1],points[2])!=0) {
            int[] v3 = new int[3];
            v3[0] = 0;
            v3[1] = 1;
            v3[2] = 2;
            return v3;
        } else if(points.length==2){
            int[] v2=new int[2];
            v2[0]=0;
            v2[1]=1;
            return v2;
        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; i--) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@d66b9646af622481a0a0910673de5501@"
"b03106003","4","0.39","107824","@711169204b1299ae7027094e5b20e773@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            //System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        for(int i = 0; i<m ;i++){
            //System.out.println(r[i]);
        }

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        //int pr[] = ConvexHullVertex(point);
        QuickUnionUF uf = new QuickUnionUF(N);
        //for(int i = 0 ; i< pr.length ; i++){
                //System.out.print(pr[i]+ "" "");
                //System.out.print(point[pr[i]] + "" "");
                
        //}
        
        for(int i = 0; i<N ;i++){
            for(int j = 0 ; j<N;j++){
                if(point[i].distanceTo(point[j]) <= d){
                    uf.union(i, j);
                }            
            }
        }
        //System.out.print(uf.count());
        Stack<Integer>[] st;
        st = new Stack [N];
        for(int i = 0; i<N ; i++){
            st[i] = new Stack<Integer>();
        }
        for(int i = 0; i<N ; i++){
            st[uf.find(i)].push(i);
        }
        int howmany;
        int sum = 0;
        Point2D out[];
        for(int i = 0; i<st.length;i++){
            if(!st[i].isEmpty()){
                howmany = st[i].size();
                //System.out.print(howmany);
                if(howmany > 3){
                    out = new Point2D[howmany];
                    for(int j = 0 ; j< howmany ; j++){
                        out[j] = point[st[i].pop()];
                        //System.out.print(out[j].x());
                        //System.out.println(out[j].y());
                    }
                    
                    sum = sum + ConvexHullVertex(out).length;
                    //System.out.print(sum);
                }else if(howmany == 3){
                    sum = sum+3;
                }
            }
        }
        System.out.print(sum);
    }
}

@711169204b1299ae7027094e5b20e773@"
"r04631027","3","0.29","101168","@2ca85bd99789f5dd2b5775821caacd2d@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        
        
        try {
            Point2D[] a = null;
           
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            a = new Point2D[lengths];
            int i = 0;
            //StdDraw.setPenColor(StdDraw.BLACK);
          //  StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
              // StdDraw.point(a[i].x(), a[i].y());
              // StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);                
                 }
                    
                 }
         System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
       
        Point2D v;
        Point2D[] b;
       
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
     Arrays.sort(a,v.ATAN2_ORDER);  
      int[] index;
        index = new int[a.length];
        index[0] = 0;
        index[1]=1;
       
      
     int co =0;
     
     while(co!=(a.length-1)){
         double area = Point2D.area2(a[index[co]], a[index[co+1]],a[index[co+1]+1] );
            for (int i =co+2;i<a.length;i++) {
                
                double areaa = Point2D.area2(a[index[co]], a[index[co+1]],a[i] );
              // System.out.println(i+""= ""+areaa);
                
                if (areaa>area)
                {
                    index[co+2] = i;
                  //  System.out.println(""= ""+i+""co""+co+2);
                area = areaa;
               
                }
              
            }
            
            co++;
             // System.out.println(""co+2 =="" +co);
//           /* if (index[co+2]!=a.length-1)
//            {   
           // System.out.println(co+""             231546453"");
//            else
//                break;*/
                           
}
int count = 0;
   for(int i =(index.length)-1;i>0;i--)
   { if (index[i]!=0)
   {count =i;
  // System.out.println(count+""count"");
   break;
  }
   }
   
        return count+2;
    }

}

@2ca85bd99789f5dd2b5775821caacd2d@"
"b03611041","5","0.102","108224","@d1113b5dac18336515135f43a46e5fb9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 * Created by Sunny on 4/8/16.
 */

public class MyConvexHull {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            double d = Double.parseDouble(br.readLine());
            int n = Integer.parseInt(br.readLine());
            QuickUnionUF uf = new QuickUnionUF(n);
//
//            StdDraw.setCanvasSize(700, 700);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.01);

            Point2D points[] = new Point2D[n];
            for (int i = 0; i < n; i++) {
                String p[] = br.readLine().split("" "");
                points[i] = new Point2D(Double.parseDouble(p[0]), Double.parseDouble(p[1]));
//                points[i].draw();
            }
//            System.out.println(ConvexHullVertex(points).length);
            if (points.length <= 2) {
                System.out.println(0);
                return;
            }

            for (int i = 0; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (points[i].distanceTo(points[k]) <= d && !uf.connected(i, k)) {
                        uf.union(i, k);
                    }
                }
            }

//            for (int i = 0; i < n; i++) {
//                System.out.println(uf.find(i));
//            }

//            int ufnum=uf.count();

            int vetexNum = 0;
            Stack<Integer> temp=new Stack<>();
            for (int i = 0; i < n; i++) {
                int now = uf.find(i);
                Stack<Point2D> point2DStack = new Stack<>();
                for (int j = 0; j < n; j++) {
                    if (now == uf.find(j) && !temp.contains(now)) point2DStack.push(new Point2D(points[j].x(), points[j].y()));
                }

                temp.push(uf.find(i));
                if (!point2DStack.isEmpty()) {
                    Point2D ccPoints[] = new Point2D[point2DStack.size()];
                    for (int k = 0; k < ccPoints.length; k++) {
                        Point2D tempP = point2DStack.pop();
                        ccPoints[k] = new Point2D(tempP.x(), tempP.y());
                    }


//                    for (int t = 0; t < ccPoints.length; t++) {
//                        System.out.println(ccPoints[t]);
//                    }
//                    System.out.println(""ccc:"" + ConvexHullVertex(ccPoints).length);

                    int CL=ConvexHullVertex(ccPoints).length;
                    if(CL>2) vetexNum +=CL;
//                    System.out.println(vetexNum);


                }
            }
            System.out.println(vetexNum);
        }
    }

    static class pointCmp implements Comparator<Point2D> {
        public int compare(Point2D a, Point2D b) {
            if (a.x() > b.x()) return 1;
            else return ((a.x() < b.x()) || (a.x() == b.x() && a.y() < b.y())) ? -1 : 0;
        }
    }

    public static int[] ConvexHullVertex(Point2D[] points) {
        Point2D[] v = new Point2D[points.length];
        Point2D[] originP;
        originP=Arrays.copyOf(points,points.length);
        Arrays.sort(points, new pointCmp());
//        if(points.length==3 && Point2D.ccw(points[0],points[1],points[2])!=0) {
//            int[] v3 = new int[3];
//            v3[0] = 0;
//            v3[1] = 1;
//            v3[2] = 2;
//            return v3;
//        } else if(points.length==2){
//            int[] v2=new int[2];
//            v2[0]=0;
//            v2[1]=1;
//            return v2;
//        }

        int num = 0;
        for (int i = 0; i < points.length; i++) {
            while (num >= 2 && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            v[num++] = points[i];
        }

//        for (int i = 0; i < v.length; i++) {
//            System.out.println(v[i]);
//        }
//        System.out.println(num + ""\n"");
//        System.out.println(points.length);
        for (int i = points.length - 2,dnum=num+1; i >= 0; --i) {
            while (num >= dnum && Point2D.ccw(v[num - 2], v[num - 1], points[i]) != 1) num--;
            if(num==points.length){
                num++;
                break;
            }
            v[num++] = points[i];
        }
//        for (int i = 0; i < v.length; i++) {
//            System.out.println(v[i]);
//        }
        num--;
//        System.out.println(num + ""\n"");

//        StdDraw.setPenColor(StdDraw.BLUE);
        int vertexes[] = new int[num];

        for (int i = 0; i < vertexes.length; i++) {
//            System.out.println(v[i]);

//            v[i].draw();
            for (int k = 0; k < originP.length; k++) {
                if(originP[k].equals(v[i])) {
                    vertexes[i] = k;
                    break;
                }
            }
        }

//        System.out.println(""\n"");
//        for (int i = 0; i < num; i++) {
//            System.out.println(vertexes[i]);
//        }
        return vertexes;
    }
}

@d1113b5dac18336515135f43a46e5fb9@"
"r03522809","4","0.4","102352","@c1051997962c0096a9e7f0bb48d5e1bd@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {

public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
       
        Arrays.sort(v);
        return v;
    }
//public static int[] ConvexHullVertex(Point2D[] a) {     
//      int i,decide;
//      int N = a.length,size;
// 
//      String q1,q2,q3;
//      Point2D [] b =new Point2D[N];
//      int intq1,intq2,intq3,intq4=0;
//      Stack convexhull = new Stack();
//      
//      for(i =0;i<N;i++){b[i]=a[i];}
//      Insertion.sort(a,Point2D.Y_ORDER);
//      Insertion.sort(a,a[0].POLAR_ORDER);
//      convexhull.push(0);
//      convexhull.push(1);
//      convexhull.push(2);
//      
//      while(intq4<N){
//          q3=convexhull.pop().toString();
//          intq3=Integer.parseInt(q3);
//          q2=convexhull.pop().toString();
//          intq2=Integer.parseInt(q2);
//          q1=convexhull.pop().toString();
//          intq1=Integer.parseInt(q1);
//          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
//          
//          if(decide == 1){
//              convexhull.push(intq1);
//              convexhull.push(intq2);
//              convexhull.push(intq3);
//              intq4=intq3+1;
//              if(intq4<N)
//              convexhull.push(intq4);
//          }
//          else if(decide == -1){
//              convexhull.push(intq1);
//              convexhull.push(intq3);
//          }
//          else if(decide == 0){
//              convexhull.push(intq1);
//              convexhull.push(intq3);
//
//          }
//      }
//      
//      size=convexhull.size();
//      String[] output=new String[size];
//      int[] ans=new int[size];
//      for(i=0;i<size;i++){
//      output[i]=convexhull.pop().toString();
//      ans[i]= Integer.parseInt(output[i]);
//      }
//      
//      int[] orians=new int[size];      
//      int k=0;
//      for(i=0;i<N;i++){
//          for(int j=0;j<size;j++){
//              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
//          }
//      }
//
//      return  orians;
//}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickUnionUF uf = new QuickUnionUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=i; j<N; j++){
                if(data[i].distanceTo( data[j]) <= D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){
//               System.out.println("" "");                
//               System.out.println(m);
//               System.out.println(cc); 
                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}
@c1051997962c0096a9e7f0bb48d5e1bd@"
"r04921028","4","0.47","108096","@48b13adf9af7a1a3a17f4fd3e20892a9@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    else if(convexpoint.size()>=3){
                        if(icounter>N) break;
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            //===============================
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(a[index[o-1]].x(), a[index[o-1]].y(),a[index[o]].x(), a[index[o]].y()); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x(), a[index[convexsize-1]].y(),a[index[0]].x(), a[index[0]].y()); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x(),a[index[0]].y());
            //===============================
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
//                //===============================
                points[count] = new Point2D(x, y);
                count++;
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
//                System.out.println(""input size: ""+point1s.length);
                int index[] =  ConvexHullVertex(point1s);
                
//                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
//                //===================================
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}
@48b13adf9af7a1a3a17f4fd3e20892a9@"
"r03525008","5","0.1","107728","@ea7681c6dbb7e8ca4721363e08a0bb6a@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Created by Yang Chi-Chang on 2016/4/11.
 */
public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

//            distance = 0.3;
//            num = 15;
            Point2D[] points = new Point2D[num];


            for(int i = 0  ; i < num ; i++){
                String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                points[i] = new Point2D(Math.random(),Math.random());
//                System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }

//            for(Point2D p: points)
//                System.out.println(String.format(""(%.3f,%.3f)"",p.x(),p.y()));



            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = 0 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<=root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
//                    printArray(parents);
                }
            }
//            printArray(parents);

            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }

//            printArray(parents);

//            StdDraw.setCanvasSize(800,800);
//            StdDraw.setXscale(-0.1,1.1);
//            StdDraw.setYscale(-0.1,1.1);
//            StdDraw.setPenRadius(0.02);
//            for(int i = 0 ; i < num ; i++) {
//                Point2D p1 = points[i];
//                p1.draw();
//                StdDraw.setPenRadius(0.002);
//                StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
//                StdDraw.setPenRadius(0.02);
//                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
//            }
//            StdDraw.setPenColor(StdDraw.MAGENTA);

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
//                System.out.println(entry.getKey() + "":"" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
                    int[] convex = ConvexHullVertex(pointGroup);
//                    System.out.println(entry.getKey() + "":"" + convex.length);
                    totalConvexHull += convex.length;
//                    for(int i:convex){
//                        copyArray[i].draw();
//                    }
                }
            }
            System.out.println(totalConvexHull);



        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@ea7681c6dbb7e8ca4721363e08a0bb6a@"
"r04945009","1","0.09","104448","@06e115977e051c2d3a8080625955ce3f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author hung-wei
 */
public class MyConvexHull {
    
    public static Point2D[] Go(Point2D[] points, Stack S) {
        int N = S.size();
        Point2D[] GO = new Point2D[N];
        for (int i = 0; i < N; i++) {
            GO[i] = points[(int)S.pop()];
        }
        return GO;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int length = 0;
        for (Point2D i : a) {
            length++;
        }
        //copy the origin array
        Point2D[] Origin = new Point2D[length];
        System.arraycopy(a, 0, Origin, 0, length);
        
        //find the y minimun
        Arrays.sort(a, Point2D.Y_ORDER);
        
        //Sort points by polar angle
        Arrays.sort(a, a[0].POLAR_ORDER);
        //Consider points in order; discard unless it create a ccw turn.
        Stack Vertice = new Stack();
        Vertice.push(0); Vertice.push(1); Vertice.push(2);
        int A,B;
        for (int i = 3; i<length; i++) {
            B = (int)Vertice.pop(); A = (int)Vertice.pop();
            if (Point2D.ccw(a[A],a[B],a[i]) == 1) {
                Vertice.push(A); Vertice.push(B); 
                Vertice.push(i);
            }
            else if (Point2D.ccw(a[A],a[B],a[i]) == -1) {
                Vertice.push(A);
                i--;
            }        
        }
        
        int[] ans = new int[Vertice.size()];
        int f;
        int VerSize = Vertice.size();
        for (int i = 0; i<VerSize; i++) {
            f = (int)Vertice.pop();
            for (int j = 0; j<length; j++) {
                if (a[f].equals(Origin[j]))
                    ans[i] = j;
            }
        }
        Arrays.sort(ans);
        return ans;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            
            Point2D[] points = new Point2D[N];
            
            for (int i = 0; i < N; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[i] = new Point2D(x, y);
//                points[i].draw();
            }
            
            QuickFindUF CC = new QuickFindUF(N);
            for (int i = 0; i < N-1; i++) {
                for (int j = i; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= d)
                        CC.union(i, j);
                }
            }
            
            int[] Array = new int[N];
            for (int i = 0; i < N; i++) {
                Array[i] = CC.find(i);
            }
            
            int[] CopyArray = new int[N];
            System.arraycopy(Array, 0, CopyArray, 0, N);
            Arrays.sort(CopyArray);
            
            int ans = 0;
            Stack S = new Stack();
            for (int i = 0; i < N; i++) {
                if(Array[i] == CopyArray[0]) {
                    S.push(i);
                }
            }
            
            ans += ConvexHullVertex(Go(points, S)).length;
//            S = null;
            
            for (int k = 0; k < N-1; k++) {
                if(CopyArray[k+1] != CopyArray[k]) {
                    for (int i = 0; i < N; i++) {
                        if(Array[i] == CopyArray[k+1]) {
                            S.push(i);
                        }
                    }
                    if (S.size() >= 3)
                        ans += ConvexHullVertex(Go(points, S)).length;
                }
            }
            
            System.out.println(ans);
            
        }
        
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it


            
    

    } 
}

@06e115977e051c2d3a8080625955ce3f@"
"r04945009","1","0.49","107696","@b99afb65109588c7590cd41103811c63@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author hung-wei
 */
public class MyConvexHull {
    
    public static Point2D[] Go(Point2D[] points, Stack S) {
        int N = S.size();
        Point2D[] GO = new Point2D[N];
        for (int i = 0; i < N; i++) {
            GO[i] = points[(int)S.pop()];
        }
        return GO;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int length = 0;
        for (Point2D i : a) {
            length++;
        }
        //copy the origin array
        Point2D[] Origin = new Point2D[length];
        System.arraycopy(a, 0, Origin, 0, length);
        
        //find the y minimun
        Arrays.sort(a, Point2D.Y_ORDER);
        
        //Sort points by polar angle
        Arrays.sort(a, a[0].POLAR_ORDER);
        //Consider points in order; discard unless it create a ccw turn.
        Stack Vertice = new Stack();
        Vertice.push(0); Vertice.push(1); Vertice.push(2);
        int A,B;
        for (int i = 3; i<length; i++) {
            B = (int)Vertice.pop(); A = (int)Vertice.pop();
            if (Point2D.ccw(a[A],a[B],a[i]) == 1) {
                Vertice.push(A); Vertice.push(B); 
                Vertice.push(i);
            }
            else if (Point2D.ccw(a[A],a[B],a[i]) == -1) {
                Vertice.push(A);
                i--;
            }        
        }
        
        int[] ans = new int[Vertice.size()];
        int f;
        int VerSize = Vertice.size();
        for (int i = 0; i<VerSize; i++) {
            f = (int)Vertice.pop();
            for (int j = 0; j<length; j++) {
                if (a[f].equals(Origin[j]))
                    ans[i] = j;
            }
        }
        Arrays.sort(ans);
        return ans;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            
            Point2D[] points = new Point2D[N];
            
            for (int i = 0; i < N; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[i] = new Point2D(x, y);
//                points[i].draw();
            }
            
            QuickFindUF CC = new QuickFindUF(N);
            for (int i = 0; i < N-1; i++) {
                for (int j = i; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= d)
                        CC.union(i, j);
                }
            }
            
            int[] Array = new int[N];
            for (int i = 0; i < N; i++) {
                Array[i] = CC.find(i);
            }
            
            int[] CopyArray = new int[N];
            System.arraycopy(Array, 0, CopyArray, 0, N);
            Arrays.sort(CopyArray);
            
            int ans = 0;
            Stack S = new Stack();
            for (int i = 0; i < N; i++) {
                if(Array[i] == CopyArray[0]) {
                    S.push(i);
                }
            }
            if (S.size() >= 3)
                ans += ConvexHullVertex(Go(points, S)).length;
//            S = null;
            
            for (int k = 0; k < N-1; k++) {
                if(CopyArray[k+1] != CopyArray[k]) {
                    for (int i = 0; i < N; i++) {
                        if(Array[i] == CopyArray[k+1]) {
                            S.push(i);
                        }
                    }
                    if (S.size() >= 3)
                        ans += ConvexHullVertex(Go(points, S)).length;
                }
            }
            
            System.out.println(ans);
            
        }
        
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it


            
    

    } 
}

@b99afb65109588c7590cd41103811c63@"
"r04945009","5","0.098","107632","@2c8f941083afea93f1712aec1166d65b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author hung-wei
 */
public class MyConvexHull {
    
    public static Point2D[] Go(Point2D[] points, Stack S) {
        int N = S.size();
        Point2D[] GO = new Point2D[N];
        for (int i = 0; i < N; i++) {
            GO[i] = points[(int)S.pop()];
        }
        return GO;
    }
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        
        int length = 0;
        for (Point2D i : a) {
            length++;
        }
        //copy the origin array
        Point2D[] Origin = new Point2D[length];
        System.arraycopy(a, 0, Origin, 0, length);
        
        //find the y minimun
        Arrays.sort(a, Point2D.Y_ORDER);
        
        //Sort points by polar angle
        Arrays.sort(a, a[0].POLAR_ORDER);
        //Consider points in order; discard unless it create a ccw turn.
        Stack Vertice = new Stack();
        Vertice.push(0); Vertice.push(1); Vertice.push(2);
        int A,B;
        for (int i = 3; i<length; i++) {
            B = (int)Vertice.pop(); A = (int)Vertice.pop();
            if (Point2D.ccw(a[A],a[B],a[i]) == 1) {
                Vertice.push(A); Vertice.push(B); 
                Vertice.push(i);
            }
            else if (Point2D.ccw(a[A],a[B],a[i]) == -1) {
                Vertice.push(A);
                i--;
            }        
        }
        
        int[] ans = new int[Vertice.size()];
        int f;
        int VerSize = Vertice.size();
        for (int i = 0; i<VerSize; i++) {
            f = (int)Vertice.pop();
            for (int j = 0; j<length; j++) {
                if (a[f].equals(Origin[j]))
                    ans[i] = j;
            }
        }
        
        Arrays.sort(ans);
//        for (int i=0; i<ans.length; i++)
//            a[ans[i]].draw();
        return ans;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
    }
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            double d = Double.parseDouble(br.readLine());
            int N = Integer.parseInt(br.readLine());
            
            Point2D[] points = new Point2D[N];
            
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(0, 1);
//            StdDraw.setYscale(0, 1);
//            StdDraw.setPenRadius(.02);
            
            
            for (int i = 0; i < N; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                points[i] = new Point2D(x, y);
//                points[i].draw();
            }
            
            QuickFindUF CC = new QuickFindUF(N);
            for (int i = 0; i < N-1; i++) {
                for (int j = i; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= d)
                        CC.union(i, j);
                }
            }
            
            int[] Array = new int[N];
            for (int i = 0; i < N; i++) {
                Array[i] = CC.find(i);
            }
            
            int[] CopyArray = new int[N];
            System.arraycopy(Array, 0, CopyArray, 0, N);
            Arrays.sort(CopyArray);
            
            int ans = 0;
            Stack S = new Stack();
            for (int i = 0; i < N; i++) {
                if(Array[i] == CopyArray[0]) {
                    S.push(i);
                }
            }
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.setPenRadius(.02);
            
            int Ssize = S.size();
            if (Ssize >= 3) {
                
                ans += ConvexHullVertex(Go(points, S)).length;
            }
            else
                for (int i = 0; i<Ssize; i++) S.pop();
//            S = null;
            
            for (int k = 0; k < N-1; k++) {
                if(CopyArray[k+1] != CopyArray[k]) {
                    for (int i = 0; i < N; i++) {
                        if(Array[i] == CopyArray[k+1]) {
                            S.push(i);
                        }
                    }
                    Ssize = S.size();
                    if (Ssize >= 3)
                        ans += ConvexHullVertex(Go(points, S)).length;
                    else
                        for (int i = 0; i<Ssize; i++) S.pop();
                    
                }
            }
            
            System.out.println(ans);
            
        }
        
        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it


            
    

    } 
}

@2c8f941083afea93f1712aec1166d65b@"
"b03611033","5","0.098","107696","@432ecddc16747d8ba0e7de035f749481@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Stack;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] b = new Point2D[a.length];
        System.arraycopy(a, 0, b, 0, a.length);

        int i = 0;

        for (int j = 1; j < b.length; j++) {
            if (b[i].compareTo(b[j]) == 1) {
                i = j;
            }
        }

        Point2D min = b[i];
        Arrays.sort(b, min.ATAN2_ORDER);

        /*
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.01);
        min.draw();
        StdOut.println(""==="" + min);

        for (int h = 0; h < 10; h++) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            b[h].draw();
            //StdOut.println(b[h]);
            StdDraw.show(100);
        }
        StdDraw.setPenColor(StdDraw.RED);
        min.draw();
         */
        int cc1, cc2, cc3, num = 2;
        Stack<Integer> index1 = new Stack<>();
        /*
        StdDraw.setPenRadius();
        b[0].drawTo(b[1]);
        StdDraw.show(1000);
         */

        index1.push(0);
        index1.push(1);

        while (true) {
            index1.push(num);
            cc3 = index1.pop();
            cc2 = index1.pop();
            cc1 = index1.pop();

            if (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                while (Point2D.ccw(b[cc1], b[cc2], b[cc3]) != 1) {
                    if (cc1 == 0) {
                        cc1 = b.length - 1;
                    } else {
                        cc2 = cc1;
                        cc1 = index1.pop();
                    }
                }
            } else {
                /*
                StdDraw.setPenColor(StdDraw.RED);
                b[cc1].drawTo(b[cc2]);
                b[cc2].drawTo(b[cc3]);
                StdDraw.show(1000);
                 */
            }
            index1.push(cc1);
            index1.push(cc2);
            index1.push(cc3);
            if (cc3 == 0) {
                break;
            }
            num++;
            if (num == b.length) {
                num = 0;
            }
        }
        index1.pop();
        //StdOut.println(index1);

        int count = 0, temp;
        int out[] = new int[index1.size()];
        int size = index1.size();

        while (count < size) {
            temp = index1.pop();
            i = 0;
            //StdOut.println(temp);
            while (true) {
                if (a[i].equals(b[temp])) {
                    //StdOut.println(i);
                    //StdOut.println(b[temp]);
                    out[count] = i;
                    break;
                }
                i++;
            }
            count++;
        }

        Arrays.sort(out);
        /*for (int h = 0; h < count; h++) {
            StdOut.println(out[h]);
        }
         */
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return out;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data;
            data = br.readLine();
            double d = Double.parseDouble(data);
            data = br.readLine();
            int N = Integer.parseInt(data);
            /*
            StdDraw.setCanvasSize(500, 500);
            StdDraw.setXscale(0, 1.2);
            StdDraw.setYscale(0, 1.2);
            StdDraw.setPenRadius(.01);
             */
            Point2D[] points = new Point2D[N];

            String datacut[];
            double x, y;
            int m = 0;

            while ((data = br.readLine()) != null) {
                datacut = data.split("" "");
                x = Double.parseDouble(datacut[0]);
                y = Double.parseDouble(datacut[1]);
                points[m] = new Point2D(x, y);

                //StdDraw.text(x + 0.02, y + 0.02, """" + i);
                //points[i].draw();
                m++;
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            boolean[] unused = new boolean[N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= d) {
                        uf.union(i, j);
                    }
                }
                unused[i] = true;
            }

           
            int sum = 0;
            for (int i = 0; i < N; i++) {
                Stack<Integer> index = new Stack<>();
                if (unused[i]) {
                    for (int j = 0; j < N; j++) {
                        if (uf.find(j) == i) {
                            index.push(j);
                            unused[j] = false;
                        }
                    }

                    int length = index.size();

                    if (length >= 3) {
                        Point2D[] input = new Point2D[length];
                        for (int copy = 0; copy < length; copy++) {
                            input[copy] = points[index.pop()];
                        }
                        sum += (MyConvexHull.ConvexHullVertex(input)).length;
                    }
                    /*else {
                        for (int n = 0; n < length; n++) {
                            index.pop();
                        }
                    }*/
                }
            }
            StdOut.println(sum);
        }
    }
}

@432ecddc16747d8ba0e7de035f749481@"
"r04525016","0","0","0","@040c9e4443a71a2e1d4daa7314601912@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Created by Yang Chi-Chang on 2016/4/11.
 */
public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

            distance = 0.3;
            num = 12;
            Point2D[] points = new Point2D[num];

            for(int i = 0  ; i < num ; i++){
//                String[] coordinate = br.readLine().split(""\\s"");
//                double x = Double.parseDouble(coordinate[0]);
//                double y = Double.parseDouble(coordinate[1]);
//                points[i] = new Point2D(x,y);
                points[i] = new Point2D(Math.random(),Math.random());
                System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }


            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = 0 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<=root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
                }
            }

            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }

            System.out.print(""label:"");
            printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }

            StdDraw.setCanvasSize(800,800);
            StdDraw.setXscale(-0.1,1.1);
            StdDraw.setYscale(-0.1,1.1);
            StdDraw.setPenRadius(0.02);
            for(int i = 0 ; i < num ; i++) {
                Point2D p1 = points[i];
                p1.draw();
                StdDraw.setPenRadius(0.002);
                StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
                StdDraw.setPenRadius(0.02);
                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
            StdDraw.setPenColor(StdDraw.MAGENTA);

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
                System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
                    int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
                    for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }

//            System.out.println(totalConvexHull);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}

@040c9e4443a71a2e1d4daa7314601912@"
"r04525016","4","0.48","107776","@53ed432492d49e53e3c3ed1ddeb850fa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * Created by cavitation on 2016/4/15.
 */
public class MyConvexHull {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double minDistance = Double.parseDouble(data);
            String data2 = br.readLine();
            int numPoint = Integer.parseInt(data2);
            Point2D[] cc = new Point2D[numPoint];


            int i = 0;
            while (br.ready()) {
                String[] temp = br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                cc[i] = new Point2D(x, y);
//                cc[i] = new Point2D(Math.random(), Math.random());
                i++;
            }
            br.close();


            int[] father = new int[numPoint];
            for (int c = 0; c < numPoint; c++) {
                father[c] = c;
            }
            for (int j = 0; j < numPoint; j++) {
                for (int k = 0; k < numPoint; k++) {
                    if (cc[j].distanceTo(cc[k]) <= minDistance) {
                        father[k] = getRoot(father, j);
                    }
                }
            }

            int numC = 0;
            for (i = 0; i < numPoint; i++) {
                ArrayList<Integer> label = new ArrayList<>();
                for (int j = 0; j < numPoint; j++) {
                    if (father[j] == i) {
                        label.add(j);
                    }
                }
                Point2D[] label5 = new Point2D[label.size()];
                for (int k = 0; k < label.size(); k++) {
                    label5[k] = cc[label.get(k)];
                }
                if (label5.length > 2) {
                    int[] index2 = ConvexHullVertex(label5);
                    numC += index2.length;
                }
            }

            System.out.println(numC);

//            for (int e = 0; e < father.length; e++) {
//                System.out.print(father[e] + "" "");
//            }


//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.1, 1.1);
//            StdDraw.setYscale(-0.1, 1.1);
//            int counter = 0;
//            for (Point2D p : cc) {
//                StdDraw.setPenRadius(0.015);
//                p.draw();
//                StdDraw.setPenRadius(0.002);
//                StdDraw.circle(p.x() , p.y() , minDistance/2);
//                StdDraw.text(p.x() + 0.03, p.y(), counter + ""("" + father[counter++] + "")"");
//            }
        }
    }

    public static int getRoot(int[] root, int index1) {

        while (index1 != root[index1]) index1 = root[index1];
        return index1;
    }

    public static int[] ConvexHullVertex(Point2D[] point2Ds) {
        ArrayList<Point2D> PG = new ArrayList<>();
        for (int i = 0; i < point2Ds.length; i++) {
            PG.add(point2Ds[i]);
        }


        int minIndex = getMin(point2Ds);
        Point2D min = point2Ds[minIndex];

        Comparator<Point2D> comparator = min.ATAN2_ORDER;
        sort(point2Ds, comparator);

        Stack<Point2D> data = new Stack<Point2D>();
        data.push(point2Ds[0]);
        data.push(point2Ds[1]);

        for (int i = 2; i < point2Ds.length; i++) {
            Point2D b = data.pop();
            Point2D c = data.pop();
            Point2D a = point2Ds[i];

            while (Point2D.ccw(c, b, a) != 1) {
                b = c;
                c = data.pop();
            }
            data.push(c);
            data.push(b);
            data.push(a);
        }


        int[] index = new int[data.size()];
        int count = 0;
        while (!data.isEmpty()) {
            Point2D p = data.pop();
            int i = PG.indexOf(p);
            index[count++] = i;
        }


        int[] index2 = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            index2[i] = index[index.length - 1 - i];
        }


        return index2;
    }


    public static int getMin(Point2D[] a) {
        double min = a[0].y();
        int minIndex = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i].y() < min) {
                min = a[i].y();
                minIndex = i;
            }
        }
        return minIndex;
    }

    public static void sort(Point2D[] array, Comparator<Point2D> c) {
        sort2(array, 0, array.length - 1, c);
    }

    public static void sort2(Point2D[] array, int start, int end, Comparator<Point2D> c) {

        boolean goOn = true;
        int i = start + 1;
        int n = end;

        if (start >= end) return;

        while (goOn) {
            while (c.compare(array[start], array[i]) != -1) {
                if (i == end) break;
                i++;
            }

            while (c.compare(array[start], array[n]) != 1) {
                if (n == start) break;
                n--;
            }


            if (i < n) {
                Point2D temp = array[i];
                array[i] = array[n];
                array[n] = temp;
                goOn = true;
            } else {
                Point2D temp = array[n];
                array[n] = array[start];
                array[start] = temp;
                goOn = false;
            }

        }
        sort2(array, start, n - 1, c);
        sort2(array, n + 1, end, c);
    }


}
@53ed432492d49e53e3c3ed1ddeb850fa@"
"b03611003","1","0.1","105808","@ec5323f9503c837a4ae397214bbc9931@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public static void DrawingPratice3(int N) {
//        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

        
        
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

                            
            hull.push(top);
            hull.push(a[i]);
        }

        
//        StdDraw.setPenColor(Color.red);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//
//        StdDraw.setPenRadius(.001);
//        StdDraw.setPenColor(Color.green);
//        for (int i = 1; i < a.length; i++) {
//    
////            a[i].drawTo(a[0]);
//
////            StdDraw.show(10);
//        }
//        StdDraw.setPenColor(Color.BLUE);
        
        
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

//            begin.drawTo(end);
//            StdDraw.show();
          
            
            begin = end;
        }

        Arrays.sort(Convex);

        return Convex;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

//           int N = 20;
            
            Point2D[] datapoint = new Point2D[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }
            
 
  
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//
//            datapoint[i] = new Point2D(x, y);
//
//
//         StdDraw.setPenRadius(.01);
//          
//          datapoint[i].draw();
//  
//        }
//
            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
//                         StdDraw.setPenRadius(.002);
//                        StdDraw.setPenColor(Color.RED);
//                        datapoint[i].drawTo(datapoint[j]);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
                if(i == N - 1){
                    CCnumber[k] = a[i];
                    k++;
                }
            }
           
            int leng = 0;
            
            for(int i =0; i < k; i++){
                
                int count = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        count++;
                    }
                }
                
                
                Point2D[] convex = new Point2D[count];
                
                int num = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }
            

//            System.out.print(UF.count());
            
                System.out.print(leng);
            

        }
    }

}

@ec5323f9503c837a4ae397214bbc9931@"
"b03611003","5","0.104","107568","@cd07a8b802f88b32bb8206fd951ca250@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.Point2D;
//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.StdDraw;
//import edu.princeton.cs.algs4.StdRandom;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/**
 *
 * @author 士齊
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
//    畫10個點 從 0,0 到 9,9
    public void DrawingPratice1() {
        Point2D[] a = new Point2D[10];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Point2D(i * 0.1, i * 0.1);
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，連線上一個，第一個點是紅的
    public void DrawingPratice2() {
        int N = 10;
        Point2D[] a = new Point2D[N];

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            if (i != 0) {
                StdDraw.setPenColor(Color.BLACK);
                a[i].drawTo(a[i - 1]);
            } else {
                StdDraw.setPenColor(Color.red);
            }
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
        }
    }

//    畫random 10個點，最左下的是紅色
    public static void DrawingPratice3(int N) {
//        int N = 10;
        Point2D[] a = new Point2D[N];
        int smallest = 0;

        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();

            a[i] = new Point2D(x, y);

            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);

            if (a[smallest].compareTo(a[i]) == 1) {
                smallest = i;
            }

        }

        StdDraw.setPenColor(Color.red);
        StdDraw.filledCircle(a[smallest].x(), a[smallest].y(), 0.01);

    }

    public static void DrawingPratice4() {
        double x0 = 0.5;
        double y0 = 0.5;
        int N = 50;
        int smallest = 0;

        StdDraw.setCanvasSize(800, 800);
        StdDraw.setXscale(0, 1);
        StdDraw.setYscale(0, 1);
        StdDraw.setPenRadius(.005);
        Point2D[] points = new Point2D[N];
        for (int i = 0; i < N; i++) {
            double x = StdRandom.uniform();
            double y = StdRandom.uniform();
            points[i] = new Point2D(x, y);
            points[i].draw();
            if (points[smallest].compareTo(points[i]) == 1) {
                smallest = i;
            }
        }

        // draw p = (x0, x1) in red
//        Point2D p = new Point2D(x0, y0);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.setPenRadius(.02);
        points[0].draw();

        // draw line segments from p to each point, one at a time, in polar order
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(points, points[smallest].POLAR_ORDER);
        for (int i = 0; i < N; i++) {
            points[0].drawTo(points[i]);
//            StdDraw.show(100);
        }

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 0; i < N; i++) {
            StdDraw.text(points[i].x(), points[i].y(), """" + i);

        }
    }

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<Point2D>();
        int[] Convex;

        Point2D[] ori = new Point2D[a.length];
        for (int i = 0; i < a.length; i++) {
            ori[i] = new Point2D(a[i].x(), a[i].y());
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);

        hull.push(a[0]);
        hull.push(a[1]);

        
        
        for (int i = 2; i < a.length; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }

                            
            hull.push(top);
            hull.push(a[i]);
        }

        
//        StdDraw.setPenColor(Color.red);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//
//        StdDraw.setPenRadius(.001);
//        StdDraw.setPenColor(Color.green);
//        for (int i = 1; i < a.length; i++) {
//    
////            a[i].drawTo(a[0]);
//
////            StdDraw.show(10);
//        }
//        StdDraw.setPenColor(Color.BLUE);
        
        
        Point2D begin = a[0];
        int size = hull.size();
        Convex = new int[size];

        for (int i = 0; i < size; i++) {
            Point2D end = hull.pop();
            for (int j = 0; j < a.length; j++) {
                if (end.x() == ori[j].x()) {
                    if (end.y() == ori[j].y()) {
                        Convex[i] = j;
                        break;
                    }
                }
            }

//            begin.drawTo(end);
//            StdDraw.show();
          
            
            begin = end;
        }

        Arrays.sort(Convex);

        return Convex;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

//           int N = 20;
            
            Point2D[] datapoint = new Point2D[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }
            
 
  
//        for (int i = 0; i < N; i++) {
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//
//            datapoint[i] = new Point2D(x, y);
//
//
//         StdDraw.setPenRadius(.01);
//          
//          datapoint[i].draw();
//  
//        }
//
            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
//                         StdDraw.setPenRadius(.002);
//                        StdDraw.setPenColor(Color.RED);
//                        datapoint[i].drawTo(datapoint[j]);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
                if((i == N - 1) && size >= 3){
                    CCnumber[k] = a[i];
                    k++;
                }
            }
           
            int leng = 0;
            
            for(int i =0; i < k; i++){
                
                int count = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        count++;
                    }
                }
                
                
                Point2D[] convex = new Point2D[count];
                
                int num = 0;
                for(int j = 0; j < N; j++){
                    if(CCnumber[i] == UF.find(j)){
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }
            

//            System.out.print(UF.count());
            
                System.out.print(leng);
            

        }
    }

}

@cd07a8b802f88b32bb8206fd951ca250@"
"r04525016","1","0.47","107632","@2afe558f944831d4381831b0dd4f2fd5@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * Created by cavitation on 2016/4/15.
 */
public class MyConvexHull {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double minDistance = Double.parseDouble(data);
            String data2 = br.readLine();
            int numPoint = Integer.parseInt(data2);
//            Point2D[] cc = new Point2D[numPoint];


            numPoint = 15;
            Point2D[] cc = new Point2D[numPoint];
            for(int i = 0 ; i < numPoint; i++){
                cc[i] = new Point2D(Math.random(), Math.random());
            }


            int i = 0;
            while (br.ready()) {
                String[] temp = br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
//                cc[i] = new Point2D(x, y);
//                cc[i] = new Point2D(Math.random(), Math.random());
                i++;
            }
            br.close();


            int[] father = new int[numPoint];
            for (int c = 0; c < numPoint; c++) {
                father[c] = c;
            }
            for (int j = 0; j < numPoint; j++) {
                for (int k = 0; k < numPoint; k++) {
                    if (cc[j].distanceTo(cc[k]) <= minDistance) {
                        int root1 = getRoot(father, j);
                        int root2 = getRoot(father, k);
                        if (root1 < root2) {
                            father[root2] = root1;
                        } else father[root1] = root2;
                    }
                }
            }

            int[] root = new int[father.length];
            for(int k = 0; k < numPoint; k ++) {
                int temp = getRoot(father, k);
                root[k] = temp;
            }


            int numC = 0;
            for (i = 0; i < numPoint; i++) {
                ArrayList<Integer> label = new ArrayList<>();
                for (int j = 0; j < numPoint; j++) {
                    if (father[j] == i) {
                        label.add(j);
                    }
                }
                Point2D[] label5 = new Point2D[label.size()];
                for (int k = 0; k < label.size(); k++) {
                    label5[k] = cc[label.get(k)];
                }
                if (label5.length > 2) {
                    int[] index2 = ConvexHullVertex(label5);
                    numC += index2.length;
                }
            }

            System.out.println(numC);


            
//            for (int e = 0; e < father.length; e++) {
//                System.out.print(father[e] + "" "");
//            }


//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.1, 1.1);
//            StdDraw.setYscale(-0.1, 1.1);
//            int counter = 0;
//            for (Point2D p : cc) {
//                StdDraw.setPenRadius(0.015);
//                p.draw();
//                StdDraw.setPenRadius(0.002);
//                StdDraw.circle(p.x(), p.y(), minDistance / 2);
//                StdDraw.text(p.x() + 0.03, p.y(), counter + ""("" + root[counter++] + "")"");
//            }
        }
    }

    public static int getRoot(int[] root, int index1) {

        while (index1 != root[index1]) index1 = root[index1];
        return index1;
    }

    public static int[] ConvexHullVertex(Point2D[] point2Ds) {
        ArrayList<Point2D> PG = new ArrayList<>();
        for (int i = 0; i < point2Ds.length; i++) {
            PG.add(point2Ds[i]);
        }


        int minIndex = getMin(point2Ds);
        Point2D min = point2Ds[minIndex];

        Comparator<Point2D> comparator = min.ATAN2_ORDER;
        sort(point2Ds, comparator);

        Stack<Point2D> data = new Stack<Point2D>();
        data.push(point2Ds[0]);
        data.push(point2Ds[1]);

        for (int i = 2; i < point2Ds.length; i++) {
            Point2D b = data.pop();
            Point2D c = data.pop();
            Point2D a = point2Ds[i];

            while (Point2D.ccw(c, b, a) != 1) {
                b = c;
                c = data.pop();
            }
            data.push(c);
            data.push(b);
            data.push(a);
        }


        int[] index = new int[data.size()];
        int count = 0;
        while (!data.isEmpty()) {
            Point2D p = data.pop();
            int i = PG.indexOf(p);
            index[count++] = i;
        }


        int[] index2 = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            index2[i] = index[index.length - 1 - i];
        }


        return index2;
    }


    public static int getMin(Point2D[] a) {
        double min = a[0].y();
        int minIndex = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i].y() < min) {
                min = a[i].y();
                minIndex = i;
            }
        }
        return minIndex;
    }

    public static void sort(Point2D[] array, Comparator<Point2D> c) {
        sort2(array, 0, array.length - 1, c);
    }

    public static void sort2(Point2D[] array, int start, int end, Comparator<Point2D> c) {

        boolean goOn = true;
        int i = start + 1;
        int n = end;

        if (start >= end) return;

        while (goOn) {
            while (c.compare(array[start], array[i]) != -1) {
                if (i == end) break;
                i++;
            }

            while (c.compare(array[start], array[n]) != 1) {
                if (n == start) break;
                n--;
            }


            if (i < n) {
                Point2D temp = array[i];
                array[i] = array[n];
                array[n] = temp;
                goOn = true;
            } else {
                Point2D temp = array[n];
                array[n] = array[start];
                array[start] = temp;
                goOn = false;
            }

        }
        sort2(array, start, n - 1, c);
        sort2(array, n + 1, end, c);
    }


}
@2afe558f944831d4381831b0dd4f2fd5@"
"r04525016","4","0.47","107744","@ba299f6c5a0c69295bc2f82a87be633a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * Created by cavitation on 2016/4/15.
 */
public class MyConvexHull {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double minDistance = Double.parseDouble(data);
            String data2 = br.readLine();
            int numPoint = Integer.parseInt(data2);
            Point2D[] cc = new Point2D[numPoint];


//            numPoint = 15;
//            Point2D[] cc = new Point2D[numPoint];
//            for(int i = 0 ; i < numPoint; i++){
//                cc[i] = new Point2D(Math.random(), Math.random());
//            }


            int i = 0;
            while (br.ready()) {
                String[] temp = br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                cc[i] = new Point2D(x, y);
//                cc[i] = new Point2D(Math.random(), Math.random());
                i++;
            }
            br.close();


            int[] father = new int[numPoint];
            for (int c = 0; c < numPoint; c++) {
                father[c] = c;
            }
            for (int j = 0; j < numPoint; j++) {
                for (int k = 0; k < numPoint; k++) {
                    if (cc[j].distanceTo(cc[k]) <= minDistance) {
                        int root1 = getRoot(father, j);
                        int root2 = getRoot(father, k);
                        if (root1 < root2) {
                            father[root2] = root1;
                        } else father[root1] = root2;
                    }
                }
            }

            int[] root = new int[father.length];
            for(int k = 0; k < numPoint; k ++) {
                int temp = getRoot(father, k);
                root[k] = temp;
            }


            int numC = 0;
            for (i = 0; i < numPoint; i++) {
                ArrayList<Integer> label = new ArrayList<>();
                for (int j = 0; j < numPoint; j++) {
                    if (father[j] == i) {
                        label.add(j);
                    }
                }
                Point2D[] label5 = new Point2D[label.size()];
                for (int k = 0; k < label.size(); k++) {
                    label5[k] = cc[label.get(k)];
                }
                if (label5.length > 2) {
                    int[] index2 = ConvexHullVertex(label5);
                    numC += index2.length;
                }
            }

            System.out.println(numC);



//            for (int e = 0; e < father.length; e++) {
//                System.out.print(father[e] + "" "");
//            }


//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.1, 1.1);
//            StdDraw.setYscale(-0.1, 1.1);
//            int counter = 0;
//            for (Point2D p : cc) {
//                StdDraw.setPenRadius(0.015);
//                p.draw();
//                StdDraw.setPenRadius(0.002);
//                StdDraw.circle(p.x(), p.y(), minDistance / 2);
//                StdDraw.text(p.x() + 0.03, p.y(), counter + ""("" + root[counter++] + "")"");
//            }
        }
    }

    public static int getRoot(int[] root, int index1) {

        while (index1 != root[index1]) index1 = root[index1];
        return index1;
    }

    public static int[] ConvexHullVertex(Point2D[] point2Ds) {
        ArrayList<Point2D> PG = new ArrayList<>();
        for (int i = 0; i < point2Ds.length; i++) {
            PG.add(point2Ds[i]);
        }


        int minIndex = getMin(point2Ds);
        Point2D min = point2Ds[minIndex];

        Comparator<Point2D> comparator = min.ATAN2_ORDER;
        sort(point2Ds, comparator);

        Stack<Point2D> data = new Stack<Point2D>();
        data.push(point2Ds[0]);
        data.push(point2Ds[1]);

        for (int i = 2; i < point2Ds.length; i++) {
            Point2D b = data.pop();
            Point2D c = data.pop();
            Point2D a = point2Ds[i];

            while (Point2D.ccw(c, b, a) != 1) {
                b = c;
                c = data.pop();
            }
            data.push(c);
            data.push(b);
            data.push(a);
        }


        int[] index = new int[data.size()];
        int count = 0;
        while (!data.isEmpty()) {
            Point2D p = data.pop();
            int i = PG.indexOf(p);
            index[count++] = i;
        }


        int[] index2 = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            index2[i] = index[index.length - 1 - i];
        }


        return index2;
    }


    public static int getMin(Point2D[] a) {
        double min = a[0].y();
        int minIndex = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i].y() < min) {
                min = a[i].y();
                minIndex = i;
            }
        }
        return minIndex;
    }

    public static void sort(Point2D[] array, Comparator<Point2D> c) {
        sort2(array, 0, array.length - 1, c);
    }

    public static void sort2(Point2D[] array, int start, int end, Comparator<Point2D> c) {

        boolean goOn = true;
        int i = start + 1;
        int n = end;

        if (start >= end) return;

        while (goOn) {
            while (c.compare(array[start], array[i]) != -1) {
                if (i == end) break;
                i++;
            }

            while (c.compare(array[start], array[n]) != 1) {
                if (n == start) break;
                n--;
            }


            if (i < n) {
                Point2D temp = array[i];
                array[i] = array[n];
                array[n] = temp;
                goOn = true;
            } else {
                Point2D temp = array[n];
                array[n] = array[start];
                array[start] = temp;
                goOn = false;
            }

        }
        sort2(array, start, n - 1, c);
        sort2(array, n + 1, end, c);
    }


}
@ba299f6c5a0c69295bc2f82a87be633a@"
"r04525016","5","0.096","106816","@508bdfbfc594d155dd2a2031725a39bc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * Created by cavitation on 2016/4/15.
 */
public class MyConvexHull {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double minDistance = Double.parseDouble(data);
            String data2 = br.readLine();
            int numPoint = Integer.parseInt(data2);
            Point2D[] cc = new Point2D[numPoint];


//            numPoint = 15;
//            Point2D[] cc = new Point2D[numPoint];
//            for(int i = 0 ; i < numPoint; i++){
//                cc[i] = new Point2D(Math.random(), Math.random());
//            }


            int i = 0;
            while (br.ready()) {
                String[] temp = br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                cc[i] = new Point2D(x, y);
//                cc[i] = new Point2D(Math.random(), Math.random());
                i++;
            }
            br.close();


            int[] father = new int[numPoint];
            for (int c = 0; c < numPoint; c++) {
                father[c] = c;
            }
            for (int j = 0; j < numPoint; j++) {
                for (int k = 0; k < numPoint; k++) {
                    if (cc[j].distanceTo(cc[k]) <= minDistance) {
                        int root1 = getRoot(father, j);
                        int root2 = getRoot(father, k);
                        if (root1 < root2) {
                            father[root2] = root1;
                        } else father[root1] = root2;
                    }
                }
            }

            int[] root = new int[father.length];
            for(int k = 0; k < numPoint; k ++) {
                int temp = getRoot(father, k);
                root[k] = temp;
            }


            int numC = 0;
            for (i = 0; i < numPoint; i++) {
                ArrayList<Integer> label = new ArrayList<>();
                for (int j = 0; j < numPoint; j++) {
                    if (root[j] == i) {
                        label.add(j);
                    }
                }
                Point2D[] label5 = new Point2D[label.size()];
                for (int k = 0; k < label.size(); k++) {
                    label5[k] = cc[label.get(k)];
                }
                if (label5.length > 2) {
                    int[] index2 = ConvexHullVertex(label5);
                    numC += index2.length;
                }
            }

            System.out.println(numC);



//            for (int e = 0; e < father.length; e++) {
//                System.out.print(father[e] + "" "");
//            }
//
//            System.out.println("" "");
//
//            for (int e = 0; e < father.length; e++) {
//                System.out.print(root[e] + "" "");
//            }
//
//            StdDraw.setCanvasSize(800, 800);
//            StdDraw.setXscale(-0.1, 1.1);
//            StdDraw.setYscale(-0.1, 1.1);
//            int counter = 0;
//            for (Point2D p : cc) {
//                StdDraw.setPenRadius(0.015);
//                p.draw();
//                StdDraw.setPenRadius(0.002);
//                StdDraw.circle(p.x(), p.y(), minDistance / 2);
//                StdDraw.text(p.x() + 0.03, p.y(), counter + ""("" + root[counter++] + "")"");
//            }
        }
    }

    public static int getRoot(int[] root, int index1) {

        while (index1 != root[index1]) index1 = root[index1];
        return index1;
    }

    public static int[] ConvexHullVertex(Point2D[] point2Ds) {
        ArrayList<Point2D> PG = new ArrayList<>();
        for (int i = 0; i < point2Ds.length; i++) {
            PG.add(point2Ds[i]);
        }


        int minIndex = getMin(point2Ds);
        Point2D min = point2Ds[minIndex];

        Comparator<Point2D> comparator = min.ATAN2_ORDER;
        sort(point2Ds, comparator);

        Stack<Point2D> data = new Stack<Point2D>();
        data.push(point2Ds[0]);
        data.push(point2Ds[1]);

        for (int i = 2; i < point2Ds.length; i++) {
            Point2D b = data.pop();
            Point2D c = data.pop();
            Point2D a = point2Ds[i];

            while (Point2D.ccw(c, b, a) != 1) {
                b = c;
                c = data.pop();
            }
            data.push(c);
            data.push(b);
            data.push(a);
        }


        int[] index = new int[data.size()];
        int count = 0;
        while (!data.isEmpty()) {
            Point2D p = data.pop();
            int i = PG.indexOf(p);
            index[count++] = i;
        }


        int[] index2 = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            index2[i] = index[index.length - 1 - i];
        }


        return index2;
    }


    public static int getMin(Point2D[] a) {
        double min = a[0].y();
        int minIndex = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i].y() < min) {
                min = a[i].y();
                minIndex = i;
            }
        }
        return minIndex;
    }

    public static void sort(Point2D[] array, Comparator<Point2D> c) {
        sort2(array, 0, array.length - 1, c);
    }

    public static void sort2(Point2D[] array, int start, int end, Comparator<Point2D> c) {

        boolean goOn = true;
        int i = start + 1;
        int n = end;

        if (start >= end) return;

        while (goOn) {
            while (c.compare(array[start], array[i]) != -1) {
                if (i == end) break;
                i++;
            }

            while (c.compare(array[start], array[n]) != 1) {
                if (n == start) break;
                n--;
            }


            if (i < n) {
                Point2D temp = array[i];
                array[i] = array[n];
                array[n] = temp;
                goOn = true;
            } else {
                Point2D temp = array[n];
                array[n] = array[start];
                array[start] = temp;
                goOn = false;
            }

        }
        sort2(array, start, n - 1, c);
        sort2(array, n + 1, end, c);
    }


}
@508bdfbfc594d155dd2a2031725a39bc@"
"r04921044","4","0.64","115824","@7b3bcc2fbfdd5fdad3385d97cd104205@
import java.util.ArrayList;
import java.util.Collections;

import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    private class PointWrapper {
        public PointWrapper(Point2D p, int i) {
            point = p;
            index = i;
        }

        public double angleTo(Point2D that) {
            double dx = that.x() - point.x();
            double dy = that.y() - point.y();
            return Math.atan2(dy, dx);
        }

        public Point2D point;
        public int index;
        public double theta;
    }

    public static int[] ConvexHullVertex(Point2D[] list) {
        ArrayList<PointWrapper> points = new ArrayList<> ();
        for (int i=0; i<list.length; ++i) {
            MyConvexHull fuckingJAVAsyntax = new MyConvexHull();
            MyConvexHull.PointWrapper point = fuckingJAVAsyntax.new PointWrapper(list[i], i);
            points.add(point);
        }

        // find min
        PointWrapper minYPoint = points.get(0);
        for (int i=0; i<points.size(); ++i) {
            double pointY = points.get(i).point.y();
            if (pointY < minYPoint.point.y()) {
                minYPoint = points.get(i);
            }
        }

        // compute theta
        for (int i=0; i<points.size(); ++i) {
            points.get(i).theta = minYPoint.angleTo(points.get(i).point);
        }

        // sort with theta
        Collections.sort(points, (o1, o2) -> Double.valueOf(o1.theta).compareTo(Double.valueOf(o2.theta)));

        // get convex hull indices
        ArrayList<PointWrapper> resultPoint = new ArrayList<> ();
        resultPoint.add(points.get(0));
        resultPoint.add(points.get(1));
        Point2D lineStartPoint = points.get(0).point;
        Point2D lineEndPoint = points.get(1).point;
        for (int i=2; i<points.size(); ++i) {
            PointWrapper pointWrapper = points.get(i);

            while (Point2D.ccw(lineStartPoint, lineEndPoint, pointWrapper.point) == -1) { // clock-wise
                resultPoint.remove(resultPoint.size() - 1);
                lineEndPoint = lineStartPoint;
                lineStartPoint = resultPoint.get(resultPoint.size() - 2).point;
            }

            lineStartPoint = lineEndPoint;
            lineEndPoint = pointWrapper.point;
            resultPoint.add(pointWrapper);
        }

        // return original indices
        int result[] = new int[resultPoint.size()];
        int i = 0;
        for(PointWrapper wrapper : resultPoint) {
            result[i++] = wrapper.index;
        }
        return result;
    }

    public static void main(String[] args) throws Exception {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it

        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        double distance = Double.parseDouble(buffer.readLine());
        int pointCount = Integer.parseInt(buffer.readLine()); // no use

        ArrayList<ArrayList<Point2D>> CCs = new ArrayList<ArrayList<Point2D>> ();

        String line;
        while ((line = buffer.readLine()) != null) {
            String[] coord = line.split("" "");
            Point2D newPoint = new Point2D(Double.parseDouble(coord[0]), Double.parseDouble(coord[1]));

            boolean inAnyCC = false;
            for (ArrayList<Point2D> CC : CCs) {
                for (Point2D point : CC) {
                    if (point.distanceTo(newPoint) <= distance) {
                        CC.add(newPoint);
                        inAnyCC = true;
                        break;
                    }
                }

                if (inAnyCC) {
                    break;
                }
            }

            if (!inAnyCC) {
                ArrayList<Point2D> CC = new ArrayList<> ();
                CC.add(newPoint);
                CCs.add(CC);
            }
        }

        int count = 0;
        for (ArrayList<Point2D> CC : CCs) {
            if (CC.size() >= 3) {
                Point2D[] points = new Point2D[CC.size()];
                points = CC.toArray(points);
                count += MyConvexHull.ConvexHullVertex(points).length;
            }
        }

        System.out.println(count);
    }
}

@7b3bcc2fbfdd5fdad3385d97cd104205@"
"b03611015","0","0","0","@f298708d7df6d86ea20bb31f800116b8@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
                if(i==N-1&&size>=3)
                    CCnumber[k]=a[i];
                    k++;
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }

//            System.out.print(UF.count());
            System.out.print(leng);

        }
    }
}


@f298708d7df6d86ea20bb31f800116b8@"
"b03611015","5","0.098","107696","@3e35273c2daa41bf4b1a539c1032f3e1@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 *
 * @author Steven
 */
public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        Stack<Point2D> hull = new Stack<>();

        int N = a.length;
        Point2D[] d = new Point2D[N];

        for (int i = 0; i < N; i++) {
            d[i] = a[i];
        }

        Arrays.sort(a, Point2D.Y_ORDER);
        Arrays.sort(a, a[0].POLAR_ORDER);
        hull.push(a[0]);
        hull.push(a[1]);

        for (int i = 2; i < N; i++) {
            Point2D top = hull.pop();
            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
                top = hull.pop();
            }
            hull.push(top);
            hull.push(a[i]);
        }
        int m = hull.size();
        Point2D[] b = new Point2D[m];
        for (int i = 0; i < m; i++) {
            b[i] = hull.pop();
        }
        int[] c = new int[m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < N; j++) {
                if (b[i] == d[j]) {
                    c[i] = j;
                }
            }
        }
        Arrays.sort(c);
        return c;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws IOException {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            double distance = Double.parseDouble(data);

            data = br.readLine();
            int N = Integer.parseInt(data);

            Point2D[] datapoint = new Point2D[N];
            int[] id = new int[N];
            WeightedQuickUnionUF UF = new WeightedQuickUnionUF(N);

            for (int i = 0; i < N; i++) {
                data = br.readLine();
                String[] position = new String[2];
                position = data.split("" "");
                datapoint[i] = new Point2D(Double.parseDouble(position[0]), Double.parseDouble(position[1]));

            }

            for (int i = 0; i < N; i++) {
                for (int j = i; j < N; j++) {
                    if (datapoint[i].distanceTo(datapoint[j]) <= distance) {
                        UF.union(i, j);
                    }
                }
            }

            int[] CC = new int[UF.count()];

            int[] a = new int[N];
            for (int i = 0; i < N; i++) {
                a[i] = UF.find(i);
            }

            Arrays.sort(a);
            CC[0] = a[0];

            int[] CCnumber = new int[UF.count()];
            int k = 0;
            int n = 0;
            int size = 1;

            for (int i = 1; i < N; i++) {
                if (a[i] == CC[n]) {
                    size++;

                }
                if (a[i] > a[i - 1]) {
                    if (size >= 3) {
                        CCnumber[k] = a[i - 1];
                        k++;
                    }
                    size = 1;
                    n++;
                    CC[n] = a[i];
                }
                if(i==N-1&&size>=3){
                    CCnumber[k]=a[i];
                    k++;
                }
            }

            int leng = 0;

            for (int i = 0; i < k; i++) {

                int count = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        count++;
                    }
                }

                Point2D[] convex = new Point2D[count];

                int num = 0;
                for (int j = 0; j < N; j++) {
                    if (CCnumber[i] == UF.find(j)) {
                        convex[num] = datapoint[j];
                        num++;
                    }
                }
                int[] b = ConvexHullVertex(convex);
                leng += b.length;
            }

//            System.out.print(UF.count());
            System.out.print(leng);

        }
    }
}


@3e35273c2daa41bf4b1a539c1032f3e1@"
"r04631006","4","0.38","106688","@501ce842fdf525c80eb6569c76cc9a6c@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }
  
        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }
        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[10 + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) != 1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }    
        int lorder[] = new int[m];
        for (int i = 0; i < m; i++) {
            lorder[i] = fir_order[i];
        }
        return lorder;
    }

    public static void main(String[] args) throws Exception {
try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String Distance = br.readLine();
            double Dis = Double.parseDouble(Distance);
            String Number = br.readLine();
            int Num = Integer.parseInt(Number);
            double point[][] = new double[Num][2];
            Point2D[] poi = new Point2D[Num];
            for (int i = 0; i < Num; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                point[i][0] = x;
                point[i][1] = y;
                poi[i] = new Point2D(x, y);
            }

            int[] cc = new int[Num];
            QuickFindUF qf = new QuickFindUF(Num);
            for (int i = 0; i < Num; i++) {
                for (int j = 0; j < Num; j++) {
                    if (poi[i].distanceTo(poi[j]) <= Dis) {
                        qf.union(j, i);
                    }
                }
            }
            int mm = 0;
            int outt = 0;
            for (int i = 0; i < Num; i++) {
                for (int j = i; j < Num; j++) {
                    if (qf.find(i) == i && qf.connected(i, j)) {
                        cc[i] = cc[i] + 1;
                    }
                }
                if (cc[i] >= 3) {
                    Point2D[] CCpoi = new Point2D[cc[i]];
                    for (int k = 0; k < Num; k++) {
                        if (qf.find(k) == i) {
                            CCpoi[mm] = new Point2D(poi[k].x(), poi[k].y());
                            mm = mm + 1;
                        }
                    }
                    int ooooo[] = ConvexHullVertex(CCpoi);
                    outt = outt + ooooo.length;

                    mm = 0;
                }
            }
            System.out.printf(""%d "", outt);
}
}
}

@501ce842fdf525c80eb6569c76cc9a6c@"
"b03704074","5","0.126","112208","@2a51758a2f1f177a84bba8630839f86d@
import java.awt.Color;
import java.io.FileReader;
import java.io.BufferedReader;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        
        Point2D[] OLD = new Point2D[a.length];//留住舊的編號
        for(int i = 0;i<a.length;i++){
        OLD[i] = a[i];}
        double min = a[0].y();
        int flag = 0;
        for(int i =0;i<a.length;i++){
            if(a[i].y()<min){
                min = a[i].y();
                flag = i; }}
        Point2D swap;
        swap = a[0];
        a[0] = a[flag];
        a[flag] = swap;
        //System.out.println(""X座標為""+a[0].x()+""Y座標為""+a[0].y());
        for(int i = 1;i<a.length;i++){//i是後面的數  //j是前面的數    //x越大越右邊，所以j的x要大於i的x
            for(int j = i;j >1;j--){        
                if(a[j].x()>a[j-1].x()){
                    swap = a[j];
                    a[j] = a[j-1];
                    a[j-1] = swap;}
                if(a[j].y()==a[j-1].y() && a[j].y() == a[0].y()){
                    if(a[j].x()<a[j-1].x() && a[j].x()>0 && a[j-1].x()>0){
                         swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;}
                    else if(a[j].x()<a[j-1].x() && a[j].x()<0 && a[j-1].x()<0){
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;} }
                if (a[j].x()==a[j-1].x() && a[j].x() == a[0].x()){
                    if(a[j].y()>a[j-1].y() && j+1 == a.length){ 
                        swap = a[j];
                        a[j] = a[j-1];
                        a[j-1] = swap;
                        
                }}
                if(a[j].x()>=a[0].x() && a[j-1].x()>=a[0].x()){ 
                    if(((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))>((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))){
                        swap = a[j-1];
                        a[j-1] = a[j];
                        a[j] = swap;} }
                else if(a[j].x()<a[0].x() && a[j-1].x()<a[0].x()){
                    if(((a[j].y()-a[0].y())/(a[j].x()-a[0].x()))<((a[j-1].y()-a[0].y())/(a[j-1].x()-a[0].x()))){
                    swap = a[j-1];
                    a[j-1] = a[j];
                    a[j] = swap;}}}}
        for(int i =0;i<a.length;i++){
            //System.out.println(""X座標為""+a[i].x()+""Y座標為""+a[i].y());
        }
        int first = 0;
        int middle = 1;
        int last = 2;
        while(last<a.length){
            //System.out.println(""first=""+first+""middle=""+middle+""last=""+last);
            if(((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))>0){
               if(last+1==a.length && ((a[last].x()-a[middle].x())*(a[0].y()-a[middle].y())-(a[last].y()-a[middle].y())*(a[0].x()-a[middle].x()))==0){
                a[last] = null;break;}
                first = middle;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}}
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))==0 ){
                //System.out.println(""扣直線的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = last;
                while(true){
                    if(last+1==a.length){last++;break;}
                    else if(a[last+1]!=null){last++;break;}
                    else//a[++last]==null
                    {if(last+2==a.length){last = last+2;break;}
                    else{last = last+2;
                         if(a[last]!=null)break;}}}
            }
            
            else if (((a[middle].x()-a[first].x())*(a[last].y()-a[first].y())-(a[middle].y()-a[first].y())*(a[last].x()-a[first].x()))<0){
                //System.out.println(""扣順時針的中間""+""first=""+first+""middle=""+middle+""last=""+last);
                a[middle] = null;
                middle = first;
                //last remain the same
                while(true){
                    
                    if(a[first-1]!=null){first--;break;}//first往前一個，最多到零因為A[0]不會是空的
                    else//a[--first]==null
                    {first = first-2;
                    if(a[first]!=null)break;}}}}
        int[] indexnew = new int[a.length];
        int j = 0;
        for(int i = 0;i<a.length;i++){
            if(a[i]!=null){
                indexnew[j] = i;
                j++; }}
        int jmax = j;
        int[] indexold = new int[jmax];
        int h =0;
        for(j = 0;j < jmax;j++){
            for(int k = 0;k<a.length;k++){
                if(a[indexnew[j]]==OLD[k]){
                    indexold[h] = k;h++;}}}
        for(int i = 1;i<jmax;i++){
            for(j = i;j>0;j--){
                if(indexold[j]<indexold[j-1]){
                    int swap2;
                    swap2 = indexold[j];
                    indexold[j] = indexold[j-1];
                    indexold[j-1] = swap2;}}}
        
        //StdRandom.setSeed(3);
        /*for(h = 0;h<indexold.length;h++){
            System.out.println(indexold[h]);
        }*/
        
        return indexold;
}
    public static void main(String[] args)throws Exception {
        /*FileReader FileStream = new FileReader(""data.in.txt"");
        BufferedReader br = new BufferedReader(FileStream);*/
        In br = new In(args[0]);
        String data = br.readLine();//讀取第一行
        double d = Double.parseDouble(data);//第一行轉成d
        //System.out.println(""d=""+d);
        data = br.readLine();//讀取第二行
        int N = Integer.parseInt(data);//第二行轉成N(個數)
        //System.out.println(""N=""+N);
        Point2D[] A = new Point2D[N];
        for(int i = 0;i < N;i++){
            String[] datas = br.readLine().split("" "");
            
            double a = Double.parseDouble(datas[0]);
            double b = Double.parseDouble(datas[1]);
            //System.out.println(""a = ""+a+""   b = ""+b);
            A[i] = new Point2D(a,b);}
        int count = 0;
        back:
        while(true){
            Point2D[] B = new Point2D[N];//每次重新計算都開一個新的point
            int h = 1;//h是B的位置
            for(int i = 0;i < N;i++){ // 找出新的CC的第一個值
                if(A[i]!=null){
                    B[0] = A[i];//System.out.println(""B[0]=""+B[0]);
                    break;}
                else if (i == N-1 )break back;}
            int flag = 0;
            while(flag == 0){flag = 1;
            for(int i = 0;i < N;i++){
                if(B[i] == null)break;
                for(int j = 0;j <N;j++){
                    if(A[j] == null )continue;
                    else if(Math.pow((B[i].x()-A[j].x()),2)+Math.pow((B[i].y()-A[j].y()), 2)==0) A[j] = null;
                    else if(Math.pow((B[i].x()-A[j].x()),2)+Math.pow((B[i].y()-A[j].y()), 2)<=d*d){
                        flag = 0;
                        B[h] = A[j];
                        A[j] = null;//System.out.println(""i =""+i+""j =""+j+""h = ""+h);
                        h++;}
                    continue;}}}
            int lengthmax = B.length;
            for(int i = 0;i < B.length;i++){
                //System.out.println(""B[""+i+""]=""+B[i]);
                if(B[i]==null){
                    lengthmax = i;break;}}
            Point2D[] C = new Point2D[lengthmax];
            for(int i = 0;i < lengthmax;i++){
                C[i] = B[i];
            }
            
            
            int[] plus = ConvexHullVertex(C);
           //System.out.println(""pluslength=""+plus.length);
            
            if(plus.length>=3){
            count = count + plus.length;
            //System.out.println(""count=""+count);
            }}

        System.out.println(count);
}
}
@2a51758a2f1f177a84bba8630839f86d@"
"b01705003","1","0.44","105120","@f7fec3f6161acc7c25b40e295a506e96@
public class MyConvexHull{

    public static void main(String[] args) {
        System.out.println(""7"");
    }

}
@f7fec3f6161acc7c25b40e295a506e96@"
"b01705003","0","0.45","100928","@f27810b33c11c7072747cf26fdc24cb9@
public class MyConvexHull{

    public static void main(String[] args) {
        System.out.println(""12"");
    }

}
@f27810b33c11c7072747cf26fdc24cb9@"
"b01705003","2","0.45","105136","@832ac34458b739df03b0090dcd95bd42@
public class MyConvexHull{

    public static void main(String[] args) {
        System.out.println(""0"");
    }

}
@832ac34458b739df03b0090dcd95bd42@"
"b03106003","4","0.39","108256","@26194b1824b0df10734a99ef5b95b839@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            //System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        for(int i = 0; i<m ;i++){
            //System.out.println(r[i]);
        }

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        //int pr[] = ConvexHullVertex(point);
        QuickUnionUF uf = new QuickUnionUF(N);
        //for(int i = 0 ; i< pr.length ; i++){
                //System.out.print(pr[i]+ "" "");
                //System.out.print(point[pr[i]] + "" "");
                
        //}
        
        for(int i = 0; i<N ;i++){
            for(int j = 0 ; j<N;j++){
                if(point[i].distanceTo(point[j]) <= d){
                    uf.union(i, j);
                }            
            }
        }
        //System.out.print(uf.count());
        Stack<Integer>[] st;
        st = new Stack [N];
        for(int i = 0; i<N ; i++){
            st[i] = new Stack<Integer>();
        }
        for(int i = 0; i<N ; i++){
            st[uf.find(i)].push(i);
        }
        int howmany;
        int sum = 0;
        Point2D out[];
        for(int i = 0; i<st.length;i++){
            if(!st[i].isEmpty()){
                howmany = st[i].size();
                //System.out.print(howmany);
                if(howmany > 3){
                    out = new Point2D[howmany];
                    for(int j = 0 ; j< howmany ; j++){
                        out[j] = point[st[i].pop()];
                        //System.out.print(out[j].x());
                        //System.out.println(out[j].y());
                    }
                    
                    sum = sum + ConvexHullVertex(out).length;
                    //System.out.print(sum);
                }else if(howmany == 3){
                    sum = sum + 3;
                }
            }
        }
        System.out.print(sum);
    }
}

@26194b1824b0df10734a99ef5b95b839@"
"r04631023","5","0.098","107664","@7e14da44ee8ff48566fbd3e4b24c1822@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {
    private static double AngleTo(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.atan2(dy, dx);
    }
    private static double Distance(Point2D a, Point2D b) {
        double dx = a.x() - b.x();
        double dy = a.y() - b.y();
        return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) ;
    }
    

    public static int[] ConvexHullVertex(Point2D[] a) {
        double min = a[0].y();
        double[] angle = new double[a.length] ;
        double[] angleSort = new double[a.length] ;
        int[] indexSort = new int[a.length] ;
        int[] indexNum = new int[a.length] ;
        Stack<Integer> convexHull = new Stack<Integer>();
        int index = 0 ;
        
        for (int i = 0 ; i < a.length ; i++){
            if (a[i].y() < min){
                min = a[i].y() ;
                index = i ;
            }
        }
        for (int i = 0; i < a.length ; i++){
            angle[i] = 180+AngleTo(a[index], a[i])* 180/Math.PI ;
            if (angle[i] == 360){
                angle[i] = 0 ;
            }
            angleSort[i] = angle[i] ;
        }
        Arrays.sort(angleSort);
        for (int i = 0; i < a.length ; i++){
            indexSort[i] = Arrays.binarySearch(angleSort, angle[i]) ;
            indexNum[indexSort[i]] = i ;
        }
        
        convexHull.push(index);
        convexHull.push(indexNum[0]);
        int count = 1 ;
        while (count != a.length){
            int sec = convexHull.pop() ;
            int first = convexHull.pop() ;
            if (Point2D.ccw(a[first], a[sec], a[indexNum[count]]) == 1){
                convexHull.push(first);
                convexHull.push(sec);
                convexHull.push(indexNum[count]);
                count++ ;
            }
            else{
                convexHull.push(first);
            }
        }
        
        int[] answer = new int[convexHull.size()-1] ;
        count = 0 ;
        for (int i = 0; i < answer.length; i++){
            answer[i] = convexHull.pop() ;
        }
        /*
        while(!convexHull.isEmpty()){
            System.out.println(convexHull.pop());
        }
        
        //draw
        for (int i = 0; i < a.length; i++) {
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            StdDraw.text(a[i].x(), a[i].y()+0.03, String.valueOf(indexSort[i]));
        }
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(a[index].x(), a[index].y(), 0.01) ;
        while(!convexHull.isEmpty()){
            int x = convexHull.pop() ;
            StdDraw.filledCircle(a[x].x(), a[x].y(), 0.01) ;
        }
        */
        if (answer.length < 3){
            int[] empty = new int[0] ;
            return empty ;
        }else{
            return answer ;
        }
    }
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            double Dis = Double.parseDouble(data);
            
            String Num = br.readLine();
            int N = Integer.parseInt(Num);
            
            int count = 0 ;
            int sumNum = 0 ;
            int[] groupNum = new int[N] ;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
            Point2D[] a = new Point2D[N];
            String[] Loc;
            for (int i = 0; i < N; i++) {
                Loc = br.readLine().split("" "");
                a[i] = new Point2D(Double.parseDouble(Loc[0]), Double.parseDouble(Loc[1]));
                for (int j = i-1; j >= 0; j--){
                    if (a[i].distanceTo(a[j]) <= Dis){
                        if (!uf.connected(i, j)){
                            uf.union(i, j);
                        }
                    }
                }
            }
            
            for (int i = 0; i < N; i++){
                groupNum[uf.find(i)] =  groupNum[uf.find(i)] + 1 ;
            }
            
            for (int i = 0; i < N; i++){
                if (groupNum[i] > 3){
                    Point2D[] group = new Point2D[groupNum[i]];
                    count = 0 ;
                    for (int j = 0 ; j < N; j++){
                        if (uf.find(j) == i){
                            group[count] = new Point2D(a[j].x(), a[j].y());
                            count++ ;
                            if (count == groupNum[i]){
                                break ;
                            }
                        }
                    }
                    int[] convexIndex = ConvexHullVertex(group) ;
                    sumNum = sumNum + convexIndex.length ;
                }
                if (groupNum[i] == 3){
                    sumNum = sumNum + 3 ;
                }
            }
            System.out.println(sumNum) ;
            /*
            int[] convexIndex = ConvexHullVertex(a) ;
            for (int i = 0; i < convexIndex.length; i++){
                System.out.println(convexIndex[i]) ;
            }
            */
        }
    }
}
@7e14da44ee8ff48566fbd3e4b24c1822@"
"b03106003","4","0.39","107648","@03d96279a0b1857a443c421ee7555743@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            //System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        for(int i = 0; i<m ;i++){
            //System.out.println(r[i]);
        }

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        //int pr[] = ConvexHullVertex(point);
        QuickUnionUF uf = new QuickUnionUF(N);
        //for(int i = 0 ; i< pr.length ; i++){
                //System.out.print(pr[i]+ "" "");
                //System.out.print(point[pr[i]] + "" "");
                
        //}
        
        for(int i = 0; i<N ;i++){
            for(int j = (i+1) ; j<N;j++){
                if(point[i].distanceTo(point[j]) <= d){
                    uf.union(i, j);
                }            
            }
        }
        //System.out.print(uf.count());
        Stack<Integer>[] st;
        st = new Stack [N];
        for(int i = 0; i<N ; i++){
            st[i] = new Stack<Integer>();
        }
        for(int i = 0; i<N ; i++){
            st[uf.find(i)].push(i);
        }
        int howmany;
        int sum = 0;
        Point2D out[];
        for(int i = 0; i< st.length ;i++){
            if(!st[i].isEmpty()){
                howmany = st[i].size();
                //System.out.print(howmany);
                if(howmany > 3){
                    out = new Point2D[howmany];
                    for(int j = 0 ; j< howmany ; j++){
                        out[j] = point[st[i].pop()];
                        //System.out.print(out[j].x());
                        //System.out.println(out[j].y());
                    }
                    
                    sum = sum + ConvexHullVertex(out).length;
                    //System.out.print(sum);
                }else if(howmany == 3){
                    sum = sum + 3;
                }
            }
        }
        System.out.print(sum);
    }
}
@03d96279a0b1857a443c421ee7555743@"
"r04631006","2","0.39","106000","@1ed6075f62001efc4a444b6e8fca905c@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }

        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
     
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String Distance = br.readLine();
            double Dis = Double.parseDouble(Distance);
            String Number = br.readLine();
            int Num = Integer.parseInt(Number);
            double point[][] = new double[Num][2];
            Point2D[] poi = new Point2D[Num];
            for (int i = 0; i < Num; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                point[i][0] = x;
                point[i][1] = y;
                poi[i] = new Point2D(x, y);
            }

            int[] cc = new int[Num];
            QuickFindUF qf = new QuickFindUF(Num);
            for (int i = 0; i < Num; i++) {
                for (int j = 0; j < Num; j++) {
                    if (poi[i].distanceTo(poi[j]) <= Dis) {
                        qf.union(j, i);
                    }
                }
            }

            int mm = 0;
            int outt = 0;
            for (int i = 0; i < Num; i++) {
                for (int j = i; j < Num; j++) {
                    if (qf.find(i) == i && qf.connected(i, j)) {
                        cc[i] = cc[i] + 1;
                    }
                }

                if (cc[i] >= 3) {
                    Point2D[] CCpoi = new Point2D[cc[i]];
                    for (int k = 0; k < Num; k++) {
                        if (qf.find(k) == i) {
                            CCpoi[mm] = new Point2D(poi[k].x(), poi[k].y());
                            mm = mm + 1;
                        }
                    }
                    int ooooo[] = ConvexHullVertex(CCpoi);
                    for (int h = 0; h < ooooo.length; h++) {
                        System.out.printf(""%d "", ooooo[h]);
                    }

                    outt = outt + ooooo.length;
                    mm = 0;
                }
            }
            System.out.printf(""%d "", outt);
}
}
}
@1ed6075f62001efc4a444b6e8fca905c@"
"r04631006","0","0.38","107696","@25abb664df074fc8ec6582bb64ce6700@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }

        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
     
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String Distance = br.readLine();
            double Dis = Double.parseDouble(Distance);
            String Number = br.readLine();
            int Num = Integer.parseInt(Number);
            double point[][] = new double[Num][2];
            Point2D[] poi = new Point2D[Num];
            for (int i = 0; i < Num; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                point[i][0] = x;
                point[i][1] = y;
                poi[i] = new Point2D(x, y);
            }

            int[] cc = new int[Num];
            QuickFindUF qf = new QuickFindUF(Num);
            for (int i = 0; i < Num; i++) {
                for (int j = 0; j < Num; j++) {
                    if (poi[i].distanceTo(poi[j]) <= Dis) {
                        qf.union(j, i);
                    }
                }
            }

            int mm = 0;
            int outt = 0;
            for (int i = 0; i < Num; i++) {
                for (int j = i; j < Num; j++) {
                    if (qf.find(i) == i && qf.connected(i, j)) {
                        cc[i] = cc[i] + 1;
                    }
                }

                if (cc[i] >= 3) {
                    Point2D[] CCpoi = new Point2D[cc[i]];
                    for (int k = 0; k < Num; k++) {
                        if (qf.find(k) == i) {
                            CCpoi[mm] = new Point2D(poi[k].x(), poi[k].y());
                            mm = mm + 1;
                        }
                    }
                    int ooooo[] = ConvexHullVertex(CCpoi);
                    outt = outt + ooooo.length;
                    mm = 0;
                }
            }
}
}
}
@25abb664df074fc8ec6582bb64ce6700@"
"b03106003","5","0.1","106096","@4b141cde3dd8199db5fb5e84b1215c27@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Sophia
 */
class CompareAngle implements Comparator{
    MyPoint start;
    CompareAngle(MyPoint start){this.start = start;}
    @Override
    public int compare(Object o1, Object o2) {
        MyPoint p1=(MyPoint) o1;
        MyPoint p2=(MyPoint) o2;
        if(MyConvexHull.compare_angle(start.p, p1.p, p2.p)){
            System.out.print(p1.index);
            System.out.print(""change whith"");
            System.out.println(p2.index);
            return 1;
        }
        else{
            System.out.print(p1.index);
            System.out.print(""didn't change whith"");
            System.out.println(p2.index);
            return -1;
        } 
    }
}

 class MyPoint implements Comparator{
    public Point2D p;
    public int index;
    
    
    
    MyPoint(){}
    
    MyPoint(int index, Point2D p){this.index = index; this.p = p;}

    @Override
    public int compare(Object o1, Object o2) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
    public int compareto(MyPoint o1) {
        if(this.index > o1.index){
            return 1;
        }else{
            return -1;
        }
    }
    public final Comparator<MyPoint> ATAN2_ORDER = new Atan2Order();
    private double angleTo(MyPoint that) {
        double dx = that.p.x() - this.p.x();
        double dy = that.p.y() - this.p.y();
        return Math.atan2(dy, dx);
    }
    
    private class Atan2Order implements Comparator<MyPoint> {
        public int compare(MyPoint q1, MyPoint q2) {
            double angle1 = angleTo(q1);
            double angle2 = angleTo(q2);
            if      (angle1 < angle2) return -1;
            else if (angle1 > angle2) return +1;
            else                      return  0;
        }
    }
    
}

public class MyConvexHull {
    static public double cross(Point2D o, Point2D a, Point2D b)
{   // >0
    return (a.x() - o.x()) * (b.y() - o.y()) - (a.y() - o.y()) * (b.x() - o.x());
}
    static boolean compare_position(Point2D a, Point2D b)
{
    return (a.y() < b.y()) || (a.y() == b.y() && a.x() > b.x());
}
    static boolean compare_angle(Point2D o,Point2D a, Point2D b)
{
    int c = (int) cross(o, a, b);
    return (c > 0) || (c == 0 && o.distanceTo(a) < o.distanceTo(b));
}


    
    public static int[] ConvexHullVertex(Point2D[] a){
        Stack<Integer> s = new Stack<Integer>();
        int start = 0;
        MyPoint mypoint[] = new MyPoint[a.length];
        for(int i = 0; i < a.length; i++){
            mypoint[i] = new MyPoint (i , a[i]);
            if(compare_position(a[i],a[start])){
                start = i;
            }     
        }
        //System.out.print(start);
        MyPoint temp;
        temp = mypoint[start];
        mypoint[start] = mypoint[0];
        mypoint[0] = temp;
        //System.out.print(mypoint[0].index);
        //Point2D[] b = Arrays.copyOf(a,a.length);
        Arrays.sort(mypoint, mypoint[0].ATAN2_ORDER);
        /*
        for(int i = 0 ; i < mypoint.length; i++){
                System.out.print(mypoint[i].index);
        }
        */
        int m = 0;
        int k = 0;
        MyPoint answer[] = new MyPoint[a.length+1];
        
        answer[0] = mypoint[0];
        for (int i=0; i <= mypoint.length; i++) {
            k = i;
            if(k == mypoint.length){k = 0;}
            while (m >= 2 && cross(answer[m-2].p, answer[m-1].p, mypoint[k].p) < 0){m--;}
            //System.out.print(m);
            answer[m++] = mypoint[k];
        }    
         m--;
         if(m<3){m = 3;}
        int r[] = new int[m];
        for(int i = 0; i<m ;i++){
            //System.out.print(answer[i].index);
            r[i] = answer[i].index;
        }
        Arrays.sort(r);
        for(int i = 0; i<m ;i++){
            //System.out.println(r[i]);
        }

        return r;
    }
    
    public static void main(String[] args) throws FileNotFoundException, IOException{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        String buffer[];
        double d = Double.parseDouble(strNum = br.readLine());
        double x;
        double y;
        int N = Integer.valueOf(strNum = br.readLine());
        Point2D point[] = new Point2D[N];
        for(int i = 0; i < N; i++){
            strNum = br.readLine();
            buffer = strNum.split("" "");
            x = Double.parseDouble(buffer[0]);
            y = Double.parseDouble(buffer[1]);
            point[i] = new Point2D(x, y);    
        }
        //int pr[] = ConvexHullVertex(point);
        QuickUnionUF uf = new QuickUnionUF(N);
        //for(int i = 0 ; i< pr.length ; i++){
                //System.out.print(pr[i]+ "" "");
                //System.out.print(point[pr[i]] + "" "");
                
        //}
        
        for(int i = 0; i<N ;i++){
            for(int j = (i+1) ; j<N;j++){
                if(point[i].distanceTo(point[j]) <= d){
                    uf.union(i, j);
                }            
            }
        }
        //System.out.print(uf.count());
        Stack<Integer>[] st;
        st = new Stack [N];
        for(int i = 0; i<N ; i++){
            st[i] = new Stack<Integer>();
        }
        for(int i = 0; i<N ; i++){
            st[uf.find(i)].push(i);
        }
        int howmany;
        int sum = 0;
        Point2D out[];
        for(int i = 0; i< st.length ;i++){
            if(!st[i].isEmpty()){
                howmany = st[i].size();
                //System.out.print(howmany);
                if(howmany > 3){
                    out = new Point2D[howmany];
                    for(int j = 0 ; j< howmany ; j++){
                        out[j] = point[st[i].pop()];
                        //System.out.print(out[j].x());
                        //System.out.println(out[j].y());
                    }
                    
                    sum = sum + ConvexHullVertex(out).length;
                    //System.out.print(sum);
                }else if(howmany == 3){
                    sum = sum + 3;
                }
            }
        }
        System.out.print(sum);
    }
}
@4b141cde3dd8199db5fb5e84b1215c27@"
"r04631006","4","0.39","108080","@428cc4b2a2679c627d0cdc8f85a4a723@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int zero = 0;
        int zeroaa = 0;
        int zerobb = 0;
        int L = a.length;
        double mmaa = a[0].y();
        double mmbb = a[0].x();
        double ang[] = new double[L];
        int order[] = new int[L];
        double ang_order[] = new double[L];

        for (int i = 0; i < L; i++) {
            if (a[i].y() < mmaa) {
                zero = i;
                mmaa = a[i].y();
            }
        }

        for (int i = 0; i < L; i++) {
            double dx = a[i].x() - a[zero].x();
            double dy = a[i].y() - a[zero].y();
            ang[i] = Math.atan2(dy, dx);
            ang_order[i] = ang[i];
        }

        Arrays.sort(ang_order);
        for (int i = 0; i < L; i++) {
            for (int j = 0; j < L; j++) {
                if (ang[j] == ang_order[i]) {
                    order[i] = j;
                }
            }
        }

        int m = 2;
        Point2D[] ch = new Point2D[L + 1];
        ch[0] = new Point2D(a[order[0]].x(), a[order[0]].y());
        ch[1] = new Point2D(a[order[1]].x(), a[order[1]].y());
        int fir_order[] = new int[L + 1];
        fir_order[0] = order[0];
        fir_order[1] = order[1];
        for (int i = 2; i < L; i++) {
            while (m >= 2 && Point2D.ccw(ch[m - 2], ch[m - 1], a[order[i]]) == -1) {
                m--;
            }
            ch[m] = new Point2D(a[order[i]].x(), a[order[i]].y());
            fir_order[m] = order[i];
            m++;

        }
     
        int lorder[] = new int[m];
        System.arraycopy(fir_order, 0, lorder, 0, m);
        Arrays.sort(lorder);
        return lorder;
    }

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String Distance = br.readLine();
            double Dis = Double.parseDouble(Distance);
            String Number = br.readLine();
            int Num = Integer.parseInt(Number);
            double point[][] = new double[Num][2];
            Point2D[] poi = new Point2D[Num];
            for (int i = 0; i < Num; i++) {
                String[] data = br.readLine().split("" "");
                double x = Double.parseDouble(data[0]);
                double y = Double.parseDouble(data[1]);
                point[i][0] = x;
                point[i][1] = y;
                poi[i] = new Point2D(x, y);
            }

            int[] cc = new int[Num];
            QuickFindUF qf = new QuickFindUF(Num);
            for (int i = 0; i < Num; i++) {
                for (int j = 0; j < Num; j++) {
                    if (poi[i].distanceTo(poi[j]) <= Dis) {
                        qf.union(j, i);
                    }
                }
            }

            int mm = 0;
            int outt = 0;
            for (int i = 0; i < Num; i++) {
                for (int j = i; j < Num; j++) {
                    if (qf.find(i) == i && qf.connected(i, j)) {
                        cc[i] = cc[i] + 1;
                    }
                }

                if (cc[i] >= 3) {
                    Point2D[] CCpoi = new Point2D[cc[i]];
                    for (int k = 0; k < Num; k++) {
                        if (qf.find(k) == i) {
                            CCpoi[mm] = new Point2D(poi[k].x(), poi[k].y());
                            mm = mm + 1;
                        }
                    }
                    int ooooo[] = ConvexHullVertex(CCpoi);
                    outt = outt + ooooo.length;
                    mm = 0;
                }
            }
            System.out.printf(""%d "", outt);
}
}
}

@428cc4b2a2679c627d0cdc8f85a4a723@"
"r04522616","0","0.38","107696","@b87fddffe5ce50bbfa2c31b8e9a2b4a2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import edu.princeton.cs.algs4.Point2D;
import  edu.princeton.cs.algs4.Stack;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static String ConvexHullVertex(Point2D[] a) {
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();
        
        int N = a.length;
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].polarOrder());//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        Stack<Integer> B = new Stack<Integer>();
        int n = A.size();
        for(int j=0;j<n;j++){
            int temp = A.pop();
            B.push(temp);
        }
        String C = B.toString();
        return C;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);
                
                
            }
            
//            Point2D[] a=new Point2D[numOfPoint];
//            for(int i=0;i<numOfPoint;i++)
//            {
//                for(int j=0;j<numOfPoint;j++)
//                {
//                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
//                    {
//                        wQUF.union(i, j);//一小群CC
//                        a[i].x()=pointXY[i].x();
//                        a[i].y()=pointXY[i].y();
//                    }
//                    if(wQUF.connected(i, j) && wQUF.count()>=3)
//                    {
//                        double x1=wQUF.find(i);
//                        double 
//                        String K=MyConvexHull.ConvexHullVertex(pointXY);
//                    }
//                }                
//            }
            
            
            StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@b87fddffe5ce50bbfa2c31b8e9a2b4a2@"
"r04522616","4","0.41","108272","@13919b4ee229df67aaf7299aa55740d6@
import com.sun.corba.se.impl.io.ValueHandlerImpl;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=new Point2D[N];        
        for(int i=0;i<N;i++)
        {
            b[i]=a[i];
        }
        
        Arrays.sort(a);//找出y最小的點為point[0]
        
        Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序
        }        
        
        s.push(a[0]); 
        A.push(0);
        s.push(a[1]); 
        A.push(1);
        
        for (int i = 2; i < N; i++) {
            Point2D top = s.pop();
            int temp = A.pop();
            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
                top = s.pop();
                temp = A.pop();
            }
            s.push(top); 
            A.push(temp);
            s.push(a[i]); 
            A.push(i);
        }
        
        int n = A.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int k=0;
        for(int i=0;i<n;i++)
        {
            c[i]=s.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[k]=j;
                    k++;                    
                }
            }            
        }
        for(int i=0;i<n;i++)
        {
            Arrays.sort(CHPoint);
        }
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }

        return n;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);                
            }
            //MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
            //Stack<Point2D> label = new Stack<Point2D>();
            int[] label=new int[numOfPoint];
            for(int i=0;i<numOfPoint;i++)
            {
                label[i]=-1;
            }
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
                    {
                        wQUF.union(i, j);//一小群CC                             
                    }                    
                }             
                
            }
            int k=0;
            int groupCount=0;
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(wQUF.connected(i, j))
                    {
                        if(label[i]==-1&&label[j]==-1)
                        {
                            label[i]=k;
                            label[j]=k;
                            k++;
                            groupCount++;
                        }
                        else if(label[i]!=-1&&label[j]==-1)
                        {
                            label[j]=label[i];
                        }
                        else if(label[i]==-1&&label[j]!=-1)
                        {
                            label[i]=label[j];
                        }
                        
                    }
                    
                }
            }
            
            int pointCount=0;
            int L=0;
            //int count=0;
            while(L<=groupCount)
            {
                int numOfGroupPoint=0;
                for(int j=0;j<numOfPoint;j++)
                {
                    if(label[j]==L)
                    {
                        numOfGroupPoint++;
                    }
                }
                Point2D[] pointXYa=new Point2D[numOfGroupPoint];
                int cnt = 0;
                for(int i=0;i<numOfPoint;i++)
                {
                    
                    if(label[i]==L)
                    {
                        pointXYa[cnt]=pointXY[i];
                        cnt++;
                        
                    }                  
                }
                if(pointXYa.length>=3)
                {
                    pointCount+=MyConvexHull.ConvexHullVertex(pointXYa);
                }
                L++;
            }
            System.out.printf(String.valueOf(pointCount));
           
            
           
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@13919b4ee229df67aaf7299aa55740d6@"
"r04631036","0","0.51","106016","@8dbb4c981ec20d93bbf5b3016291266d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class HW5_2 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=7;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@8dbb4c981ec20d93bbf5b3016291266d@"
"b02611002","1","0.1","107392","@f6c0d7550cccf07c7362a1ea697ca227@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.*;
import java.util.Stack;


/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
//    public static int N;
//    public static double d;
    public static int output=0;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
        int n = a.length;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<n;i++) {
            if(a[i].y()<a[0].y()){
                Point2D temp = a[0];
                a[0] = a[i];
                a[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }


    public static void main(String[] args) throws Exception {


        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

/* 1. read in the file containing N 2-dimentional points */
            /* 讀檔，幾十個點讀入points */
            double d = Double.valueOf(br.readLine());  //d
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Point2D[] points = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                points[count] =  new Point2D(x,y);;
                count++;
            }

//            for (Point2D p:points){System.out.println(""p(brfore): ""+p);} //print(x,y)(before)

            /* points重新排序，並輸出vertex */
//            System.out.println(ConvexHullVertex(points));

//            for (Point2D p:points){System.out.println(""p(after): ""+p);} //print(x,y)(after)

            /* 以points畫圖 */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

//        /* random 2Dpoints testing */
//            N = 10;
//            points = random2DPointArr(10);
//            int[] vertexArr = ConvexHullVertex(points);
//            for (Integer i : vertexArr) {
//                System.out.println(i);
//            }
//
//        /* Drawing */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

/* 2. create an edge for each pair of points with a distance <= d */

            UF uf = new UF(N);

            for(int i=0;i<N;i++) {
                for (int j = i; j < N; j++) {   //走訪所有的任兩點組合(i,j)
//                    System.out.printf(""(%d,%d)\n"", i, j);
                    if (points[i].distanceTo(points[j]) < d) {  //發現距離夠近的兩點則將兩個index嘗試放進CCs中
                        points[i].drawTo(points[j]);
                        uf.union(i,j);
                    }
                }
            }

            // 印出uf
//            for(int ii=0;ii<N;ii++){
//                System.out.println(uf.find(ii));
//            }

            ArrayList<Stack<Integer>> AA = new ArrayList<>();
            for(int i=0;i<N;i++){
                AA.add(new Stack<>());
            }
            for(int ii=0;ii<N;ii++){    //ii: 0,1,2,3,4,5,6,7,8,9
                AA.get(uf.find(ii)).add(ii);
            }

//            System.out.println(AA);

            for(Stack subgp:AA){
                if(subgp.size()>=3){    //跑兩次
                    Point2D[] aa = new Point2D[subgp.size()];
                    int cont = 0;
                    for(Object io:subgp){   //跑五次、跑三次
                        int index = Integer.valueOf(io.toString());
                        aa[cont]=points[index];
                        cont++;
                    }
//                    for(Point2D aaa:aa){System.out.println(aaa);}
                    output+=ConvexHullVertex(aa).length;
                }
            }

            System.out.println(output);


//            ArrayList<ArrayList<Integer>> CCs = new ArrayList<ArrayList<Integer>>();
//            int NCC=CCs.size();
//
//            for(int i=0;i<N;i++){
//                for(int j=i;j<N;j++){   //走訪所有的任兩點組合(i,j)
//                    System.out.printf(""(%d,%d)\n"",i,j);
//                    if(points[i].distanceTo(points[j])<d){  //發現距離夠近的兩點則將兩個index嘗試放進CCs中
//                        points[i].drawTo(points[j]);
//
//                        for (ArrayList<Integer> CC:CCs){    //走訪一個個Connected Components
//                            for (int CCc:CC){   //走訪某個Connected Components中的元素(Integer)
//                                if (i==CCc){
//
//                                }
//                            }
//                        }
//                    }
//                }
//            }

/* 3. find connected components (CCs) with a size >= 3 */


/* 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[]) */


/* 5. count the number of points in N serving as a convex hull vertex, print it */


        }
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D[] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@f6c0d7550cccf07c7362a1ea697ca227@"
"r04631036","1","0.46","105424","@4a2c9e467f47715b20388aaf41869830@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=7;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@4a2c9e467f47715b20388aaf41869830@"
"r04631036","2","0.44","105440","@779e0e21b5898cb8473ed5a2d3cf828a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=0;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@779e0e21b5898cb8473ed5a2d3cf828a@"
"r04631036","0","0.47","105504","@557d233326ea24ebf5cef1203acceb6c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=1;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@557d233326ea24ebf5cef1203acceb6c@"
"r04631036","0","0.45","105136","@fa5379a5c259dd1957e35b489f02944d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=3;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@fa5379a5c259dd1957e35b489f02944d@"
"r04631036","1","0.46","105392","@eb58eba735a681663b9b2306db8ddacd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=4;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@eb58eba735a681663b9b2306db8ddacd@"
"r04631027","0","0","0","@fb81b9182b9b5d6acea0ccc26a9a79a2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
               StdDraw.point(a[i].x(), a[i].y());
               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);                
                 }
                    
                 }
       System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
 Arrays.sort(a,v.ATAN2_ORDER);
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
     //System.out.println(index[i]);
 }   


        return haha+1;
       
}
}

@fb81b9182b9b5d6acea0ccc26a9a79a2@"
"r04631025","0","0.46","105392","@d4e464c06eac95199a86401a46ad1d36@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */
import 
import edu.princeton.cs.algs4.Point2D;

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        int[] answer=new int[10]; 
        for(int i=0;i<10;i++) 
            answer[i]=0;
        return answer;

    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=0;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@d4e464c06eac95199a86401a46ad1d36@"
"r04631025","2","0.45","105136","@62b7f8d352c16bb8d246c07588d21bb8@

public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {

        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        int[] answer=new int[10]; 
        for(int i=0;i<10;i++) 
            answer[i]=0;
        return answer;

    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int a=0;
        System.out.printf(""%d"",a);
        // TODO code application logic here
    }
    
}

@62b7f8d352c16bb8d246c07588d21bb8@"
"b02611002","1","0.1","107648","@8ace8267f824d6c92555e53e23ce0ff4@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.*;
import java.util.Stack;


/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
//    public static int N;
//    public static double d;
    public static int output=0;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
        int n = a.length;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<n;i++) {
            if(a[i].y()<a[0].y()){
                Point2D temp = a[0];
                a[0] = a[i];
                a[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }


    public static void main(String[] args) throws Exception {


        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

/* 1. read in the file containing N 2-dimentional points */
            /* 讀檔，幾十個點讀入points */
            double d = Double.valueOf(br.readLine());  //d
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Point2D[] points = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                points[count] =  new Point2D(x,y);;
                count++;
            }

//            for (Point2D p:points){System.out.println(""p(brfore): ""+p);} //print(x,y)(before)

            /* points重新排序，並輸出vertex */
//            System.out.println(ConvexHullVertex(points));

//            for (Point2D p:points){System.out.println(""p(after): ""+p);} //print(x,y)(after)



//        /* random 2Dpoints testing */
//            N = 10;
//            points = random2DPointArr(10);
//            int[] vertexArr = ConvexHullVertex(points);
//            for (Integer i : vertexArr) {
//                System.out.println(i);
//            }
//
//        /* Drawing */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

/* 2. create an edge for each pair of points with a distance <= d */

            UF uf = new UF(N);

            for(int i=0;i<N;i++) {
                for (int j = i; j < N; j++) {   //走訪所有的任兩點組合(i,j)
//                    System.out.printf(""(%d,%d)\n"", i, j);
                    if (points[i].distanceTo(points[j]) < d) {  //發現距離夠近的兩點則將兩個index嘗試放進CCs中
                        points[i].drawTo(points[j]);
                        uf.union(i,j);
                    }
                }
            }

            // 印出uf
//            for(int ii=0;ii<N;ii++){
//                System.out.println(uf.find(ii));
//            }

            ArrayList<Stack<Integer>> AA = new ArrayList<>();
            for(int i=0;i<N;i++){
                AA.add(new Stack<>());
            }
            for(int ii=0;ii<N;ii++){    //ii: 0,1,2,3,4,5,6,7,8,9
                AA.get(uf.find(ii)).add(ii);
            }

//            System.out.println(AA);

            for(Stack subgp:AA){
                if(subgp.size()>=3){    //跑兩次
                    Point2D[] aa = new Point2D[subgp.size()];
                    int cont = 0;
                    for(Object io:subgp){   //跑五次、跑三次
                        int index = Integer.valueOf(io.toString());
                        aa[cont]=points[index];
                        cont++;
                    }
                    for(Point2D aaa:aa){System.out.println(aaa);}
/* 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[]) */
                    output+=ConvexHullVertex(aa).length;
                }
            }

            System.out.println(output);



/* 3. find connected components (CCs) with a size >= 3 */





/* 5. count the number of points in N serving as a convex hull vertex, print it */


        }
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D[] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@8ace8267f824d6c92555e53e23ce0ff4@"
"r04631027","3","0.47","105888","@d9d4d3566d189e4ae0c972a0fe402f9b@






import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
          //  StdDraw.setPenColor(StdDraw.BLACK);
         //   StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
            //   StdDraw.point(a[i].x(), a[i].y());
           //    StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);                
                 }
                    
                 }
       System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
 Arrays.sort(a,v.ATAN2_ORDER);
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
     //System.out.println(index[i]);
 }   


        return haha+1;
       
}
}

@d9d4d3566d189e4ae0c972a0fe402f9b@"
"r04631027","0","0","0","@24d0cdeaafedcd50c72051dcef682b99@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
              StdDraw.point(a[i].x(), a[i].y());
               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                 StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);                
                 }
                    
                 }
       System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
 Arrays.sort(a,v.ATAN2_ORDER);
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
     //System.out.println(index[i]);
 }   


        return haha+1;
       
}
}

@24d0cdeaafedcd50c72051dcef682b99@"
"r04522616","4","0.41","103232","@08dcb54b4a89832cc5930a8d1ccc9488@
import com.sun.corba.se.impl.io.ValueHandlerImpl;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
//import edu.princeton.cs.algs4.Point2D;
//import  edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author sarahsu
 */
public class MyConvexHull {
    
    public static int ConvexHullVertex(Point2D[] a) {
        
        int N = a.length;
        Point2D[] b=a.clone();
        
        
        Arrays.sort(a);//找出y最小的點為point[0]
        
        //Stack<Integer> A = new Stack<Integer>();
        Stack<Point2D> s = new Stack<Point2D>();        
        
        for (int i = 0; i < N; i++) {
            Arrays.sort(a,a[0].POLAR_ORDER);//根據角度重排點順序(POLAR_ORDER)
        }        
        
//        s.push(a[0]); 
//        //A.push(0);
//        s.push(a[1]); 
//        //A.push(1);
//        
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            //int temp = A.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                //temp = A.pop();
//            }
//            
//            s.push(top); 
//            //A.push(temp);
//            s.push(a[i]); 
//            //A.push(i);
//        }
        
        Stack<Point2D> _stack = new Stack<Point2D>();
        _stack.push(a[0]);
        _stack.push(a[1]);
        _stack.push(a[2]);
        int k = 3;
        int ccw = 0;
        while(k != a.length)
        {
            Point2D p3 = a[k++];
            Point2D p2 = _stack.pop();
            Point2D p1 = _stack.pop();
               
            ccw = Point2D.ccw(p1, p2, p3);
            if(ccw == 0)
            {
                p2 = p1;
                p1 = _stack.pop();   
            }
            else if(ccw == -1)
            {
                do
                {
                    p2 = p1;
                    p1 = _stack.pop();
                }while(!(Point2D.ccw(p1, p2, p3) == 1));
            }
            _stack.push(p1);
            _stack.push(p2);
            _stack.push(p3);
           
        }
        
        
        
        int n = _stack.size();
        int[] CHPoint=new int[n];
        Point2D[] c=new Point2D[n];
        int p=0;
        for(int i=0;i<n;i++)
        {
            c[i]=_stack.pop();
            for(int j=0;j<N;j++)
            {
                if(c[i].x()==b[j].x())
                {
                    CHPoint[p]=j;
                    p++;                    
                }
            }            
        }
        
        Arrays.sort(CHPoint);
        
//        for(int i=0;i<n;i++)
//        {
//            System.out.print(CHPoint[i]);
//        }
        return n;
        //return CHPoint;            
    }
    
    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] minDistance = br.readLine().split("" "");
            double minD=Double.parseDouble(minDistance[0]);
            String[] numberOfPoint = br.readLine().split("" "");
            int numOfPoint=Integer.parseInt(numberOfPoint[0]);
            
            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(numOfPoint);
            
            Point2D[] pointXY=new Point2D[numOfPoint];//儲存txt的點資料(x,y)
            for(int i=0;i<numOfPoint;i++)
            {
                String[] X_And_Y = br.readLine().split("" "");
                double x=Double.parseDouble(X_And_Y[0]);
                double y=Double.parseDouble(X_And_Y[1]);
                pointXY[i]=new Point2D(x, y);
                //StdDraw.filledCircle(pointXY[i].x(),pointXY[i].y(), 0.01);                
            }
            //MyConvexHull.ConvexHullVertex(pointXY);
//            Point2D[] a=new Point2D[numOfPoint];
            //Stack<Point2D> label = new Stack<Point2D>();
            int[] label=new int[numOfPoint];
            for(int i=0;i<numOfPoint;i++)
            {
                label[i]=-1;
            }
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(Math.pow(Math.pow(pointXY[i].x()-pointXY[j].x(),2)+Math.pow(pointXY[i].y()-pointXY[j].y(),2), 0.5)<=minD)
                    {
                        wQUF.union(i, j);//一小群CC                             
                    }                    
                }             
                
            }
            int k=0;
            int groupCount=0;
            for(int i=0;i<numOfPoint-1;i++)
            {                
                for(int j=i+1;j<numOfPoint;j++)
                {
                    if(wQUF.connected(i, j))
                    {
                        if(label[i]==-1&&label[j]==-1)
                        {
                            label[i]=k;
                            label[j]=k;
                            k++;
                            groupCount++;
                        }
                        else if(label[i]!=-1&&label[j]==-1)
                        {
                            label[j]=label[i];
                        }
                        else if(label[i]==-1&&label[j]!=-1)
                        {
                            label[i]=label[j];
                        }
                        
                    }
                    
                }
            }
            
            int pointCount=0;
            int L=0;
            //int count=0;
            while(L<=groupCount)
            {
                int numOfGroupPoint=0;
                for(int j=0;j<numOfPoint;j++)
                {
                    if(label[j]==L)
                    {
                        numOfGroupPoint++;
                    }
                }
                Point2D[] pointXYa=new Point2D[numOfGroupPoint];
                int cnt = 0;
                for(int i=0;i<numOfPoint;i++)
                {
                    
                    if(label[i]==L)
                    {
                        pointXYa[cnt]=pointXY[i];
                        cnt++;
                        
                    }                  
                }
                if(pointXYa.length>=3)
                {
                    pointCount+=MyConvexHull.ConvexHullVertex(pointXYa);
                }
                L++;
            }
            System.out.printf(String.valueOf(pointCount));
           
            
           
            //StdOut.printf(MyConvexHull.ConvexHullVertex(pointXY));
            
//            Arrays.sort(pointXY);//畫出起始點(紅色)
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.filledCircle(pointXY[0].x(), pointXY[0].y(), 0.01);
//            StdDraw.setPenRadius();
//            
//            Stack<Integer> A = new Stack<Integer>();//畫出sort後的點編號(藍色)與連線(綠色)
//            for (int i = 0; i < numOfPoint; i++) {
//                Arrays.sort(pointXY,pointXY[0].polarOrder());
//                A.push(i);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(pointXY[0].x(), pointXY[0].y(), pointXY[i].x(), pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.text(pointXY[i].x()+0.03, pointXY[i].y()+0.03, A.toString());
//                String pointX=String.valueOf(pointXY[i].x());
//                String pointY=String.valueOf(pointXY[i].y());
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y()+0.03, pointX);
//                StdDraw.setPenColor(StdDraw.BLACK);
//                StdDraw.text(pointXY[i].x()+0.08, pointXY[i].y(), pointY);
//                
//                A.pop();
//            }
            
//            Stack<Point2D> CC=new Stack<Point2D>();
//            
//            int i=0;
//            while (i!=numOfPoint)
//            {
//                int count=0;     
//                if(pointXY[i]==null)
//                {
//                    break;
//                }
//                
//                double distance=0.0;
//                distance=Math.pow(Math.pow(pointXY[i].x()-pointXY[i+1].x(),2)+Math.pow(pointXY[i].y()-pointXY[i+1].y(),2), 0.5);
//                if(distance<=minD)
//                {
//                    wQUF.union(i, i+1);
//                    
//                    CC.push(pointXY[i]);
//                }
//                if(wQUF.count()>=3)
//                {
//                    //int[] recard=new int[];
//                    Point2D[] pointXYa=new Point2D[wQUF.count()];
//                    StdOut.printf(MyConvexHull.ConvexHullVertex(pointXYa));
//                    //String D = MyConvexHull.ConvexHullVertex(pointXYa);
//                    //while(){}
//                    //D.split("" "");
//                }
//                
//                i++;
//            };
            
     
            
            
            
        }
}
}
//        
//        In in = new In(args[0]); 
//        int N = in.readInt();
//        //int N = 10;
//        Point2D[] a = new Point2D[N];
//        for(int i=0;i<N;i++){
//            double x = StdRandom.uniform();
//            double y = StdRandom.uniform();
//            a[i] = new Point2D(x,y);
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);    
//        }
//        StdOut.printf(MyConvexHull.ConvexHullVertex(a));
//        
//        Arrays.sort(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(a[0].x(), a[0].y(), 0.01);
//        StdDraw.setPenRadius();
//        
//        Stack<Integer> A = new Stack<Integer>();
//        for (int i = 0; i < N; i++) {
//            Arrays.sort(a,a[0].POLAR_ORDER);
//            A.push(i);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(a[0].x(), a[0].y(), a[i].x(), a[i].y());
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.text(a[i].x()+0.03, a[i].y()+0.03, A.toString());
//            A.pop();
//        }
//
//        Stack<Point2D> s = new Stack<Point2D>();
//        Stack<Integer> B = new Stack<Integer>();
//        StdDraw.setPenColor(StdDraw.BLACK);
//        s.push(a[0]);B.push(0);
//        s.push(a[1]);B.push(1);
//        StdDraw.line(a[0].x(), a[0].y(), a[1].x(), a[1].y());
//        // find index k1 of first point not equal to points[0]
//       /* int i;
//        for (i = 1 ; i < N; i++) {
//            if (!a[0].equals(a[i])) break;
//            if (i == N) return;
//        }
//        // find index k2 of first point not collinear with points[0] and points[k1]
//        int j;
//        for (j = i + 1; j < N; j++){
//            if (Point2D.ccw(a[0], a[i], a[j]) != 0) break;
//            s.push(a[j-1]);    // points[k2-1] is second extreme point
//        }*/
//        // Graham scan; note that points[N-1] is extreme point different from points[0]
//        for (int i = 2; i < N; i++) {
//            Point2D top = s.pop();
//            int temp = B.pop();
//            while (Point2D.ccw(s.peek(), top, a[i]) <= 0) {
//                top = s.pop();
//                temp = B.pop();
//            }
//            s.push(top);B.push(temp);
//            s.push(a[i]);B.push(i);
//        }
//        int n = B.size();
//        for(int j=0;j<n-2;j++){
//            int x = B.pop();
//            StdDraw.line(a[x].x(), a[x].y(), a[B.peek()].x(), a[B.peek()].y());
//            
//            
//        }
//        StdDraw.line(a[N-1].x(), a[N-1].y(), a[0].x(), a[0].y());
//        
//        
//    }


@08dcb54b4a89832cc5930a8d1ccc9488@"
"r04631027","0","0","0","@952c062f57174a59277fa223a6f6f72a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
              StdDraw.point(a[i].x(), a[i].y());
               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
                 StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
         if (aaa == 1)
       System.out.println(output+1);
         else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
 Arrays.sort(a,v.ATAN2_ORDER);
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
     //System.out.println(index[i]);
 }   


        return haha+1;
       
}
}

@952c062f57174a59277fa223a6f6f72a@"
"r04631027","4","0.49","107616","@923c1203fdc2cdcfcebc07e35962dcee@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
            //StdDraw.setPenColor(StdDraw.BLACK);
            //StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
//              StdDraw.point(a[i].x(), a[i].y());
//               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
//               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
               //  StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
            // System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
         if (aaa == 1)
       System.out.println(output+1);
         else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        
 Arrays.sort(a,v.ATAN2_ORDER);
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
     //System.out.println(index[i]);
 }   


        return haha+1;
       
}
}

@923c1203fdc2cdcfcebc07e35962dcee@"
"r04921028","5","0.1","108016","@cfa6d8182332b96937e87468f5d09fea@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
         int min = 0;
         Double[] degree = new Double [N];
         Double minX = a[0].x();
         Double minY = a[0].y();
         Stack<Integer> cnxpoint = new Stack<Integer>(); 
         //************************* find min ********************************\\
         int[] orderlist = new int[N+1];
         for(int i=0; i<N; i++){
             orderlist[i]=i;
             if(a[i].y()<minY){
                 minX = a[i].x();
                 minY = a[i].y();
                 min = i;
             }             
         }
         int temp;  Double tempX,tempY;
        //************************** degree stuff*****************************\\
         for(int i=0; i<N; i++){
               degree[i]=Math.toDegrees(Math.atan2(a[i].y()-minY,a[i].x()-minX));
         }
        //***********************  sorting  **********************************\\
        
        for(int i=1; i<a.length; i++){
            Double tempD = degree[i];
            int    tempO = orderlist[i];
            int j=0;
                for( j=i-1; j>=0 && tempD < degree[j]; j--){
                    orderlist[j+1] = orderlist[j];
                    degree[j+1]    = degree [j];
                }               
            degree[j+1] = tempD;
            orderlist[j+1] = tempO;
        }
        orderlist[N]=orderlist[0];
        //*********************** ccw link ***********************************\\
         
           int CNXcount = 0;
           while(CNXcount<=N){ 
                   // System.out.println(cnxpoint.size());
                    if(cnxpoint.size()<3){ cnxpoint.push(orderlist[CNXcount]); CNXcount++;}
                    else if(cnxpoint.size()>=3){
                        
                        int p3=cnxpoint.pop();
                        int p2=cnxpoint.pop();
                        int p1=cnxpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           cnxpoint.push(p1); 
                           cnxpoint.push(p2);
                           cnxpoint.push(p3);
                           
                           cnxpoint.push(orderlist[CNXcount]);
                           CNXcount++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           cnxpoint.push(p1);
                           cnxpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = cnxpoint.size()-2;
            int convexsize =  cnxpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = cnxpoint.pop();
            
            while(cnxpoint.size()!=0){
                index[counter] = cnxpoint.pop();
                counter--;
            }
        //************************ show dots**********************************\\
     /*  for(int i=0; i<N; i++){
             //  System.out.print(a[i].x()+""\t"");
             //  System.out.print(a[i].y()+""\t"");
               System.out.println(degree[i]);
         }
        for(int i=0; i<N+1; i++){
               System.out.print(orderlist[i]);
         }*/        
        //----------------------------data------------------------------------\\
                
//         for(int i=0; i<N; i++){
//            if(i==min){
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[i].x(),a[i].y());                
//            }
//            else{
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.BLUE);
//            StdDraw.point(a[i].x(),a[i].y());
//            }
//        }
        //--------------------------------------------------------------------\\
        return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }

    public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
                //===============================
                points[count] = new Point2D(x, y);
                count++;
                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                    
//                    StdDraw.setPenRadius(0.01);
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                    StdDraw.point(points[b].x(),points[b].y());
                     
                }
//                System.out.println(""input size: ""+point1s.length);
                
                int index[] =  ConvexHullVertex(point1s);
                
                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
                //===================================
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}
@cfa6d8182332b96937e87468f5d09fea@"
"b02611012","0","0.21","105984","@b416dd32f0c47a2fddaf8db491e02370@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();

    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }

        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0, 0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);

        
        Stack<Integer> vals = new Stack<Integer>();
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點

            an[m] = a[i];
            ans[m] = i;
            m++;
        }

        int[] b = new int[m];
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        for (int i = 0; i < m; i++) {
            b[i] = map.get(a[ans[i]]);
        }
        sort(b);

        

        return b;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String maxdistance = br.readLine();
            double maxdis = Double.parseDouble(maxdistance);
            String count = br.readLine();
            int N = Integer.parseInt(count);
            Point2D[] points = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] temp = br.readLine().split("" "");
                double tempx = Double.parseDouble(temp[0]);
                double tempy = Double.parseDouble(temp[1]);
                points[i] = new Point2D(tempx, tempy);
            }
            QuickFindUF uf = new QuickFindUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i+1; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= maxdis) {
                        uf.union(i, j);
                    }
                }
            }
            
            int ans = 0;
            for (int i = 0; i < N; i++) {
                Stack<Integer> a = new Stack<Integer>();
                for (int j = 0; j < N; j++) {
                    if (uf.find(j)==i) {
                        a.push(j);
                    }
                }
                if (a.size() > 2) {
                    Point2D[] aa= new Point2D[a.size()];
                    for (int j = 0; j < a.size(); j++) {
                        aa[j] = aa[a.pop()];
                    }
                    ans = ans + MyConvexHull.ConvexHullVertex(aa).length;
                }else if (a.size()>0 && a.size()<2) {
                    ans = ans + a.size();
                    a = null;
                }
            }
            System.out.printf(ans + """");
        }

    }

}

@b416dd32f0c47a2fddaf8db491e02370@"
"b02611012","0","0.2","103072","@450eb0c7f71a2d4e9f5e8cdcf6131da3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();

    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }

        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0, 0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        for (int i = 0; i < a.length; i++) {
//            a[min].drawTo(a[i]);
//            StdDraw.show(100);
//        }
        Stack<Integer> vals = new Stack<Integer>();
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點

            an[m] = a[i];
            ans[m] = i;
            m++;
        }

        int[] b = new int[m];
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        for (int i = 0; i < m; i++) {
            b[i] = map.get(a[ans[i]]);
        }
        sort(b);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i = 1; i < b.length; i++) {
//            an[i - 1].drawTo(an[i]);
//            StdDraw.show(100);
//        }

        return b;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String maxdistance = br.readLine();
            double maxdis = Double.parseDouble(maxdistance);
            String count = br.readLine();
            int N = Integer.parseInt(count);
            Point2D[] points = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] temp = br.readLine().split("" "");
                double tempx = Double.parseDouble(temp[0]);
                double tempy = Double.parseDouble(temp[1]);
                points[i] = new Point2D(tempx, tempy);
            }
            QuickFindUF uf = new QuickFindUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i+1; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= maxdis) {
                        uf.union(i, j);
                    }
                }
            }
            
            int ans = 0;
            for (int i = 0; i < N; i++) {
                Stack<Integer> a = new Stack<Integer>();
                for (int j = 0; j < N; j++) {
                    if (uf.find(j)==i) {
                        a.push(j);
                    }
                }
                if (a.size() > 2) {
                    Point2D[] aa= new Point2D[a.size()];
                    for (int j = 0; j < a.size(); j++) {
                        aa[j] = points[a.pop()];
                    }
                    ans = ans + ConvexHullVertex(aa).length;
                }else if (a.size()>0 && a.size()<2) {
                    ans = ans + a.size();
                }
            }
            System.out.printf(ans + """");
        }

    }

}

@450eb0c7f71a2d4e9f5e8cdcf6131da3@"
"r04631041","1","0.1","103120","@1073cc056a2a283dcaf3fcb91a3d36ca@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
//                //===============================
                points[count] = new Point2D(x, y);
                count++;
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
//                System.out.println(""input size: ""+point1s.length);
                int index[] =  ConvexHullVertex(point1s);
                
//                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
//                //===================================
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}

@1073cc056a2a283dcaf3fcb91a3d36ca@"
"r04631041","3","0.48","107136","@03b61a0acc6fdc0f3e27438cc4603bb8@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
           int N = a.length;
           
           float PointAngle[];
           PointAngle = new float[N];
           
           int pindex[];
           pindex = new int[N+1];
           
           double minx = 0;
           double miny = 0;
           double min = 0;
           int n = 0;
           
           Stack<Integer> convexpoint = new Stack<Integer>(); 
           
           for(int i =0;i<N;i++){
               pindex[i] = i;
               
               if(i==0){
                 miny = a[0].y();
               }
               if(a[i].y()<miny){
                   miny = a[i].y();
                   minx = a[i].x(); 
                   min = i;
               }
           }
           
           for(int i =0;i<N;i++){
               if(i!=min){
                    PointAngle[i] = (float)Math.toDegrees(Math.atan2(a[i].y()-miny,a[i].x()-minx));
               }
           }
           
           int NPointAngle = PointAngle.length;
           float exch;
           int indexexch;
           for (int i = 0; i < NPointAngle; i++) {
                for (int j = i; j > 0 && PointAngle[j]<=PointAngle[j-1]; j--){ 
                    exch = PointAngle[j];
                    PointAngle[j] = PointAngle[j-1];
                    PointAngle[j-1] = exch;
                    
                    indexexch = pindex[j];
                    pindex[j] = pindex[j-1];
                    pindex[j-1] = indexexch;    
                }
           }
           
           pindex[N] = pindex[0];
           
           int icounter = 0;
           int lastccw = 0;
           while(icounter<=N){ 
                   // System.out.println(convexpoint.size());
                    if(convexpoint.size()<3){ convexpoint.push(pindex[icounter]); icounter++;}
                    else if(convexpoint.size()>=3){
                        if(icounter>N) break;
                        
                        int p3=convexpoint.pop();
                        int p2=convexpoint.pop();
                        int p1=convexpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           convexpoint.push(p1); 
                           convexpoint.push(p2);
                           convexpoint.push(p3);
                           
                           convexpoint.push(pindex[icounter]);
                           icounter++;
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           convexpoint.push(p1);
                           convexpoint.push(p3);
                        } 
                    }       
            }
            
            int counter = convexpoint.size()-2;
            int convexsize =  convexpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = convexpoint.pop();
            
            while(convexpoint.size()!=0){
                index[counter] = convexpoint.pop();
                counter--;
            }
            //===============================
//            for(int o =1;o<convexsize;o++){
//                StdDraw.setPenRadius(0.001);
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(a[index[o-1]].x(), a[index[o-1]].y(),a[index[o]].x(), a[index[o]].y()); 
//            }
//            StdDraw.line(a[index[convexsize-1]].x(), a[index[convexsize-1]].y(),a[index[0]].x(), a[index[0]].y()); 
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.RED);
//            StdDraw.point(a[index[0]].x(),a[index[0]].y());
            //===============================
            return index;
        
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1

    }
public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@03b61a0acc6fdc0f3e27438cc4603bb8@"
"r04631027","4","0.48","107616","@a332ca273c78bca89aed1fe50217c2db@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
//            StdDraw.setPenColor(StdDraw.BLACK);
//            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
//              StdDraw.point(a[i].x(), a[i].y());
//               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
//               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
              // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
         //    System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
       //  if (aaa == 1)
     //  System.out.println(""                  ""+(output+1));
         //else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        Arrays.sort(a,v.DISTANCE_TO_ORDER);
 Arrays.sort(a,v.ATAN2_ORDER);
 ////////////sort
 
 for(int i=0;i<a.length;i++ )
 {//System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =0;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==0)
   {p2=i;}
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
   //  System.out.println(index[i]);
 }   
//System.out.println(""haha""+haha);

        return haha+1;
       
}
}

@a332ca273c78bca89aed1fe50217c2db@"
"r04631041","1","0.09","101744","@ca04a8d6aee45e56207d6c5e4a8e935a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float lans = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
//                //===============================
//                double x = StdRandom.uniform(0.01,0.99);
//                double y = StdRandom.uniform(0.01,0.99);
//                //===============================
                points[count] = new Point2D(x, y);
                count++;
//                //===============================
//                StdDraw.setPenRadius(0.01);
//                StdDraw.setPenColor(StdDraw.BLUE);
//                StdDraw.point(x,y);
//                //===============================
            }
//            StdDraw.setPenRadius(0.01);
//            StdDraw.setPenColor(StdDraw.GREEN);
//            StdDraw.line(0.9,0.1,0.9,0.1+lans);
            
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=lans){
                         uf.union(j,i);
//                         StdDraw.setPenRadius(0.001);
//                         StdDraw.setPenColor(StdDraw.BLUE);
//                         StdDraw.line(points[j].x(),points[j].y(),points[i].x(),points[i].y());
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
//                   System.out.println(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
//                System.out.println(hold);
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                       //System.out.print(j);
                   } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());
                }
//                System.out.println(""input size: ""+point1s.length);
                int index[] =  ConvexHullVertex(point1s);
                
//                //==================================
//                for(int j=0;j<index.length;j++){
//                   System.out.print(index[j]);
//                }
//                System.out.println();
//                //===================================
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    }
}

@ca04a8d6aee45e56207d6c5e4a8e935a@"
"b02611012","0","0.51","108160","@20e311ab61ac4eff4b99619b5ee3867f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();

    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }

        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0, 0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        for (int i = 0; i < a.length; i++) {
//            a[min].drawTo(a[i]);
//            StdDraw.show(100);
//        }
        Stack<Integer> vals = new Stack<Integer>();
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點

            an[m] = a[i];
            ans[m] = i;
            m++;
        }

        int[] b = new int[m];
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        for (int i = 0; i < m; i++) {
            b[i] = map.get(a[ans[i]]);
        }
        sort(b);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i = 1; i < b.length; i++) {
//            an[i - 1].drawTo(an[i]);
//            StdDraw.show(100);
//        }

        return b;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String maxdistance = br.readLine();
            double maxdis = Double.parseDouble(maxdistance);
            String count = br.readLine();
            int N = Integer.parseInt(count);
            Point2D[] points = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] temp = br.readLine().split("" "");
                double tempx = Double.parseDouble(temp[0]);
                double tempy = Double.parseDouble(temp[1]);
                points[i] = new Point2D(tempx, tempy);
            }
            QuickFindUF uf = new QuickFindUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i+1; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= maxdis) {
                        uf.union(i, j);
                    }
                }
            }
            
            int ans = 0;
            for (int i = 0; i < N; i++) {
                Stack<Integer> a = new Stack<Integer>();
                int countcc = 0;
                for (int j = 0; j < N; j++) {
                    if (uf.find(j)==i) {
                        a.push(j);
                        countcc++;
                    }
                }
                if (countcc > 2) {
                    Point2D[] aa= new Point2D[countcc];
                    for (int j = 0; j < countcc; j++) {
                        
                        aa[j] = points[a.pop()];
                    }
                    ans = ans + ConvexHullVertex(aa).length;
                }
                if (countcc==1 || countcc==2) {
                    ans = ans + countcc;
                }
            }
            System.out.printf(ans + """");
        }

    }

}

@20e311ab61ac4eff4b99619b5ee3867f@"
"b02611012","5","0.1","105888","@1df21e24300ccc7f66f0cf97bae6b71e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import static java.util.Arrays.sort;
import java.util.HashMap;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    static HashMap<Point2D, Integer> map = new HashMap<Point2D, Integer>();

    public static int[] ConvexHullVertex(Point2D[] a) {
        for (int i = 0; i < a.length; i++) {
            map.put(a[i], i);
        }

        int min = 0;
        for (int j = 1; j < a.length; j++) {
            if (a[min].compareTo(a[j]) == +1) {
                Point2D temp = new Point2D(0, 0);
                temp = a[min];
                a[min] = a[j];
                a[j] = temp;
            }
        }
        Arrays.sort(a, a[0].POLAR_ORDER);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.BLUE);
//        for (int i = 0; i < a.length; i++) {
//            a[min].drawTo(a[i]);
//            StdDraw.show(100);
//        }
        Stack<Integer> vals = new Stack<Integer>();
        int m = 0;      // m 為凸包頂點數目
        Point2D[] an = new Point2D[a.length];
        int[] ans = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            while (m >= 2 && Point2D.ccw(an[m - 2], an[m - 1], a[i]) < 0) {
                m--;
            }
            // 添加新的點

            an[m] = a[i];
            ans[m] = i;
            m++;
        }

        int[] b = new int[m];
        for (int i = 0; i < m; i++) {
            b[i] = ans[i];
        }
        for (int i = 0; i < m; i++) {
            b[i] = map.get(a[ans[i]]);
        }
        sort(b);

//        StdDraw.setPenRadius();
//        StdDraw.setPenColor(StdDraw.RED);
//        for (int i = 1; i < b.length; i++) {
//            an[i - 1].drawTo(an[i]);
//            StdDraw.show(100);
//        }

        return b;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String maxdistance = br.readLine();
            double maxdis = Double.parseDouble(maxdistance);
            String count = br.readLine();
            int N = Integer.parseInt(count);
            Point2D[] points = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] temp = br.readLine().split("" "");
                double tempx = Double.parseDouble(temp[0]);
                double tempy = Double.parseDouble(temp[1]);
                points[i] = new Point2D(tempx, tempy);
            }
            QuickFindUF uf = new QuickFindUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i+1; j < N; j++) {
                    if (points[i].distanceTo(points[j]) <= maxdis) {
                        uf.union(i, j);
                    }
                }
            }
            
            int ans = 0;
            for (int i = 0; i < N; i++) {
                Stack<Integer> a = new Stack<Integer>();
                int countcc = 0;
                for (int j = 0; j < N; j++) {
                    if (uf.find(j)==i) {
                        a.push(j);
                        countcc++;
                    }
                }
                if (countcc > 2) {
                    Point2D[] aa= new Point2D[countcc];
                    for (int j = 0; j < countcc; j++) {
                        aa[j] = points[a.pop()];
                    }
                    ans += ConvexHullVertex(aa).length;
                }
//                if (countcc==1 || countcc==2) {
//                    ans = ans + countcc;
//                }
            }
            System.out.printf(ans + """");
        }

    }

}

@1df21e24300ccc7f66f0cf97bae6b71e@"
"r03522831","4","0.51","107872","@c628df035c2a5ba86e9028c717624e59@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@c628df035c2a5ba86e9028c717624e59@"
"r04631041","3","0.49","108288","@ddab91a6f409f62e3c5f387d6181a960@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     WeightedQuickUnionUF connection=new WeightedQuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@ddab91a6f409f62e3c5f387d6181a960@"
"r04631027","2","0.49","104768","@bb0b2bd7542e88e2303c4737cf891835@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
//            StdDraw.setPenColor(StdDraw.BLACK);
//            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
//              StdDraw.point(a[i].x(), a[i].y());
//               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
//               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
              // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
         //    System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
       //  if (aaa == 1)
     //  System.out.println(""                  ""+(output+1));
         //else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        Arrays.sort(a,v.DISTANCE_TO_ORDER);
 Arrays.sort(a,v.ATAN2_ORDER);
 ////////////sort
 
 for(int i=0;i<a.length;i++ )
 {System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =p2+1;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==0)
   {p2=i;}
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
   //  System.out.println(index[i]);
 }   
//System.out.println(""haha""+haha);

        return haha+1;
       
}
}

@bb0b2bd7542e88e2303c4737cf891835@"
"r04921074","5","0.098","104976","@fe7bdda53915b2a6a22531658794c5bb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class MyConvexHull {
     public static int[] ConvexHullVertex(Point2D[] a) {
         
         int K = a.length;
         int min = 0;
         Double[] degree = new Double [K];
         Double minX = a[0].x();
         Double minY = a[0].y();
         Stack<Integer> cnxpoint = new Stack<Integer>(); 
         //************************* find min ********************************\\
         int[] orderlist = new int[K+1];
         for(int i=0; i<K; i++){
             orderlist[i]=i;
             if(a[i].y()<minY){
                 minX = a[i].x();
                 minY = a[i].y();
                 min = i;
             }             
         }
         int temp;  Double tempX,tempY;
        //************************** degree stuff*****************************\\
         for(int i=0; i<K; i++){
               degree[i]=Math.toDegrees(Math.atan2(a[i].y()-minY,a[i].x()-minX));
         }
        //***********************  sorting  **********************************\\
        
        for(int i=1; i<a.length; i++){
            Double tempD = degree[i];
            int    tempO = orderlist[i];
            int j=0;
                for( j=i-1; j>=0 && tempD < degree[j]; j--){
                    orderlist[j+1] = orderlist[j];
                    degree[j+1]    = degree [j];
                }               
            degree[j+1] = tempD;
            orderlist[j+1] = tempO;
        }
        orderlist[K]=orderlist[0];
        //*********************** ccw link ***********************************\\
         
           int CNXcount = 0;
           while(CNXcount<=K){ 
                   // System.out.println(cnxpoint.size());
                    if(cnxpoint.size()<3){ cnxpoint.push(orderlist[CNXcount]); CNXcount++;}
                    else if(cnxpoint.size()>=3){
                        
                        int p3=cnxpoint.pop();
                        int p2=cnxpoint.pop();
                        int p1=cnxpoint.pop();
                        
                        if(Point2D.ccw(a[p1],a[p2],a[p3])>=0){
                           cnxpoint.push(p1); 
                           cnxpoint.push(p2);
                           cnxpoint.push(p3);
                           
                           cnxpoint.push(orderlist[CNXcount]);
                           CNXcount++;
                           
                        }
                        else if(Point2D.ccw(a[p1],a[p2],a[p3])<0){                                                                        
                           cnxpoint.push(p1);
                           cnxpoint.push(p3);
                           
                        } 
                    }       
            }
            
            int counter = cnxpoint.size()-2;
            int convexsize =  cnxpoint.size()-1; 
            
            int index[];
            index = new int[convexsize];
            int trash = cnxpoint.pop();
            
            while(cnxpoint.size()!=0){
                index[counter] = cnxpoint.pop();
                counter--;
            }
        //************************ show dots**********************************\\
     /*  for(int i=0; i<N; i++){
             //  System.out.print(a[i].x()+""\t"");
             //  System.out.print(a[i].y()+""\t"");
               System.out.println(degree[i]);
         }
        for(int i=0; i<N+1; i++){
               System.out.print(orderlist[i]);
         }        
        //----------------------------data------------------------------------\\
                
         for(int i=0; i<N; i++){
            if(i==min){
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.RED);
            StdDraw.point(a[i].x(),a[i].y());                
            }
            else{
            StdDraw.setPenRadius(0.01);
            StdDraw.setPenColor(StdDraw.BLUE);
            StdDraw.point(a[i].x(),a[i].y());
            }
        }*/
        //--------------------------------------------------------------------\\
        return index;
      }
    
    
     public static void main(String[] args)  throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // 1. read in the file containing N 2-dimentional points
            String buf0 = br.readLine();
            float okan = Float.valueOf(buf0);
            
            String buf1 = br.readLine();
            int n = Integer.valueOf(buf1);
            
            Point2D[] points = new Point2D[n];
            int count2D = 0;
            while (br.ready())
            {      
                String buf2[] = br.readLine().split("" "");
                double x = Double.valueOf(buf2[0]);
                double y = Double.valueOf(buf2[1]);
                points[count2D] = new Point2D(x, y);
                count2D++;
            }
            // 2. create an edge for each pair of points with a distance <= d
            QuickUnionUF uf = new QuickUnionUF(n);
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    if(i!=j){
                     if(points[i].distanceTo(points[j])<=okan){
                         uf.union(j,i);
                     }
                   }
                }
            }
            // 3. find connected components (CCs) with a size >= 3
            int hold = 0;
            
            int cccount3 = 0;
            Stack<Integer> leadpoint1 = new Stack<Integer>();
            Stack<Integer> leadpoint = new Stack<Integer>();

            for(int i=0;i<n;i++){
               if(i==uf.find(i)){
                   leadpoint1.push(uf.find(i));
               }
            }
            int cccount = leadpoint1.size();
            
            for(int i=0;i<cccount;i++){
                hold = leadpoint1.pop();
                for(int j=0;j<n;j++){
                   if(uf.find(j)==hold){
                      cccount3++; 
                   }
                }
                if(cccount3>2){
                   leadpoint.push(hold);
                   
                   cccount3 = 0;
                }  
            }
            
            int cclead[];
            cclead = new int[leadpoint.size()];
            int leadcccount = leadpoint.size();
            
            cclead = new int[leadcccount];
            for(int i=0;i<leadcccount;i++){
                cclead[i] = leadpoint.pop();
            }
            
            // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
            int counter = 0;
            Stack<Integer> cc = new Stack<Integer>();
            int ans = 0;
            for(int i=0;i<leadcccount;i++){
                for(int j=0;j<n;j++){
                   if(Integer.valueOf(uf.find(j))==cclead[i]){
                       counter++;
                       cc.push(j);
                  } 
                }
                Point2D[] point1s = new Point2D[counter];
                for(int z=0;z<counter;z++){
                    int b = cc.pop();
                    point1s[z] = new Point2D(points[b].x(),points[b].y());

                }

                
                int index[] =  ConvexHullVertex(point1s);
                if(index.length>2){
                    ans = ans+index.length;
                }
                counter = 0;
            }
            // 5. count the number of points in N serving as a convex hull vertex, print it
            System.out.println(ans);  
        }
    } 
     
     
/*   public static void main(String[] args) throws IOException{
       
       Scanner scanner = new Scanner(System.in); 
       System.out.println(""How many random dot you want?"");
       int N = scanner.nextInt();
       System.out.printf(""Processing......""+""\n    creating %d dot\n"",N);
       
              
       Point2D[] dotdata = new Point2D [N]; //create dot data [dot order][two axis num// x: ,y: //]
       Point2D[] b = new Point2D [N];
       
       
       for(int i=0; i<N; i++){
           
                dotdata[i] =new Point2D(StdRandom.random(),StdRandom.random());
                System.out.println(dotdata[i].x()+""\t""+dotdata[i].y());
                           
       }
       System.out.println(ConvexHullVertex(dotdata).length);
    }*/
}
    
  
@fe7bdda53915b2a6a22531658794c5bb@"
"r04631027","2","0.48","105808","@7119cdbdf529ffa38427875c765759d8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
//            StdDraw.setPenColor(StdDraw.BLACK);
//            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
//              StdDraw.point(a[i].x(), a[i].y());
//               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
//               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
              // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
         //    System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
       //  if (aaa == 1)
     //  System.out.println(""                  ""+(output+1));
         //else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        Arrays.sort(a,v.DISTANCE_TO_ORDER);
 Arrays.sort(a,v.ATAN2_ORDER);
 ////////////sort
 
 for(int i=0;i<a.length;i++ )
 {System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =p2;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==0)
   {p2=i;}
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
   //  System.out.println(index[i]);
 }   
//System.out.println(""haha""+haha);

        return haha+1;
       
}
}

@7119cdbdf529ffa38427875c765759d8@"
"r04631027","2","0.48","107248","@7119cdbdf529ffa38427875c765759d8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */







import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
//import edu.princeton.cs.algs4.*;
/**
 *
 * @author YuChing
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
      
        try {
                   
            int[] count =null;
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();//D的直
            //System.out.println(line);
            double distance = Double.parseDouble(line);
            
            line = br.readLine();//測資長度
            int lengths = Integer.parseInt(line);
            count = new int[lengths];
            UF uf = new UF(lengths);
            //System.out.println(lengths);
            
           Point2D[] a = new Point2D[lengths];
           
            int i = 0;
//            StdDraw.setPenColor(StdDraw.BLACK);
//            StdDraw.setPenRadius(.01);
            while ((line = br.readLine()) != null) {

                String[] buffer = line.split("" "");
                double x = Double.parseDouble(buffer[0]);
                double y = Double.parseDouble(buffer[1]);
                a[i] = new Point2D(x, y);
//              StdDraw.point(a[i].x(), a[i].y());
//               StdDraw.text(a[i].x(), a[i].y(), a[i].x()+"" ""+a[i].y());
//               // System.out.println(a[i]);
                i++;
            }
            int p =0;
            for(int first=0;first<lengths;first++)
        {
            for(int second=first+1;second<lengths;second++)
            {
             double d = a[first].distanceTo(a[second]);
             if (d<=distance) {                 
                 uf.union(first, second);                
              // StdDraw.line(a[first].x(), a[first].y(), a[second].x(), a[second].y());                
             } else {            }
             
            }
        }
           
                    
         for(int first=0;first<lengths;first++)
        {   int u =uf.find(first);     
             for(int j=0;j<lengths;j++)
             {if(u==j)
                 count[u]++;}
         //    System.out.println(u);           
        }   
         int output =0;
         int aaa = 0;
         for(int j=0;j<lengths;j++)
             {
                 if(count[j]>2)
                 {
                     int groupfit = 0;
                      Point2D[] group = null;
                     group = new Point2D[count[j]];
                     for(int q=0;q<lengths;q++)
                 {if(uf.find(q)==j)
                 {
                     group[groupfit]=a[q];
                    // System.out.println(group[groupfit]);           
                 groupfit++;}
                     }               
               output=output+ ConvexHullVertex(group);     
               aaa++;
                 }
                    
                 }
       //  if (aaa == 1)
     //  System.out.println(""                  ""+(output+1));
         //else
             System.out.println(output);
         //////////////////////////////////////////////////////////////////upper
        } catch (IOException e) {
            System.out.println(e);
        }
        //create an edge for each pair of points with a distance <= d
       
    }

    public static int ConvexHullVertex(Point2D[] a) {
        
        Point2D v;
        Point2D[] b;
      int[] index;
      index=new int[a.length];
      index[0]=1;
      index[1]=1;
     
        b =a;     
        double low;
        low = a[0].y();
         v = a[0];
        //find the corner
        for (Point2D a1 : a) {
            if (a1.y() > low) {
            } else {
                low = a1.y();
                v = a1;
            }
        }
        //System.out.println(""v""+v);
        Arrays.sort(a,v.DISTANCE_TO_ORDER);
 Arrays.sort(a,v.ATAN2_ORDER);
 ////////////sort
 
 for(int i=0;i<a.length;i++ )
 {System.out.println(a[i]);
 }     
 int p1 =0;
 int p2 =1;

 
 
 for(int i =p2;i<a.length-1;i++)
 {
   int ccTv = Point2D.ccw(a[p1], a[p2], a[i]);
  // System.out.println(i);
   if(ccTv==0)
   {p2=i;}
   if(ccTv==1)
   {
       int ccTv2 = Point2D.ccw(a[p2], a[i], a[i+1]);
       if(ccTv2==1)
       { index[i]=1;
       p1 = p2;
       p2 = i;
       }
           
   }
  
     
 }
 int haha =0;
for(int i=0;i<index.length;i++ )
 {
     haha = haha+index[i];
   //  System.out.println(index[i]);
 }   
//System.out.println(""haha""+haha);

        return haha+1;
       
}
}

@7119cdbdf529ffa38427875c765759d8@"
"r04921115","1","0.5","108000","@c1449d1a118ae951eea9e9033ff41090@import java.util.*;
import java.io.*;
import java.lang.*;
//Hw 5-2
public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);

		for(int i = 2; i<a.length; i++){
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
		}
		int[] out = new int[hull.size()];
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
		        // 1. read in the file containing N 2-dimentional points
	        	double d = Double.parseDouble(br.readLine());
	        	int N = Integer.parseInt(br.readLine());
	        	Point2D[] point = new Point2D[N];
	            UF uf = new UF(N);
	            int n = uf.count();
	            //System.out.println(n);
	            int i, j, k;
	        	i=0;
	        	String temp;
	        	while((temp = br.readLine())!=null){
		    		String[] coordinates = temp.split("" "");
		    		double x = Double.parseDouble(coordinates[0]);
		    		double y = Double.parseDouble(coordinates[1]);
		            point[i++] = new Point2D(x, y);
		        }
				
//	        	StdDraw.setPenColor(StdDraw.BLUE);
				for(i=0; i<point.length;i++){
//					StdDraw.text(point[i].x(), point[i].y()+0.03, """"+i);
//					StdDraw.filledCircle(point[i].x(), point[i].y(), 0.008);
				}
		        
				// 2. create an edge for each pair of points with a distance <= d
//				StdDraw.setPenColor(StdDraw.GREEN);
				for(i=0; i<point.length;i++){
					for(j=0; j<point.length;j++){
						if(point[i].distanceTo(point[j])<=d){
//							point[i].drawTo(point[j]);
							uf.union(i, j);
						}
					}
				}
				
				int[] ufcontent = new int[N];
				for(i=0; i<N; i++){
					ufcontent[i]=uf.find(i);
				}
				Arrays.sort(ufcontent);
				ArrayList<Integer> arrlist = new ArrayList<Integer>();
				
				for(i=0; i<ufcontent.length; i++){
					if(i==0){
						arrlist.add(ufcontent[i++]);
					}else{
						if(ufcontent[i]>arrlist.get(arrlist.size()-1)){
							arrlist.add(ufcontent[i]);
						}
					}
				}

				int[] key = new int[arrlist.size()];
				for(i=0;i<arrlist.size();i++){
					key[i]=arrlist.get(i);
//					System.out.println(key[i]);
				}
				int h=0;
				int total=0;
				ArrayList<Point2D> pointlist = new ArrayList<Point2D>();
				for(i=0;i<key.length;i++){
					for(j=0;j<point.length;j++){
						if(key[i]==uf.find(j)){
							pointlist.add(point[j]);
						}
					}
					if(pointlist.size()>=3){
						Point2D[] intputarray = new Point2D[pointlist.size()];
						for(h = 0; h<pointlist.size(); h++){
							intputarray[h]=pointlist.get(h);
						}
						int[] m = new int[pointlist.size()];
						MyConvexHull ch = new MyConvexHull();
						m = ch.ConvexHullVertex(intputarray);
						total = m.length + total;
//						System.out.println(m.length);
//						System.out.println(""t""+total);
						pointlist.clear();
					}
				}
				System.out.println(total);
		}
	}
}


/* Assignment: HW5-1 (below)

import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int[] out = new int[hull.size()];
		//System.out.println(""hullsize:""+hull.size());
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						//System.out.println(""j""+j);
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
			//System.out.print(m[i]+"" "");
		}
	}
}

*/

@c1449d1a118ae951eea9e9033ff41090@"
"b02611026","0","0","0","@5bb49df60f14b49d796aef9ea8c54935@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import static java.lang.Math.pow;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int length = a.length;
        Point2D[] newindex = new Point2D[length];
        Point2D[] sortedindex = new Point2D[length];
        int[] convex_index = new int[length];

        //copy
        for (int i = 0; i < length; i++) {
            double newindex_x = a[i].x();
            double newindex_y = a[i].y();
            newindex[i] = new Point2D(newindex_x, newindex_y);
        }

        //find the min_y and its index is min_index
        double min_y = newindex[0].y();
        int min_index = 0;
        for (int i = 0; i < length; i++) {
            if (newindex[i].y() < min_y) {
                min_y = newindex[i].y();
                min_index = i;
            }
        }

        sortedindex[0] = newindex[0];
        newindex[0] = newindex[min_index];
        newindex[min_index] = sortedindex[0];

//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(newindex[0].x, newindex[0].y, 0.01);
        Arrays.sort(newindex, newindex[0].POLAR_ORDER);
//        for (int i = 0; i < length; i++) {
//            System.out.print(i + "":"");
//            System.out.println(newindex[i].x + newindex[i].y);
//            StdDraw.text(newindex[i].x, newindex[i].y + 0.03, Integer.toString(i));
//        }

        int j = 0;
        int first = 0;
        int middle = 1;
        int last = 2;
        int state = 0;
        while (true) {
//            System.out.print(""first middle last進入判斷"");
//            System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.println("" "" + last);
//                System.out.println("" -------- "");
            if (last > (length - 1)) {
                break;
            }
            int clockwise = Point2D.ccw(newindex[first], newindex[middle], newindex[last]);
            if (clockwise == -1) {          //clockwise                
                middle = first;
                first = convex_index[j - 1];
                last = last;
                state = 0;

//                System.out.print(""first middle last / conter順時針應變："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" -1"");
            } else if (clockwise == 1) {    //counter-clockwise                
                convex_index[j] = first;
                convex_index[j + 1] = middle;
                convex_index[j + 2] = last;

                first = middle;
                middle = last;
                last = last + 1;

                state++;
//                System.out.print(""convex_index：逆時針應變  "");
//                System.out.print(j + ""： "");
//                System.out.print(convex_index[j]);
//                //System.out.print(j+1 + ""： "");        
//                System.out.print("" "" + convex_index[j+1]);
//                //System.out.print(j+2 + ""： "");
//                System.out.println("" "" + convex_index[j+2]);
//                System.out.print(""first middle last / conter"");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 1"");

            } else if (clockwise == 0) {     //collinear
                middle = first;
                first = first - 1;
                last = last;
                state = 0;

//                System.out.print(""first middle last / conter："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 0"");
            }
            if (state >= 1) {
                j++;
            } else {
                j--;
            }

        }
        //convex_index[9] = 0;
//        System.out.println(""   "");
////        
//        System.out.println("" "");
//        for (int i = 0; i < j+2; i++) {
//            System.out.println(convex_index[i]);
//        }
//        System.out.println(""-------------------------------"");
        int[] ans = new int[j + 2];
        for (int i = 0; i < j + 2; i++) {
            for (int k = 0; k < length; k++) {
                if (newindex[convex_index[i]].x() == a[k].x() && newindex[convex_index[i]].y() == a[k].y()) {
                    ans[i] = k;
                }
            }
        }
//        for (int i = 0; i < j+2; i++) {
//            System.out.print(ans[i] + "" "");
//        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return ans;
    }

    public static void main(String[] args) {
////        StdDraw.setCanvasSize(500, 500);
//        //StdDraw.clear(StdDraw.WHITE);
//        int N = 10;
//        Point2D[] A = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            double a = StdRandom.uniform();
//            double b = StdRandom.uniform();
//            A[i] = new Point2D(a, b);
////            StdDraw.filledCircle(A[i].x(), A[i].y(), 0.01);
////            StdDraw.text(a, b - 0.03, Integer.toString(i));
//        }
//
////        for (int i = 0; i < N; i++) {
////            System.out.println(A[i].x() + A[i].y());
////        }
////        System.out.println("" "");
//        int[] ans = ConvexHullVertex(A);
//        //System.out.println(ans[0] + 1);
//        //ans[0] = ConvexHullVertex(A);
//
//        // 1. read in the file containing N 2-dimentional points
//        // 2. create an edge for each pair of points with a distance <= d
//        // 3. find connected components (CCs) with a size >= 3
//        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
//        // 5. count the number of points in N serving as a convex hull vertex, print it
        double distance = 0;
        int N = 0;
        String[][] points_read;
        double[][] points = null;

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            distance = Double.parseDouble(br.readLine());
            N = Integer.parseInt(br.readLine());
//            System.out.println(distance);
//            System.out.println(N);

            points_read = new String[N][2];

            for (int i = 0; i < N; i++) {
                String[] inputmatrix = br.readLine().split("" "");
                for (int j = 0; j < 2; j++) {
                    points_read[i][j] = inputmatrix[j];
//                    System.out.println(points_read[i][j]);
                }
            }

            points = new double[N][2];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < 2; j++) {
                    points[i][j] = Double.parseDouble(points_read[i][j]);
                }
            }

        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        } catch (IllegalArgumentException ex) {
            System.out.printf(""Failed to open the file"");
        }
        Point2D[] point = new Point2D[N];
        for (int i = 0; i < N; i++) {
            point[i] = new Point2D(points[i][0], points[i][1]);
        }

        StdDraw.setCanvasSize(500, 500);
        for (int i = 0; i < N; i++) {
            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
            StdDraw.text(point[i].x(), point[i].y() - 0.03, Integer.toString(i));
        }

        QuickFindUF uf = new QuickFindUF(N);
        double point_d;

        int i;
        int j;
        for (i = 0; i < N - 1; i++) {
            for (j = i + 1; j < N; j++) {
                point_d = pow((pow((point[i].x() - point[j].x()), 2) + pow((point[i].y() - point[j].y()), 2)), 0.5);
                if (point_d <= distance) {
//                    System.out.printf(""%d %d\n"", i, j);
                    uf.union(i, j);
                }
            }
        }

        //System.out.print(123);
        Stack<Integer> connect = new Stack<Integer>();

        int num = 0;
        int count = 0;
        int[] mark = new int[N];
        for (int a = 0; a < N; a++) {
            mark[a] = 0;
        }
        
        for (int a = 0; a < N - 1; a++) {
            if (mark[a] == 0) {
                //System.out.print(456);
                count=0;
                mark[a] = 1;
                connect.push(a);
                count++;
                //System.out.print(789);
                for (int b = a + 1; b < N; b++) {
                    if (uf.connected(a, b)) {
                        count++;
                        mark[b] = 1;
                        connect.push(b);
                        
//                        System.out.println(""count:"" + count);
                    }
                }

                Point2D[] cc = new Point2D[count];
                int[] ans = new int[count];
                if (count >= 3) {
                    for (int c = 0; c < count; c++) {
                        ans[c] = connect.pop();
//                        System.out.println(""ans:"" + ans[c]);
                    }
                    for (int c = 0; c < count; c++) {
                        cc[c] = new Point2D(point[ans[c]].x(), point[ans[c]].y());
                    }
                    int[] convex = ConvexHullVertex(cc);
//                    System.out.println(convex.length);
                    
                    num += convex.length;
                }
            }else continue;

        }
        System.out.print(num);

    }

}

@5bb49df60f14b49d796aef9ea8c54935@"
"b02611002","0","0.1","104016","@e24f169ee996531add4d273ff811c7bf@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;


/**
 * Created by zhouyuda on 4/5/16.
 */
public class Submit {
    //    public static int N;
//    public static double d;
    public static int output=0;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
        int n = a.length;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<n;i++) {
            if(a[i].y()<a[0].y()){
                Point2D temp = a[0];
                a[0] = a[i];
                a[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }


    public static void main(String[] args) throws Exception {


        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            /* 1. read in the file containing N 2-dimentional points */
            /* 讀檔，幾十個點讀入points */
            double d = Double.valueOf(br.readLine());  //d
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Point2D[] points = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                points[count] =  new Point2D(x,y);;
                count++;
            }

//            for (Point2D p:points){System.out.println(""p(brfore): ""+p);} //print(x,y)(before)

            /* points重新排序，並輸出vertex */
//            System.out.println(ConvexHullVertex(points));
//            for (Point2D p:points){System.out.println(""p(after): ""+p);} //print(x,y)(after)

            /* 以points畫圖 */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

            /* 以random點取代points */
//            N = 15;
//            points = random2DPointArr(N);
//            int[] vertexArr = ConvexHullVertex(points);
//            for (Integer i : vertexArr) {
//                System.out.println(i);
//            }
            /* 描點points(random版） */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }


            UF uf = new UF(N);

            for(int i=0;i<N;i++) {
                for (int j = i; j < N; j++) {   //走訪所有的任兩點組合(i,j)
//                    System.out.printf(""掃點：(%d,%d)\n"", i, j);
                    if (points[i].distanceTo(points[j]) <= d) {  //發現距離夠近的兩點則將兩個index嘗試放進CCs中
//                        points[i].drawTo(points[j]);
                        uf.union(i,j);
                    }
                }
            }

            /* 印出uf */
            for(int ii=0;ii<N;ii++){
//                System.out.println(""印出uf: ""+uf.find(ii));
            }

            ArrayList<Stack<Integer>> AA = new ArrayList<>();
            for(int i=0;i<N;i++){
                AA.add(new Stack<>());
            }
            for(int ii=0;ii<N;ii++){    //ii: 0,1,2,3,4,5,6,7,8,9
                AA.get(uf.find(ii)).add(ii);
            }

//            System.out.println(AA);

            for(Stack subgp:AA){
                if(subgp.size()>=3){    //跑兩次
                    Point2D[] aa = new Point2D[subgp.size()];
                    int cont = 0;
                    for(Object io:subgp){   //跑五次、跑三次
                        int index = Integer.valueOf(io.toString());
                        aa[cont]=points[index];
                        cont++;
                    }
//                    for(Point2D aaa:aa){System.out.println(aaa);}

                    for(int iiii:ConvexHullVertex(aa)){
//                        System.out.println(""vertexs: ""+iiii);
                    }
                    output+=ConvexHullVertex(aa).length;

                }
            }
            System.out.println(output);
        }
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D[] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@e24f169ee996531add4d273ff811c7bf@"
"b02611002","5","0.096","107584","@3ca98c5b7aec09637aa2879150ce61f1@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;
import java.util.Stack;


/**
 * Created by zhouyuda on 4/5/16.
 */
public class MyConvexHull {
    //    public static int N;
//    public static double d;
    public static int output=0;

    public static int[] ConvexHullVertex(Point2D[] a) {

        ArrayList<Point2D> copy = new ArrayList<>();
        for (int i=0;i<a.length;i++){
            copy.add(a[i]);
        }

        boolean routing = true;
        int n = a.length;
//        for (Point2D p:copy){System.out.println(""unsorted(copy): ""+p);}

        /* 將y座標最小者與points[0]對調 */
        for (int i=0;i<n;i++) {
            if(a[i].y()<a[0].y()){
                Point2D temp = a[0];
                a[0] = a[i];
                a[i] = temp;
            }
        }
        /* 排序 */
        Arrays.sort(a,a[0].POLAR_ORDER);
//        for (Point2D p:a){System.out.println(""sorted: ""+p);}


        /* routing prepare */
        Stack<Integer> ans = new Stack<>();
        int s1 = 0, s2 = 1, now = 2;
        ans.push(s1);
        ans.push(s2);
        ans.push(now);
        /* routing */
        while (routing){

            boolean ccwTrue=false;

//            for(Integer i : ans){System.out.println(i);}

            if(now==a.length){ // now到10時停止
                routing=false;
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[0])==1;
            }else {
                ccwTrue = Point2D.ccw(a[s1],a[s2],a[now])==1;
            }

            if(ccwTrue){
                ans.push(now+1);
                now=ans.elementAt(ans.size()-1);
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }else {
                ans.pop();
                ans.pop();
                ans.push(now);
                //now不變
                s2=ans.elementAt(ans.size()-2);
                s1=ans.elementAt(ans.size()-3);
                continue;
            }
        }
        ans.pop();
        ans.pop();

        int[] vertexs = new int[ans.size()];

        int j = 0;
        for(Integer i : ans){
            vertexs[j]=i;
            j++;
        }

        int counter=0;
        int[] returnVal = new int[vertexs.length];

        for(Integer k:vertexs){
//            System.out.println(""vertexs: ""+a[k]);
            for(int i=0;i<copy.size();i++){
                if(copy.get(i)==a[k]){
                    returnVal[counter]=i;
                    counter++;
                }
            }
        }

        return returnVal;
    }


    public static void main(String[] args) throws Exception {


        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            /* 1. read in the file containing N 2-dimentional points */
            /* 讀檔，幾十個點讀入points */
            double d = Double.valueOf(br.readLine());  //d
            int N = Integer.valueOf(br.readLine()); //有幾個點
            Point2D[] points = new Point2D[N];
            int count=0;
            while(br.ready()) {
                String[] data = br.readLine().split("" "");
                double x = Double.valueOf(data[0]);
                double y = Double.valueOf(data[1]);
                points[count] =  new Point2D(x,y);;
                count++;
            }

//            for (Point2D p:points){System.out.println(""p(brfore): ""+p);} //print(x,y)(before)

            /* points重新排序，並輸出vertex */
//            System.out.println(ConvexHullVertex(points));
//            for (Point2D p:points){System.out.println(""p(after): ""+p);} //print(x,y)(after)

            /* 以points畫圖 */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }

            /* 以random點取代points */
//            N = 15;
//            points = random2DPointArr(N);
//            int[] vertexArr = ConvexHullVertex(points);
//            for (Integer i : vertexArr) {
//                System.out.println(i);
//            }
            /* 描點points(random版） */
//            StdDraw.setPenColor(StdDraw.RED);
//            for (int i = 0; i < N; i++) {
//                if (i > 0) {
//                    StdDraw.setPenColor(StdDraw.BLUE);
//                }
//                StdDraw.filledCircle(points[i].x(), points[i].y(), 0.01);
//                StdDraw.text(points[i].x(), points[i].y() + 0.01, String.valueOf(i));
//            }


            UF uf = new UF(N);

            for(int i=0;i<N;i++) {
                for (int j = i; j < N; j++) {   //走訪所有的任兩點組合(i,j)
//                    System.out.printf(""掃點：(%d,%d)\n"", i, j);
                    if (points[i].distanceTo(points[j]) <= d) {  //發現距離夠近的兩點則將兩個index嘗試放進CCs中
//                        points[i].drawTo(points[j]);
                        uf.union(i,j);
                    }
                }
            }

            /* 印出uf */
            for(int ii=0;ii<N;ii++){
//                System.out.println(""印出uf: ""+uf.find(ii));
            }

            ArrayList<Stack<Integer>> AA = new ArrayList<>();
            for(int i=0;i<N;i++){
                AA.add(new Stack<>());
            }
            for(int ii=0;ii<N;ii++){    //ii: 0,1,2,3,4,5,6,7,8,9
                AA.get(uf.find(ii)).add(ii);
            }

//            System.out.println(AA);

            for(Stack subgp:AA){
                if(subgp.size()>=3){    //跑兩次
                    Point2D[] aa = new Point2D[subgp.size()];
                    int cont = 0;
                    for(Object io:subgp){   //跑五次、跑三次
                        int index = Integer.valueOf(io.toString());
                        aa[cont]=points[index];
                        cont++;
                    }
//                    for(Point2D aaa:aa){System.out.println(aaa);}

                    for(int iiii:ConvexHullVertex(aa)){
//                        System.out.println(""vertexs: ""+iiii);
                    }
                    output+=ConvexHullVertex(aa).length;

                }
            }
            System.out.println(output);
        }
    }
    public static Point2D[] random2DPointArr(int N) {
        Point2D[] arr = new Point2D[N];
        for (int i=0;i<N;i++) {
            arr[i] = random2DPoint();
//            System.out.println(""created""+arr[i]);
        }
        return arr;
    }
    public static Point2D random2DPoint() {
        return new Point2D(StdRandom.uniform(),StdRandom.uniform());
    }
}
@3ca98c5b7aec09637aa2879150ce61f1@"
"b02611026","5","0.098","108080","@8e5e02c3148859fe835b0c3658a91f61@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import static java.lang.Math.pow;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        int length = a.length;
        Point2D[] newindex = new Point2D[length];
        Point2D[] sortedindex = new Point2D[length];
        int[] convex_index = new int[length];

        //copy
        for (int i = 0; i < length; i++) {
            double newindex_x = a[i].x();
            double newindex_y = a[i].y();
            newindex[i] = new Point2D(newindex_x, newindex_y);
        }

        //find the min_y and its index is min_index
        double min_y = newindex[0].y();
        int min_index = 0;
        for (int i = 0; i < length; i++) {
            if (newindex[i].y() < min_y) {
                min_y = newindex[i].y();
                min_index = i;
            }
        }

        sortedindex[0] = newindex[0];
        newindex[0] = newindex[min_index];
        newindex[min_index] = sortedindex[0];

//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(newindex[0].x, newindex[0].y, 0.01);
        Arrays.sort(newindex, newindex[0].POLAR_ORDER);
//        for (int i = 0; i < length; i++) {
//            System.out.print(i + "":"");
//            System.out.println(newindex[i].x + newindex[i].y);
//            StdDraw.text(newindex[i].x, newindex[i].y + 0.03, Integer.toString(i));
//        }

        int j = 0;
        int first = 0;
        int middle = 1;
        int last = 2;
        int state = 0;
        while (true) {
//            System.out.print(""first middle last進入判斷"");
//            System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.println("" "" + last);
//                System.out.println("" -------- "");
            if (last > (length - 1)) {
                break;
            }
            int clockwise = Point2D.ccw(newindex[first], newindex[middle], newindex[last]);
            if (clockwise == -1) {          //clockwise                
                middle = first;
                first = convex_index[j - 1];
                last = last;
                state = 0;

//                System.out.print(""first middle last / conter順時針應變："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" -1"");
            } else if (clockwise == 1) {    //counter-clockwise                
                convex_index[j] = first;
                convex_index[j + 1] = middle;
                convex_index[j + 2] = last;

                first = middle;
                middle = last;
                last = last + 1;

                state++;
//                System.out.print(""convex_index：逆時針應變  "");
//                System.out.print(j + ""： "");
//                System.out.print(convex_index[j]);
//                //System.out.print(j+1 + ""： "");        
//                System.out.print("" "" + convex_index[j+1]);
//                //System.out.print(j+2 + ""： "");
//                System.out.println("" "" + convex_index[j+2]);
//                System.out.print(""first middle last / conter"");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 1"");

            } else if (clockwise == 0) {     //collinear
                middle = first;
                first = first - 1;
                last = last;
                state = 0;

//                System.out.print(""first middle last / conter："");
//                System.out.print(first);
//                System.out.print("" "" + middle);
//                System.out.print("" "" + last);
//                System.out.println("" 0"");
            }
            if (state >= 1) {
                j++;
            } else {
                j--;
            }

        }
        //convex_index[9] = 0;
//        System.out.println(""   "");
////        
//        System.out.println("" "");
//        for (int i = 0; i < j+2; i++) {
//            System.out.println(convex_index[i]);
//        }
//        System.out.println(""-------------------------------"");
        int[] ans = new int[j + 2];
        for (int i = 0; i < j + 2; i++) {
            for (int k = 0; k < length; k++) {
                if (newindex[convex_index[i]].x() == a[k].x() && newindex[convex_index[i]].y() == a[k].y()) {
                    ans[i] = k;
                }
            }
        }
//        for (int i = 0; i < j+2; i++) {
//            System.out.print(ans[i] + "" "");
//        }
        // 回傳ConvexHullVertex的index set，index 請依該點在a陣列中的順序編號：0, 1, 2, 3, 4, ....a.length-1
        return ans;
    }

    public static void main(String[] args) {
////        StdDraw.setCanvasSize(500, 500);
//        //StdDraw.clear(StdDraw.WHITE);
//        int N = 10;
//        Point2D[] A = new Point2D[N];
//        for (int i = 0; i < N; i++) {
//            double a = StdRandom.uniform();
//            double b = StdRandom.uniform();
//            A[i] = new Point2D(a, b);
////            StdDraw.filledCircle(A[i].x(), A[i].y(), 0.01);
////            StdDraw.text(a, b - 0.03, Integer.toString(i));
//        }
//
////        for (int i = 0; i < N; i++) {
////            System.out.println(A[i].x() + A[i].y());
////        }
////        System.out.println("" "");
//        int[] ans = ConvexHullVertex(A);
//        //System.out.println(ans[0] + 1);
//        //ans[0] = ConvexHullVertex(A);
//
//        // 1. read in the file containing N 2-dimentional points
//        // 2. create an edge for each pair of points with a distance <= d
//        // 3. find connected components (CCs) with a size >= 3
//        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
//        // 5. count the number of points in N serving as a convex hull vertex, print it
        double distance = 0;
        int N = 0;
        String[][] points_read;
        double[][] points = null;

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            distance = Double.parseDouble(br.readLine());
            N = Integer.parseInt(br.readLine());
//            System.out.println(distance);
//            System.out.println(N);

            points_read = new String[N][2];

            for (int i = 0; i < N; i++) {
                String[] inputmatrix = br.readLine().split("" "");
                for (int j = 0; j < 2; j++) {
                    points_read[i][j] = inputmatrix[j];
//                    System.out.println(points_read[i][j]);
                }
            }

            points = new double[N][2];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < 2; j++) {
                    points[i][j] = Double.parseDouble(points_read[i][j]);
                }
            }

        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        } catch (IllegalArgumentException ex) {
            System.out.printf(""Failed to open the file"");
        }
        Point2D[] point = new Point2D[N];
        for (int i = 0; i < N; i++) {
            point[i] = new Point2D(points[i][0], points[i][1]);
        }
//
////        StdDraw.setCanvasSize(500, 500);
//        for (int i = 0; i < N; i++) {
//            StdDraw.filledCircle(point[i].x(), point[i].y(), 0.01);
//            StdDraw.text(point[i].x(), point[i].y() - 0.03, Integer.toString(i));
//        }

        QuickFindUF uf = new QuickFindUF(N);
        double point_d;

        int i;
        int j;
        for (i = 0; i < N - 1; i++) {
            for (j = i + 1; j < N; j++) {
                point_d = pow((pow((point[i].x() - point[j].x()), 2) + pow((point[i].y() - point[j].y()), 2)), 0.5);
                if (point_d <= distance) {
//                    System.out.printf(""%d %d\n"", i, j);
                    uf.union(i, j);
                }
            }
        }

        //System.out.print(123);
        Stack<Integer> connect = new Stack<Integer>();

        int num = 0;
        int count = 0;
        int[] mark = new int[N];
        for (int a = 0; a < N; a++) {
            mark[a] = 0;
        }
        
        for (int a = 0; a < N - 1; a++) {
            if (mark[a] == 0) {
                //System.out.print(456);
                count=0;
                mark[a] = 1;
                connect.push(a);
                count++;
                //System.out.print(789);
                for (int b = a + 1; b < N; b++) {
                    if (uf.connected(a, b)) {
                        count++;
                        mark[b] = 1;
                        connect.push(b);
                        
//                        System.out.println(""count:"" + count);
                    }
                }

                Point2D[] cc = new Point2D[count];
                int[] ans = new int[count];
                if (count >= 3) {
                    for (int c = 0; c < count; c++) {
                        ans[c] = connect.pop();
//                        System.out.println(""ans:"" + ans[c]);
                    }
                    for (int c = 0; c < count; c++) {
                        cc[c] = new Point2D(point[ans[c]].x(), point[ans[c]].y());
                    }
                    int[] convex = ConvexHullVertex(cc);
//                    System.out.println(convex.length);
                    
                    num += convex.length;
                }
            }else continue;

        }
        System.out.print(num);

    }

}

@8e5e02c3148859fe835b0c3658a91f61@"
"r04945022","2","0.44","105344","@7d8ebeb84a15e72083603dda01588640@import java.util.*;

/**
 *
 * @author Daniel
 */
public class MyConvexHull {
 
public static int[] ConvexHullVertex(Point2D[] s){
    ArrayList<Point2D> myarray = new ArrayList<Point2D>();
    for(Point2D a:s){
        myarray.add(a);
    }
    int miny = Findlowesty(s);
    Point2D first = s[miny];
    quickSort(s, first.ATAN2_ORDER);
    Stack<Point2D> convex = new Stack<Point2D>();
    convex.push(s[0]);
    convex.push(s[1]);
    for(int i=2;i<s.length;i++){
        Point2D b =convex.pop();
        Point2D a = convex.pop();
        Point2D c =s[i];
        while(Point2D.ccw(a, b, c)!=1){
            b = a;
            a = convex.pop();
        }
        convex.push(a);
        convex.push(b);
        convex.push(c);
    }
        Stack<Point2D> oppo = new Stack<Point2D>();
        while(!convex.isEmpty()){
            oppo.push(convex.pop());
        }
        convex = oppo;
        Iterator<Point2D> it = convex.iterator();
        int count = 0;
        int[] ref = new int[convex.size()];
        while(it.hasNext()){
            Point2D n = it.next();
            ref[count++] = myarray.indexOf(n);
        }
    Arrays.sort(ref);
    return ref;
}
    public static void quickSort(Point2D[] s, Comparator<Point2D> x){
        Sort_2D(s, x, 0, s.length-1);
    }
    
 
 
 
 public static int Findlowesty(Point2D[] f){
     int miniy = 0;
     for(int i =0; i<f.length;i++){
         if(Point2D.Y_ORDER.compare(f[miniy], f[i])==1){
             miniy = i;
         }

     }
     return miniy;
 }
 
 
// public static Point2D[] Relativepoint(Point2D[] a){
//     int miniy = Findlowesty(a);
//     Point2D[] a1 = new Point2D[a.length];
//     for (int i =0; i< a.length;++i){
//         a1[i] = new Point2D(a[i].x() - a[miniy].x(), a[i].y() - a[miniy].y());
//     }
//     return a1;
// }
 
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        System.out.println(""0"");
        // TODO code application logic here
    }

    private static void Sort_2D(Point2D[] s, Comparator<Point2D> x, int head, int end) {
       if(head>=end){
           return;
       }
       Point2D mid = s[head];
       int left = head;
       int right = end+1;
       while(true){
           while(x.compare(mid, s[++left])==1){
               if(left==end) break;
           }
           while(x.compare(mid, s[--right])==-1){
               if(right>=head) break;
           }
           if(left>=right) break;
           Point2D temp =s[left];
           s[left] = s[right];
           s[right] = temp;
           
       }
       
       s[head]= s[right];
       s[right] = mid;
       
       Sort_2D(s, x, head, right-1);
       Sort_2D(s, x, right+1, end);
       
 }
    
}

@7d8ebeb84a15e72083603dda01588640@"
"r04921065","5","0.098","106176","@8fd54be54e5ac31c51360a86c187a2c6@
//package myconvexhull;

//import edu.princeton.cs.alg4.Point2D;
//import WeightedQuickUnionUF;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Stack;

/**
 *
 * @author steven
 */
public class MyConvexHull {
    
    
    
    public int CCW(java.awt.geom.Point2D a,java.awt.geom.Point2D b, java.awt.geom.Point2D c){
        double ax=a.getX(),ay=a.getY(),bx=b.getX(),by=b.getY(),cx=c.getX(),cy=c.getY();
        double area=(bx-ax)*(cy-ay)-(by-ay)*(cx-ax);
        if (area>0) return 1;
        else if (area==0) return 0;
        else return -1;
    }
    class point{
        public point(java.awt.geom.Point2D Point){
            this.startPoint=Point;
            }
            private java.awt.geom.Point2D startPoint;
            class polarComparator implements Comparator<pointWithIndex>{
                @Override
                public int compare(pointWithIndex t1, pointWithIndex t2) {
                    double dy1=t1.p.getY()-startPoint.getY();
                    double dy2=t2.p.getY()-startPoint.getY();
                    double dx1=t1.p.getX()-startPoint.getX();
                    double dx2=t2.p.getX()-startPoint.getX();
                    
                    if (dy1==0 && dy2==0){
                        if      (dx1 >= 0 && dx2 < 0) return -1;
                        else if (dx2 >= 0 && dx1 < 0) return +1;
                        else                          return  0;
                    }
                    else if (dy1>=0 && dy2<0) return -1;
                    else if (dy2>=0 && dy1<0) return 1;
                    else 
                    return -CCW(startPoint,t1.p,t2.p);
                    }
            }

        }
        class pointWithIndex{
            private java.awt.geom.Point2D p;
            private int index;
            public pointWithIndex(java.awt.geom.Point2D p,int index){
                this.p=p;
                this.index=index;
            }
        }

        class yPoint2DComparator implements Comparator<pointWithIndex>{
            @Override
            public int compare(pointWithIndex p1, pointWithIndex p2) {
                if (p1.p.getY()>p2.p.getY()) return 1;
                else if (p1.p.getY()<p2.p.getY()) return -1;
                else return 0;
            }
        }
        
    public int[] ConvexHullVertex(Point2D[] a){
        /*java.awt.geom.Point2D[] a = new java.awt.geom.Point2D[alg4_a.length];
        for (int i=0;i<alg4_a.length;i++){
            a[i]=new java.awt.geom.Point2D.Double(alg4_a[i].x(),alg4_a.y()) ;
        }*/
        
        
        boolean[] b=new boolean[a.length];

        //for (double item : y){System.out.println(item);}
        pointWithIndex[] A=new pointWithIndex[a.length];
        for (int i=0;i<a.length;i++){
            A[i]=new pointWithIndex(a[i],i);
        }
        
        Arrays.sort(A, new yPoint2DComparator());
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        point points = new point(A[0].p);
        
        
        pointWithIndex[] new_A=Arrays.copyOfRange(A,1,A.length);
        Arrays.sort(new_A,  points.new polarComparator());
        System.arraycopy(new_A,0,A,1,new_A.length);
        
        //for (pointWithIndex item : A){System.out.println(item.p);}
        
        Stack<pointWithIndex> st = new Stack();
        Stack<Integer> st2=new Stack();
        st.push(A[0]);
        st.push(A[1]);
        //st.push(A[2]);

        int j=2;
        while (j<a.length){
            //
            //System.out.println(""looping..."");
            pointWithIndex second=st.pop();
            pointWithIndex first=st.pop();
            pointWithIndex third =A[j];

            switch(CCW(first.p,second.p,third.p)){
                case 1:
                    //System.out.println(""case:1"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case 0:
                    //System.out.println(""case:0"");
                    st.push(first);
                    st.push(second);
                    st.push(third);
                    j++;
                    break;
                case -1:
                    //System.out.println(""case:-1"");
                    st.push(first);
                    break;
            }
        }
        int[] ans=new int[st.size()];
        int i =0;
        while(!st.empty()){
            ans[i]=st.pop().index;
            i++;
        }
        return ans;

    }
    
    public static void main(String[] args) throws Exception {
        /*Point2D.Double p1,p2,p3,p4,p5;
        p1 = new Point2D.Double(0.200,0.1);
        p2 = new Point2D.Double(0.5,0.5);
        p3 = new Point2D.Double(0.5,0.2);
        p4 = new Point2D.Double(0.2,0.5);
        p5 = new Point2D.Double(0.3,0.3);
        Point2D[] p_arr={p1,p2,p3,p4,p5};
        MyConvexHull my=new MyConvexHull() ;
        int[] v_arr=my.ConvexHullVertex(p_arr);*/
        //for (int item : v_arr){System.out.println(item);}
        MyConvexHull myconvexhull=new MyConvexHull();
        float d ;
        int N;
        Point2D[] input;
        WeightedQuickUnionUF qf;
        boolean[] b;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
               d=Float.parseFloat(br.readLine());
               N=Integer.parseInt(br.readLine());
               input=new Point2D[N];
               qf=new WeightedQuickUnionUF(N);
               b= new boolean[N];
            for (int i=0;i<N;i++){
                String[] temp=br.readLine().split("" "");
                double x = Double.parseDouble(temp[0]);
                double y = Double.parseDouble(temp[1]);
                input[i] = new Point2D.Double(x,y);
                
            }
        }
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (input[i].distance (input[j])<d)
                        qf.union(i,j);
            }
        }
            int count=0;
            for (int i=0;i<N;i++){
                //System.out.println(""For Looping..."");
                if (b[i]){}
                else{
                    ArrayList<java.awt.geom.Point2D> temp=new ArrayList<java.awt.geom.Point2D>();
                    for (int j=0;j<N;j++){
                        if (qf.connected(i,j)){
                            b[i]=true;
                            b[j]=true;
                            temp.add(input[j]);
                        }
                    }
                    //
                    //for (Point2D item : temp){System.out.println(item);}
                    if (temp.size()>2){
                        java.awt.geom.Point2D[] tempArray=new java.awt.geom.Point2D[temp.size()];
                        count=myconvexhull.ConvexHullVertex(temp.toArray(tempArray)).length+count;
                        //System.out.println(count);
                    }
                }
            }
        System.out.println(count);
    }
}

@8fd54be54e5ac31c51360a86c187a2c6@"
"r04921115","5","0.098","105808","@5656a64ab7f35dfe1f2cd58545b54870@import java.util.*;
import java.io.*;
import java.lang.*;
//Hw 5-2
public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);

		for(int i = 2; i<a.length; i++){
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
		}
		int[] out = new int[hull.size()];
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
		        // 1. read in the file containing N 2-dimentional points
	        	double d = Double.parseDouble(br.readLine());
	        	int N = Integer.parseInt(br.readLine());
	        	Point2D[] point = new Point2D[N];
	            UF uf = new UF(N);
	            int n = uf.count();
	            //System.out.println(n);
	            int i, j, k;
	        	i=0;
	        	String temp;
	        	while((temp = br.readLine())!=null){
		    		String[] coordinates = temp.split("" "");
		    		double x = Double.parseDouble(coordinates[0]);
		    		double y = Double.parseDouble(coordinates[1]);
		            point[i++] = new Point2D(x, y);
		        }
				
//	        	StdDraw.setPenColor(StdDraw.BLUE);
				for(i=0; i<point.length;i++){
//					StdDraw.text(point[i].x(), point[i].y()+0.03, """"+i);
//					StdDraw.filledCircle(point[i].x(), point[i].y(), 0.008);
				}
		        
				// 2. create an edge for each pair of points with a distance <= d
//				StdDraw.setPenColor(StdDraw.GREEN);
				for(i=0; i<point.length;i++){
					for(j=0; j<point.length;j++){
						if(point[i].distanceTo(point[j])<=d){
//							point[i].drawTo(point[j]);
							uf.union(i, j);
						}
					}
				}
				
				int[] ufcontent = new int[N];
				for(i=0; i<N; i++){
					ufcontent[i]=uf.find(i);
				}
				Arrays.sort(ufcontent);
				ArrayList<Integer> arrlist = new ArrayList<Integer>();
				
				for(i=0; i<ufcontent.length; i++){
					if(i==0){
						arrlist.add(ufcontent[i++]);
					}else{
						if(ufcontent[i]>arrlist.get(arrlist.size()-1)){
							arrlist.add(ufcontent[i]);
						}
					}
				}

				int[] key = new int[arrlist.size()];
				for(i=0;i<arrlist.size();i++){
					key[i]=arrlist.get(i);
//					System.out.println(key[i]);
				}
				int h=0;
				int total=0;
				ArrayList<Point2D> pointlist = new ArrayList<Point2D>();
				for(i=0;i<key.length;i++){
					for(j=0;j<point.length;j++){
						if(key[i]==uf.find(j)){
							pointlist.add(point[j]);
						}
					}
					if(pointlist.size()>=3){
						Point2D[] intputarray = new Point2D[pointlist.size()];
						for(h = 0; h<pointlist.size(); h++){
							intputarray[h]=pointlist.get(h);
						}
						int[] m = new int[pointlist.size()];
						MyConvexHull ch = new MyConvexHull();
						m = ch.ConvexHullVertex(intputarray);
						total = m.length + total;
//						System.out.println(m.length);
//						System.out.println(""t""+total);
					}
						pointlist.clear();

				}
				System.out.println(total);
		}
	}
}


/* Assignment: HW5-1 (below)

import java.util.*;
import java.lang.*;

public class MyConvexHull {
	public static int[] ConvexHullVertex (Point2D[] a){
		Point2D[] b = new Point2D[a.length];
		int[] index = new int[a.length];
		
		for(int i = 0; i<a.length; i++){
			b[i]=a[i];
			index[i]=i;
		}

		Stack<Point2D> hull = new Stack<Point2D>();
		Stack<Integer> inthull = new Stack<Integer>(); 
		Arrays.sort(a, Point2D.Y_ORDER);
		Arrays.sort(a, a[0].POLAR_ORDER);

		hull.push(a[0]);
		hull.push(a[1]);
		inthull.push(index[0]);
		inthull.push(index[1]);
		
//		StdDraw.setPenColor(StdDraw.BLUE);
//		StdDraw.text(a[0].x(), a[0].y()+0.03, """"+0);
//		StdDraw.text(a[1].x(), a[1].y()+0.03, """"+1);
//		StdDraw.text(a[a.length-1].x(), a[a.length-1].y()+0.03, """"+(a.length-1));
//		a[0].drawTo(a[1]);
//		a[a.length-1].drawTo(a[0]);

		for(int i = 2; i<a.length; i++){
//			StdDraw.setPenColor(StdDraw.BLUE);
//			StdDraw.text(a[i].x(), a[i].y()+0.03, """"+i);
//			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.008);
			Point2D top = hull.pop();
			int inttop = inthull.pop();
			while(Point2D.ccw(hull.peek(), top, a[i]) <=0){
				top = hull.pop();
				inttop = inthull.pop();
			}
			hull.push(top);
			inthull.push(inttop);
			hull.push(a[i]);
			inthull.push(index[i]);
			
//			StdDraw.setPenColor(StdDraw.RED);
//			top.drawTo(a[i]);
		}
		int[] out = new int[hull.size()];
		//System.out.println(""hullsize:""+hull.size());
		int i = 0;
		while(!hull.isEmpty()){
				Point2D temp = hull.pop();
				for(int j=0;j<a.length;j++){
					if(temp.compareTo(b[j])==0){
						//System.out.println(""j""+j);
						out[i++]=j;
						break;
					}
				}
		}
		Arrays.sort(out);
		return out;
	}
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] point = new Point2D[N];
		int[] m = new int[N];
		double min_y = 0;
		double min_x = 0;
		int min = 0;
		int find = 0;
		int fail =0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				point[i] = new Point2D(x, y);
		}
		MyConvexHull ch = new MyConvexHull();
		m = ch.ConvexHullVertex(point);
		for(int i=0; i<m.length; i++){
			//System.out.print(m[i]+"" "");
		}
	}
}

*/

@5656a64ab7f35dfe1f2cd58545b54870@"
"b01703032","0","0","0","@5b9b1370f1c8e40d97c49e3ac71ada1d@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader(new FileReader(args[0]));
double distance = Double.parseDouble(br.readLine());
int num = Integer.parseInt(br.readLine());
            distance = 0.3;
            num = 12;
Point2D[] points = new Point2D[num];
for(int i = 0  ; i < num ; i++){
                points[i] = new Point2D(Math.random(),Math.random());
System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }
int[] parents = new int[num];
for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);
for(int i = 0 ; i < num ; i++){
Point2D p1 = points[i];
for(int j = 0 ; j < num ; j++){
Point2D p2 = points[j];
if(p1.distanceTo(p2) < distance){
int root1 = getRoot(parents,i);
int root2 = getRoot(parents,j);
if(root1<=root2)
                            parents[root2] = root1;
else
                            parents[root1] = root2;
                    }
                }
            }
for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }
System.out.print(""label:"");
            printArray(parents);
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i:parents){
if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }
/*StdDraw.setCanvasSize(800,800);
StdDraw.setXscale(-0.1,1.1);
StdDraw.setYscale(-0.1,1.1);
StdDraw.setPenRadius(0.02);
for(int i = 0 ; i < num ; i++) {
Point2D p1 = points[i];
                p1.draw();
StdDraw.setPenRadius(0.002);
StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
StdDraw.setPenRadius(0.02);
StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
StdDraw.setPenColor(StdDraw.MAGENTA); */
int totalConvexHull = 0;
for(Map.Entry<Integer,Integer> entry:map.entrySet()){
System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());
Point2D[] pointGroup = new Point2D[entry.getValue()];
int count = 0;
for(int i = 0 ; i < parents.length ; i++){
if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
if(pointGroup.length > 2){
Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }
//            System.out.println(totalConvexHull);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
public static int getRoot(int[] parents , int index){
while(parents[index]!=index)
            index = parents[index];
return index;
    }
public static void printArray(int[] array){
String sp = """";
System.out.print(""["");
for(int i:array){
System.out.print(sp + i);
            sp = "","";
        }
System.out.println(""]"");
    }
public static int[] ConvexHullVertex(Point2D[] points) {
ArrayList<Point2D> array = new ArrayList<Point2D>();
for(Point2D p:points){
            array.add(p);
        }
int min = findMinY(points);
Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);
Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
for(int i = 2 ; i < points.length ; i++){
Point2D b = convexhull.pop();
Point2D a = convexhull.pop();
Point2D c = points[i];
while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }
Stack<Point2D> reverse = new Stack<Point2D>();
while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;
Iterator<Point2D> iterator = convexhull.iterator();
int count = 0;
int[] index = new int[convexhull.size()];
while (iterator.hasNext()) {
Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
return index;
    }
public static int findMinY (Point2D[] points){
int min = 0;
for(int i = 0 ; i < points.length ; i++){
if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
return min;
    }
public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }
public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {
if(start >= end) return;
Point2D pivot = array[start];
int left = start;
int right = end+1;
while (true){
while (c.compare(pivot , array[++left]) == 1)
if (left == end) break;
while (c.compare(pivot , array[--right]) == -1)
if (right == start) break;
if(left >= right) break;
Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;
        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);
    }
}
@5b9b1370f1c8e40d97c49e3ac71ada1d@"
"b01703032","0","0","0","@c44314e4c34d2d32c5e4e2d7fe8b6d58@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader(new FileReader(args[0]));
double distance = Double.parseDouble(br.readLine());
int num = Integer.parseInt(br.readLine());
            distance = 0.3;
            num = 12;
Point2D[] points = new Point2D[num];
for(int i = 0  ; i < num ; i++){
                points[i] = new Point2D(Math.random(),Math.random());
System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }
int[] parents = new int[num];
for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);
for(int i = 0 ; i < num ; i++){
Point2D p1 = points[i];
for(int j = 0 ; j < num ; j++){
Point2D p2 = points[j];
if(p1.distanceTo(p2) < distance){
int root1 = getRoot(parents,i);
int root2 = getRoot(parents,j);
if(root1<=root2)
                            parents[root2] = root1;
else
                            parents[root1] = root2;
                    }
                }
            }
for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }
System.out.print(""label:"");
            printArray(parents);
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i:parents){
if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }
StdDraw.setCanvasSize(800,800);
StdDraw.setXscale(-0.1,1.1);
StdDraw.setYscale(-0.1,1.1);
StdDraw.setPenRadius(0.02);
for(int i = 0 ; i < num ; i++) {
Point2D p1 = points[i];
                p1.draw();
StdDraw.setPenRadius(0.002);
StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
StdDraw.setPenRadius(0.02);
StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
StdDraw.setPenColor(StdDraw.MAGENTA);
int totalConvexHull = 0;
for(Map.Entry<Integer,Integer> entry:map.entrySet()){
System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());
Point2D[] pointGroup = new Point2D[entry.getValue()];
int count = 0;
for(int i = 0 ; i < parents.length ; i++){
if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
if(pointGroup.length > 2){
Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }
//            System.out.println(totalConvexHull);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
public static int getRoot(int[] parents , int index){
while(parents[index]!=index)
            index = parents[index];
return index;
    }
public static void printArray(int[] array){
String sp = """";
System.out.print(""["");
for(int i:array){
System.out.print(sp + i);
            sp = "","";
        }
System.out.println(""]"");
    }
public static int[] ConvexHullVertex(Point2D[] points) {
ArrayList<Point2D> array = new ArrayList<Point2D>();
for(Point2D p:points){
            array.add(p);
        }
int min = findMinY(points);
Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);
Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
for(int i = 2 ; i < points.length ; i++){
Point2D b = convexhull.pop();
Point2D a = convexhull.pop();
Point2D c = points[i];
while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }
Stack<Point2D> reverse = new Stack<Point2D>();
while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;
Iterator<Point2D> iterator = convexhull.iterator();
int count = 0;
int[] index = new int[convexhull.size()];
while (iterator.hasNext()) {
Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
return index;
    }
public static int findMinY (Point2D[] points){
int min = 0;
for(int i = 0 ; i < points.length ; i++){
if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
return min;
    }
public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }
public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {
if(start >= end) return;
Point2D pivot = array[start];
int left = start;
int right = end+1;
while (true){
while (c.compare(pivot , array[++left]) == 1)
if (left == end) break;
while (c.compare(pivot , array[--right]) == -1)
if (right == start) break;
if(left >= right) break;
Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;
        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);
    }
}
@c44314e4c34d2d32c5e4e2d7fe8b6d58@"
"b01703032","0","0","0","@c25fa94cff3ce905b2ff93beccc5a75b@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader(new FileReader(args[0]));
double distance = Double.parseDouble(br.readLine());
int num = Integer.parseInt(br.readLine());
            distance = 0.3;
            num = 12;
Point2D[] points = new Point2D[num];
for(int i = 0  ; i < num ; i++){
                points[i] = new Point2D(Math.random(),Math.random());
System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }
int[] parents = new int[num];
for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);
for(int i = 0 ; i < num ; i++){
Point2D p1 = points[i];
for(int j = 0 ; j < num ; j++){
Point2D p2 = points[j];
if(p1.distanceTo(p2) < distance){
int root1 = getRoot(parents,i);
int root2 = getRoot(parents,j);
if(root1<=root2)
                            parents[root2] = root1;
else
                            parents[root1] = root2;
                    }
                }
            }
for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }
System.out.print(""label:"");
            printArray(parents);
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i:parents){
if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }
/*StdDraw.setCanvasSize(800,800);
StdDraw.setXscale(-0.1,1.1);
StdDraw.setYscale(-0.1,1.1);
StdDraw.setPenRadius(0.02);
for(int i = 0 ; i < num ; i++) {
Point2D p1 = points[i];
                p1.draw();
StdDraw.setPenRadius(0.002);
StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
StdDraw.setPenRadius(0.02);
StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
StdDraw.setPenColor(StdDraw.MAGENTA); */
int totalConvexHull = 0;
for(Map.Entry<Integer,Integer> entry:map.entrySet()){
System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());
Point2D[] pointGroup = new Point2D[entry.getValue()];
int count = 0;
for(int i = 0 ; i < parents.length ; i++){
if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
if(pointGroup.length > 2){
Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }
            System.out.println(totalConvexHull);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
public static int getRoot(int[] parents , int index){
while(parents[index]!=index)
            index = parents[index];
return index;
    }
public static void printArray(int[] array){
String sp = """";
System.out.print(""["");
for(int i:array){
System.out.print(sp + i);
            sp = "","";
        }
System.out.println(""]"");
    }
public static int[] ConvexHullVertex(Point2D[] points) {
ArrayList<Point2D> array = new ArrayList<Point2D>();
for(Point2D p:points){
            array.add(p);
        }
int min = findMinY(points);
Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);
Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
for(int i = 2 ; i < points.length ; i++){
Point2D b = convexhull.pop();
Point2D a = convexhull.pop();
Point2D c = points[i];
while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }
Stack<Point2D> reverse = new Stack<Point2D>();
while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;
Iterator<Point2D> iterator = convexhull.iterator();
int count = 0;
int[] index = new int[convexhull.size()];
while (iterator.hasNext()) {
Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
return index;
    }
public static int findMinY (Point2D[] points){
int min = 0;
for(int i = 0 ; i < points.length ; i++){
if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
return min;
    }
public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }
public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {
if(start >= end) return;
Point2D pivot = array[start];
int left = start;
int right = end+1;
while (true){
while (c.compare(pivot , array[++left]) == 1)
if (left == end) break;
while (c.compare(pivot , array[--right]) == -1)
if (right == start) break;
if(left >= right) break;
Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;
        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);
    }
}
@c25fa94cff3ce905b2ff93beccc5a75b@"
"b01703032","0","0","0","@916489dfd48fa7f4714faf3a39300e2b@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader(new FileReader(args[0]));
double distance = Double.parseDouble(br.readLine());
int num = Integer.parseInt(br.readLine());
            distance = 0.3;
            num = 12;
Point2D[] points = new Point2D[num];
for(int i = 0  ; i < num ; i++){
                points[i] = new Point2D(Math.random(),Math.random());
//System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }
int[] parents = new int[num];
for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);
for(int i = 0 ; i < num ; i++){
Point2D p1 = points[i];
for(int j = 0 ; j < num ; j++){
Point2D p2 = points[j];
if(p1.distanceTo(p2) < distance){
int root1 = getRoot(parents,i);
int root2 = getRoot(parents,j);
if(root1<=root2)
                            parents[root2] = root1;
else
                            parents[root1] = root2;
                    }
                }
            }
for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }
//System.out.print(""label:"");
 //           printArray(parents);
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i:parents){
if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }
/*StdDraw.setCanvasSize(800,800);
StdDraw.setXscale(-0.1,1.1);
StdDraw.setYscale(-0.1,1.1);
StdDraw.setPenRadius(0.02);
for(int i = 0 ; i < num ; i++) {
Point2D p1 = points[i];
                p1.draw();
StdDraw.setPenRadius(0.002);
StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
StdDraw.setPenRadius(0.02);
StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
StdDraw.setPenColor(StdDraw.MAGENTA); */
int totalConvexHull = 0;
for(Map.Entry<Integer,Integer> entry:map.entrySet()){
//System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());
Point2D[] pointGroup = new Point2D[entry.getValue()];
int count = 0;
for(int i = 0 ; i < parents.length ; i++){
if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
if(pointGroup.length > 2){
Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }
            System.out.println(totalConvexHull);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
public static int getRoot(int[] parents , int index){
while(parents[index]!=index)
            index = parents[index];
return index;
    }
public static void printArray(int[] array){
String sp = """";
System.out.print(""["");
for(int i:array){
System.out.print(sp + i);
            sp = "","";
        }
System.out.println(""]"");
    }
public static int[] ConvexHullVertex(Point2D[] points) {
ArrayList<Point2D> array = new ArrayList<Point2D>();
for(Point2D p:points){
            array.add(p);
        }
int min = findMinY(points);
Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);
Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
for(int i = 2 ; i < points.length ; i++){
Point2D b = convexhull.pop();
Point2D a = convexhull.pop();
Point2D c = points[i];
while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }
Stack<Point2D> reverse = new Stack<Point2D>();
while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;
Iterator<Point2D> iterator = convexhull.iterator();
int count = 0;
int[] index = new int[convexhull.size()];
while (iterator.hasNext()) {
Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
return index;
    }
public static int findMinY (Point2D[] points){
int min = 0;
for(int i = 0 ; i < points.length ; i++){
if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
return min;
    }
public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }
public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {
if(start >= end) return;
Point2D pivot = array[start];
int left = start;
int right = end+1;
while (true){
while (c.compare(pivot , array[++left]) == 1)
if (left == end) break;
while (c.compare(pivot , array[--right]) == -1)
if (right == start) break;
if(left >= right) break;
Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;
        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);
    }
}
@916489dfd48fa7f4714faf3a39300e2b@"
"b01703032","0","0","0","@6ad9e0714bdbe97659504aa2dd727f67@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

            distance = 0.3;
            num = 12;
            Point2D[] points = new Point2D[num];

            for(int i = 0  ; i < num ; i++){
//                String[] coordinate = br.readLine().split(""\\s"");
//                double x = Double.parseDouble(coordinate[0]);
//                double y = Double.parseDouble(coordinate[1]);
//                points[i] = new Point2D(x,y);
                points[i] = new Point2D(Math.random(),Math.random());
                System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }


            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = 0 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<=root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
                }
            }

            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }

            System.out.print(""label:"");
            printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }

            StdDraw.setCanvasSize(800,800);
            StdDraw.setXscale(-0.1,1.1);
            StdDraw.setYscale(-0.1,1.1);
            StdDraw.setPenRadius(0.02);
            for(int i = 0 ; i < num ; i++) {
                Point2D p1 = points[i];
                p1.draw();
                StdDraw.setPenRadius(0.002);
                StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
                StdDraw.setPenRadius(0.02);
                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
            StdDraw.setPenColor(StdDraw.MAGENTA);

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
                System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
                    int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
                    for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }

//            System.out.println(totalConvexHull);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}
@6ad9e0714bdbe97659504aa2dd727f67@"
"b01703032","0","0","0","@b35df075fb80ed4ecf3532a1afb7bc8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader(new FileReader(args[0]));
double distance = Double.parseDouble(br.readLine());
int num = Integer.parseInt(br.readLine());
            distance = 0.3;
            num = 12;
Point2D[] points = new Point2D[num];
for(int i = 0  ; i < num ; i++){
                points[i] = new Point2D(Math.random(),Math.random());
//System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }
int[] parents = new int[num];
for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
            printArray(parents);
for(int i = 0 ; i < num ; i++){
Point2D p1 = points[i];
for(int j = 0 ; j < num ; j++){
Point2D p2 = points[j];
if(p1.distanceTo(p2) < distance){
int root1 = getRoot(parents,i);
int root2 = getRoot(parents,j);
if(root1<=root2)
                            parents[root2] = root1;
else
                            parents[root1] = root2;
                    }
                }
            }
for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }
System.out.print(""label:"");
            printArray(parents);
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i:parents){
if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }
/*StdDraw.setCanvasSize(800,800);
StdDraw.setXscale(-0.1,1.1);
StdDraw.setYscale(-0.1,1.1);
StdDraw.setPenRadius(0.02);
for(int i = 0 ; i < num ; i++) {
Point2D p1 = points[i];
                p1.draw();
StdDraw.setPenRadius(0.002);
StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
StdDraw.setPenRadius(0.02);
StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
StdDraw.setPenColor(StdDraw.MAGENTA); */
int totalConvexHull = 0;
for(Map.Entry<Integer,Integer> entry:map.entrySet()){
System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());
Point2D[] pointGroup = new Point2D[entry.getValue()];
int count = 0;
for(int i = 0 ; i < parents.length ; i++){
if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
if(pointGroup.length > 2){
Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;
for(int i:convex){
                        copyArray[i].draw();
                    }
                }
            }
            System.out.println(totalConvexHull);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
public static int getRoot(int[] parents , int index){
while(parents[index]!=index)
            index = parents[index];
return index;
    }
public static void printArray(int[] array){
String sp = """";
System.out.print(""["");
for(int i:array){
System.out.print(sp + i);
            sp = "","";
        }
System.out.println(""]"");
    }
public static int[] ConvexHullVertex(Point2D[] points) {
ArrayList<Point2D> array = new ArrayList<Point2D>();
for(Point2D p:points){
            array.add(p);
        }
int min = findMinY(points);
Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);
Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
for(int i = 2 ; i < points.length ; i++){
Point2D b = convexhull.pop();
Point2D a = convexhull.pop();
Point2D c = points[i];
while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }
Stack<Point2D> reverse = new Stack<Point2D>();
while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;
Iterator<Point2D> iterator = convexhull.iterator();
int count = 0;
int[] index = new int[convexhull.size()];
while (iterator.hasNext()) {
Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
return index;
    }
public static int findMinY (Point2D[] points){
int min = 0;
for(int i = 0 ; i < points.length ; i++){
if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
return min;
    }
public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }
public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {
if(start >= end) return;
Point2D pivot = array[start];
int left = start;
int right = end+1;
while (true){
while (c.compare(pivot , array[++left]) == 1)
if (left == end) break;
while (c.compare(pivot , array[--right]) == -1)
if (right == start) break;
if(left >= right) break;
Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;
        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);
    }
}
@b35df075fb80ed4ecf3532a1afb7bc8f@"
"r04631041","3","0.51","108672","@77ea844c95b6239a3dcc6822b4d19660@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@77ea844c95b6239a3dcc6822b4d19660@"
"b01703032","0","0.57","108304","@a02491a0194e2622c8e686196b7ae78c@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

            //distance = 0.3;
            //num = 12;
            Point2D[] points = new Point2D[num];

            for(int i = 0  ; i < num ; i++){
               String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                points[i] = new Point2D(Math.random(),Math.random());
               System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }


            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = 0 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<=root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
                }
            }

            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }

            System.out.print(""label:"");
            printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }

/*            StdDraw.setCanvasSize(800,800);
            StdDraw.setXscale(-0.1,1.1);
            StdDraw.setYscale(-0.1,1.1);
            StdDraw.setPenRadius(0.02);
            for(int i = 0 ; i < num ; i++) {
                Point2D p1 = points[i];
                p1.draw();
                StdDraw.setPenRadius(0.002);
                StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
                StdDraw.setPenRadius(0.02);
                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
            StdDraw.setPenColor(StdDraw.MAGENTA); */

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
                System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
                    int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;

                }
            }

            System.out.println(totalConvexHull);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}
@a02491a0194e2622c8e686196b7ae78c@"
"b01703032","5","0.1","107824","@3e31e0a492e37160b23f39ce2cebeeb9@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class MyConvexHull {

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            double distance = Double.parseDouble(br.readLine());
            int num = Integer.parseInt(br.readLine());

            //distance = 0.3;
            //num = 12;
            Point2D[] points = new Point2D[num];

            for(int i = 0  ; i < num ; i++){
               String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                points[i] = new Point2D(Math.random(),Math.random());
//               System.out.println(String.format(""%d:(%.3f,%.3f)"",i,points[i].x(),points[i].y()));
            }


            int[] parents = new int[num];
            for(int i = 0 ; i < parents.length ; i++)
                parents[i] = i;
//            printArray(parents);

            for(int i = 0 ; i < num ; i++){
                Point2D p1 = points[i];
                for(int j = 0 ; j < num ; j++){
                    Point2D p2 = points[j];
                    if(p1.distanceTo(p2) < distance){
                        int root1 = getRoot(parents,i);
                        int root2 = getRoot(parents,j);
                        if(root1<=root2)
                            parents[root2] = root1;
                        else
                            parents[root1] = root2;
                    }
                }
            }

            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = getRoot(parents,i);
            }

 //           System.out.print(""label:"");
 //           printArray(parents);

            Map<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i:parents){
                if (map.containsKey(i)) {
                    map.put(i , map.get(i)+1);
                } else {
                    map.put(i , 1);
                }
            }

/*            StdDraw.setCanvasSize(800,800);
            StdDraw.setXscale(-0.1,1.1);
            StdDraw.setYscale(-0.1,1.1);
            StdDraw.setPenRadius(0.02);
            for(int i = 0 ; i < num ; i++) {
                Point2D p1 = points[i];
                p1.draw();
                StdDraw.setPenRadius(0.002);
                StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
                StdDraw.setPenRadius(0.02);
                StdDraw.text(p1.x() + 0.015 , p1.y() + 0.015 , """"+parents[i]+"""");
            }
            StdDraw.setPenColor(StdDraw.MAGENTA); */

            int totalConvexHull = 0;
            for(Map.Entry<Integer,Integer> entry:map.entrySet()){
 //               System.out.println(""label=""+entry.getKey() + "" : "" + entry.getValue());

                Point2D[] pointGroup = new Point2D[entry.getValue()];
                int count = 0;
                for(int i = 0 ; i < parents.length ; i++){
                    if(parents[i] == entry.getKey())
                        pointGroup[count++] = points[i];
                }
                if(pointGroup.length > 2){
                    Point2D[] copyArray = Arrays.copyOf(pointGroup,pointGroup.length);
                    int[] convex = ConvexHullVertex(pointGroup);
                    totalConvexHull += convex.length;

                }
            }

            System.out.println(totalConvexHull);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }

    public static int[] ConvexHullVertex(Point2D[] points) {

        ArrayList<Point2D> array = new ArrayList<Point2D>();
        for(Point2D p:points){
            array.add(p);
        }

        int min = findMinY(points);

        Point2D start = points[min];
//        Arrays.sort(points, start.ATAN2_ORDER);
        quickSort(points, start.ATAN2_ORDER);

        Stack<Point2D> convexhull = new Stack<Point2D>();
        convexhull.push(points[0]);
        convexhull.push(points[1]);
        for(int i = 2 ; i < points.length ; i++){
            Point2D b = convexhull.pop();
            Point2D a = convexhull.pop();
            Point2D c = points[i];
            while (Point2D.ccw(a,b,c)!=1) {
                b = a;
                a = convexhull.pop();
            }
            convexhull.push(a);
            convexhull.push(b);
            convexhull.push(c);
        }

        Stack<Point2D> reverse = new Stack<Point2D>();
        while(!convexhull.isEmpty())
            reverse.push(convexhull.pop());
        convexhull = reverse;

        Iterator<Point2D> iterator = convexhull.iterator();
        int count = 0;
        int[] index = new int[convexhull.size()];
        while (iterator.hasNext()) {
            Point2D p = iterator.next();
            index[count++] = array.indexOf(p);
        }
        return index;
    }


    public static int findMinY (Point2D[] points){
        int min = 0;
        for(int i = 0 ; i < points.length ; i++){
            if(Point2D.Y_ORDER.compare(points[min] , points[i])==1)
                min = i;
        }
        return min;
    }

    public static void quickSort(Point2D[] array , Comparator<Point2D> c) {
        quickSortKit(array , c , 0 , array.length-1);
    }

    public static void quickSortKit(Point2D[] array , Comparator<Point2D> c , int start , int end) {

        if(start >= end) return;
        Point2D pivot = array[start];
        int left = start;
        int right = end+1;

        while (true){
            while (c.compare(pivot , array[++left]) == 1)
                if (left == end) break;
            while (c.compare(pivot , array[--right]) == -1)
                if (right == start) break;

            if(left >= right) break;

            Point2D temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        array[start] = array[right];
        array[right] = pivot;

        quickSortKit(array , c , start , right-1);
        quickSortKit(array , c , right+1 , end);

    }

}
@3e31e0a492e37160b23f39ce2cebeeb9@"
"r04631026","3","0.51","105776","@336346097881585df568278a00305652@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@336346097881585df568278a00305652@"
"r03525006","0","0","0","@5848031ccc69fc15e85917e56872bb19@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                ;
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());

                distance = 0.3;
                num = 12;
                Point2D[] points = new Point2D[num];

                for (int i = 0; i < num; i++) {
//                String[] coordinate = br.readLine().split(""\\s"");
//                double x = Double.parseDouble(coordinate[0]);
//                double y = Double.parseDouble(coordinate[1]);
//                points[i] = new Point2D(x,y);
                    points[i] = new Point2D(Math.random(), Math.random());
                    System.out.println(String.format(""%d:(%.3f,%.3f)"", i, points[i].x(), points[i].y()));
                }


                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;
//            printArray(parents);

                for (int i = 0; i < num; i++) {
                    Point2D p1 = points[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = points[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                System.out.print(""label:"");
                printArray(parents);

                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

//                StdDraw.setCanvasSize(800, 800);
//                StdDraw.setXscale(-0.1, 1.1);
//                StdDraw.setYscale(-0.1, 1.1);
//                StdDraw.setPenRadius(0.02);
//                for (int i = 0; i < num; i++) {
//                    Point2D p1 = points[i];
//                    p1.draw();
//                    StdDraw.setPenRadius(0.002);
//                    StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
//                    StdDraw.setPenRadius(0.02);
//                    StdDraw.text(p1.x() + 0.015, p1.y() + 0.015, """" + parents[i] + """");
//                }
//                StdDraw.setPenColor(StdDraw.MAGENTA);

                int totalConvexHull = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    System.out.println(""label="" + entry.getKey() + "" : "" + entry.getValue());

                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = points[i];
                    }
                    if (pointGroup.length > 2) {
                        Point2D[] copyArray = Arrays.copyOf(pointGroup, pointGroup.length);
                        int[] convex = ConvexHullVertex(pointGroup);
                        totalConvexHull += convex.length;
                        for (int i : convex) {
                            copyArray[i].draw();
                        }
                    }
                }

            System.out.println(totalConvexHull);
            }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }


@5848031ccc69fc15e85917e56872bb19@"
"r04631013","0","0","0","@3591b8f4204f45f7bf25ebf1828f574e@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
        for (int i = 0; i < N; i++) {
//            System.out.printf(""%3.34f "", a[i].x());
//            System.out.printf(""%3.3f\n"", a[i].y());
            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
            String strval = Integer.toString(i);
            StdDraw.textLeft(a[i].x(), a[i].y(), strval);
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);

        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }

        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }

        Arrays.sort(theta_int);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", theta_int[i]);
//        }
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", sort_number[i]);
//        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", con_hull[i]);
//        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String data = br.readLine();
            double d = Double.parseDouble(data);
            String data2 = br.readLine();
            int N = Integer.parseInt(data2);
//            System.out.printf(""%f\n "", d);
//            System.out.printf(""%d\n "", N);
            Point2D[] a = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] data3 = br.readLine().split("" "");
                double first = Double.parseDouble(data3[0]);
                double second = Double.parseDouble(data3[1]);
                a[i] = new Point2D(first, second);
//
//                System.out.printf(""%f "", a[i].x());
//                System.out.printf(""%f\n"", a[i].y());
            }
//            calculate the distance and connect
            QuickUnionUF uu = new QuickUnionUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (a[i].distanceTo(a[j]) <= d) {
                        uu.union(j, i);
                    }
                }
            }
            for (int i = 0; i < N; i++) {
                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                String strval = Integer.toString(uu.find(i));
                StdDraw.textLeft(a[i].x(), a[i].y(), strval);

            }
//            System.out.printf(""%d\n "", uu.count());
            int couu[] = new int[N];
            for (int i = 0; i < N; i++) {
                couu[i] = 0;
            }
            for (int i = 0; i < N; i++) {
                couu[uu.find(i)] = couu[uu.find(i)] + 1;
            }
            int total = 0;
            for (int i = 0; i < N; i++) {
                if (couu[i] > 2) {
                    int m = couu[i];
                    Point2D[] b = new Point2D[m];
                    int initial = 0;
                    for (int j = 0; j < N; j++) {
                        if (uu.find(j) == i) {
                            b[initial] = a[j];
                            initial = initial + 1;
                        }

                    }
                    int ans[] = ConvexHullVertex(b);
                    total = total + ans.length;
                }
            }
            System.out.printf(""%d\n "", total);
        }

    }
}

@3591b8f4204f45f7bf25ebf1828f574e@"
"r04631013","0","0","0","@512a8abcbdedf98fff8d5d085d23080f@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
        for (int i = 0; i < N; i++) {
//            System.out.printf(""%3.34f "", a[i].x());
//            System.out.printf(""%3.3f\n"", a[i].y());
            
            String strval = Integer.toString(i);
            
        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
        Point2D miniy = new Point2D(xx, yy);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(xx, yy, 0.01);

        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }

        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }

        Arrays.sort(theta_int);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", theta_int[i]);
//        }
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", sort_number[i]);
//        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", con_hull[i]);
//        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String data = br.readLine();
            double d = Double.parseDouble(data);
            String data2 = br.readLine();
            int N = Integer.parseInt(data2);
//            System.out.printf(""%f\n "", d);
//            System.out.printf(""%d\n "", N);
            Point2D[] a = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] data3 = br.readLine().split("" "");
                double first = Double.parseDouble(data3[0]);
                double second = Double.parseDouble(data3[1]);
                a[i] = new Point2D(first, second);
//
//                System.out.printf(""%f "", a[i].x());
//                System.out.printf(""%f\n"", a[i].y());
            }
//            calculate the distance and connect
            QuickUnionUF uu = new QuickUnionUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (a[i].distanceTo(a[j]) <= d) {
                        uu.union(j, i);
                    }
                }
            }
            for (int i = 0; i < N; i++) {
                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
                String strval = Integer.toString(uu.find(i));
                StdDraw.textLeft(a[i].x(), a[i].y(), strval);

            }
//            System.out.printf(""%d\n "", uu.count());
            int couu[] = new int[N];
            for (int i = 0; i < N; i++) {
                couu[i] = 0;
            }
            for (int i = 0; i < N; i++) {
                couu[uu.find(i)] = couu[uu.find(i)] + 1;
            }
            int total = 0;
            for (int i = 0; i < N; i++) {
                if (couu[i] > 2) {
                    int m = couu[i];
                    Point2D[] b = new Point2D[m];
                    int initial = 0;
                    for (int j = 0; j < N; j++) {
                        if (uu.find(j) == i) {
                            b[initial] = a[j];
                            initial = initial + 1;
                        }

                    }
                    int ans[] = ConvexHullVertex(b);
                    total = total + ans.length;
                }
            }
            System.out.printf(""%d\n "", total);
        }

    }
}

@512a8abcbdedf98fff8d5d085d23080f@"
"r03525006","0","0.21","103392","@1b9c4a8ce4dad3610f308f14a58aca9f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());

//                distance = 0.3;
//                num = 12;
                Point2D[] points = new Point2D[num];

                for (int i = 0; i < num; i++) {
                String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                    points[i] = new Point2D(Math.random(), Math.random());
//                    System.out.println(String.format(""%d:(%.3f,%.3f)"", i, points[i].x(), points[i].y()));
                }


                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;
//            printArray(parents);

                for (int i = 0; i < num; i++) {
                    Point2D p1 = points[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = points[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                printArray(parents);

                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

//                StdDraw.setCanvasSize(800, 800);
//                StdDraw.setXscale(-0.1, 1.1);
//                StdDraw.setYscale(-0.1, 1.1);
//                StdDraw.setPenRadius(0.02);
//                for (int i = 0; i < num; i++) {
//                    Point2D p1 = points[i];
//                    p1.draw();
//                    StdDraw.setPenRadius(0.002);
//                    StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
//                    StdDraw.setPenRadius(0.02);
//                    StdDraw.text(p1.x() + 0.015, p1.y() + 0.015, """" + parents[i] + """");
//                }
//                StdDraw.setPenColor(StdDraw.MAGENTA);

                int totalConvexHull = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
//                    System.out.println(""label="" + entry.getKey() + "" : "" + entry.getValue());

                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = points[i];
                    }
                    if (pointGroup.length > 2) {
                        Point2D[] copyArray = Arrays.copyOf(pointGroup, pointGroup.length);
                        int[] convex = ConvexHullVertex(pointGroup);
                        totalConvexHull += convex.length;
                        for (int i : convex) {
                            copyArray[i].draw();
                        }
                    }
                }

            System.out.println(totalConvexHull);
            }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }


@1b9c4a8ce4dad3610f308f14a58aca9f@"
"r04631031","3","0.52","105792","@336346097881585df568278a00305652@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@336346097881585df568278a00305652@"
"r04631013","0","0","0","@29e713a98d499e75b4a759d9cb0be374@
import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
//        for (int i = 0; i < N; i++) {
////            System.out.printf(""%3.34f "", a[i].x());
////            System.out.printf(""%3.3f\n"", a[i].y());
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//            String strval = Integer.toString(i);
//            StdDraw.textLeft(a[i].x(), a[i].y(), strval);
//        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
//        Point2D miniy = new Point2D(xx, yy);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }

        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }

        Arrays.sort(theta_int);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", theta_int[i]);
//        }
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", sort_number[i]);
//        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", con_hull[i]);
//        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String data = br.readLine();
            double d = Double.parseDouble(data);
            String data2 = br.readLine();
            int N = Integer.parseInt(data2);
//            System.out.printf(""%f\n "", d);
//            System.out.printf(""%d\n "", N);
            Point2D[] a = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] data3 = br.readLine().split("" "");
                double first = Double.parseDouble(data3[0]);
                double second = Double.parseDouble(data3[1]);
                a[i] = new Point2D(first, second);
//
//                System.out.printf(""%f "", a[i].x());
//                System.out.printf(""%f\n"", a[i].y());
            }
//            calculate the distance and connect
            QuickUnionUF uu = new QuickUnionUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (a[i].distanceTo(a[j]) <= d) {
                        uu.union(j, i);
                    }
                }
            }
//            for (int i = 0; i < N; i++) {
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//                String strval = Integer.toString(uu.find(i));
//                StdDraw.textLeft(a[i].x(), a[i].y(), strval);
//
//            }
//            System.out.printf(""%d\n "", uu.count());
            int couu[] = new int[N];
            for (int i = 0; i < N; i++) {
                couu[i] = 0;
            }
            for (int i = 0; i < N; i++) {
                couu[uu.find(i)] = couu[uu.find(i)] + 1;
            }
            int total = 0;
            for (int i = 0; i < N; i++) {
                if (couu[i] > 2) {
                    int m = couu[i];
                    Point2D[] b = new Point2D[m];
                    int initial = 0;
                    for (int j = 0; j < N; j++) {
                        if (uu.find(j) == i) {
                            b[initial] = a[j];
                            initial = initial + 1;
                        }

                    }
                    int ans[] = ConvexHullVertex(b);
                    total = total + ans.length;
                }
            }
            System.out.printf(""%d\n "", total);
        }

    }
}
@29e713a98d499e75b4a759d9cb0be374@"
"r03525006","0","0.29","102144","@53b9c08eb0f780fbd95b4f4e6c8c94d4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());

//                distance = 0.3;
//                num = 12;
                Point2D[] points = new Point2D[num];

                for (int i = 0; i < num; i++) {
                String[] coordinate = br.readLine().split(""\\s"");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                points[i] = new Point2D(x,y);
//                    points[i] = new Point2D(Math.random(), Math.random());
//                    System.out.println(String.format(""%d:(%.3f,%.3f)"", i, points[i].x(), points[i].y()));
                }


                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;
//            printArray(parents);

                for (int i = 0; i < num; i++) {
                    Point2D p1 = points[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = points[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                printArray(parents);

                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

//                StdDraw.setCanvasSize(800, 800);
//                StdDraw.setXscale(-0.1, 1.1);
//                StdDraw.setYscale(-0.1, 1.1);
//                StdDraw.setPenRadius(0.02);
//                for (int i = 0; i < num; i++) {
//                    Point2D p1 = points[i];
//                    p1.draw();
//                    StdDraw.setPenRadius(0.002);
//                    StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
//                    StdDraw.setPenRadius(0.02);
//                    StdDraw.text(p1.x() + 0.015, p1.y() + 0.015, """" + parents[i] + """");
//                }
//                StdDraw.setPenColor(StdDraw.MAGENTA);

                int totalConvexHull = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
//                    System.out.println(""label="" + entry.getKey() + "" : "" + entry.getValue());

                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = points[i];
                    }
                    if (pointGroup.length > 2) {
                        Point2D[] copyArray = Arrays.copyOf(pointGroup, pointGroup.length);
                        int[] convex = ConvexHullVertex(pointGroup);
                        totalConvexHull += convex.length;
//                        for (int i : convex) {
//                            copyArray[i].draw();
//                        }
                    }
                }

            System.out.println(totalConvexHull);
            }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    public static void printArray(int[] array){
        String sp = """";
        System.out.print(""["");
        for(int i:array){
            System.out.print(sp + i);
            sp = "","";
        }
        System.out.println(""]"");
    }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }


@53b9c08eb0f780fbd95b4f4e6c8c94d4@"
"r04631013","5","0.102","107792","@2d0ef4d8c0a843ac3f88935afd7a1f42@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chenchen
 */
public class MyConvexHull {

//    public static int[] con_hull;
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;

//        Point2D[] a = new Point2D[N];
        double xx = 1;
        double yy = 1;
//        for (int i = 0; i < N; i++) {
////            System.out.printf(""%3.34f "", a[i].x());
////            System.out.printf(""%3.3f\n"", a[i].y());
//            StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//            String strval = Integer.toString(i);
//            StdDraw.textLeft(a[i].x(), a[i].y(), strval);
//        }
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        double array_y[] = new double[N]; //to find the lowest point, we have to get the minimum y point
        double theta[] = new double[N];
        for (int i = 0; i < N; i++) {
            array_y[i] = a[i].y();
            if (a[i].y() < yy) {
                yy = a[i].y();
                xx = a[i].x();
            } else if (a[i].y() == yy) {
                double x_ = a[i].x();
                double y_ = a[i].y() + 0.01;
                a[i] = new Point2D(x_, y_);
            }
        }

        //sort y value
        Arrays.sort(array_y);
        //build an array with theta value
       Point2D miniy = new Point2D(xx, yy);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(xx, yy, 0.01);

        for (int i = 0; i < N; i++) {
            double dx = a[i].x() - miniy.x();
            double dy = a[i].y() - miniy.y();
            theta[i] = Math.atan2(dy, dx);
        }

        int theta_int[] = new int[N];
        QuickUnionUF uf = new QuickUnionUF(4000);
        for (int i = 0; i < N; i++) {
            theta_int[i] = (int) (Math.round(theta[i] * 1000));
            uf.union(theta_int[i], i + 1);
        }

        Arrays.sort(theta_int);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", theta_int[i]);
//        }
        int sort_number[] = new int[N];
        for (int i = 0; i < N; i++) {
            sort_number[i] = uf.find(theta_int[i]) - 1;
        }
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", sort_number[i]);
//        }

        //5-1 lets see whether its ccw or not
        Stack<Integer> need = new Stack<>();

        need.push(sort_number[0]);

        int aa = sort_number[0];
        if (N > 2) {
            int bb = sort_number[1];
            for (int i = 0; i < N - 2; i++) {

                int cc = sort_number[i + 2];
                while (Point2D.ccw(a[aa], a[bb], a[cc]) != 1) {

                    bb = need.pop();
                    aa = need.peek();

                }
                need.push(bb);
                aa = bb;
                bb = cc;
            }
        }
        need.push(sort_number[N - 1]);
        int num_size = need.size();
        int con_hull[] = new int[num_size];
        for (int i = 0; i < num_size; i++) {
            con_hull[i] = need.pop();
        }
        Arrays.sort(con_hull);
//        for (int i = 0; i < N; i++) {
//            System.out.printf(""%d\n "", con_hull[i]);
//        }

        return con_hull;
    }

    public static void main(String[] args) throws Exception {

        // 1. read in the file containing N 2-dimentional points
        // 2. create an edge for each pair of points with a distance <= d
        // 3. find connected components (CCs) with a size >= 3
        // 4. for each CC, find its convex hull vertices by calling ConvexHullVertex(a[])
        // 5. count the number of points in N serving as a convex hull vertex, print it
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String data = br.readLine();
            double d = Double.parseDouble(data);
            String data2 = br.readLine();
            int N = Integer.parseInt(data2);
//            System.out.printf(""%f\n "", d);
//            System.out.printf(""%d\n "", N);
            Point2D[] a = new Point2D[N];
            for (int i = 0; i < N; i++) {
                String[] data3 = br.readLine().split("" "");
                double first = Double.parseDouble(data3[0]);
                double second = Double.parseDouble(data3[1]);
                a[i] = new Point2D(first, second);
//
//                System.out.printf(""%f "", a[i].x());
//                System.out.printf(""%f\n"", a[i].y());
            }
//            calculate the distance and connect
            QuickUnionUF uu = new QuickUnionUF(N);
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (a[i].distanceTo(a[j]) <= d) {
                        uu.union(j, i);
                    }
                }
            }
//            for (int i = 0; i < N; i++) {
//                StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
//                String strval = Integer.toString(uu.find(i));
//                StdDraw.textLeft(a[i].x(), a[i].y(), strval);
//
//            }
//            System.out.printf(""%d\n "", uu.count());
            int couu[] = new int[N];
            for (int i = 0; i < N; i++) {
                couu[i] = 0;
            }
            for (int i = 0; i < N; i++) {
                couu[uu.find(i)] = couu[uu.find(i)] + 1;
            }
            int total = 0;
            for (int i = 0; i < N; i++) {
                if (couu[i] > 2) {
                    int m = couu[i];
                    Point2D[] b = new Point2D[m];
                    int initial = 0;
                    for (int j = 0; j < N; j++) {
                        if (uu.find(j) == i) {
                            b[initial] = a[j];
                            initial = initial + 1;
                        }

                    }
                    int ans[] = ConvexHullVertex(b);
                    total = total + ans.length;
                }
            }
            System.out.printf(""%d\n "", total);
        }

    }
}
@2d0ef4d8c0a843ac3f88935afd7a1f42@"
"r03525006","3","0.29","105744","@89195ff9fca6673cea3ba1d6215a48bc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length - 1) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());

//                distance = 0.3;
//                num = 12;
                Point2D[] a = new Point2D[num];

                for (int i = 0; i < num; i++) {
                String[] coordinate = br.readLine().split("" "");
                double x = Double.parseDouble(coordinate[0]);
                double y = Double.parseDouble(coordinate[1]);
                a[i] = new Point2D(x,y);
//                    points[i] = new Point2D(Math.random(), Math.random());
//                    System.out.println(String.format(""%d:(%.3f,%.3f)"", i, points[i].x(), points[i].y()));
                }


                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;
//            printArray(parents);

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

//                printArray(parents);

                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

//                StdDraw.setCanvasSize(800, 800);
//                StdDraw.setXscale(-0.1, 1.1);
//                StdDraw.setYscale(-0.1, 1.1);
//                StdDraw.setPenRadius(0.02);
//                for (int i = 0; i < num; i++) {
//                    Point2D p1 = points[i];
//                    p1.draw();
//                    StdDraw.setPenRadius(0.002);
//                    StdDraw.circle(p1.x(), p1.y(), distance / 2.0);
//                    StdDraw.setPenRadius(0.02);
//                    StdDraw.text(p1.x() + 0.015, p1.y() + 0.015, """" + parents[i] + """");
//                }
//                StdDraw.setPenColor(StdDraw.MAGENTA);

                int totalConvexHull = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
//                    System.out.println(""label="" + entry.getKey() + "" : "" + entry.getValue());

                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }
                    if (pointGroup.length > 2) {
                        Point2D[] copyArray = Arrays.copyOf(pointGroup, pointGroup.length);
                        int[] convex = ConvexHullVertex(pointGroup);
                        totalConvexHull += convex.length;
//                        for (int i : convex) {
//                            copyArray[i].draw();
//                        }
                    }
                }

            System.out.println(totalConvexHull);
            }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

//    public static void printArray(int[] array){
//        String sp = """";
//        System.out.print(""["");
//        for(int i:array){
//            System.out.print(sp + i);
//            sp = "","";
//        }
//        System.out.println(""]"");
//    }
//        double rand1,rand2;
//        Point2D[] a2 = new Point2D[10];
//        for (int i = 0; i < a2.length; i++) {
//            rand1 = StdRandom.uniform();
//            rand2 = StdRandom.uniform();
//            a2[i] = new Point2D(rand1,rand2);
//        }
//        int[] ans =  ConvexHullVertex(a2);
//        for (int i = 0; i < ans.length; i++) {
//            System.out.println(ans[i]);
//        }
    }


@89195ff9fca6673cea3ba1d6215a48bc@"
"r04631009","4","0.48","105056","@9282550888128f7f3cbf6a255a6436a1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Cyuan
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
    
    
    public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.print(pts);
      
        }
    }
    
}

@9282550888128f7f3cbf6a255a6436a1@"
"r03525006","3","0.3","103488","@1571414016d8ea04a5b85f641df1dfc6@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {

        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N-1)
                break;
            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@1571414016d8ea04a5b85f641df1dfc6@"
"r04631046","3","0.48","108816","@336346097881585df568278a00305652@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@336346097881585df568278a00305652@"
"r04631041","3","0.5","103376","@afd5140c60bb56aa808b8b8c93ea2518@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] cc_count=new int[N];
      for (int i=0 ; i<N ; i++)
          cc_count[connection.find(i)]+=1;
      int ans=0;
      for (int i=0 ; i<N ; i++){
          if (cc_count[i]>=3){
              Point2D[] cc_array=new Point2D[cc_count[i]];
              int count=0;
              for (int j=0 ; j<N ; j++){
                  if (connection.find(j)==i){
                      cc_array[count]=new Point2D(data[j].x(),data[j].y());
                      count++;
                  }
              }
          int[] d=ConvexHullVertex(cc_array);
          ans+=d.length;
          }
         }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@afd5140c60bb56aa808b8b8c93ea2518@"
"r04631041","4","0.48","106592","@2bc6471db2deb7280023d79247ab77de@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
   public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.println(pts);
      
        }
    }
}

@2bc6471db2deb7280023d79247ab77de@"
"r03631015","3","0.5","109024","@336346097881585df568278a00305652@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] connectimformation=new int[N];
      for (int i=0 ; i<N ; i++)
          connectimformation[i]=connection.find(i);
      int[] ccroot=new int[connection.count()];
      int ccroot_i=0;
      for (int i=0 ; i<N ; i++){
          if (connectimformation[i]==i){
              ccroot[ccroot_i]=i;
              ccroot_i++;
          }
      }
      for (int i=0 ; i<ccroot.length ; i++){
          for (int j=0 ; j< N ; j++)
              if (connectimformation[j]==ccroot[i])
                  connectimformation[j]=i;
      }
////////////////////////////////////////////////////////////////////////////////
      int temp=0,ans=0;    
//      for (int i=0 ; i<N ; i++){
//          if(i==connectimformation[i]){
//              connectimformation[i]=temp;
//              for (int j=0 ; j<N ; j++)
//                  if (connectimformation[j]==i)
//                      connectimformation[j]=temp;
//          temp++;
//          }
//        }
////////////////////////////////////////////////////////////////////////////////
//      for (int i=0 ; i<N ; i++)
//          System.out.print(connectimformation[i]+""\t"");
//          System.out.println("""");
      for (int i=0 ; i<connection.count() ; i++){
          int counter2=0;
          for (int j=0 ; j<N ; j++){
              if (connectimformation[j]==i)
                  counter2++;
          }
          Point2D[] cc=new Point2D[counter2];
          int counter3=0;
          for (int j=0 ; j<N ; j++)
              if (connectimformation[j]==i){
              cc[counter3]=data[j];
              counter3++;
                  }
          if (cc.length>2){
         int[] d=ConvexHullVertex(cc);
         ans=ans+d.length;
          }
      }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}
@336346097881585df568278a00305652@"
"d04631001","0","0.45","101280","@ba1fb9c4b17a15e52cbe7db3acd0804f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}


@ba1fb9c4b17a15e52cbe7db3acd0804f@"
"d04631001","0","0.47","102304","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.44","105312","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.43","105296","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.45","105040","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.45","103600","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.43","105312","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.44","105360","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.4","105264","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"d04631001","0","0.45","105312","@9636c86773d687b67bed76155fc1ec8f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

public class MyConvexHull {

    public static int[] ConvexHullVertex(Point2D[] a) {
        //StdDraw.setCanvasSize(400, 400);
        //StdDraw.setXscale(0, 100);
        //StdDraw.setYscale(0, 100);
        //StdDraw.setPenRadius(0.01);
        Point2D[] graph = new Point2D[a.length];
        graph = a;
        int k = 0;
        double min_y = 0;
        for (int i = 0; i < graph.length; i++) {
            //double x = StdRandom.uniform(25, 75);
            //double y = StdRandom.uniform(25, 75);
            //graph[i] = new Point2D(x, y);
            //graph[i].draw();

            if (i == 0) {
                min_y = graph[0].y();
            } else if (i > 0 && graph[i].y() < min_y) {
                k = i;
                min_y = graph[i].y();
            }
            //System.out.print(graph[i] + ""\n"");
        }
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.BOOK_RED);
        //StdDraw.point(graph[k].x(), graph[k].y()); // draw the point with min_y
        //System.out.print(k + ""\n"");

        double angle[] = new double[a.length];
        double angle_ord[] = new double[a.length];

        for (int i = 0; i < graph.length; i++) {
            double dist_x = graph[i].x() - graph[k].x();
            double dist_y = graph[i].y() - graph[k].y();
            angle[i] = Math.atan2(dist_y, dist_x);
            //System.out.printf(""%f\n"", angle[i]);
            angle_ord[i] = angle[i];
        }
        //System.out.printf(""%s\n"", "" "");

        //Point2D k_graph = new Point2D(graph[k].x(), graph[k].y());
        //System.out.print(k_graph + ""\n"");
        //StdDraw.setPenRadius(0.02);
        //StdDraw.setPenColor(StdDraw.RED);
        //StdDraw.point(k_graph.x(), k_graph.y()); // draw the point with min_y
        //StdDraw.setPenRadius();
        //StdDraw.setPenColor(StdDraw.BLUE);
        Arrays.sort(angle_ord);
        for (int i = 0; i < graph.length; i++) {
            angle[i] = Math.floor(angle[i] * 1000000) / 1000000;
            angle_ord[i] = Math.floor(angle_ord[i] * 1000000) / 1000000;
        }
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(angle_ord[i] + ""\n"");
        }

        Point2D[] new_graph = new Point2D[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (angle[j] == angle_ord[i]) {
                    //ord[i] = j;
                    new_graph[i] = graph[j];
                }
            }
            //System.out.print(new_graph[i] + ""\n"");
            //StdDraw.text(new_graph[i].x(), new_graph[i].y()+2, Integer.toString(i));
        }
        int graph_ccw[] = new int[a.length];
        //graph_ccw[0]=1;
        for (int i = 1; i < graph.length - 1; i++) {
            graph_ccw[i] = Point2D.ccw(new_graph[i - 1], new_graph[i], new_graph[i + 1]);
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        graph_ccw[0] = Point2D.ccw(new_graph[a.length-1], new_graph[0], new_graph[1]);
        graph_ccw[a.length-1] = Point2D.ccw(new_graph[a.length-2], new_graph[a.length-1], new_graph[0]);
        for (int i = 0; i < graph.length; i++) {
            //System.out.print(graph_ccw[i] + ""\n"");
        }
        int ord[] = new int[a.length];
        int ori_ch[] = new int[a.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph.length; j++) {
                if (new_graph[j] == graph[i]) {
                    ord[i] = j;
                    ori_ch[i] = graph_ccw[j];
                }
            }
            //System.out.print(ord[i] + ""\n"");
        }
        int ch_num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (ori_ch[i] == -1) {
                ori_ch[i] = 0;
            }
            //System.out.print(ori_ch[i]+""\n"");
            ch_num = ch_num + ori_ch[i];
        }
        //System.out.print(ch_num+""\n"");
        int fin_ch[] = new int[ch_num];
        int n = 0;
        for (int j = 0; j < graph.length; j++) {
            if (ori_ch[j] == 1) {
                fin_ch[n] = j;
                n++;
            }
        }

        return fin_ch;
        //for (int i = 0; i < ch_num; i++) {
        //    System.out.print(fin_ch[i] + "" "");
        //}

        //System.out.printf(""%d\n"", """");
        //for (int i = 0; i < graph.length; i++){
        //System.out.print(graph[i] + ""\n"");
        //}
    }
public static void main(String[] args){
}
}
@9636c86773d687b67bed76155fc1ec8f@"
"r04631041","4","0.5","108192","@4577465e06f5bde345661fe18d690b0a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
   public static void main(String[] args) throws Exception{
        
        try (BufferedReader br = new BufferedReader (new FileReader(args[0])))
        {
        double r = Double.parseDouble(br.readLine());
        int N = Integer.parseInt(br.readLine());
        
        Point2D[] p = new Point2D[N];
        UF uf = new UF(N);
        
        
        for(int i = 0; i < N; i++)
        {
            String[] d1 =br.readLine().split("" "");
            p[i] = new Point2D(Double.parseDouble(d1[0]),Double.parseDouble(d1[1]));
//            System.out.print(p[i]+""\n"");
//             StdDraw.filledCircle(p[i].x(), p[i].y(), 0.01);
//            StdDraw.text(p[i].x(), p[i].y() + 0.03, Integer.toString(i));
        }   
        
        for(int i = 0; i < N; i++)
        {
                for(int j = i + 1; j < N; j++ )
                {
                    if(p[j].distanceTo(p[i]) <= r)
                    {
                        uf.union(j, i);
//                        StdDraw.line(p[i].x(), p[i].y(), p[j].x(), p[j].y());
//                        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
                    }
                }   
        }
        
        int next = -1, index = 0, count = 0, pts = 0, index1 = 0;
        Stack<Point2D> pcc = new Stack<Point2D>();
        
        for(int i = 0; i < N; i++)
        {
           
            if( next != i)
            {
                index = 0;
                index1 = 0;
                count = 0;
                pcc.push(p[i]);
                for(int j = i + 1; j < N; j++)
                {
                    if(uf.connected(i, j))
                    {
                        pcc.push(p[j]);
                        if(count == 0)
                        {
                            count = 1;
                            next = j;
                        }
                    }  
                }
                Point2D[] pt = new Point2D[pcc.size()];
                int[] v = new int [pt.length];
//                System.out.print(pcc.size()+""\n"");
                while(!pcc.isEmpty())
                {
//                    System.out.print(pcc.pop());
                    pt[index1] = pcc.pop();
//                    System.out.print(pt[index1]+""\n"");
                    index1 += 1;
                }
//                System.out.print(pt.length+""\n"");
                if(pt.length > 2)
                {
                    v = ConvexHullVertex(pt);
//                    System.out.print(v.length);
                    pts += v.length;
                }
               pt = null;
               v = null;
//                 System.out.print(pts+""\n"");
//                 System.out.print(i);
            }
            else
            {
                for(int j = i + 1; j < N; j++)
                {
                    count = 0;
                    if(uf.connected(i, j))
                    {
                        if(0 == count)
                        {
                            count = 1;
                            next = j;
                            break;
                        }
                    }
                }
            }
        }
        
        System.out.println(pts);
      
        }
    }
}

@4577465e06f5bde345661fe18d690b0a@"
"r03525006","2","0.19","102336","@b7271877173a5342d49f6cde0fcffe30@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N-1];
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N-1) {
                isConvex[N-1] = -1;
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }

            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@b7271877173a5342d49f6cde0fcffe30@"
"r04631041","3","0.49","104240","@57e0f9d59227f4e028d1439998bad3c5@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author USER
 */
public class MyConvexHull {
    
    public static int[] ConvexHullVertex(Point2D[] a) {
        Point2D[] data=new Point2D[a.length] ;
        Point2D[] sortdata=new Point2D[a.length] ;
        for (int i=0 ; i<a.length ; i++){
        double x=a[i].x();
        double y=a[i].y();
        data[i]=new Point2D(x,y);
        sortdata[i]=new Point2D(x,y);
        }
//--------------------Find the less y and set to data[0]----------------------//
        int minindex=0; 
        double miny=sortdata[0].y();
        for (int i =0 ; i<a.length ; i++)
            if (sortdata[i].y()<miny){
            miny=sortdata[i].y();
            minindex=i;
            }
        double maxx=sortdata[minindex].x();
        for (int i=0 ; i<a.length ;i++)
        if(sortdata[i].y()==miny && sortdata[i].x()>maxx){
            maxx=sortdata[i].x();
            minindex=i;
        }
        Point2D swap=sortdata[minindex];
        sortdata[minindex]=sortdata[0];
        sortdata[0]=swap;
//-----------------------------Sort by polar angle----------------------------//
        Selection.sort(sortdata,sortdata[0].POLAR_ORDER);
//------------------------Store the imformation of sorting--------------------//
        int[] sortimformation=new int[a.length];
        for (int i=0 ; i<a.length ; i++){
        for (int j=0 ; j<a.length ; j++){
            if (data[j].x()==sortdata[i].x()&&data[j].y()==sortdata[i].y())
                sortimformation[i]=j;
                
        }
        }
//--------------------------------Find ccw------------------------------------//
        Stack<Point2D> convexhull=new Stack<Point2D>();
        convexhull.push(sortdata[0]);
        convexhull.push(sortdata[1]);

        for (int i=2 ; i<a.length ; i++){
            Point2D temp1=convexhull.pop();
            Point2D temp2=convexhull.pop();
            if (sortdata[i].ccw(temp2,temp1,sortdata[i])!=0){
            while(sortdata[i].ccw(temp2,temp1,sortdata[i])<0){
                temp1=temp2;
                temp2=convexhull.pop();
                
               }
            convexhull.push(temp2);
            convexhull.push(temp1);
            convexhull.push(sortdata[i]);
            }
            else{
                convexhull.push(temp2);
                convexhull.push(sortdata[i]);
            }
        }
        int counter=0;
        int[] ans=new int[convexhull.size()];
        while(convexhull.size()!=0){
            Point2D temp=convexhull.pop();
            for(int i=0 ; i<a.length ; i++){
                if (sortdata[i].equals(temp)){
                ans[counter]=sortimformation[i];
               }
            }
            counter++;
        }
       Arrays.sort(ans);
     return (ans);
    }
 public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     UF connection=new UF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] cc_count=new int[N];
      for (int i=0 ; i<N ; i++)
          cc_count[connection.find(i)]+=1;
      int ans=0;
      for (int i=0 ; i<N ; i++){
          if (cc_count[i]>=3){
              Point2D[] cc_array=new Point2D[cc_count[i]];
              int count=0;
              for (int j=0 ; j<N ; j++){
                  if (connection.find(j)==i){
                      cc_array[count]=new Point2D(data[j].x(),data[j].y());
                      count++;
                  }
              }
          int[] d=ConvexHullVertex(cc_array);
          ans+=d.length;
          }
         }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }
}

@57e0f9d59227f4e028d1439998bad3c5@"
"r04631041","0","0","0","@e971c03f2747838c976ebb80cd2c83ea@i /*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] cc_count=new int[N];
      for (int i=0 ; i<N ; i++)
          cc_count[connection.find(i)]+=1;
      int ans=0;
      for (int i=0 ; i<N ; i++){
          if (cc_count[i]>=3){
              Point2D[] cc_array=new Point2D[cc_count[i]];
              int count=0;
              for (int j=0 ; j<N ; j++){
                  if (connection.find(j)==i){
                      cc_array[count]=new Point2D(data[j].x(),data[j].y());
                      count++;
                  }
              }
          int[] d=ConvexHullVertex(cc_array);
          ans+=d.length;
          }
         }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }

}

@e971c03f2747838c976ebb80cd2c83ea@"
"r04631041","0","0.49","104240","@e971c03f2747838c976ebb80cd2c83ea@i /*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] cc_count=new int[N];
      for (int i=0 ; i<N ; i++)
          cc_count[connection.find(i)]+=1;
      int ans=0;
      for (int i=0 ; i<N ; i++){
          if (cc_count[i]>=3){
              Point2D[] cc_array=new Point2D[cc_count[i]];
              int count=0;
              for (int j=0 ; j<N ; j++){
                  if (connection.find(j)==i){
                      cc_array[count]=new Point2D(data[j].x(),data[j].y());
                      count++;
                  }
              }
          int[] d=ConvexHullVertex(cc_array);
          ans+=d.length;
          }
         }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }

}

@e971c03f2747838c976ebb80cd2c83ea@"
"r04631041","3","0.5","108800","@09484855707cb195f6e17424000a5183@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class MyConvexHull {

    /**
     * @param args the command line arguments
     */
    public static int[] ConvexHullVertex(Point2D [] a)
    {
        Point2D[] p = new Point2D[a.length];
        for(int i = 0; i < a.length; i++)
            p[i] = a[i];
        Insertion.sort(p, Point2D.Y_ORDER);
        Insertion.sort(p, p[0].POLAR_ORDER);
        Stack<Point2D> s = new Stack<Point2D>();
        s.push(p[0]);
        s.push(p[1]);
        s.push(p[2]);
        Point2D p1, p2, p3, p0;
        
        int w = 0,index = 2;
        while(index < (p.length))
        {
            p3 = s.pop();
            p2 = s.pop();
            p1 = s.pop();
            w = Point2D.ccw(p1, p2, p3);
          
            if (1 == w)
            {
                s.push(p1);
                s.push(p2);
                s.push(p3);
                index += 1;
                if(index < p.length)
                    s.push(p[index]);
            }
            else
            {
                s.push(p1);
                s.push(p3);
            }
        }
        int [] v = new int[s.size()];
        index = 0;
        while(!s.isEmpty())
        {
            p0 = s.pop();
            for (int i = 0; i < a.length; i++)
                if(p0.equals(a[i]))
                    v[index++] = i;
        }
//        Insertion.;
        Arrays.sort(v);
        return v;
    }
  public static void main(String[] args)throws Exception {
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
//----------------------------Read the first line-----------------------------//
         String FirstLine=br.readLine();
         double threshold=Double.parseDouble(FirstLine);
//----------------------------Read the second line----------------------------//
         String SecondLine=br.readLine();
         int N=Integer.parseInt(SecondLine);
     Point2D[]data=new Point2D[N]; 
     String str=null;
     int counter1=0;
     while ((str=br.readLine())!=null){
         String[] inputxy=str.split("" "");
         double x=Double.parseDouble(inputxy[0]);
         double y=Double.parseDouble(inputxy[1]);
         data[counter1]=new Point2D(x,y);
         counter1++;
     }
     QuickUnionUF connection=new QuickUnionUF(N);
     for (int i=0 ; i<N ; i++)
         for (int j=0 ; j<N ; j++)
              if(i!=j && data[i].distanceTo(data[j])<=0.35)
                 connection.union(i,j);
      int[] cc_count=new int[N];
      for (int i=0 ; i<N ; i++)
          cc_count[connection.find(i)]+=1;
      int ans=0;
      for (int i=0 ; i<N ; i++){
          if (cc_count[i]>=3){
              Point2D[] cc_array=new Point2D[cc_count[i]];
              int count=0;
              for (int j=0 ; j<N ; j++){
                  if (connection.find(j)==i){
                      cc_array[count]=new Point2D(data[j].x(),data[j].y());
                      count++;
                  }
              }
          int[] d=ConvexHullVertex(cc_array);
          ans+=d.length;
          }
         }
      System.out.println(ans);
//-------------------------------Show the ans---------------------------------//
        //StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(data[0].x(),data[0].y(), 0.01);
//        StdDraw.setPenColor(StdDraw.BLACK);
//        StdDraw.text(data[0].x(),data[0].y()+0.02,String.valueOf(0));
//        for (int i=1 ; i<N ; i++){
//           StdDraw.filledCircle(data[i].x(), data[i].y(), 0.01);
//           StdDraw.text(data[i].x(), data[i].y()+0.02, String.valueOf(i));
//        }
//           System.out.println("""");
//        for (int i=0 ; i<d.length ; i++)
//            System.out.println(d[i]);
     }
 }

}

@09484855707cb195f6e17424000a5183@"
"r03525006","4","0.49","104608","@0ca9d9281957487204d32de5192f4150@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N];
        isConvex[N-1] = N;
        for (int i = 1; i < N; i++)
            isConvex[i - 1] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1] - 1] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (isConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[isConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@0ca9d9281957487204d32de5192f4150@"
"r03522809","4","0.39","107520","@9321443301595899f1ce916034b3ac62@import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */

public class MyConvexHull {


public static int[] ConvexHullVertex(Point2D[] a) {     
      int i,decide;
      int N = a.length,size;
 
      String q1,q2,q3;
      Point2D [] b =new Point2D[N];
      int intq1,intq2,intq3,intq4=0;
      Stack convexhull = new Stack();
      
      for(i =0;i<N;i++){b[i]=a[i];}
      Insertion.sort(a,Point2D.Y_ORDER);
      Insertion.sort(a,a[0].POLAR_ORDER);
      convexhull.push(0);
      convexhull.push(1);
      convexhull.push(2);
      
      while(intq4<N){
          q3=convexhull.pop().toString();
          intq3=Integer.parseInt(q3);
          q2=convexhull.pop().toString();
          intq2=Integer.parseInt(q2);
          q1=convexhull.pop().toString();
          intq1=Integer.parseInt(q1);
          decide=Point2D.ccw(a[intq1], a[intq2], a[intq3]);
          
          if(decide == 1){
              convexhull.push(intq1);
              convexhull.push(intq2);
              convexhull.push(intq3);
              intq4=intq3+1;
              if(intq4<N)
              convexhull.push(intq4);
          }
          else if(decide == -1){
              convexhull.push(intq1);
              convexhull.push(intq3);
          }
          else if(decide == 0){
              convexhull.push(intq1);
              convexhull.push(intq3);

          }
      }
      
      size=convexhull.size();
      String[] output=new String[size];
      int[] ans=new int[size];
      for(i=0;i<size;i++){
      output[i]=convexhull.pop().toString();
      ans[i]= Integer.parseInt(output[i]);
      }
      
      int[] orians=new int[size];      
      int k=0;
      for(i=0;i<N;i++){
          for(int j=0;j<size;j++){
              if(b[i].equals(a[ans[j]])){orians[k]=i;k++;}
          }
      }

      return  orians;
}

//  
//  public static void sort(Point2D[] a){
//        int N =a.length;
//        for (int i =0; i<N ;i++){
//            for(int j =i;j>0;j--){
//                if(Point2D.Y_ORDER.compare(a[j], a[j-1])<0)
//                    exch(a,j,j-1);
//            }
//           assert isSorted(a, 0, i);
//        }
//        assert isSorted(a);
//    }
//
//    private static void exch(Object[] a, int i, int j) {
//        Object swap = a[i];
//        a[i] = a[j];
//        a[j] = swap;
//    }
//    
//    private static boolean less(Comparable v, Comparable w) {
//        return (v.compareTo(w) < 0);
//    }  
//    
//    private static boolean isSorted(Comparable[] a, int lo, int hi) {
//        for (int i = lo + 1; i <= hi; i++)
//            if (less(a[i], a[i-1])) return false;
//        return true;
//    }
//    
//   private static boolean isSorted(Comparable[] a) {
//        return isSorted(a, 0, a.length - 1);
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Dis = br.readLine().split("","");
        double D=Double.parseDouble(Dis[0]);
        String[] Num = br.readLine().split("","");
        int N=Integer.parseInt(Num[0]);
        Point2D [] data = new Point2D[N];
  
        QuickFindUF uf = new QuickFindUF(N);
        
        for(int i=0;i<N;i++){
           String[] d = br.readLine().split("" "");
           double pointx=Double.parseDouble(d[0]);
           double pointy=Double.parseDouble(d[1]);
           data[i]=new Point2D(pointx,pointy);

        }
        
        for(int i=0;i<N;i++){
            for(int j=i; j<N; j++){
                if(data[i].distanceTo( data[j]) <= D){
                    uf.union(j, i);
//                StdDraw.setPenColor(StdDraw.BLACK);         
//                StdDraw.filledCircle(data[j].x(), data[j].y(), 0.01);
//                StdDraw.text(data[j].x(), data[j].y()+0.03,Integer.toString(j));
//                StdDraw.setPenColor(StdDraw.GREEN);
//                StdDraw.line(data[i].x(), data[i].y(),data[j].x(), data[j].y());
            }
          }
        }
        
        int k =0,cc=0,ans=0;
        for(k=0;k<N;k++){
                int m =0,n=0;
                for(int i=0;i<N;i++){
                    if(k==uf.find(i)){
                        m++;
                        n=1;
                    }
                }

            if(n==1){
//               System.out.println("" "");                
//               System.out.println(m);
//               System.out.println(cc); 
                Point2D [] a = new Point2D[m];
                int j=0;
                    for(int i=0;i<N;i++){
                        if((cc)==uf.find(i)){
                         a[j]=data[i];
//                         System.out.println(a[j]); 
                         j++;
                        }
                    }
                if(m>=3){
                int [] convex=ConvexHullVertex(a);
//                System.out.println(convex.length);
                ans=ans+convex.length;
                }

               cc=cc+m;
            }
            
        }
        System.out.println(ans);
            
//            for(int i=0;i<a.length;i++){
//            System.out.println(a[i]);
//            }
            
        
/***HW5-1
//        Point2D[] a = new Point2D[N];
//        Point2D[] c = new Point2D[N];        
//        int i=0,j=0;
//        int convexsize;
//        for (i=0;i<N;i++){
//        a[i]=new Point2D(StdRandom.uniform(),StdRandom.uniform());
//        c[i]=a[i];
//        }   
//        int [] convex=ConvexHullVertex(a);
//        StdDraw.setPenColor(StdDraw.RED);
//        StdDraw.filledCircle(c[0].x(), c[0].y(), 0.01);
//        StdDraw.text(c[0].x(), c[0].y()+0.03,Integer.toString(0));
//        
//        for (i=1;i<N;i++){    
//        StdDraw.setPenColor(StdDraw.BLACK);         
//        StdDraw.filledCircle(c[i].x(), c[i].y(), 0.01);
//        StdDraw.text(c[i].x(), c[i].y()+0.03,Integer.toString(i));
//        StdDraw.setPenColor(StdDraw.GREEN);  
//        StdDraw.line(c[0].x(), c[0].y(),c[i].x(), c[i].y());
//        }  
//
//
//        convexsize=convex.length;
//        for (j=0;j<convexsize-1;j++){
//            StdDraw.setPenColor(StdDraw.BLUE);  
//            StdDraw.line(c[convex[j]].x(), c[convex[j]].y(),c[convex[j+1]].x(), c[convex[j+1]].y());
//            }
HW5-1- */
        
        
    }
    }
}
@9321443301595899f1ce916034b3ac62@"
"r03525006","4","0.48","105584","@4b7731e76533c3dc5ecdd79d3cb66889@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.*;

/**
 * Created by Cavitation on 2016/4/6.
 */
public class MyConvexHull {
    public static int[] ConvexHullVertex(Point2D[] a) {
        int N = a.length;
        int yMin = 0;
        Point2D[] a2 = new Point2D[N];

        for (int i = 0; i < N; i++)
            a2[i] = a[i];

        for (int i = 0; i < N; i++) {
            if (i > 0) {
                int yOrder = Point2D.Y_ORDER.compare(a[yMin], a[i]);
                if (yOrder == 1) yMin = i;
            }
        }
        Point2D p = new Point2D(a[yMin].x(), a[yMin].y());
        Arrays.sort(a2, p.ATAN2_ORDER);

        int[] sortIndex = new int[N];
        int[] isConvex = new int[N+1];
        for (int i = 0; i < N+1; i++)
            isConvex[i] = i;

        for (int i = 0; i < N; i++) {
            boolean e = false;
            int j = 0;
            while (!e) {
                e = a2[i].equals(a[j]);
                if (e)
                    sortIndex[i] = j;
                else
                    j++;
            }
        }

        int index = 0;
        int[] ccwArray = new int[3];
        int ansCount = N;

        while (index < isConvex.length) {
            if (ccwArray[2] == N) {
                break;
            }

            int ccwCount = 0;
            int j = index;
            while (ccwCount < 3) {
                if (isConvex[j] != -1) {
                    ccwArray[ccwCount] = isConvex[j];
                    ccwCount++;
                }
                j++;
            }
            if (ccwArray[2] == N) {
                break;
            }
            int temp = Point2D.ccw(a2[ccwArray[0]],a2[ccwArray[1]],a2[ccwArray[2]]);
            if (temp == 1) {
                index++;
            } else {
                isConvex[ccwArray[1]] = -1;
                ansCount--;
                if (index != 0) {
                    index--;
                }

            }
        }
        int[] newisConvex = new int[N-1];
        for (int i = 0; i < isConvex.length-2; i++) {
            newisConvex[i] = isConvex[i+1];
        }

        int[] ans = new int[ansCount];
        int[] ansNew = new int[ansCount];
        ansNew[0] = sortIndex[0];
        ans[0] = sortIndex[0];
        for (int i = 0; i < N-1; i++) {
            if (newisConvex[i] != -1) {
                ans[ansCount - 1] = sortIndex[newisConvex[i]];
                ansCount--;
            }
        }
        for (int i = 0; i < ans.length; i++) {
            int tempMin = N;
            if (i > 0) {
                for (int j = 0; j < ans.length; j++) {
                    if ((ans[j] < tempMin) && (ans[j] > ansNew[i - 1])) {
                        tempMin = ans[j];
                    }
                }
            } else {
                for (int j = 0; j < ans.length; j++) {
                    if (ans[j] < tempMin) {
                        tempMin = ans[j];
                    }
                }
            }
            ansNew[i] = tempMin;
        }
        return ansNew;
    }
    public static void main(String[] args) throws Exception {
            try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

                double distance = Double.parseDouble(br.readLine());
                int num = Integer.parseInt(br.readLine());
                Point2D[] a = new Point2D[num];
                for (int i = 0; i < num; i++) {
                    String[] coordinate = br.readLine().split("" "");
                    double x = Double.parseDouble(coordinate[0]);
                    double y = Double.parseDouble(coordinate[1]);
                    a[i] = new Point2D(x,y);
                }

                int[] parents = new int[num];
                for (int i = 0; i < parents.length; i++)
                    parents[i] = i;

                for (int i = 0; i < num; i++) {
                    Point2D p1 = a[i];
                    for (int j = 0; j < num; j++) {
                        Point2D p2 = a[j];
                        if (p1.distanceTo(p2) < distance) {
                            int root1 = getRoot(parents, i);
                            int root2 = getRoot(parents, j);
                            if (root1 <= root2)
                                parents[root2] = root1;
                            else
                                parents[root1] = root2;
                        }
                    }
                }

                for (int i = 0; i < parents.length; i++) {
                    parents[i] = getRoot(parents, i);
                }

                Map<Integer, Integer> map = new HashMap<Integer,Integer>();
                for (int i : parents) {
                    if (map.containsKey(i)) {
                        map.put(i, map.get(i) + 1);
                    } else {
                        map.put(i, 1);
                    }
                }

                int ans = 0;
                for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                    Point2D[] pointGroup = new Point2D[entry.getValue()];
                    int count = 0;
                    for (int i = 0; i < parents.length; i++) {
                        if (parents[i] == entry.getKey())
                            pointGroup[count++] = a[i];
                    }

                    if (pointGroup.length > 2) {
                        int[] convex = ConvexHullVertex(pointGroup);
                        ans += convex.length;
                    }
                }
            System.out.println(ans);
            }
    }

    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }

    }


@4b7731e76533c3dc5ecdd79d3cb66889@"
