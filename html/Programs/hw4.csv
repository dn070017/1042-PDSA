"r04945025","10","0.141","172848","@2f458169ab1d42f441fad9d4d2a0b52c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

   	private class Node{
        Item item;
        Node prev;
        Node next;
   	}
    
   	private class DequeIterator implements Iterator<Item>{
   		private Node current = first;
   		public boolean hasNext(){
   		    return current != null;	
   		}
   		public Item next(){
   		    if(!this.hasNext()){
                throw new NoSuchElementException();
   		    }
   			Item item = current.item;
   			current = current.next;
   			return item;
   		}
   		public void remove(){
   		    throw new UnsupportedOperationException();  
   		}
   	}

    private Node first, last;

 	public Deque(){
 		this.first = null;
 		this.last  = null;
 	}

	public boolean isEmpty(){
		return first == null;
	}       

	public int size(){
        int count = 0;
        Node node = this.first;
        while(node != null){
        	node = node.next;
        	count++;
        }
        return count;
	}                        
   	public void addFirst(Item item){
   	    if(item == null){
   			throw new NullPointerException();
   		}
        Node node = new Node();
        node.item = item;
        if(this.isEmpty()){
            node.prev  = null;
       	    node.next  = null;
       	    this.first = node;  
       	    this.last  = node;
        }
        else{
            node.prev = null;
            node.next = this.first;
            this.first.prev = node;
       	    this.first = node;
        }
   	}

   	public void addLast(Item item){
   	    if(item == null){
   			throw new NullPointerException();
   	    }
        Node node = new Node();
        node.item = item;
        if(this.isEmpty()){
       		node.prev  = null;
       		node.next  = null;
        	this.first = node;
        	this.last  = node;
        }
        else{
           	node.prev = this.last;
        	node.next = null;
        	this.last.next = node;
          	this.last = node;
        }
   	}         
   	
   	public Item removeFirst(){
   		if(this.isEmpty()){
   		    throw new NoSuchElementException();
   		}
   		Item item  = this.first.item;
   		if(this.first == this.last){
   		    this.first = null;
   		  	this.last  = null;
   		}
   		else{
   		    this.first = this.first.next;
   		    this.first.prev = null;
   		}
   		return item;
   	}                
   	
   	public Item removeLast(){
        if(this.isEmpty()){
   		    throw new NoSuchElementException();
   		}
   		Item item = this.last.item;
  	    if(this.first == this.last){
  			this.first = null;
  			this.last = null;
   		}
   		else{
        	this.last = this.last.prev;
        	this.last.next = null;
        }
   		return item;
   	}                  
   	
   	public Iterator<Item> iterator(){
        return new DequeIterator();
   	}
   	
   	public void print(){
   		Node node = this.first;
   	    while(node != null){
   	    	System.out.print(node.item);
   	    	System.out.printf(""\t"");
            if(node.prev != null){
            	System.out.printf(""prev:"");
            	System.out.print(node.prev.item);
            }
            System.out.printf(""\t"");
            if(node.next != null){
            	System.out.printf(""next:"");
            	System.out.print(node.next.item);
            }
            System.out.printf(""\n"");
        	node = node.next;
        }	
   	}

    public static void main(String[] argv){
        System.out.println(""Test"");
    }
}

@2f458169ab1d42f441fad9d4d2a0b52c@"
"b03611041","0","0.099","105824","@26d48def991bb923d0e7853dd237a70e@import java.util.Stack;

/**
 * Created by Sunny on 3/23/16.
 */
public class Calculator {
    private Stack<String> myStack = new Stack<String>();
    private Double answer = 0.0;
    private Stack<Double> valueStack = new Stack<Double>();
    private Stack<String> operatorStack = new Stack<String>();

    public Double ans(String e) {
        String s[] = e.split("" "");
        for (int i = s.length - 1; i >= 0; i--) {
            myStack.push(s[i]);
        }

        while (!myStack.isEmpty()) {
            String t=myStack.pop();
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
            } else if (t.equals("")"")) {
                String op=operatorStack.pop();
                if (op.equals(""+"")) {
                    valueStack.push(valueStack.pop() + valueStack.pop());
                }
                else if (op.equals(""-"")) {
                    valueStack.push(-(valueStack.pop() - valueStack.pop()));
                }
                else if (op.equals(""*"")) {
                    valueStack.push(valueStack.pop() * valueStack.pop());
                }
                else if (op.equals(""/"")) {
                    valueStack.push(1/(valueStack.pop() / valueStack.pop()));

                }
            }else{
                valueStack.push(Double.parseDouble(t));
            }
        }
        answer=valueStack.pop();
        return answer;
    }
}

@26d48def991bb923d0e7853dd237a70e@"
"r04447001","0","1.28","184736","@46bbacbf819cd051ad94c67fbfab56a9@import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node header ;
    private Node tailer;
     
    public class Node{
    public Item item;
    public Node next;
    public Node prev;
    
    public Node(){
    item = null;
    next = null;
    prev = null;
    }
    
    public Node(Item item, Node n, Node p){
    item = item;
    next = n;
    prev = p; 
    }
    }    

    
     public Deque() {
       header = new Node();
       tailer = new Node();
       header.next = tailer;
       tailer.prev = header;
        N = 0;
    }
     
     public boolean isEmpty() {
         if (N == 0) return true;
         else return false;
    }   
     
    public int size() {
        return N;     
    }
    
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return header.next.item;
    }
    
    public void addFirst(Item item){
    if(item == null) throw new NullPointerException();
    Node second = header.next;
    Node first = new Node();
    first.item = item;
    first.next = second;
    first.prev = header;
    second.prev = first;
    header.next = first;
    N++;
    }
    
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node first  = header.next;
        Item item = first.item;
        Node second = first.next;
        header.next = second;
        second.prev = header;
        return item;
    }
    
    public void addLast(Item item) {
        if(item == null) throw new NullPointerException();
        Node oldlast = tailer.prev;
        Node last = new Node();
        last.item = item;
        last.next = tailer;
        last.prev = oldlast;
        oldlast.next = last;
        tailer.prev = last;
        N++;
    }
    
        public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node last = tailer.prev;
        Item item = last.item;
        Node secondlast = last.prev;
        tailer.prev = secondlast;
        secondlast.next = tailer;      
        return item;
    }
        
 public Iterator<Item> iterator()  {
        return new ListIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private Node current = header.next;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }     
        
    
    public static void main(String[] args) {
        Deque<Integer> test = new Deque<Integer>();
        test.addFirst(3);
        test.addFirst(5);
        test.addLast(7);
        test.addLast(10);
        System.out.println(test.removeFirst());
        System.out.println(test.removeLast());
        System.out.println(test.removeLast());
        System.out.println(test.removeLast());
    }
}

@46bbacbf819cd051ad94c67fbfab56a9@"
"r04447001","0","1.26","184768","@09f1f4df5244db22e136774d0809adab@import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node header ;
    private Node tailer;
     
    public class Node{
    public Item item;
    public Node next;
    public Node prev;
    
    public Node(){
    item = null;
    next = null;
    prev = null;
    }
    
    public Node(Item item, Node n, Node p){
    item = item;
    next = n;
    prev = p; 
    }
    }    

    
     public Deque() {
       header = new Node();
       tailer = new Node();
       header.next = tailer;
       tailer.prev = header;
        N = 0;
    }
     
     public boolean isEmpty() {
         if (N == 0) return true;
         else return false;
    }   
     
    public int size() {
        return N;     
    }
    
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return header.next.item;
    }
    
    public void addFirst(Item item){
    if(item == null) throw new NullPointerException();
    Node second = header.next;
    Node first = new Node();
    first.item = item;
    first.next = second;
    first.prev = header;
    second.prev = first;
    header.next = first;
    N++;
    }
    
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node first  = header.next;
        Item item = first.item;
        Node second = first.next;
        header.next = second;
        second.prev = header;
        return item;
    }
    
    public void addLast(Item item) {
        if(item == null) throw new NullPointerException();
        Node oldlast = tailer.prev;
        Node last = new Node();
        last.item = item;
        last.next = tailer;
        last.prev = oldlast;
        oldlast.next = last;
        tailer.prev = last;
        N++;
    }
    
        public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node last = tailer.prev;
        Item item = last.item;
        Node secondlast = last.prev;
        tailer.prev = secondlast;
        secondlast.next = tailer;      
        return item;
    }
        
 public Iterator<Item> iterator()  {
        return new ListIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private Node current = header.next;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }     

}

@09f1f4df5244db22e136774d0809adab@"
"r04447001","5","1.28","178272","@17e0c49605ed710c0656285d6cffcbed@import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node header ;
    private Node tailer;
     
    public class Node{
    public Item item;
    public Node next;
    public Node prev;
    
    public Node(){
    item = null;
    next = null;
    prev = null;
    }
    
    public Node(Item item, Node n, Node p){
    item = item;
    next = n;
    prev = p; 
    }
    }    

    
     public Deque() {
       header = new Node();
       tailer = new Node();
       header.next = tailer;
       tailer.prev = header;
        N = 0;
    }
     
     public boolean isEmpty() {
         if (N == 0) return true;
         else return false;
    }   
     
    public int size() {
        return N;     
    }
    
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return header.next.item;
    }
    
    public void addFirst(Item item){
    if(item == null) throw new NullPointerException();
    Node second = header.next;
    Node first = new Node();
    first.item = item;
    first.next = second;
    first.prev = header;
    second.prev = first;
    header.next = first;
    N++;
    }
    
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node first  = header.next;
        Item item = first.item;
        Node second = first.next;
        header.next = second;
        second.prev = header;
        return item;
    }
    
    public void addLast(Item item) {
        if(item == null) throw new NullPointerException();
        Node oldlast = tailer.prev;
        Node last = new Node();
        last.item = item;
        last.next = tailer;
        last.prev = oldlast;
        oldlast.next = last;
        tailer.prev = last;
        N++;
    }
    
        public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node last = tailer.prev;
        Item item = last.item;
        Node secondlast = last.prev;
        tailer.prev = secondlast;
        secondlast.next = tailer;      
        return item;
    }
        
 public Iterator<Item> iterator()  {
        return new ListIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private Node current = header.next;

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }     

}

@17e0c49605ed710c0656285d6cffcbed@"
"r04447001","5","1.26","180160","@32db700b6d23e1957397fadfebfea68f@import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node header ;
    private Node tailer;
     
    public class Node{
    public Item item;
    public Node next;
    public Node prev;
    
    public Node(){
    item = null;
    next = null;
    prev = null;
    }
    
    public Node(Item item, Node n, Node p){
    item = item;
    next = n;
    prev = p; 
    }
    }    

    
     public Deque() {
       header = new Node();
       tailer = new Node();
       header.next = tailer;
       tailer.prev = header;
        N = 0;
    }
     
     public boolean isEmpty() {
         if (N == 0) return true;
         else return false;
    }   
     
    public int size() {
        return N;     
    }
    
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return header.next.item;
    }
    
    public void addFirst(Item item){
    if(item == null) throw new NullPointerException();
    Node second = header.next;
    Node first = new Node();
    first.item = item;
    first.next = second;
    first.prev = header;
    second.prev = first;
    header.next = first;
    N++;
    }
    
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node first  = header.next;
        Item item = first.item;
        Node second = first.next;
        header.next = second;
        second.prev = header;
        return item;
    }
    
    public void addLast(Item item) {
        if(item == null) throw new NullPointerException();
        Node oldlast = tailer.prev;
        Node last = new Node();
        last.item = item;
        last.next = tailer;
        last.prev = oldlast;
        oldlast.next = last;
        tailer.prev = last;
        N++;
    }
    
        public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Node last = tailer.prev;
        Item item = last.item;
        Node secondlast = last.prev;
        tailer.prev = secondlast;
        secondlast.next = tailer;      
        return item;
    }
        
 public Iterator<Item> iterator()  {
        return new ListIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private Node current = header.next;

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }     
        
}

@32db700b6d23e1957397fadfebfea68f@"
"r04447001","10","0.138","183456","@a3be82f13364bacc63b916e6730be4a2@import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node header ;
    private Node tailer;
     
    public class Node{
    public Item item;
    public Node next;
    public Node prev;
    
    public Node(){
    item = null;
    next = null;
    prev = null;
    }
    
    public Node(Item item, Node n, Node p){
    item = item;
    next = n;
    prev = p; 
    }
    }    

    
     public Deque() {
       header = new Node();
       tailer = new Node();
       header.next = tailer;
       tailer.prev = header;
       N = 0;
    }
     
     public boolean isEmpty() {
         if (N == 0) return true;
         return false;
    }   
     
    public int size() {
        return N;     
    }
    
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return header.next.item;
    }
    
    public void addFirst(Item item){
    if(item == null) throw new NullPointerException();
    Node second = header.next;
    Node first = new Node();
    first.item = item;
    first.next = second;
    first.prev = header;
    second.prev = first;
    header.next = first;
    N++;
    }

    public void addLast(Item item) {
        if(item == null) throw new NullPointerException();
        Node oldlast = tailer.prev;
        Node last = new Node();
        last.item = item;
        last.next = tailer;
        last.prev = oldlast;
        oldlast.next = last;
        tailer.prev = last;
        N++;
    }
    
        public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node first  = header.next;
        Item item = first.item;
        Node second = first.next;
        header.next = second;
        second.prev = header;
        N--;
        return item;
    }
        
        public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Node last = tailer.prev;
        Item item = last.item;
        Node secondlast = last.prev;
        tailer.prev = secondlast;
        secondlast.next = tailer;      
        N--;
        return item;
    }
        
 public Iterator<Item> iterator()  {
        return new ListIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private Node current = header.next;

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }     
      
}

@a3be82f13364bacc63b916e6730be4a2@"
"r04942099","0","0","0","@b926eebdbd85229aa2ace0e59208eb9c@
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private Node first = null;
    private Node last = null;
   
    private int N=0;
    private class Node{
        Item item;
        Node next;
        Node previous;
        
    }
    
   public Deque()  {
   }// construct an empty deque

   public boolean isEmpty(){
       return first == null;
   }                 // is the deque empty?

  public int size(){
      return N;
  }                        // return the number of items on the deque

  public void addFirst(Item item){
      Node oldfirst = first;
      first = new Node();
      first.item = item;
      first.next = oldfirst;
      first.previous = null;
      oldfirst.previous = first;
      if(isEmpty()) last = first;
      else first.next = oldfirst;
      N++;
  }          // add the item to the front

   public void addLast(Item item){
    Node oldlast = last;
    last = new Node();
      last.item = item;
      oldlast.next = last; 
      last.next = null;
      last.previous = oldlast; 
      if(isEmpty()) first = last;
      else oldlast.next = last;
      N++;
}           // add the item to the end

   public Item removeFirst(){
       Item item = first.item;
       first = first.next;
       if(isEmpty()) last = null;
       N--;
       return item;
}                // remove and return the item from the front

   public Item removeLast(){
       Item item = last.item;
       last = last.previous;
       if(isEmpty()) last = null;
       N--;
       return item;
       
   }                 // remove and return the item from the end

  public Iterator<Item> iterator() {  return new ListIterator();  }        // return an iterator over items in order from front to end
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args){}   // unit testing

}
@b926eebdbd85229aa2ace0e59208eb9c@"
"r04942099","0","0","0","@da3404a585f1b21285b3885c70956017@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;

    private int N = 0;

    private class Node {

        Item item;
        Node next;
        Node previous;

    }

    public Deque() {
    }// construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        oldfirst.previous = first;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        oldlast.next = last;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;
        first = first.next;
        if (isEmpty()) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;
        last = last.previous;
        if (isEmpty()) {
            last = null;
        }
        N--;
        return item;

    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@da3404a585f1b21285b3885c70956017@"
"r04921051","0","0.36","102448","@3cb59c7f8482aefdb6934bfb8603826b@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addFirst(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the front

   public void addLast(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) first = last;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the end

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
/*    
   public static void main(String[] args)   // unit testing
*/
}



@3cb59c7f8482aefdb6934bfb8603826b@"
"r04921051","0","0.36","102512","@5cab60a60227a2506e32b3b327453cb2@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addFirst(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the front

   public void addLast(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) first = last;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the end

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@5cab60a60227a2506e32b3b327453cb2@"
"r04942099","0","1.45","174128","@2a3faccf113843ac42e214a914348d3e@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first;
    private Node last;

    private int N = 0;

    private class Node {

        Item item;
        Node next;
        Node previous;

    }

    public Deque() {
        first = new Node();
        last = new Node();
        first.next = last;
        last.previous = last;
    }// construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;
        first = first.next;
        if (isEmpty()) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;
        last = last.previous;
        if (isEmpty()) {
            last = null;
        }
        N--;
        return item;

    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@2a3faccf113843ac42e214a914348d3e@"
"b02611016","7","1.08","102480","@9d147e0d64b34b4beb4ec20a955278e9@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        return first.item;
    }
   public Iterator iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
        StdOut.println(""("" + D.size() + "" left on queue)"");
    }
        // TODO code application logic here
    }
    

@9d147e0d64b34b4beb4ec20a955278e9@"
"r04447001","6","1.08","102384","@74bcb482065001dce92a9424a47cdc06@
import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item> {

    private Item[] s;
    private int first;
    private int last;
    private int N;

    public Deque() {
        s = (Item[]) new Object[2];
        first = 0;
        last = 0;
        N = 0;
    }

    public boolean isEmpty() {
        if (N == 0) {
            return true;
        }
        return false;
    }

    public int size() {
        return N;
    }
    
    private void resize(int max){
          Item[] temp = (Item[]) new Object[max];
        for (int i = 0; i < N; i++) {
            temp[i] = s[(first + i) % s.length];
        }
        s = temp;
        first = 0;
        last  = N;  
    }


    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == s.length) resize(2*s.length);   // double size of array if necessary
        s[first++] = item;                        // add item
        if (first == s.length) first = 0;          // wrap-around
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == s.length) resize(2*s.length);   // double size of array if necessary
        s[last++] = item;                        // add item
        if (last == s.length) last = 0;          // wrap-around
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = s[first];
        s[first] = null;                            // to avoid loitering
        N--;
        first++;
        if (first == s.length) first = 0;           // wrap-around
        // shrink size of array if necessary
        if (N > 0 && N == s.length/4) resize(s.length/2); 
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = s[last];
        s[last] = null;                            // to avoid loitering
        N--;
        last--;
        if (last == 0) last = s.length;           // wrap-around
        // shrink size of array if necessary
        if (N > 0 && N == s.length/4) resize(s.length/2); 
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {

        private int i = 0;

        public boolean hasNext() {
            return i < N;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = s[(i + first) % s.length];
            i++;
            return item;
    }
    }

}

@74bcb482065001dce92a9424a47cdc06@"
"r04546032","0","0.097","105808","@0789750710e1599d2602220fbecbeb92@import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<Item> implements Iterable<Item>{

   private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre  = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private Item item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty()    { return N == 0; }
    public int size()           { return N;      }

    // add the item to the list
    public void add(Item item) {
        Node last = post.prev;
        Node x = new Node();
        x.item = item;
        x.next = post;
        x.prev = last;
        post.prev = x;
        last.next = x;
        N++;
    }
 
    public ListIterator<Item> iterator()  { return new DequeIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DequeIterator implements ListIterator<Item> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            Item item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public Item previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(Item item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(Item item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }

    // a test client
    public static void main(String[] args) {
        int N  = Integer.parseInt(args[0]);

        // add elements 1, ..., N
        StdOut.println(N + "" random integers between 0 and 99"");
        Deque<Integer> list = new Deque<Integer>();
        for (int i = 0; i < N; i++)
            list.add(StdRandom.uniform(100));
        StdOut.println(list);
        StdOut.println();

        ListIterator<Integer> iterator = list.iterator();

        // go forwards with next() and set()
        StdOut.println(""add 1 to each element via next() and set()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            iterator.set(x + 1);
        }
        StdOut.println(list);
        StdOut.println();

        // go backwards with previous() and set()
        StdOut.println(""multiply each element by 3 via previous() and set()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            iterator.set(x + x + x);
        }
        StdOut.println(list);
        StdOut.println();


        // remove all elements that are multiples of 4 via next() and remove()
        StdOut.println(""remove elements that are a multiple of 4 via next() and remove()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            if (x % 4 == 0) iterator.remove();
        }
        StdOut.println(list);
        StdOut.println();


        // remove all even elements via previous() and remove()
        StdOut.println(""remove elements that are even via previous() and remove()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            if (x % 2 == 0) iterator.remove();
        }
        StdOut.println(list);
        StdOut.println();


        // add elements via next() and add()
        StdOut.println(""add elements via next() and add()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            iterator.add(x + 1);
        }
        StdOut.println(list);
        StdOut.println();

        // add elements via previous() and add()
        StdOut.println(""add elements via previous() and add()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            iterator.add(x * 10);
            iterator.previous();
        }
        StdOut.println(list);
        StdOut.println();
    }
}

@0789750710e1599d2602220fbecbeb92@"
"r04546032","0","0","0","@0789750710e1599d2602220fbecbeb92@import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<Item> implements Iterable<Item>{

   private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre  = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private Item item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty()    { return N == 0; }
    public int size()           { return N;      }

    // add the item to the list
    public void add(Item item) {
        Node last = post.prev;
        Node x = new Node();
        x.item = item;
        x.next = post;
        x.prev = last;
        post.prev = x;
        last.next = x;
        N++;
    }
 
    public ListIterator<Item> iterator()  { return new DequeIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DequeIterator implements ListIterator<Item> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            Item item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public Item previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(Item item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(Item item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }

    // a test client
    public static void main(String[] args) {
        int N  = Integer.parseInt(args[0]);

        // add elements 1, ..., N
        StdOut.println(N + "" random integers between 0 and 99"");
        Deque<Integer> list = new Deque<Integer>();
        for (int i = 0; i < N; i++)
            list.add(StdRandom.uniform(100));
        StdOut.println(list);
        StdOut.println();

        ListIterator<Integer> iterator = list.iterator();

        // go forwards with next() and set()
        StdOut.println(""add 1 to each element via next() and set()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            iterator.set(x + 1);
        }
        StdOut.println(list);
        StdOut.println();

        // go backwards with previous() and set()
        StdOut.println(""multiply each element by 3 via previous() and set()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            iterator.set(x + x + x);
        }
        StdOut.println(list);
        StdOut.println();


        // remove all elements that are multiples of 4 via next() and remove()
        StdOut.println(""remove elements that are a multiple of 4 via next() and remove()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            if (x % 4 == 0) iterator.remove();
        }
        StdOut.println(list);
        StdOut.println();


        // remove all even elements via previous() and remove()
        StdOut.println(""remove elements that are even via previous() and remove()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            if (x % 2 == 0) iterator.remove();
        }
        StdOut.println(list);
        StdOut.println();


        // add elements via next() and add()
        StdOut.println(""add elements via next() and add()"");
        while (iterator.hasNext()) {
            int x = iterator.next();
            iterator.add(x + 1);
        }
        StdOut.println(list);
        StdOut.println();

        // add elements via previous() and add()
        StdOut.println(""add elements via previous() and add()"");
        while (iterator.hasPrevious()) {
            int x = iterator.previous();
            iterator.add(x * 10);
            iterator.previous();
        }
        StdOut.println(list);
        StdOut.println();
    }
}

@0789750710e1599d2602220fbecbeb92@"
"r04546032","0","0","0","@fe942f8f13d08973280d9af4ffeff227@import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<Item> implements Iterable<Item>{

   private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre  = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private Item item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty()    { return N == 0; }
    public int size()           { return N;      }

    // add the item to the list
    public void add(Item item) {
        Node last = post.prev;
        Node x = new Node();
        x.item = item;
        x.next = post;
        x.prev = last;
        post.prev = x;
        last.next = x;
        N++;
    }
 
    public ListIterator<Item> iterator()  { return new DequeIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DequeIterator implements ListIterator<Item> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            Item item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public Item previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(Item item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(Item item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }

    // a test client
    public static void main(String[] args) {
   
    }
}
@fe942f8f13d08973280d9af4ffeff227@"
"b02611019","5","1.46","179152","@837c5bbd51b0bd1b0e43ff363a0ee0f0@import java.util.Iterator;
import java.util.*;//NoSuchElementException;
import java.util.Scanner;


public class Deque <Item> implements Iterable {
    private Node first, last;
    static int num;
    private class Node 
    {
        Item item;
        Node next;
    }

   public Deque()   {
       first=null;
       last=null;
       
   }// construct an empty deque

   public boolean isEmpty()  {// is the deque empty?
       return first == null;
   }

   public int size(){                        // return the number of items on the deque
       return num;
      
   }

   public void addFirst(Item item){

         if(item==null){
            throw new NullPointerException() ;
        }
        else{
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            num++;
            
            if(last == null)
                last = first;
        }
   }// add the item to the front

   public void addLast(Item item){
       if(item==null){
           throw new NullPointerException();
       }
       else{
           Node oldlast = last;
           last = new Node();
           last.item = item;
           last.next = null;
           if (isEmpty()) first = last;
           else oldlast.next = last;
           num++;
           
           if(first == null)
               first = last;
       }
       
   }// add the item to the end

   public Item removeFirst() {               // remove and return the item from the front
       
       if(first == null){
           throw new NoSuchElementException();
       }
       else{
            Item item = first.item;
            first = first.next;
            num--;
            return item;
       }
       
   }

   public Item removeLast(){                 // remove and return the item from the end
      
       if(last==null||num==0){
           
           throw new NoSuchElementException();
       }
       else{
           Item item = last.item;
           last=null;
           Node newlast=first;
           for(int i=0;i<=(num-3);i++)newlast=newlast.next;

           last=newlast;

           if (isEmpty()) last = null;
           num--;
           return item;
       }
   }

   public Iterator iterator()   {      // return an iterator over items in order from front to end
       
       return new ListIterator();
   }
   private class ListIterator implements Iterator<Item>
    {
        private Node current = first;
        public boolean hasNext() { return current != null; }
        public void remove() { /* not supported */
            throw new UnsupportedOperationException(); 
        
        }
        public Item next()
        {
            if(current.item==null ){
                throw new NoSuchElementException(); 
            }
            else{
                Item item = current.item;
                current = current.next;
                return item;
            }
        }
    }

   public static void main(String[] args){   // unit testing
       
       Deque aa= new Deque();
       
       Scanner scanner = new Scanner(System.in);
       String ss=""aa"";
       try{
//            aa.addFirst(""ss"");
           
            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());
            
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
//            StdOut.print(aa.removeLast());
//            StdOut.print(aa.removeLast());
            
//            StdOut.print(aa.removeFirst());
//            StdOut.print(aa.removeFirst());
//            StdOut.print(aa.removeFirst());
//            StdOut.print(aa.removeFirst());
//            StdOut.print(aa.removeFirst());
       }
       catch(NoSuchElementException exx){
           StdOut.print(""remove 為 null"");
       }
       catch(NullPointerException ex){
           StdOut.print(""輸入為NULL"");
       }
       
       

               
   }

}
@837c5bbd51b0bd1b0e43ff363a0ee0f0@"
"r04921094","5","1.43","182416","@4a2f30e01a9e036d2fe6bee3cbc26aa1@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		//first.next.previous = null;
		first = first.next;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		//last.previous.next = null;
		last = last.previous;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addFirst(""2"");
		System.out.println(deque.removeFirst());
		System.out.println(deque.removeFirst());
	}
}
@4a2f30e01a9e036d2fe6bee3cbc26aa1@"
"b02611016","7","1.08","102480","@59a877af68ad9fcfbb53fe7aa53f5704@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
        StdOut.println(""("" + D.size() + "" left on deque)"");
    }
        // TODO code application logic here
    }
    

@59a877af68ad9fcfbb53fe7aa53f5704@"
"r04921094","7","1.43","183328","@2d49b2888a02691dd7fb48412a6cbba1@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		//first.next.previous = null;
		first = first.next;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		//last.previous.next = null;
		last = last.previous;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		String a = null;
		deque.addFirst(""1"");
		deque.addFirst(""2"");
		deque.addFirst(a);
		System.out.println(deque.removeFirst());
		System.out.println(deque.removeFirst());
	}
}
@2d49b2888a02691dd7fb48412a6cbba1@"
"b02611016","7","1.07","102384","@d6db4056d3b1734d9ef57ccaa13b68de@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
 /*   public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }*/
    
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }
        // TODO code application logic here
    }
    

@d6db4056d3b1734d9ef57ccaa13b68de@"
"b02611016","7","1.09","102480","@aa7305e2d16cdd9213858220697206b9@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
     @Override
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }
        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }
        // TODO code application logic here
    }
    

@aa7305e2d16cdd9213858220697206b9@"
"r04921094","9","1.37","182928","@d596c4eeee25fcf4b7886e9192a7fb0e@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		//first.next.previous = null;
		first = first.next;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		last.previous.next = null;
		last = last.previous;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addFirst(""0"");
		System.out.println(deque.removeLast());
		Iterator<String> i = deque.iterator();
		while(i.hasNext()){
			String s = i.next();
			System.out.print(s);
		}
		System.out.println();

		System.out.println(deque.removeLast());

	}
}
@d596c4eeee25fcf4b7886e9192a7fb0e@"
"r04921094","7","0.81","102368","@47725648c8c6ff4b7c9c6c56aed01ebd@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		first.next.previous = null;
		first = first.next;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		last.previous.next = null;
		last = last.previous;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addFirst(""0"");
		System.out.println(deque.removeLast());
		Iterator<String> i = deque.iterator();
		while(i.hasNext()){
			String s = i.next();
			System.out.print(s);
		}
		System.out.println();

		System.out.println(deque.removeLast());

	}
}
@47725648c8c6ff4b7c9c6c56aed01ebd@"
"r04921104","0","1.09","102480","@b96e6373672dbe74b11f7fb0e387dde9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

;

public class Deques<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N = 0;               // number of elements on deque

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deques() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

    public boolean isEmpty() {
        return N == 0;
    }// is the deque empty?

    public int size() {
        return N;
    }// return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        //StdOut.println(item.getClass());
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.previous = oldlast;
        }
        N++;
    }// add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
        }
        return item;
    }// remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
        }
        return item;
    }// remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }         // return an iterator over items in order from front to end

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    //test
//    public static void main(String[] args) {
//        Deque<Integer> q = new Deque<Integer>();
//        while (true) {
//            String item = StdIn.readString();
//            if (item.equals(""++"")) {
//                int adfst = StdIn.readInt();
//                q.addFirst(adfst);
//            } else if (item.equals(""+-"")) {
//                int adlst = StdIn.readInt();
//                q.addLast(adlst);
//            } else if (item.equals(""-+"")) {
//                int rmfst = q.removeFirst();
//                StdOut.println(rmfst);
//            } else if (item.equals(""--"")) {
//                int rmlst = q.removeLast();
//                StdOut.println(rmlst);
//            } else if (item.equals(""q"")) {
//                break;
//            } else {
//                StdOut.println(""please enter '++','+-','-+','--' or'q' to break"");
//            }
//        }
//
//        StdOut.println(""("" + q.size() + "" left on deque)"");
//        
//        Iterator<Integer> i = q.iterator();
//        //i.remove();
//        while (i.hasNext()) {
//            StdOut.println(i.next().toString());
//        }
//        StdOut.println(i.next().toString());
//    }

}

@b96e6373672dbe74b11f7fb0e387dde9@"
"r04921094","9","1.4","179312","@4d135b2d296a7f546a62959a028139a0@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		//first.next.previous = null;
		first = first.next;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()){
			throw new java.util.NoSuchElementException();
		}
		Item popItem = last.item;
		if(last.previous != null)last.previous.next = null;
		last = last.previous;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addFirst(""0"");
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		Iterator<String> i = deque.iterator();
		while(i.hasNext()){
			String s = i.next();
			System.out.print(""I:"" + s);
		}
		System.out.println();

		//System.out.println(deque.removeLast());

	}
}
@4d135b2d296a7f546a62959a028139a0@"
"r04921094","9","1.41","181600","@dc95236eb8386ba65e863de3576825b1@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		//first.next.previous = null;
		first = first.next;
		if(first == null) last = null;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		if(last.previous != null) last.previous.next = null;
		last = last.previous;
		if(last == null) first = null;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addFirst(""0"");
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		Iterator<String> i = deque.iterator();
		while(i.hasNext()){
			String s = i.next();
			System.out.print(""I:"" + s);
		}
		System.out.println();

		//System.out.println(deque.removeLast());

	}
}
@dc95236eb8386ba65e863de3576825b1@"
"r04921094","10","0.14","177472","@7bbac205ff012a63d80161d9124274c7@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable{
	private int N;			// number of elements
	private Element<Item> first;
	private Element<Item> last;

	public Deque(){
		N = 0;
		first = null;
		last = null;
	} 

	private class Element<Item>{
		private Item item;
		private Element<Item> next;
		private Element<Item> previous;
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newFirst = new Element<Item>();
		if (isEmpty())  last = newFirst;
		else first.previous = newFirst;
		newFirst.item = item;
		newFirst.next = first;
		newFirst.previous = null;
		first = newFirst;
		++N;
	}

	public void addLast(Item item){
		if(item == null) throw new java.lang.NullPointerException();
		Element<Item> newLast = new Element<Item>();
		if (isEmpty())  first = newLast;
		else last.next = newLast;
		newLast.item = item;
		newLast.next = null;
		newLast.previous = last;
		last = newLast;
		++N;
	}

	public Item removeFirst(){			// garbage collection???
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = first.item;
		if(first.next != null) first.next.previous = null;
		first = first.next;
		if(first == null) last = null;
		--N;
		return popItem;
	}

	public Item removeLast(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		Item popItem = last.item;
		if(last.previous != null) last.previous.next = null;
		last = last.previous;
		if(last == null) first = null;
		--N;
		return popItem;
	}

	public Iterator<Item> iterator(){
		return new DequeIterator<Item>(first);
	}

	public class DequeIterator<Item> implements Iterator<Item>{
			public Element<Item> current;

			public DequeIterator(Element<Item> first){
				current = first;
			}

			public boolean hasNext(){
				return current != null;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public Item next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				Item item = current.item;
				current = current.next;
				return item;
			}

		};

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addFirst(""0"");
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		System.out.println(deque.removeLast());
		Iterator<String> i = deque.iterator();
		while(i.hasNext()){
			String s = i.next();
			System.out.print(""I:"" + s);
		}
		System.out.println();

		//System.out.println(deque.removeLast());

	}
}
@7bbac205ff012a63d80161d9124274c7@"
"r04921104","0","1.4","179312","@987c89746b28c154e1c59a80ead1414f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

public class Deques<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N = 0;               // number of elements on deque

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deques() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

    public boolean isEmpty() {
        return N == 0;
    }// is the deque empty?

    public int size() {
        return N;
    }// return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        //StdOut.println(item.getClass());
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.previous = oldlast;
        }
        N++;
    }// add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Deques underflow"");
        }
        Item item = first.item;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
            first = null;
        } else {
            first = first.next;
            first.previous = null;
        }
        return item;
    }// remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Deques underflow"");
        }
        Item item = last.item;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
            last = null;
        } else {
            last = last.previous;
            last.next = null;
        }
        return item;
    }// remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }         // return an iterator over items in order from front to end

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    //test
    public static void main(String[] args) {
        Deques<Integer> q = new Deques<Integer>();
        while (true) {
            String item = StdIn.readString();
            if (item.equals(""++"")) {
                int adfst = StdIn.readInt();
                q.addFirst(adfst);
            } else if (item.equals(""+-"")) {
                int adlst = StdIn.readInt();
                q.addLast(adlst);
            } else if (item.equals(""-+"")) {
                int rmfst = q.removeFirst();
                StdOut.println(rmfst);
            } else if (item.equals(""--"")) {
                int rmlst = q.removeLast();
                StdOut.println(rmlst);
            } else if (item.equals(""q"")) {
                break;
            } else {
                StdOut.println(""please enter '++','+-','-+','--' or'q' to break"");
            }
        }

        StdOut.println(""("" + q.size() + "" left on deque)"");

        Iterator<Integer> i = q.iterator();
        //i.remove();
        while (i.hasNext()) {
            StdOut.println(i.next().toString());
        }
    }

}

@987c89746b28c154e1c59a80ead1414f@"
"r04921104","10","0.139","180864","@faeea4449246d8a832f0e6f97dd627b5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N = 0;               // number of elements on deque

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

    public boolean isEmpty() {
        return N == 0;
    }// is the deque empty?

    public int size() {
        return N;
    }// return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""uncompatible null input"");
        }
        //StdOut.println(item.getClass());
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.previous = oldlast;
        }
        N++;
    }// add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Deques underflow"");
        }
        Item item = first.item;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
            first = null;
        } else {
            first = first.next;
            first.previous = null;
        }
        return item;
    }// remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Deques underflow"");
        }
        Item item = last.item;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
            last = null;
        } else {
            last = last.previous;
            last.next = null;
        }
        return item;
    }// remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }         // return an iterator over items in order from front to end

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    //test
    public static void main(String[] args) {
        Deque<Integer> q = new Deque<Integer>();
        while (true) {
            String item = StdIn.readString();
            if (item.equals(""++"")) {
                int adfst = StdIn.readInt();
                q.addFirst(adfst);
            } else if (item.equals(""+-"")) {
                int adlst = StdIn.readInt();
                q.addLast(adlst);
            } else if (item.equals(""-+"")) {
                int rmfst = q.removeFirst();
                StdOut.println(rmfst);
            } else if (item.equals(""--"")) {
                int rmlst = q.removeLast();
                StdOut.println(rmlst);
            } else if (item.equals(""q"")) {
                break;
            } else {
                StdOut.println(""please enter '++','+-','-+','--' or'q' to break"");
            }
        }

        StdOut.println(""("" + q.size() + "" left on deque)"");

        Iterator<Integer> i = q.iterator();
        //i.remove();
        while (i.hasNext()) {
            StdOut.println(i.next().toString());
        }
    }

}

@faeea4449246d8a832f0e6f97dd627b5@"
"r04942099","7","1.46","179248","@63da664737593ab7c48fdfcb2a4239ea@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }

    public Deque() {
      
    }// construct an empty deque

    public boolean isEmpty() {
        return N==0;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException();
        }
        
        Item item = first.item;
        first = first.next;
        if (N==0) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.previous;
        if (N==0) {
            last = null;
        }
        N--;
        return item;

    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@63da664737593ab7c48fdfcb2a4239ea@"
"r04942099","7","1.45","181280","@9938c783c68c51a5279f7b28c03f8322@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        if (N==0) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        if (N==0) {
            last = null;
        }
        N--;
        return item;

    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@9938c783c68c51a5279f7b28c03f8322@"
"b02611016","7","1.06","102416","@595ae732ba2a4e4240fae0e351b3e7c8@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
     @Override
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }
        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       //throw new NullPointerException();
    }
        // TODO code application logic here
    }
    

@595ae732ba2a4e4240fae0e351b3e7c8@"
"b02611016","7","1.07","102448","@a27c0cbf38902f32cd750d259a2c8f7a@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
     @Override
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
   
        public boolean hasNext()  { return current != null;                     }
      
        public void remove()      { /*throw new UnsupportedOperationException(); */ }
       
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }
        // TODO code application logic here
    }
    

@a27c0cbf38902f32cd750d259a2c8f7a@"
"r04942099","7","1.47","178832","@125a4a4019400c98130572aa7c4384a7@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        if (isEmpty()) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
       /* last = last.previous;
        if (last == null) {
            first = null;
        }
        N--;*/
        return item;
     
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@125a4a4019400c98130572aa7c4384a7@"
"r04942099","6","0.81","102080","@2dade646a2a4ea47aa8ab197452f0fc3@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (N==0) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (N==0) {
            first = null;
        }
        
        return item;
     
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@2dade646a2a4ea47aa8ab197452f0fc3@"
"b02611016","7","1.55","186192","@7996a71eac635fbdec53d6dd4041f94a@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
     
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
  /* {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }*/
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
   public Item removeLast()                 // remove and return the item from the end
 /*  { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}*/
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
   
        public boolean hasNext()  { return current != null;                     }
      
        public void remove()      { throw new UnsupportedOperationException();  }
       
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }
        // TODO code application logic here
    }
    

@7996a71eac635fbdec53d6dd4041f94a@"
"r04942099","6","0.86","101936","@f738ea016dc7eb5456a4b1a69767225f@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        //first.previous = null;
        N--;
        if (N==0) {
            last = null;
        }
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) {
            first = null;
        }
        
        return item;
     
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@f738ea016dc7eb5456a4b1a69767225f@"
"r04942099","6","0.84","102432","@ff691c82dd383c428b5af44bf85e9809@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        
        N--;
        if (N==0) {
            last = null;
        }else{first.previous = null;}
        N--;
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        
        N--;
        if (N==0) {
            first = null;
        }else{last.next = null;}
        
        return item;
     
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@ff691c82dd383c428b5af44bf85e9809@"
"r04942099","10","0.139","180960","@dacdb911c2754118111331549f2193da@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node first=null;
    private Node last=null;

    private int N = 0;

    private class Node {

        Item item;
        Node next=null;
        Node previous=null;

    }



    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
        }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        
        if (N==0) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        N++;
    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        
        if (N==0) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }           // add the item to the end

    public Item removeFirst() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        Item item = first.item;
        first = first.next;
        
        N--;
        if (N==0) {
            last = null;
        }else{first.previous = null;}
        
        return item;
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N==0) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        last = last.previous;
        
        N--;
        if (N==0) {
            first = null;
        }else{last.next = null;}
        
        return item;
     
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }        // return an iterator over items in order from front to end

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }   // unit testing

}

@dacdb911c2754118111331549f2193da@"
"r04921051","6","0.82","102336","@95aa80673603f7bfaefbd43293791760@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@95aa80673603f7bfaefbd43293791760@"
"b02611019","8","1.15","164368","@aa5cfc2fdb7c2c6646c6214e0455c85f@
import java.util.Iterator;
import java.util.*;//NoSuchElementException;
import java.util.Scanner;

public class Deque<Item> implements Iterable {

    private Node first, last;
    static int num;

    private class Node {

        Item item;
        Node next;
        Node pre;
    }

    public Deque() {
        this.first = null;
        this.last = null;

    }// construct an empty deque

    public boolean isEmpty() {// is the deque empty?
        return num == 0;
    }

    public int size() {                        // return the number of items on the deque
        return num;

    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException();
        } else {
            Node newnode = new Node();
            newnode.item = item;
            if (isEmpty()) {
                newnode.pre = null;
                newnode.next = null;
                first = newnode;
                last = newnode;
            } else {
                newnode.next = first;
                newnode.pre = null;
                first.pre = newnode;
                first = newnode;
            }

            num++;
        }
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node newnode = new Node();
            newnode.item = item;
            if (isEmpty()) {
                newnode.pre = null;
                newnode.next = null;
                first = newnode;
                last = newnode;
            } else {
                last.next = newnode;
                newnode.pre = last;
                newnode.next = null;
                last = newnode;
            }
            num++;
        }

    }// add the item to the end

    public Item removeFirst() {               // remove and return the item from the front
        if (first == null) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            if (first == last) {
                first = null;
                last = null;
            } else {
                first = first.next;
                first.pre = null;
            }
            num--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end

        if (last == null || num == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            if (first == last) {
                first = null;
                last = null;
            } else {
                last = last.pre;
                last.next=null;
            }
            num--;
            return item;
        }
    }

    public Iterator iterator() {      // return an iterator over items in order from front to end

        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() { /* not supported */

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (current.item == null) {
                throw new NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }
    }

    public static void main(String[] args) {   // unit testing

        Deque aa = new Deque();

        Scanner scanner = new Scanner(System.in);
        String ss = ""aa"";
        try {
//            aa.addFirst(""ss"");

            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());

//            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
//            Iterator iterator = aa.iterator();
//            while (iterator.hasNext()) {
//                StdOut.print(iterator.next());
//            }
        } catch (NoSuchElementException exx) {
            StdOut.print(""remove 為 null"");
        } catch (NullPointerException ex) {
            StdOut.print(""輸入為NULL"");
        }

    }

}

@aa5cfc2fdb7c2c6646c6214e0455c85f@"
"b02611019","8","1.15","175424","@9d56c323ae6c0434b2747fb8d5731030@
import java.util.Iterator;
import java.util.*;//NoSuchElementException;
import java.util.Scanner;

public class Deque<Item> {

    private Node first, last;
    static int num;

    private class Node {

        Item item;
        Node next;
        Node pre;
    }

    public Deque() {
        this.first = null;
        this.last = null;

    }// construct an empty deque

    public boolean isEmpty() {// is the deque empty?
        return num == 0;
    }

    public int size() {                        // return the number of items on the deque
        return num;

    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException();
        } else {
            Node newnode = new Node();
            newnode.item = item;
            if (isEmpty()) {
                newnode.pre = null;
                newnode.next = null;
                first = newnode;
                last = newnode;
            } else {
                newnode.next = first;
                newnode.pre = null;
                first.pre = newnode;
                first = newnode;
            }

            num++;
        }
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node newnode = new Node();
            newnode.item = item;
            if (isEmpty()) {
                newnode.pre = null;
                newnode.next = null;
                first = newnode;
                last = newnode;
            } else {
                last.next = newnode;
                newnode.pre = last;
                newnode.next = null;
                last = newnode;
            }
            num++;
        }

    }// add the item to the end

    public Item removeFirst() {               // remove and return the item from the front
        if (first == null) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            if (first == last) {
                first = null;
                last = null;
            } else {
                first = first.next;
                first.pre = null;
            }
            num--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end

        if (last == null || num == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            if (first == last) {
                first = null;
                last = null;
            } else {
                last = last.pre;
                last.next=null;
            }
            num--;
            return item;
        }
    }

    public Iterator iterator() {      // return an iterator over items in order from front to end

        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() { /* not supported */

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (current.item == null) {
                throw new NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }
    }

    public static void main(String[] args) {   // unit testing

        Deque aa = new Deque();

        Scanner scanner = new Scanner(System.in);
        String ss = ""aa"";
        try {
//            aa.addFirst(""ss"");

            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());
            aa.addFirst(scanner.nextLine());

//            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
            StdOut.print(aa.removeLast());
//            Iterator iterator = aa.iterator();
//            while (iterator.hasNext()) {
//                StdOut.print(iterator.next());
//            }
        } catch (NoSuchElementException exx) {
            StdOut.print(""remove 為 null"");
        } catch (NullPointerException ex) {
            StdOut.print(""輸入為NULL"");
        }

    }

}

@9d56c323ae6c0434b2747fb8d5731030@"
"r04447001","7","1.75","181696","@2c05af67036d37cd29656cf1613a55f7@
import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author jerry
 */
public class Deque<Item> implements Iterable<Item> {

    private Item[] s;
    private int first;
    private int last;
    private int N;

    public Deque() {
        s = (Item[]) new Object[1024];
        first = 1023;
        last = 0;
        N = 0;
    }

    public boolean isEmpty() {
        if (N == 0) {
            return true;
        }
        return false;
    }

    public int size() {
        return N;
    }
    
    private void resize(int max){
          Item[] temp = (Item[]) new Object[max];
          first++;
        for (int i = 0; i < N; i++) {
            temp[i] = s[(first + i) % s.length];
        }
        s = temp;
        first = s.length-1;
        last  = 0;  
    }


    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == s.length) resize(2*s.length);   // double size of array if necessary
        s[first] = item;  // add item
        first--;
        if (first == -1) first = s.length-1;          // wrap-around
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == s.length) resize(2*s.length);   // double size of array if necessary
        s[last] = item;                        // add item
        last++;
        if (last == s.length) last = 0;          // wrap-around
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        first++;
        if (first == s.length) first = 0;
        Item item = s[first];
        s[first] = null;                            // to avoid loitering
        N--;
        // shrink size of array if necessary
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        last--;
        if (last == -1) last = s.length-1;
        Item item = s[last];
        s[last] = null;                            // to avoid loitering
        N--;
        // shrink size of array if necessary
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        private int i = (first+1);

        public boolean hasNext() {
            if(i >= last) return (i-s.length) < last;
            else return i < last;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = s[i % s.length];
            i++;
            return item;
    }
    }

}

@2c05af67036d37cd29656cf1613a55f7@"
"r04921012","0","1.01","107072","@5623bb089fd24cfc026c43c8003cdaf9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;

/**
 *
 * @author steven
 */
public class Deque implements Iterable{
    private ArrayList list;
    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque
   public class Item<T>{
       private T t;
       public void set(T t){
           this.t=t;
       }
       public T get(){
           return t;
       }
   }
   public void addFirst(Item item){
       list.add(0,item);
   }// add the item to the front

   public void addLast(Item item){
       list.add(item);
   }// add the item to the end

   public Item removeFirst(){
       Item a = null;
       a.set(list.get(0));
       list.remove(0);
       return a;
       
   }// remove and return the item from the front

   public Item removeLast(){
       Item a=null;
       a.set(list.get(list.size()-1));
       list.remove(list.size()-1);
       return a;
   }// remove and return the item from the end

   public Iterator iterator(){
       return list.iterator();
   }// return an iterator over items in order from front to end

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@5623bb089fd24cfc026c43c8003cdaf9@"
"b02611016","7","1.07","102496","@0a4c8fe8f35a57fe33a89de278ad00f8@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }
   // Deque tttt = new Deque() ; 
    
    
}
        // TODO code application logic here

  
    

@0a4c8fe8f35a57fe33a89de278ad00f8@"
"r04921051","7","0.84","102480","@a7abe3e3dcafbbf8eb880c41a2bba004@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@a7abe3e3dcafbbf8eb880c41a2bba004@"
"b03611023","9","1.41","173424","@ea788961a946d34970f16ee30e7b4254@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return first == null;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     if(last == null){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
         first.next = oldfirst;
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(first == null){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      N--;      
      return remove;
  }
 
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@ea788961a946d34970f16ee30e7b4254@"
"r03525008","8","1.5","173136","@7e6cf27ce68bfb6e844d9371ce38573a@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Yang Chi-Chang on 2016/3/25.
 */
public class Deque<E> implements Iterable {

    private Object[] elementData;
    private int size;
    private static final int DEFAULT_SIZE = 10;

    public Deque(){
        this.elementData = new Object[DEFAULT_SIZE];
        size = 0;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    public void addFirst(E e){
        if(e == null) throw new NullPointerException();
        for(int i = size++ ; i > 0 ; i--)
            elementData[i] = elementData[i-1];
        elementData[0] = e;
        resize();
    }

    public void addLast(E e){
        if(e == null) throw new NullPointerException();
        elementData[size++] = e;
        resize();
    }

    public E removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        E first = (E) elementData[0];
        for(int i = 0 ; i < size-2 ; i++)
            elementData[i] = elementData[i+1];
        size--;
        resize();
        return first;
    }

    public E removeLast(){
        if(isEmpty()) throw new NoSuchElementException();
        resize();
        return (E) elementData[size--];
    }



    private void resize(){
        if(size == elementData.length){
            Object[] copy = new Object[2*elementData.length];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        } else if (size <= elementData.length/4){
            Object[] copy = new Object[elementData.length/2];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        }
    }


    public String toString(){
        String s = ""["";
        for(int i = 0; i < size; i++)
            s += elementData[i] + "","";
        s = s.substring(0,s.length()-1)+""]"";
        return s;
    }


    @Override
    public Iterator<E> iterator() {
        Iterator<E> iterator = new Iterator<E>() {

            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public E next() {
                if(!hasNext()) throw new NoSuchElementException();
                return (E) elementData[index++];
            }

            public void remove(){
                throw new UnsupportedOperationException();
            }

        };
        return iterator;
    }
}

@7e6cf27ce68bfb6e844d9371ce38573a@"
"b03611023","9","1.39","177920","@4360385b246a81279260bafb4d216342@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     if(last == null){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
         first.next = oldfirst;
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(first == null){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      N--;      
      return remove;
  }
 
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@4360385b246a81279260bafb4d216342@"
"r04921051","7","0.84","102400","@19d32e0d15d2492dd9e3817d6b10a19a@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@19d32e0d15d2492dd9e3817d6b10a19a@"
"r03525008","10","0.155","172192","@87c365588378708eba90269fb9b79320@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Yang Chi-Chang on 2016/3/25.
 */
public class Deque<E> implements Iterable {

    private Object[] elementData;
    private int size;
    private static final int DEFAULT_SIZE = 10;

    public Deque(){
        this.elementData = new Object[DEFAULT_SIZE];
        size = 0;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    public void addFirst(E e){
        if(e == null) throw new NullPointerException();
        for(int i = size++ ; i > 0 ; i--)
            elementData[i] = elementData[i-1];
        elementData[0] = e;
        resize();
    }

    public void addLast(E e){
        if(e == null) throw new NullPointerException();
        elementData[size++] = e;
        resize();
    }

    public E removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        E first = (E) elementData[0];
        for(int i = 0 ; i < size-1 ; i++)
            elementData[i] = elementData[i+1];
        size--;
        resize();
        return first;
    }

    public E removeLast(){
        if(isEmpty()) throw new NoSuchElementException();
        resize();
        return (E) elementData[size--];
    }



    private void resize(){
        if(size == elementData.length){
            Object[] copy = new Object[2*elementData.length];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        } else if (size <= elementData.length/4){
            Object[] copy = new Object[elementData.length/2];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        }
    }


    public String toString(){
        String s = ""["";
        for(int i = 0; i < size; i++)
            s += elementData[i] + "","";
        s = s.substring(0,s.length()-1)+""]"";
        return s;
    }


    @Override
    public Iterator<E> iterator() {
        Iterator<E> iterator = new Iterator<E>() {

            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public E next() {
                if(!hasNext()) throw new NoSuchElementException();
                return (E) elementData[index++];
            }

            public void remove(){
                throw new UnsupportedOperationException();
            }

        };
        return iterator;
    }
}

@87c365588378708eba90269fb9b79320@"
"r04921051","0","1.39","177920","@6b11a7f8bcbf06bc90fda90cc19bde81@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){/*
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;*/
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@6b11a7f8bcbf06bc90fda90cc19bde81@"
"b03611023","9","1.39","178608","@a9d841b05b0fd6d22b480484e3fb9dd0@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     if(last == null){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
         first.next = oldfirst;
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(first == null){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@a9d841b05b0fd6d22b480484e3fb9dd0@"
"r04921051","7","0.82","102368","@274abbde8aff4f74facb5225fea655a3@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@274abbde8aff4f74facb5225fea655a3@"
"r04921051","0","0.81","100144","@86e56924c7c5da730048e0cd06d936e0@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@86e56924c7c5da730048e0cd06d936e0@"
"r04921051","7","0.84","101664","@274abbde8aff4f74facb5225fea655a3@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@274abbde8aff4f74facb5225fea655a3@"
"r04921051","0","0.84","102448","@401574accf3f13a6bf16252a477b75dd@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@401574accf3f13a6bf16252a477b75dd@"
"b02611016","6","0.84","102464","@bbf272a38d8f835922c4cb50634a9d23@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     @Override
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            for(int i=0;i<24;i++){
            deque.addFirst(data[i]);
             System.out.println(deque.peek());
            }*/
          //   System.out.println(deque.removeLast());
        Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();
    }

    
    
}
        // TODO code application logic here

  
    

@bbf272a38d8f835922c4cb50634a9d23@"
"r04921051","0","0.82","102656","@86e56924c7c5da730048e0cd06d936e0@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@86e56924c7c5da730048e0cd06d936e0@"
"r04921051","7","0.79","102432","@33fcf2acf6f4a945bb34b6e8bdd992c9@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        Node<Item> dummyfirst = new Node<Item>();
        dummyfirst.next = first;
        return new ListIterator<Item>(dummyfirst);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@33fcf2acf6f4a945bb34b6e8bdd992c9@"
"b02611016","6","0.83","102416","@e4b5190cb101aa597ddaa18b68a51c30@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   {Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
             
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@e4b5190cb101aa597ddaa18b68a51c30@"
"b03611023","9","1.38","179264","@8e950162525829521c166f78118289fa@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     if(N == 0){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
         first.next = oldfirst;
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(N == 0){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@8e950162525829521c166f78118289fa@"
"b02611016","7","0.82","102336","@2c7a2f331390828987305ffc5d87cfde@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
             
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@2c7a2f331390828987305ffc5d87cfde@"
"b02611016","8","1.07","102512","@ae20eee122b1fd088d45de8c9e2c0ccc@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
             
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@ae20eee122b1fd088d45de8c9e2c0ccc@"
"r04921051","9","1.41","184112","@75a13ebcb04ba994a5f7c951c8a6233c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(N > 1)
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(N > 1)
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        Node<Item> dummyfirst = new Node<Item>();
        dummyfirst.next = first;
        return new ListIterator<Item>(dummyfirst);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@75a13ebcb04ba994a5f7c951c8a6233c@"
"r04921051","5","1.49","181040","@5a95fe658c2b8b8ed64dd101e97f3a75@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();/*
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;*/
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(N > 1)
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(N > 1)
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        Node<Item> dummyfirst = new Node<Item>();
        dummyfirst.next = first;
        return new ListIterator<Item>(dummyfirst);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@5a95fe658c2b8b8ed64dd101e97f3a75@"
"r04921051","7","0.95","102496","@2459a9262b81e3d7ffd8a0d17588bf29@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(N > 1)
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(N > 1)
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        Node<Item> dummyfirst = new Node<Item>();
        dummyfirst.next = first;
        first.previous = dummyfirst;
        return new ListIterator<Item>(dummyfirst);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@2459a9262b81e3d7ffd8a0d17588bf29@"
"r04921051","9","1.37","184832","@75a13ebcb04ba994a5f7c951c8a6233c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 

         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.previous = first;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(N > 1)
        first.previous = null;
        N--;
        return item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(N > 1)
        last.next = null;
        N--;
        return item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        Node<Item> dummyfirst = new Node<Item>();
        dummyfirst.next = first;
        return new ListIterator<Item>(dummyfirst);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@75a13ebcb04ba994a5f7c951c8a6233c@"
"r04921051","0","1.4","173712","@6f463960679fb7f7941b7025e72b5f21@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.previous = null;
        first.next = last;
        last.item = null;
        last.previous = first;
        last.next = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 
         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.previous = last.previous;
        last.previous.next = lastItem;
        last.previous = lastItem;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.previous = first;
        first.next.previous = firstItem;
        first.next = firstItem;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.previous = first;
        first.next = firstItem.next;
        N--;
        return firstItem.item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.previous;
        lastItem.previous.next = last;
        last.previous = lastItem.previous;
        N--;
        return lastItem.item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@6f463960679fb7f7941b7025e72b5f21@"
"r04921051","10","0.139","185664","@3b39aa11a0c212aa653aac994d5447f7@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.previous = null;
        first.next = last;
        last.item = null;
        last.previous = first;
        last.next = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 
         
   public int size(){
        return N;     
    }                        // return the number of items on the deque

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.previous = last.previous;
        last.previous.next = lastItem;
        last.previous = lastItem;
        N++;
    }          // add the item to the end

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.previous = first;
        first.next.previous = firstItem;
        first.next = firstItem;
        N++;
    }             // add the item to the front

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.previous = first;
        first.next = firstItem.next;
        N--;
        return firstItem.item;
    }                // remove and return the item from the front

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.previous;
        lastItem.previous.next = last;
        last.previous = lastItem.previous;
        N--;
        return lastItem.item;
    }                 // remove and return the item from the end

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         // return an iterator over items in order from front to end
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next.item != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            //Item item = current.item;
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}



@3b39aa11a0c212aa653aac994d5447f7@"
"b03611023","9","1.41","178976","@55b5ee390629f85e746580f9a00cf958@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     first.left = null;
     if(N == 0){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
        
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(N == 0){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@55b5ee390629f85e746580f9a00cf958@"
"b03611023","7","0.83","102480","@a3e87f88c9a2770c8b3b4e457b3ff012@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     first.left = null;
     if(N == 0){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
        
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(N == 0){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
      else{
          last.item = null;
      }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      if(last == null){
          first = last;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
        if(first == null){
            throw new NoSuchElementException();
        }
        else{
        
        return new ListIterator<>(first);
        }
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@a3e87f88c9a2770c8b3b4e457b3ff012@"
"b03611023","10","0.142","177424","@7bcad4869a95f6d29f70d82bca8a04f0@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     first.left = null;
     if(N == 0){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
        
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(N == 0){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
     if(first == null){
         last = first;
     }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      if(last == null){
          first = last;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
      
        
        return new ListIterator<>(first);
        
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@7bcad4869a95f6d29f70d82bca8a04f0@"
"r04546032","10","0.16","178368","@4a237b179fa16930a75ae99d56326118@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private static final class NodeIterator<Item> implements Iterator<Item> {
        private Node<Item> next;

        public NodeIterator(final Deque<Item> deque) {
            if (deque.first != null) {
                this.next = deque.first;
            } else {
                this.next = deque.last;
            }
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            final Item item = next.item;
            next = next.next;
            return item;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private static final class Node<Item> {
        private Item item;
        private Node<Item> next;

        public Node(final Item i, final Node<Item> n) {
            item = i;
            next = n;
        }
    }

    private Node<Item> first = null;
    private Node<Item> last = null;
    private int size;

    /**
     * Construct an empty deque
     */
    public Deque() {
    }

    /**
     * Is the deque empty?
     * 
     * @return true if there are no first or last items
     */
    public boolean isEmpty() {
        return first == null && last == null;
    }

    /**
     * Return the number of items on the deque
     * 
     * @return an int >= 0
     */
    public int size() {
        return size;
    }

    /**
     * Insert the item at the front
     * 
     * @param item
     */
    public void addFirst(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            first = new Node<Item>(item, last);
        } else {
            final Node<Item> newFirst = new Node<Item>(item, first);
            first = newFirst;
            if (last == null) {
                last = first.next;
            }
        }
        if (last == null) {
            last = first;
        }
        
        size++;
    }

    /**
     * Insert the item at the end
     * 
     * @param item
     *            the item to add
     */
    public void addLast(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (last == null) {
            last = new Node<Item>(item, null);
            if (first != null) {
                first.next = last;
            }
        } else {
            final Node<Item> newLast = new Node<Item>(item, null);
            final Node<Item> oldLast = last;
            oldLast.next = newLast;
            last = newLast;
            if (first == null) {
                first = oldLast;
            }
        }
        if (first == null) {
            first = last;
        }
        size++;
    }

    /**
     * Delete and return the item at the front
     * 
     * @return the item removed
     */
    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }

        final Node<Item> oldFirst = first;
        if (oldFirst == last) {
            first = null;
            last = null;
        } else {
            final Node<Item> newFirst = first.next;
            first = newFirst;
        }
        size--;
        return oldFirst.item;
    }

    /**
     * Delete and return the item at the end
     * 
     * @return the item removed
     */
    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        final Node<Item> oldLast = last;

        if (first == last) {
            // last item left
            first = null;
            last = null;
        } else if (first != null) {
            // find penultimate Node and set as last
            final Node<Item> newLast = findPenultimateNode();
            newLast.next = null;
            last = newLast;
        } else {
            last = null;
        }
        size--;

        if (oldLast != null) {
            return oldLast.item;
        } else {
            return first.item;
        }
    }

    /**
     * Return an iterator over items in order from front to end
     * 
     * @return an iterator over the items in this queue
     */
    public Iterator<Item> iterator() {
        return new NodeIterator<Item>(this);
    }

    private Node<Item> findPenultimateNode() {
        Node<Item> newLast = first;
        while (newLast.next != null && newLast.next != last) {
            newLast = newLast.next;
        }
        // now at penultimate node i.e. last.previous or last-1
        // newLast.next = null
        return newLast;
    }
}
@4a237b179fa16930a75ae99d56326118@"
"r04631041","0","0.099","108416","@2af24e07a8fe8d05264a1fcfdfc5450b@public class Deque<Item> implements Iterable<Item> {

    private int size;
    private Node first;
    private Node last;

    public Deque() {

    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return size;
    }

    public void addFirst(Item item) {
        throwIfNull(item);

        Node newFirst = new Node();
        newFirst.item = item;

        if (first != null) {
            newFirst.next = first;
            first.previous = newFirst;
        }
        first = newFirst;
        if (last == null) last = first;

        size++;
    }

    public Item removeFirst() {
        throwIfEmpty();

        Node oldFirst = first;
        first = first.next;

        if (first == null)
            last = null;
        else
            first.previous = null;

        size--;

        return oldFirst.item;
    }

    public void addLast(Item item) {
        throwIfNull(item);

        Node newLast = new Node();
        newLast.item = item;

        if (last != null) {
            newLast.previous = last;
            last.next = newLast;
        }
        last = newLast;
        if (first == null) first = last;

        size++;
    }

    public Item removeLast() {
        throwIfEmpty();

        Node oldLast = last;
        last = oldLast.previous;

        if (last == null)
            first = null;
        else
            last.next = null;

        size--;

        return oldLast.item;
    }

    private void throwIfEmpty() {
        if (first == null)
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

    @Override
    public Iterator<Item> iterator() {
        return new ItemsIterator();
    }

    private class ItemsIterator implements Iterator<Item> {

        private Node current;

        public ItemsIterator() {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public Item next() {
            if (current == null)
                throw new NoSuchElementException();

            Item item = current.item;
            current = current.next;
            return item;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private class Node {
        Item item;
        Node next;
        Node previous;
    }

}
@2af24e07a8fe8d05264a1fcfdfc5450b@"
"r04921012","7","1.31","181248","@0e28447d0a8c11bcf42857e87642a655@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       T a = null;
       a=list.get(0);
       list.remove(0);
       return a;
       
   }// remove and return the item from the front

   public T removeLast(){
       T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;
   }// remove and return the item from the end

   public Iterator iterator(){
       return list.iterator();
   }// return an iterator over items in order from front to end

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@0e28447d0a8c11bcf42857e87642a655@"
"r04921012","8","0.93","102304","@6f85b7da48e037412bb7201871c6d7c7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a = null;
       a=list.get(0);
       list.remove(0);
       return a;
       
   }// remove and return the item from the front

   public T removeLast(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;
   }// remove and return the item from the end

   public Iterator iterator(){
       return list.iterator();
   }// return an iterator over items in order from front to end

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> a=new Deque<String>();
        String b=null;
        a.addFirst(b);
        String c=a.removeFirst();
        System.out.println(c);
    }
    
}

@6f85b7da48e037412bb7201871c6d7c7@"
"r04631041","7","1.15","182256","@3b76857aeace3cdccf2f6f12bc30d5e0@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator();}
    private class ListIterator implements Iterator<Item>
    {
       private Node current=first;
       public boolean hasNext() {return current!=null;}
       public void remove() {}
       public Item next()
               {
                   Item item=current.item;
                   current=current.next;
                   return item;
               }
    }
    private Node first;
    private Node last;
    private  int number;
    private class Node
    {
        Item item;
        Node next;
        Node previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       return item;
    }
    public static void main(String[] args){
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        testing.addLast(""i"");
        testing.addFirst(""b"");
        testing.addLast(""j"");
        testing.addFirst(""k"");
        testing.addFirst(""p"");
        testing.addLast(""q"");
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}
@3b76857aeace3cdccf2f6f12bc30d5e0@"
"r04921012","8","0.93","102336","@78da636d44050cad08e2b661cb9092c3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a = null;
       a=list.get(0);
       list.remove(0);
       return a;
       
   }// remove and return the item from the front

   public T removeLast(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;
   }// remove and return the item from the end

   public Iterator<T> iterator(){
       return list.iterator();
   }// return an iterator over items in order from front to end
  /* private class Listiterator() implements Iterator<T>{
       public void remove(){throws new UnsupportedOperationException();}
       public T next(){
           
       }
   }*/
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> a=new Deque<String>();
        String b=null;
        a.addFirst(b);
        String c=a.removeFirst();
        System.out.println(c);
    }
    
}

@78da636d44050cad08e2b661cb9092c3@"
"r04921012","0","0.93","102304","@44a5b3eb064ac9eaeaadb2c766881bcf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a = null;
       a=list.get(0);
       list.remove(0);
       return a;
       
   }// remove and return the item from the front

   public T removeLast(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;
   }// remove and return the item from the end

   //public Iterator<T> iterator(){
   //    return list.iterator();
   //}// return an iterator over items in order from front to end
  /* private class Listiterator() implements Iterator<T>{
       public void remove(){throws new UnsupportedOperationException();}
       public T next(){
           
       }
   }*/
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> a=new Deque<String>();
        String b=""b"";
        String c =""fdf"";
        a.addFirst(b);
        a.addFirst(c);
        Iterator it=a.iterator();
        while (it.hasNext())
            System.out.println(it.next());
    }
    
}

@44a5b3eb064ac9eaeaadb2c766881bcf@"
"r04921012","8","0.94","102368","@f2ad395ffe7862bada6dd5a76e4f0e31@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       else{T a = null;
       a=list.get(0);
       list.remove(0);
       return a;}
       
   }// remove and return the item from the front

   public T removeLast(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       else{T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;}
   }// remove and return the item from the end

   public Iterator<T> iterator(){
       return list.iterator();
   }// return an iterator over items in order from front to end
  /* private class Listiterator() implements Iterator<T>{
       public void remove(){throws new UnsupportedOperationException();}
       public T next(){
           
       }
   }*/
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> a=new Deque<String>();
        String b=""b"";
        String c =""fdf"";
        a.addFirst(b);
        //a.addFirst(c);
        Iterator it=a.iterator();
        while (it.hasNext())
            System.out.println(it.next());
    }
    
}

@f2ad395ffe7862bada6dd5a76e4f0e31@"
"b03704074","0","0.93","102336","@2f9024fb94f7168c1fedc757064e5a81@import java.util.Iterator;
public class Deques<Item> implements Iterable<Item>{
    Deques deques = new Deques();
    private class Node{
        Item item;
        Node next;
        Node pre;}
    private Node first = null;
    private Node last = null;
    public boolean isEmpty()
    {return first == null;}
    public void addfirst(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;}
    public void addlast(Item item){
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast; }
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        return item;}
    public Item removeLast(){
        Item item = last.item;
        last = last.pre;
        return item;}
    public Iterator<Item> iterator() { return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext() { return current != null; }
        public void remove() {  }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;  }
        public void output(){
            while(hasNext()){
                Item s = next();
                System.out.println(s);}}
    }
    
    
    
    
    
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@2f9024fb94f7168c1fedc757064e5a81@"
"b03704074","0","0.93","102304","@2f9024fb94f7168c1fedc757064e5a81@import java.util.Iterator;
public class Deques<Item> implements Iterable<Item>{
    Deques deques = new Deques();
    private class Node{
        Item item;
        Node next;
        Node pre;}
    private Node first = null;
    private Node last = null;
    public boolean isEmpty()
    {return first == null;}
    public void addfirst(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;}
    public void addlast(Item item){
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast; }
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        return item;}
    public Item removeLast(){
        Item item = last.item;
        last = last.pre;
        return item;}
    public Iterator<Item> iterator() { return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext() { return current != null; }
        public void remove() {  }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;  }
        public void output(){
            while(hasNext()){
                Item s = next();
                System.out.println(s);}}
    }
    
    
    
    
    
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@2f9024fb94f7168c1fedc757064e5a81@"
"b03704074","0","0.94","102368","@2f9024fb94f7168c1fedc757064e5a81@import java.util.Iterator;
public class Deques<Item> implements Iterable<Item>{
    Deques deques = new Deques();
    private class Node{
        Item item;
        Node next;
        Node pre;}
    private Node first = null;
    private Node last = null;
    public boolean isEmpty()
    {return first == null;}
    public void addfirst(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;}
    public void addlast(Item item){
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast; }
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        return item;}
    public Item removeLast(){
        Item item = last.item;
        last = last.pre;
        return item;}
    public Iterator<Item> iterator() { return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext() { return current != null; }
        public void remove() {  }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;  }
        public void output(){
            while(hasNext()){
                Item s = next();
                System.out.println(s);}}
    }
    
    
    
    
    
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
}

@2f9024fb94f7168c1fedc757064e5a81@"
"b03611041","1","0.84","102448","@a3be53020a6839f281f0b98672a3a4e2@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=oldlast;
        N++;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first=first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last=last.next;
        N--;
        return item;
    }

    public boolean isEmpty() {
        return first == null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return null;
        }

        public ListIterator(Node<Item> first){
            current=first;
        }
    }

    public static void main(String[] args) {
    }

}

@a3be53020a6839f281f0b98672a3a4e2@"
"b02611016","3","1.49","187312","@d397a55b397a49795e360e2d471c13d2@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   else{ Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
   Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        // oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
           // deque.addFirst(data[3]);
           
           // System.out.println(deque.removeFirst());
            deque.addLast(data[5]);
       
            for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }*/
             //System.out.println(deque.removeLast());
             
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    



@d397a55b397a49795e360e2d471c13d2@"
"b02611016","8","1.48","178528","@fdb37f1b75f7cb1e90327a54eeb4a05a@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   else{ Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;}}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
   Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        if(oldlast==null){oldlast =last; oldlast.next = last;}
        else oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            deque.addFirst(data[3]);
           
            System.out.println(deque.removeFirst());
            deque.addLast(data[5]);
       
           /* for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }*/
             System.out.println(deque.removeLast());
             
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@fdb37f1b75f7cb1e90327a54eeb4a05a@"
"r04631041","7","1.17","184784","@14f5aced3419ffe10edd3a36c59c7496@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator();}
    private class ListIterator implements Iterator<Item>
    {
       private Node current=first;
       public boolean hasNext() {return current!=null;}
       public void remove() {}
       public Item next()
               {
                   Item item=current.item;
                   current=current.next;
                   return item;
               }
    }
    private Node first;
    private Node last;
    private  int number;
    private class Node
    {
        Item item;
        Node next;
        Node previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        testing.addLast(""i"");
        testing.addFirst(""b"");
        testing.addLast(""j"");
        testing.addFirst(""k"");
        testing.addFirst(""p"");
        testing.addLast(""q"");
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        // System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        }catch(NullPointerException e){System.out.println(""It's empty. Don't remove!"");}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@14f5aced3419ffe10edd3a36c59c7496@"
"r04945025","10","0.152","177712","@2f458169ab1d42f441fad9d4d2a0b52c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

   	private class Node{
        Item item;
        Node prev;
        Node next;
   	}
    
   	private class DequeIterator implements Iterator<Item>{
   		private Node current = first;
   		public boolean hasNext(){
   		    return current != null;	
   		}
   		public Item next(){
   		    if(!this.hasNext()){
                throw new NoSuchElementException();
   		    }
   			Item item = current.item;
   			current = current.next;
   			return item;
   		}
   		public void remove(){
   		    throw new UnsupportedOperationException();  
   		}
   	}

    private Node first, last;

 	public Deque(){
 		this.first = null;
 		this.last  = null;
 	}

	public boolean isEmpty(){
		return first == null;
	}       

	public int size(){
        int count = 0;
        Node node = this.first;
        while(node != null){
        	node = node.next;
        	count++;
        }
        return count;
	}                        
   	public void addFirst(Item item){
   	    if(item == null){
   			throw new NullPointerException();
   		}
        Node node = new Node();
        node.item = item;
        if(this.isEmpty()){
            node.prev  = null;
       	    node.next  = null;
       	    this.first = node;  
       	    this.last  = node;
        }
        else{
            node.prev = null;
            node.next = this.first;
            this.first.prev = node;
       	    this.first = node;
        }
   	}

   	public void addLast(Item item){
   	    if(item == null){
   			throw new NullPointerException();
   	    }
        Node node = new Node();
        node.item = item;
        if(this.isEmpty()){
       		node.prev  = null;
       		node.next  = null;
        	this.first = node;
        	this.last  = node;
        }
        else{
           	node.prev = this.last;
        	node.next = null;
        	this.last.next = node;
          	this.last = node;
        }
   	}         
   	
   	public Item removeFirst(){
   		if(this.isEmpty()){
   		    throw new NoSuchElementException();
   		}
   		Item item  = this.first.item;
   		if(this.first == this.last){
   		    this.first = null;
   		  	this.last  = null;
   		}
   		else{
   		    this.first = this.first.next;
   		    this.first.prev = null;
   		}
   		return item;
   	}                
   	
   	public Item removeLast(){
        if(this.isEmpty()){
   		    throw new NoSuchElementException();
   		}
   		Item item = this.last.item;
  	    if(this.first == this.last){
  			this.first = null;
  			this.last = null;
   		}
   		else{
        	this.last = this.last.prev;
        	this.last.next = null;
        }
   		return item;
   	}                  
   	
   	public Iterator<Item> iterator(){
        return new DequeIterator();
   	}
   	
   	public void print(){
   		Node node = this.first;
   	    while(node != null){
   	    	System.out.print(node.item);
   	    	System.out.printf(""\t"");
            if(node.prev != null){
            	System.out.printf(""prev:"");
            	System.out.print(node.prev.item);
            }
            System.out.printf(""\t"");
            if(node.next != null){
            	System.out.printf(""next:"");
            	System.out.print(node.next.item);
            }
            System.out.printf(""\n"");
        	node = node.next;
        }	
   	}

    public static void main(String[] argv){
        System.out.println(""Test"");
    }
}

@2f458169ab1d42f441fad9d4d2a0b52c@"
"r04546032","5","0.96","102464","@ea69efd03a159b6a3c9e42dcb8cd154f@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {

        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post;
            post.prev = x;
            x.prev = pre;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post;
            post.prev = x;
            x.prev = pre;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.prev = pre;
            pre.next.prev = x;
            x.next = pre.next;
            pre.next = x;
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next.next.prev = pre;
            pre.next = pre.next.next;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
             T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {

    }
}

@ea69efd03a159b6a3c9e42dcb8cd154f@"
"r04921065","10","0.137","179424","@ae7a6391af0fa7e20e0a84dea0be78ca@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 余軒
 */
public class Deque<Item> implements Iterable<Item>{

private Node first;
private Node last;
private int size;

    

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
        //throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    
// construct empty deque    
public Deque(){
    first = null;
    last = null;
    size = 0;
    
}    


    
private class Node<Item>{
    private Item item;
    public Node next;
    public Node previous;
    public Node(Item item, Node next,Node previous){
     this.item = item;
     this.next = next;
     this.previous = previous;
    }
//    Item item;
//    Node next=null;
//    Node previous=null;
}

public boolean isEmpty(){
    return first ==null;
}

public int size(){
    return size;
}

public void addFirst(Item item){
    if (item == null){
    throw new NullPointerException();}
    else{
    if(first==null)
    {
      first = new Node(item,null,null);
      last = first;
      size++;
    }
    else {
        Node temp = new Node(item,first,null);
        first.previous = temp;
        first = temp;
        size++;
    }
    }
}

public void addLast(Item item){
    if (item == null){
    throw new NullPointerException();}
    else{
    if(first==null){
        first = new Node(item,null,null);
        last = first;
        size++;
    }
    else{
        Node temp = new Node(item,null,last);
        last.next = temp;
        last = temp;
        size++;
        
                }
    }
}

public Item removeFirst(){
    if(first==null) throw new NoSuchElementException(""list is empty"");
    Item item = (Item) first.item;
    first = first.next;
    if (first!=null){
        first.previous=null;
    }
    else{
         //移除後變empty
        last = first;
    }
    size--;
    return item;
}

public Item removeLast(){
    if(last==null) throw new NoSuchElementException(""list is empty"");
    Item item = (Item)last.item;
    last = last.previous;
    if (last!=null){
        last.next =null;
    }
    else{
        //移除後變empty
        first = last;
    }
    size--;
    return item;
}

   public static void main(String[] args) throws IOException {
        // TODO code application logic here
          
   }
}

@ae7a6391af0fa7e20e0a84dea0be78ca@"
"b02611016","3","0.35","100368","@2db1ef989c0d5929c694bdae0c395755@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
        first = new Node<Item>();
        last=new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
         first = new Node<Item>();
        last = new Node<Item>();
        last.item = item;
        first.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addFirst(data[5]);
            System.out.println(deque.removeFirst());
            deque.addLast(data[3]);
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@2db1ef989c0d5929c694bdae0c395755@"
"b03611041","7","1.44","180928","@a7cff5e6d5006f2a7bb6c503f468d2b1@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        if(N==1)last=first;
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        if(N==1)first=last;
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        if(N==1)first=last;
        Item item=first.item;
        first=first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        if(N==1)last=first;
        Item item=last.item;
        last=last.prev;
        N--;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@a7cff5e6d5006f2a7bb6c503f468d2b1@"
"b02611016","8","1.52","175152","@b027b688df81a3457f9cb93a1b4f4788@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
    
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addFirst(data[3]);
             deque.addFirst(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@b027b688df81a3457f9cb93a1b4f4788@"
"b03611041","7","1.46","185600","@9d5dc3ffb9c223c3f234f5629b35b66d@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        if(N==1)last=first;
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        if(N==1)first=last;
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        if(N==1 && first==null)first=last;
        Item item=first.item;
        first=first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        if(N==1&& last==null)last=first;
        Item item=last.item;
        last=last.prev;
        N--;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@9d5dc3ffb9c223c3f234f5629b35b66d@"
"b03611041","7","1.45","177216","@9b4368044460c221a89f0e83e2586e7b@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();

        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        if(N==1 && first==null)first=last;
        Item item=first.item;
        first=first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        if(N==1&& last==null)last=first;
        Item item=last.item;
        last=last.prev;
        N--;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@9b4368044460c221a89f0e83e2586e7b@"
"r04546014","0","0","0","@e24380c920a4f69e65362d98f1326226@import java.util.Iterator;
public class Deque<Item> implements Iterable {

    private Node first = null;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldFirst = first;
            first = new Node();
            first.item = item;
            first.next = oldFirst;
            oldFirst.previous = first;
            first.previous = null;
        }
        size++;
    }

    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        first.previous = null;
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        Item item = last.item;
        last = last.previous;
        last.next = null;
        size--;
        return item;
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        return new ListIterator();
    }
    private class ListIterator implements Iterator{
        private Node current=first;
        public boolean hasNext(){return current !=null;}
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current .next;
            return item;
        }
    }
   
}

@e24380c920a4f69e65362d98f1326226@"
"r04546014","0","0","0","@e24380c920a4f69e65362d98f1326226@import java.util.Iterator;
public class Deque<Item> implements Iterable {

    private Node first = null;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldFirst = first;
            first = new Node();
            first.item = item;
            first.next = oldFirst;
            oldFirst.previous = first;
            first.previous = null;
        }
        size++;
    }

    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        first.previous = null;
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        Item item = last.item;
        last = last.previous;
        last.next = null;
        size--;
        return item;
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        return new ListIterator();
    }
    private class ListIterator implements Iterator{
        private Node current=first;
        public boolean hasNext(){return current !=null;}
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current .next;
            return item;
        }
    }
   
}

@e24380c920a4f69e65362d98f1326226@"
"r04546014","0","0","0","@d708615e7191d22a89dcabcb39146934@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first = null;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
       
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面        
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldFirst = first;
            first = new Node();
            first.item = item;
            first.next = oldFirst;
            oldFirst.previous = first;
            first.previous = null;
        }
        size++;
    }

    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        first.previous = null;
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        Item item = last.item;
        last = last.previous;
        last.next = null;
        size--;
        return item;
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        return new ListIterator();
    }
    private class ListIterator implements Iterator{
        private Node current=first;
        public boolean hasNext(){return current !=null;}
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current .next;
            return item;
        }
    }
   
}

@d708615e7191d22a89dcabcb39146934@"
"r04546014","6","0.71","102384","@4cb1b43e53f6d2a24144a4e828c45990@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable{

    private Node first;    
    private Node last = first;    
    private int size = 0;

    public static void main(String[] args) {
     
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
       first = null;
       last = first;
       size=0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面        
        if (first == null) {
            first=new Node();
            last=first;
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldFirst = first;
            first = new Node();
            first.item = item;
            first.next = oldFirst;
            oldFirst.previous = first;
            first.previous = null;
        }
        size++;
    }


    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first=new Node();  
            last=first;
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        first.previous = null;
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        Item item = last.item;
        last = last.previous;
        last.next = null;
        size--;
        return item;
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        return new ListIterator();
    }
    private class ListIterator implements Iterator{
        private Node current=first;
        public boolean hasNext(){return current !=null;}
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current .next;
            return item;
        }
    }
   
}

@4cb1b43e53f6d2a24144a4e828c45990@"
"r04546014","6","0.82","102384","@d755382dbe5cf408503ba20850456b29@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable{

    private Node first;    
    private Node last = first;    
    private int size = 0;

    public static void main(String[] args) {
        Deque<Double> abc=new Deque<Double>();
        abc.addFirst(1.0);
        double a = abc.removeLast();
        
        abc.addFirst(2.0);
     
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
       first = null;
       last = first;
       size=0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面        
        if (first == null) {
            first=new Node();
            last=first;
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldFirst = first;
            first = new Node();
            first.item = item;
            first.next = oldFirst;
            oldFirst.previous = first;
            first.previous = null;
        }
        size++;
    }


    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first=new Node();  
            last=first;
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        if(first!=null)
            first.previous = null;
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        Item item = last.item;
        last = last.previous;
        if(last!=null)
            last.next=null;
        size--;
        return item;
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        return new ListIterator();
    }
    private class ListIterator implements Iterator{
        private Node current=first;
        public boolean hasNext(){return current !=null;}
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current .next;
            return item;
        }
    }
   
}

@d755382dbe5cf408503ba20850456b29@"
"b02611016","3","1.57","170512","@207a66e5b384d0f526686d62d50358f4@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first2.item;        // save item to return
        first2 = first2.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = first1.item;
       first1 = first1.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@207a66e5b384d0f526686d62d50358f4@"
"b02611016","7","1.57","170112","@e5ff0d454c387f66d361d57e06ba55bc@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first2.item;        // save item to return
        first2 = first2.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = first1.item;
       first1 = first1.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first2) {
            current = first2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");*/
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
         /*   deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());*/
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@e5ff0d454c387f66d361d57e06ba55bc@"
"b02611016","0","1.57","170240","@3ee42e01888dc0c0e3b6d78be3c16b92@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first2.item;        // save item to return
        first2 = first2.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = first1.item;
       first1 = first1.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first1.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first1);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first1) {
            current = first1;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");*/
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
         /*   deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());*/
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@3ee42e01888dc0c0e3b6d78be3c16b92@"
"b02611016","7","1.58","173648","@7c0fa1c7f30a28837ce0826e1614bf6f@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first2.item;        // save item to return
        first2 = first2.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = first1.item;
       first1 = first1.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first2) {
            current = first2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");*/
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
         /*   deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());*/
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@7c0fa1c7f30a28837ce0826e1614bf6f@"
"b02611016","5","0.84","101296","@c96af5d5ebe440ad27ebba38a87bc3a1@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first1.item;        // save item to return
        first1 = first1.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = first2.item;
       first2 = first2.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first2) {
            current = first2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");*/
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
         /*   deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());*/
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@c96af5d5ebe440ad27ebba38a87bc3a1@"
"r04546014","6","0.84","102368","@831126975095a369a6a9700447fa24fa@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        Deque<Double> abc = new Deque<Double>();
        abc.addFirst(null);
        double a = abc.removeLast();
        abc.addFirst(2.0);

    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        try {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } catch (NullPointerException e) {
            throw e;
        }
    }

    public void addLast(Item item) {//加入一個node在後面
        if (first == null) {
            first = new Node();
            last = first;
            first.item = item;
            first.next = null;
            first.previous = null;
        } else {
            Node oldLast = last;
            last = new Node();
            last.item = item;
            oldLast.next = last;
            last.previous = oldLast;
            last.next = null;
        }
        size++;
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        Item item = first.item;
        first = first.next;
        if (first != null) {
            first.previous = null;
        }
        size--;
        return item;
    }

    public Item removeLast() {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }

    }

}

@831126975095a369a6a9700447fa24fa@"
"b02611016","5","1.57","177104","@21ae034bb40822eaa8bc645bb1265ed1@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first2 == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last;
        last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last.item = item;
        first.next = oldfirst;
        first2=first;
        if (isEmpty1()) first1 = last;
        else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first;
        last = new Node<Item>();
        first=new Node<Item>();
        last.item = item;
        first.item=item;
        last.next=oldlast;
        first1=last;
        if (isEmpty()) first2 = first;
         else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty1()) throw new NoSuchElementException();
        Item item = first1.item;        // save item to return
        first1 = first1.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = first2.item;
       first2 = first2.next;
        N--;
        if (isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()||isEmpty()) throw new NoSuchElementException();
        return first1.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first2) {
            current = first2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
          /*  Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");*/
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
         /*   deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.iterator());*/
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@21ae034bb40822eaa8bc645bb1265ed1@"
"r04546014","6","0.83","102336","@1a3aaaa60e34793cee14d05458f625cc@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        Deque<Double> abc = new Deque<Double>();
        abc.addFirst(null);
        abc.addFirst(0.1);
        abc.addLast(0.2);
        abc.addFirst(0.3);
        Iterator iterator = abc.iterator();

        double a = abc.removeLast();
        abc.addFirst(2.0);

    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        try {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            if (first.item != null) {
                size++;
            }
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public void addLast(Item item) {//加入一個node在後面
        try {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            if (first.item != null) {
                size++;
            }
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

@1a3aaaa60e34793cee14d05458f625cc@"
"r04546014","6","0.84","102416","@0f04d67d443d4519674295d1b1b28d83@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        Deque<Double> abc = new Deque<Double>();
        abc.removeLast();
        abc.addFirst(null);
        abc.addFirst(0.1);
        abc.addLast(0.2);
        abc.addFirst(0.3);
        Iterator iterator = abc.iterator();

        double a = abc.removeLast();
        abc.addFirst(2.0);

    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     

        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        }
    }

    public void addLast(Item item) {//加入一個node在後面
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            if(last==null)
                throw new NullPointerException();
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {

        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

@0f04d67d443d4519674295d1b1b28d83@"
"r04546014","6","0.83","102352","@0d9ffbb8f489a3ba803e172696f7308d@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        Deque<Double> abc = new Deque<Double>();
        abc.removeLast();
        abc.addFirst(null);
        abc.addFirst(0.1);
        abc.addLast(0.2);
        abc.addFirst(0.3);
        Iterator iterator = abc.iterator();

        double a = abc.removeLast();
        abc.addFirst(2.0);

    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     

        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        }
    }

    public void addLast(Item item) {//加入一個node在後面
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            if (last == null) {
                throw new NullPointerException();
            }
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            current.previous = null;
            size--;
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

@0d9ffbb8f489a3ba803e172696f7308d@"
"r04546014","6","0.83","102432","@e3e923378982df1995d3de2a420f54cd@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        Deque<Double> abc = new Deque<Double>();
//        abc.removeLast();
        abc.addFirst(null);
        abc.addFirst(0.1);
        abc.addLast(0.2);
        abc.addFirst(0.3);
        Iterator iterator = abc.iterator();

        double a = abc.removeLast();
        abc.addFirst(2.0);

    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        }
        else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        }
        else{            
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            if (last == null) {
                throw new NullPointerException();
            }
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            current.previous = null;
            size--;
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

@e3e923378982df1995d3de2a420f54cd@"
"r03945012","3","1.39","177536","@2d92bc6b852934bcb0341436f138e51f@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;

    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;
        }
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
//        last.next = null;
        N--;
        if (isEmpty()) {
            last = null;
        }
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<String> q = new Deque<String>();
        q.addLast(""1"");
        q.addFirst(""2"");
        q.addLast(""3"");
        q.addFirst(""4"");

        StdOut.println(q.removeLast());
        StdOut.println(q.removeLast());
        StdOut.println(q.removeLast());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@2d92bc6b852934bcb0341436f138e51f@"
"r04546014","6","0.83","102528","@6680a23a44951a2eb616ccbebc018237@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try{
        Deque<Double> abc = new Deque<Double>();
//        abc.removeLast();
        abc.addFirst(null);
        abc.addFirst(0.1);
        abc.addLast(0.2);
        abc.addFirst(0.3);
        Iterator iterator = abc.iterator();

        double a = abc.removeLast();
        abc.addFirst(2.0);
        }
        catch(NullPointerException e){
            throw e;
        }catch(NoSuchElementException e){
            throw e;
        }catch(UnsupportedOperationException e){
            throw e;
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        }
        else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        }
        else{            
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            if (last == null) {
                throw new NullPointerException();
            }
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try{
            current.previous = null;
            size--;
            }catch(UnsupportedOperationException e){
                throw e;
            }
        }

        public Item next() {
            try{
            Item item = current.item;
            current = current.next;
            return item;
            }catch(NoSuchElementException e){
                throw e;
            }
        }
    }
}

@6680a23a44951a2eb616ccbebc018237@"
"r04546014","6","0.83","102368","@310795c0a4b6e9e8d97bbd032de5311e@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();

            abc.addFirst(0.1);
            abc.addLast(0.2);
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double a = abc.removeLast();
            abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            abc.iterator().remove();
            kk = abc.size();
            System.out.println(kk);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                current = current.next;
                current.previous = null;
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}

@310795c0a4b6e9e8d97bbd032de5311e@"
"r03945012","5","1.44","175296","@8b087feeeef4d45e352b1d307d8595b6@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<String> q = new Deque<String>();
        q.addLast(""1"");
        q.addFirst(""2"");
        q.addLast(""3"");
//        q.addFirst(""4"");

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeLast());
//        StdOut.println(q.removeLast());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@8b087feeeef4d45e352b1d307d8595b6@"
"r03945012","5","1.41","185648","@9a115765a9a5a711c6d8190308aaf0e5@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<String> q = new Deque<String>();
        q.addLast(""1"");
        q.addLast(""2"");
//        q.addLast(""3"");
//        q.addFirst(""4"");

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeFirst());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@9a115765a9a5a711c6d8190308aaf0e5@"
"r04546014","7","0.81","101536","@b22d8de065a0625caa742d3c70c72a56@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();
            
//            abc.iterator().remove();
            abc.addFirst(0.1);
            abc.removeLast();
            
            abc.addLast(0.2);
            abc.removeFirst();
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double a = abc.removeLast();
            abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            abc.iterator().remove();
            kk = abc.size();
            System.out.println(kk);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            else{
                last=first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            else{
                first=last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                current = current.next;
                current.previous = null;
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}

@b22d8de065a0625caa742d3c70c72a56@"
"r03945012","7","1.39","179920","@69995f706cbe18027e0c8cc6e8c472fc@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        N--;
//        if (isEmpty()) {
//            last = null;
//        }
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
//        q.addLast(null);
//        q.addLast(2);
//        q.addFirst(3);
//        q.addFirst(4);

//        StdOut.println(q.removeLast());
//        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
        StdOut.println(q.removeFirst());
        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@69995f706cbe18027e0c8cc6e8c472fc@"
"r04546014","7","0.81","102400","@e57d29b921e17982f1cb30bb93c2a48a@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();
            
//            abc.iterator().remove();
            for(int i=0;i<10;i++){
//                abc.addLast(0.2);
            abc.addFirst(0.1);
            }
            for(int i=0;i<19;i++)
            {
//            abc.removeLast();
             abc.removeFirst();
            }
            abc.addLast(0.2);
            abc.removeFirst();
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double a = abc.removeLast();
            abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            abc.iterator().remove();
            kk = abc.size();
            System.out.println(kk);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception{//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) throws Exception{//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() throws Exception{//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            }
            else{
                last=first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            }
            else{
                first=last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                current = current.next;
                current.previous = null;
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}
@e57d29b921e17982f1cb30bb93c2a48a@"
"r04546014","7","0.83","102416","@bbcf7a1b146f31248173fae32433b9aa@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();

//            abc.iterator().remove();
            for (int i = 0; i < 10; i++) {
//                abc.addLast(0.2);
                abc.addFirst(0.1);
            }
            for (int i = 0; i < 19; i++) {
//            abc.removeLast();
                abc.removeFirst();
            }
            abc.addLast(0.2);
            abc.removeFirst();
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double a = abc.removeLast();
            abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            abc.iterator().remove();
            kk = abc.size();
            System.out.println(kk);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) throws Exception {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() throws Exception {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            } else {
                last = first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            } else {
                first = last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                first = first.next;
                if (first != null) {
                    first.previous = null;
                } else {
                    last = first;
                }
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}

@bbcf7a1b146f31248173fae32433b9aa@"
"r03945012","7","1.39","181440","@403f2f9f37b23284b776bdce88ce8ab5@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        if (first == last){
            first.next = null;
        }
        first = first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        if (first == last){
            last.pre = null;
        }
        last = last.pre;
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addFirst(3);
//        q.addFirst(4);

        StdOut.println(q.removeLast());
//        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@403f2f9f37b23284b776bdce88ce8ab5@"
"r04546014","0","0.81","102400","@f2f71f223a74c84b1bf4f8700af6b943@public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();

//            abc.iterator().remove();
            for (int i = 0; i < 10; i++) {
                abc.addLast(0.2);
                abc.addFirst(0.1);
            }
            for (int i = 0; i < 19; i++) {
//            abc.removeLast();
                abc.removeFirst();
            }
            abc.addLast(0.2);
            abc.removeFirst();
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double ll=abc.removeFirst();
            double a = abc.removeLast();
           // abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            
            kk = abc.size();
            System.out.println(ll);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) throws Exception {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() throws Exception {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            } else {
                last = first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            } else {
                first = last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                first = first.next;
                if (first != null) {
                    first.previous = null;
                } else {
                    last = first;
                }
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}

@f2f71f223a74c84b1bf4f8700af6b943@"
"r04546014","0","0.83","102416","@c943bb310a32991383bc3d84bff34eb5@import java.util.Iterator;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        try {
            Deque<Double> abc = new Deque<Double>();

//            abc.iterator().remove();
            for (int i = 0; i < 10; i++) {
                abc.addLast(0.2);
                abc.addFirst(0.1);
            }
            for (int i = 0; i < 19; i++) {
//            abc.removeLast();
                abc.removeFirst();
            }
            abc.addLast(0.2);
            abc.removeFirst();
            abc.addFirst(0.3);
            Iterator iterator = abc.iterator();
            int kk = abc.size();
            double ll=abc.removeFirst();
            double a = abc.removeLast();
           // abc.removeLast();
            abc.addFirst(2.0);
            boolean ee = abc.iterator().hasNext();
            
            kk = abc.size();
            System.out.println(ll);
        } catch (NullPointerException e) {
            System.out.println(""a"");
        } catch (NoSuchElementException e) {
            System.out.println(""b"");
        } catch (UnsupportedOperationException e) {
            System.out.println(""c"");
        }
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) throws Exception {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() throws Exception {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            } else {
                last = first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            } else {
                first = last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                first = first.next;
                if (first != null) {
                    first.previous = null;
                } else {
                    last = first;
                }
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}

@c943bb310a32991383bc3d84bff34eb5@"
"r04546014","7","0.84","102368","@f0f2307104150cd82548ab2e989dfb5b@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
        
    }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public void addLast(Item item) throws Exception {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeFirst() throws Exception {//回傳最前面的node,並移除他
        try {
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            } else {
                last = first;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        try {
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            } else {
                first = last;
            }
            size--;
            return item;
        } catch (NullPointerException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            try {
                first = first.next;
                if (first != null) {
                    first.previous = null;
                } else {
                    last = first;
                }
                size--;
            } catch (UnsupportedOperationException e) {
                throw e;
            }
        }

        public Item next() {
            try {
                Item item = current.item;
                current = current.next;
                return item;
            } catch (NoSuchElementException e) {
                throw e;
            }
        }
    }
}
@f0f2307104150cd82548ab2e989dfb5b@"
"r03945012","8","1.42","192960","@26772268206995f4b510916216f4e860@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
        //return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        if (first == last){
            last = null;
            first.next = null;
        }
        first = first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        if (first == last){
            first = null;
            last.pre = null;
            
        }
        last = last.pre;
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addLast(3);
//        q.addLast(4);
//        q.addFirst(4);
//        q.addFirst(3);

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeLast());
        q.addLast(5);
        q.addLast(6);
        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@26772268206995f4b510916216f4e860@"
"r04945021","7","1.36","182304","@c6d7aac51b314ca24ff65abaaa7f702e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node first=null;
private Node last=null;
private class Node
{
    Item item;
    Node next;
    Node pre;
}
    public Deque(){}// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
      Iterator itr=iterator();
       int counter = 0;

       while (itr.hasNext()) {
           itr.next();
           counter++;
       }
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
           first=new Node();
            first.item = item;
            first.next = null;
            first.pre = null;
            last=first;
        }
        else{
        Node oldfirst = first;
  first=new Node();
  first.item=item;
  first.next=oldfirst;
  first.pre=null;
      oldfirst.pre=first;    
        }
   }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
      if(isEmpty()){
          first=last;
          
      }
       Node oldlast =last;
       last = new Node();
       last.item=item;
       last.next=null;
       
       if(isEmpty()) first=last;
       else {
           last.pre=oldlast;
           oldlast.next=last;
       }
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    last=last.pre;
    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
      return new ListIterator();
       // return an iterator over items in order from front to end   
   }
   private class ListIterator implements Iterator<Item>
   {
       private Node current = first;
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
         //  System.out.println(current.next);
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
  
      //static  
        
    public static void main(String[] args) throws Exception {
//        Deque<String> de=new <String>Deque();
//        
//        de.addLast(""Hello"");
//        de.addLast(""He"");
//        int Si=de.size();
//        System.out.println(Si);
//       de.removeLast();
//        System.out.println(Si);
//        
//        while(de.iterator().hasNext()){
//          
//            System.out.println(de.iterator().next());
//        }
        

        
    }

}

  

    
@c6d7aac51b314ca24ff65abaaa7f702e@"
"r04945021","7","1.39","180736","@cd86f3c2d2ab4f135e35ed27a1a0623d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node first=null;
private Node last=null;
private int counter = 0;
private class Node
{
    Item item;
    Node next;
    Node pre;
}
    public Deque(){}// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
           first=new Node();
            first.item = item;
            first.next = null;
            first.pre = null;
            last=first;
        }
        else{
        Node oldfirst = first;
  first=new Node();
  first.item=item;
  first.next=oldfirst;
  first.pre=null;
      oldfirst.pre=first;    
        }
        counter++;
   }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
      if(isEmpty()){
          first=last;
          
      }
       Node oldlast =last;
       last = new Node();
       last.item=item;
       last.next=null;
       
       if(isEmpty()) first=last;
       else {
           last.pre=oldlast;
           oldlast.next=last;
       }
       counter++;
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       counter--;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    last=last.pre;
    counter--;

    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
      return new ListIterator();
       // return an iterator over items in order from front to end   
   }
   private class ListIterator implements Iterator<Item>
   {
       private Node current = first;
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
         //  System.out.println(current.next);
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
  
      //static  
        
    public static void main(String[] args) throws Exception {
      
       // }
        

        
    }

}

  

    
@cd86f3c2d2ab4f135e35ed27a1a0623d@"
"r04945021","7","1.5","169120","@4f98854715f6ca5fa867b1b09b9057bd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node<Item> first;
private Node<Item> last;
private int counter;

private class Node<Item>
{
    Item item;
    Node<Item> next;
    Node<Item> pre;
}
    public Deque(){
    first=null;
    last=null;
    counter=0;
    }// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
            first = new Node();
            first.item = item;
            first.next = null;
            first.pre = null;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        counter++;
    }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
      if(isEmpty()){
          first=last;
          
      }
       Node<Item> oldlast =last;
       last = new Node();
       last.item=item;
       last.next=null;
       
       if(isEmpty()) first=last;
       else {
           last.pre=oldlast;
           oldlast.next=last;
       }
       counter++;
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       counter--;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    last=last.pre;
    counter--;
    System.out.println(counter);
    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       
       return new ListIterator<Item>(first);
       
       // return an iterator over items in order from front to end   
   }
   private class ListIterator<Item> implements Iterator<Item>
   {
       
       
       private Node<Item> current;
       public ListIterator(Node first) {
            current = first;
        }
   
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
           
           Item item = current.item;
           current = current.next;          
           return item;
       }
   }
  
      //static  
        
    public static void main(String[] args) throws Exception {
        Deque<String> de=new <String>Deque();
        
        
        de.addLast(""He"");
        de.addLast(""A"");
        de.addLast(""B"");
        int Si=de.size();
      Iterator ii=de.iterator();
        
        
        while(ii.hasNext()){
          System.out.println(ii.next());
           
           
       
        }
        

        
    }

}

  

    
@4f98854715f6ca5fa867b1b09b9057bd@"
"r04546014","10","0.141","179264","@7bce9762f3ebd39c36a5e1caa89265f1@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable {

    private Node first;
    private Node last = first;
    private int size = 0;

    public static void main(String[] args) throws Exception {
           }

    private class Node {

        Node previous;
        Item item;
        Node next;
    }

    public Deque() {//產生一個空的node
        first = null;
        last = first;
        size = 0;
    }

    public boolean isEmpty() {//回傳此node是否為空
        return first == null;
    }

    public int size() {//回傳此node的大小
        return size;
    }

    public void addFirst(Item item) throws Exception {//加入一個node在前面     
        if (item != null) {//傳進來如果是null，就會發生多一格的情況
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldFirst = first;
                first = new Node();
                first.item = item;
                first.next = oldFirst;
                oldFirst.previous = first;
                first.previous = null;
            }
            size++;
        } else {
            throw new NullPointerException();
        }
    }

    public void addLast(Item item) throws Exception {//加入一個node在後面        
        if (item != null) {
            if (first == null) {
                first = new Node();
                last = first;
                first.item = item;
                first.next = null;
                first.previous = null;
            } else {
                Node oldLast = last;
                last = new Node();
                last.item = item;
                oldLast.next = last;
                last.previous = oldLast;
                last.next = null;
            }
            size++;
        } else {
            throw new NullPointerException();
        }
    }

    public Item removeFirst() throws Exception {//回傳最前面的node,並移除他
        if(first!=null){
            Item item = first.item;
            first = first.next;
            if (first != null) {
                first.previous = null;
            } else {
                last = first;
            }
            size--;
            return item;
        } 
        else{
            throw new NoSuchElementException ();
        }
    }

    public Item removeLast() throws Exception {//回傳最後面的node,並移除他
        if(last!=null){
            Item item = last.item;
            last = last.previous;
            if (last != null) {
                last.next = null;
            } else {
                first = last;
            }
            size--;
            return item;
        } else {
            throw new NoSuchElementException ();
        }
    }

    public Iterator iterator() {//回傳此node裡的每一個物件
        try {
            return new ListIterator();
        } catch (UnsupportedOperationException e) {
            throw e;
        } catch (NoSuchElementException e) {
            throw e;
        }
    }

    private class ListIterator implements Iterator {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            if(first!=null){
                first = first.next;
                if (first != null) {
                    first.previous = null;
                } else {
                    last = first;
                }
                size--;
            }else {
                throw new UnsupportedOperationException ();
            }
        }

        public Item next() {
            if(current!=null){
                Item item = current.item;
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException ();
            }
        }
    }
}

@7bce9762f3ebd39c36a5e1caa89265f1@"
"r04546032","5","0.96","102432","@d3904354dd93b719cba3e78ed98369c3@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post;
            post.prev = x;
            x.prev = pre;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post;
            post.prev = x;
            x.prev = pre;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;     
            pre.next = x;
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next.next.prev = pre;
            pre.next = pre.next.next;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {

    }
}
@d3904354dd93b719cba3e78ed98369c3@"
"r04546032","0","0","0","@92df87f9488a7070f52b4b57d76524eb@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post.prev;
            post.prev = x.next;
            x.prev = pre.next;
            pre.next = x.prev;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post.prev.next;
            x.prev = post.prev;
            post.prev = x.prev;
            post.prev.next = x.next;
            
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.next = post.prev;
            post.prev = x.next;
            x.prev = pre.next;
            pre.next = x.prev;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre.next.prev;
            x.next = pre.next;
            pre.next= x.next;
            pre.next=x.prev;
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next.next.prev = pre.next;
            pre.next = pre.next.next.prev;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post.prev;
            post.prev = post.prev.prev.next;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            DQ.removeFirst();
            DQ.removeLast();
            
            System.out.println(DQ.iterator().next());
          
    }
}

@92df87f9488a7070f52b4b57d76524eb@"
"r04546032","6","0.7","102528","@ffd3db5b28defac5c10ac3fa6ff5a847@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;           
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;
            pre.next = x;
            
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next = pre.next.next;
            pre.next.next.prev=pre;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            DQ.removeFirst();
            DQ.removeLast();
            
            System.out.println(DQ.iterator().next());
          
    }
}

@ffd3db5b28defac5c10ac3fa6ff5a847@"
"r04546032","5","1.28","177152","@7c8a3d7c435bfe47bff7d285add2eccc@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;           
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;
            pre.next = x;
            
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next = pre.next.next.prev;
            pre.next.next.prev=pre.next;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post.prev;
            post.prev = post.prev.prev.next;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
            //System.out.println( DQ.removeFirst());
            //System.out.println( DQ.removeLast());
            DQ.removeFirst();
          
            
          
          
    }
}

@7c8a3d7c435bfe47bff7d285add2eccc@"
"r04546032","8","0.96","102432","@9931d6e1fb31f8a1511f9beba3b207b9@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (pre.next == post && post.prev == pre);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;           
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;
            pre.next = x;
            
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next = pre.next.next;
            pre.next.prev=pre;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
     
    }
}

@9931d6e1fb31f8a1511f9beba3b207b9@"
"r04546032","8","0.96","102496","@3fa2186e9865302dea901f3df0420e70@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (N==0);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new IllegalStateException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;           
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;
            pre.next = x;
            
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next = pre.next.next;
            pre.next.prev=pre;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
              
    }
}

@3fa2186e9865302dea901f3df0420e70@"
"r04546032","10","0.14","183456","@e18248149fc0d5a1bb6557143323a71e@
import java.util.NoSuchElementException;
import java.util.ListIterator;

/**
 *
 * @author CHIN LUNG
 */
public class Deque<T> implements Iterable<T> {

    private int N;        // number of elements on list
    private Node pre;     // sentinel before first item
    private Node post;    // sentinel after last item

    public Deque() {
        pre = new Node();
        post = new Node();
        pre.next = post;
        post.prev = pre;
    }

    // linked list node helper data type
    private class Node {
        private T item;
        private Node next;
        private Node prev;
    }

    public boolean isEmpty() {
        return (N==0);
    }

    public int size() {
        return N;
    }
//implement
public ListIterator<T> iterator()  { return new DoublyLinkedListIterator(); }

    // assumes no calls to DoublyLinkedList.add() during iteration
    private class DoublyLinkedListIterator implements ListIterator<T> {
        private Node current      = pre.next;  // the node that is returned by next()
        private Node lastAccessed = null;      // the last node to be returned by prev() or next()
                                               // reset to null upon intervening remove() or add()
        private int index = 0;

        public boolean hasNext()      { return index < N; }
        public boolean hasPrevious()  { return index > 0; }
        public int previousIndex()    { return index - 1; }
        public int nextIndex()        { return index;     }

        public T next() {
            if (!hasNext()) throw new NoSuchElementException();
            lastAccessed = current;
            T item = current.item;
            current = current.next; 
            index++;
            return item;
        }

        public T previous() {
            if (!hasPrevious()) throw new NoSuchElementException();
            current = current.prev;
            index--;
            lastAccessed = current;
            return current.item;
        }

        // replace the item of the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void set(T item) {
            if (lastAccessed == null) throw new IllegalStateException();
            lastAccessed.item = item;
        }

        // remove the element that was last accessed by next() or previous()
        // condition: no calls to remove() or add() after last call to next() or previous()
        public void remove() { 
            if (lastAccessed == null) throw new UnsupportedOperationException();
            Node x = lastAccessed.prev;
            Node y = lastAccessed.next;
            x.next = y;
            y.prev = x;
            N--;
            if (current == lastAccessed)
                current = y;
            else
                index--;
            lastAccessed = null;
        }

        // add element to list 
        public void add(T item) {
            Node x = current.prev;
            Node y = new Node();
            Node z = current;
            y.item = item;
            x.next = y;
            y.next = z;
            z.prev = y;
            y.prev = x;
            N++;
            index++;
            lastAccessed = null;
        }

    }
    // add the item to the list
    public void addLast(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.next = post;
            x.prev = post.prev;
            post.prev.next = x;
            post.prev = x;           
            N++;
        }
    }

    public void addFirst(T item) {
         if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty() == true) {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = post;
            post.prev = x;
            pre.next = x;
            N++;
        } else {
            Node x = new Node();
            x.item = item;
            x.prev = pre;
            x.next = pre.next;
            pre.next.prev = x;
            pre.next = x;
            
            N++;
        }
    }

    public T removeFirst() // remove and return the item from the front
    {
        
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = pre.next.item;
            pre.next = pre.next.next;
            pre.next.prev=pre;
             N--;
             return item;
        }      
    }

    public T removeLast() // remove and return the item from the end
    {
        if (isEmpty() == true) {
             throw new NoSuchElementException();
        } else {
            T item = post.prev.item;
            post.prev.prev.next = post;
            post.prev = post.prev.prev;
            N--;
            return item;           
        }     
    }


    public static void main(String[] args) {
            Deque DQ =new Deque();
            DQ.addFirst(1);
            DQ.addLast(2);
            DQ.addFirst(0);
            DQ.addLast(3);
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
            System.out.println( DQ.removeFirst());
            System.out.println( DQ.removeLast());
            System.out.println(DQ.removeFirst());
    }
}

@e18248149fc0d5a1bb6557143323a71e@"
"b02611023","0","0.96","102432","@41d60aa042e5d0da88d9613a9250d2b9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deques<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    private Node<Item> oldfirst, oldlast;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deques() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size()==0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /*public static void main(String[] args) {

        Deques d = new Deques();
        d.iterator().remove();
        String a = null;
        String a = ""0"";
        String b = ""1"";
        d.addFirst(a);
        d.addLast(b);
        d.addFirst(1);
        d.removeLast();
        d.removeFirst();
        System.out.println(d.removeFirst());

    }*/
}

@41d60aa042e5d0da88d9613a9250d2b9@"
"b02611023","0","0.96","102496","@dac91263aac747d926fa4fdce46f05da@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deques<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    private Node<Item> oldfirst, oldlast;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deques() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size()==0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /*public static void main(String[] args) {

        Deques d = new Deques();
        String a = null;
        String b = ""0"";
        String c = ""1"";
        d.addFirst(b);
        d.addFirst(c);
        d.removeLast();
        d.removeFirst();
        System.out.println(d.removeLast());

    }*/
}
@dac91263aac747d926fa4fdce46f05da@"
"b02611023","7","1.43","178064","@41e1b5fc4f2661dfd411d3388cc43e63@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    private Node<Item> oldfirst, oldlast;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size()==0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /*public static void main(String[] args) {

        Deque d = new Deque();
        String a = null;
        String b = ""0"";
        String c = ""1"";
        d.addFirst(b);
        d.addLast(c);
        d.removeLast();
        d.removeFirst();
        System.out.println(d.removeLast());

    }*/
}

@41e1b5fc4f2661dfd411d3388cc43e63@"
"b02611023","7","1.43","182384","@473dd5af8eba3826c01bc585412157f3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    private Node<Item> oldfirst, oldlast;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            oldlast = first;
            if (size()==0) {
                last = first;
                //first.next = oldfirst;
            } else {
                first.next = oldfirst;
                
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /*public static void main(String[] args) {

        Deque d = new Deque();
        String a = null;
        String b = ""0"";
        String c = ""1"";
        String e = ""2"";
        d.addFirst(b);
        d.addLast(c);
        d.addFirst(e);
        d.removeFirst();
        d.removeLast();
        System.out.println(d.removeLast());

    }*/
}

@473dd5af8eba3826c01bc585412157f3@"
"b02611023","7","1.46","181136","@7e41e75477799774208e638f56228be9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null; 
            if (size() == 0) {
                last = first;
                //first.next = oldfirst;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        while(count>0){
            s_first.push(temp.pop());
            count--;
        }
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            /*Item item = last.item;
             last = oldlast;*/
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            }
            else{
                Item item = s_first.pop();
                N--;
                return item;
            }
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /*public static void main(String[] args) {

        Deque<String> d = new Deque<String>();
        String a = null;
        String b = ""0"";
        String c = ""1"";
        String e = ""2"";
        d.addFirst(b);
        d.addLast(c);
        d.addFirst(e);
        d.removeFirst();
        d.removeLast();
        d.removeLast();
        System.out.println(d.removeLast());

    }*/
}

@7e41e75477799774208e638f56228be9@"
"b02611016","0","1.43","178064","@922a7060c1ad7884060e9f49c7b9c7f8@run:
*
12
+
1
Deque$ListIterator@4e25154f
BUILD SUCCESSFUL (total time: 0 seconds)

@922a7060c1ad7884060e9f49c7b9c7f8@"
"b02611016","1","1.39","166880","@7e7751c30222caf856c74cf9bbd86b75@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    first2=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
      // Node<Item> oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
       // last.item = item;
        first.next = oldfirst;
     //   first2=first;
      //  if (isEmpty1()) first1 = last;
      //  else oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
       // first=new Node<Item>();
        last.item = item;
      //  first.item=item;
        last.next=oldlast;
     //   first1=last;
  //      if (isEmpty()) first2 = first;
      //   else oldfirst.next =first;
      //if (isEmpty1()) first1 = last;
        
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
      last = last.next;
        N--;
        //if (isEmpty()||isEmpty1()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()||isEmpty()) throw new NoSuchElementException();
        return first1.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last) {
            current = last;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    

@7e7751c30222caf856c74cf9bbd86b75@"
"r04921094","9","1.39","184800","@8022e469d2317927f35424c113b7405b@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<T> implements Iterable{
	private Node<T> dummyNode;
	private int N;

	public Deque(){
		dummyNode = new Node<T>();
		N = 0;
	}

	private class Node<T>{
		private Node<T> prev;
		private Node<T> next;
		private T content;

		public Node() {
			prev = next = this;
		}

		private Node(T content, Node<T> prev, Node<T> next){
			this.content = content;
			this.prev = prev;
			this.next = next;
		}
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst (T Item){
		if(Item == null) throw new java.lang.NullPointerException();
		dummyNode.next.prev = dummyNode.next = new Node<T>(Item, dummyNode, dummyNode.next);
		++N;
	}

	public void addLast(T Item){
		if(Item == null) throw new java.lang.NullPointerException();
		dummyNode.prev.next = dummyNode.prev = new Node<T>(Item, dummyNode.prev, dummyNode);
		++N;
	}

	public T removeFirst(){
		return remove(dummyNode.next);
	}

	public T removeLast() {
		return remove(dummyNode.prev);
	}

	protected T remove(Node<T> target) {
		T rtn = target.content;
		target.prev.next = target.next;
		target.next.prev = target.prev;
		--N;
		return rtn;
	}

	public Iterator<T> iterator(){
		return new DequeIterator<T>(dummyNode.next);
	}

	public class DequeIterator<T> implements Iterator<T>{
			public Node<T> current;

			public DequeIterator(Node<T> first){
				current = first;
			}

			public boolean hasNext(){
				return current != dummyNode;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public T next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				T Item = current.content;
				current = current.next;
				return Item;
			}

		}

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addLast(""4"");
		deque.addFirst(""0"");
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeFirst());
		// System.out.println(deque.removeFirst());
		Iterator<String> i = deque.iterator();
		 while(i.hasNext()){
			String s = i.next();
			System.out.print(s);
		}
		System.out.println();
	}
}
@8022e469d2317927f35424c113b7405b@"
"r04921094","10","0.14","178720","@9b7b0afa3d76062454dd84218d3ac013@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<T> implements Iterable{
	private Node<T> dummyNode;
	private int N;

	public Deque(){
		dummyNode = new Node<T>();
		N = 0;
	}

	private class Node<T>{
		private Node<T> prev;
		private Node<T> next;
		private T content;

		public Node() {
			prev = next = this;
		}

		private Node(T content, Node<T> prev, Node<T> next){
			this.content = content;
			this.prev = prev;
			this.next = next;
		}
	}

	public boolean isEmpty(){
		return N == 0;
	}

	public int size(){
		return N;
	}

	public void addFirst (T Item){
		if(Item == null) throw new java.lang.NullPointerException();
		dummyNode.next.prev = dummyNode.next = new Node<T>(Item, dummyNode, dummyNode.next);
		++N;
	}

	public void addLast(T Item){
		if(Item == null) throw new java.lang.NullPointerException();
		dummyNode.prev.next = dummyNode.prev = new Node<T>(Item, dummyNode.prev, dummyNode);
		++N;
	}

	public T removeFirst(){
		if(isEmpty()) throw new java.util.NoSuchElementException();
		return remove(dummyNode.next);
	}

	public T removeLast() {
		if(isEmpty()) throw new java.util.NoSuchElementException();
		return remove(dummyNode.prev);
	}

	protected T remove(Node<T> target) {
		T rtn = target.content;
		target.prev.next = target.next;
		target.next.prev = target.prev;
		--N;
		return rtn;
	}

	public Iterator<T> iterator(){
		return new DequeIterator<T>(dummyNode.next);
	}

	public class DequeIterator<T> implements Iterator<T>{
			public Node<T> current;

			public DequeIterator(Node<T> first){
				current = first;
			}

			public boolean hasNext(){
				return current != dummyNode;
			}

			public void remove(){
				throw new java.lang.UnsupportedOperationException();
			}

			public T next(){
				if(!hasNext()) throw new java.util.NoSuchElementException();
				T Item = current.content;
				current = current.next;
				return Item;
			}

		}

	public static void main(String[] args) {
		Deque<String> deque = new Deque<String>();
		deque.addFirst(""1"");
		deque.addLast(""2"");
		deque.addLast(""3"");
		deque.addLast(""4"");
		deque.addFirst(""0"");
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeLast());
		// System.out.println(deque.removeFirst());
		// System.out.println(deque.removeFirst());
		Iterator<String> i = deque.iterator();
		 while(i.hasNext()){
			String s = i.next();
			System.out.print(s);
		}
		System.out.println();
	}
}
@9b7b0afa3d76062454dd84218d3ac013@"
"b02611023","6","1.47","181040","@4477c126365607fe56ec8d32b5dd41d0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    //private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return (first == null)&&(last == null);
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null; 
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size()==0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        while(count>0){
            s_first.push(temp.pop());
            count--;
        }
        if (size() == 0) {
            throw new NoSuchElementException();
        } else {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            }
            else{
                Item item = s_first.pop();
                N--;
                return item;
            }
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@4477c126365607fe56ec8d32b5dd41d0@"
"b02611023","7","1.47","177488","@b13bd80c044f6cda8d9e69d1f369e02d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    //private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null; 
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() <= 0) {
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        while(count>0){
            s_first.push(temp.pop());
            count--;
        }
        if (size() <= 0) {
            throw new NoSuchElementException();
        } else {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            }
            else{
                Item item = s_first.pop();
                N--;
                return item;
            }
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@b13bd80c044f6cda8d9e69d1f369e02d@"
"r03945012","8","1.4","178752","@47f672a4830217727810ea2313c5dd5b@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        return first == null || last == null;
        //return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        if (first == last){
            last = null;
            first.next = null;
        }
        first = first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        if (first == last){
            first = null;
            last.pre = null;
        }
        last = last.pre;
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addLast(3);
//        q.addLast(4);
//        q.addFirst(4);
//        q.addFirst(3);

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeLast());
        q.addLast(5);
        q.addLast(6);
        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@47f672a4830217727810ea2313c5dd5b@"
"r03945012","8","1.33","182000","@b0270ba3d0dc1e50f903c186f6b6f629@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        //return first == null || last == null;
        return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        if (first == last){
            last = null;
            first.next = null;
        }
        first = first.next;
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        if (first == last){
            first = null;
            last.pre = null;
        }
        last = last.pre;
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addLast(3);
//        q.addLast(4);
//        q.addFirst(4);
//        q.addFirst(3);

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeLast());
        q.addLast(5);
        q.addLast(6);
        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@b0270ba3d0dc1e50f903c186f6b6f629@"
"r03945012","8","1.39","178608","@30776cf585303645f57784008cd33228@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        //return first == null || last == null;
        return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (last == null) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (first == null) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addLast(3);
//        q.addLast(4);
//        q.addFirst(4);
//        q.addFirst(3);

        StdOut.println(q.removeFirst());
        StdOut.println(q.removeLast());
        q.addLast(5);
        q.addLast(6);
        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@30776cf585303645f57784008cd33228@"
"b02611016","0","1.29","178160","@abdd91147b92496f65845a5ddeda126c@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    first2 =null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        first1.item=item;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        //if (isEmpty1()) last = null;   // to avoid loitering
         N--;
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last2) {
            current = last2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@abdd91147b92496f65845a5ddeda126c@"
"b02611016","1","1.28","170224","@8ba5b660cbc0b974a1fb3dc0a2c51a30@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    first2 =null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        first1.item=item;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        //if (isEmpty1()) last = null;   // to avoid loitering
         N--;
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last) {
            current = last;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@8ba5b660cbc0b974a1fb3dc0a2c51a30@"
"b02611016","4","1.27","179440","@9e59e7117ff2290d48aa2d3eef604e2e@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    first2 =null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        first1.item=item;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        //if (isEmpty1()) last = null;   // to avoid loitering
         N--;
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@9e59e7117ff2290d48aa2d3eef604e2e@"
"r03945012","8","1.39","185408","@5da0660c10563aa0f5caa1bb4b8e6dd0@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        //return first == null || last == null;
        return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<Integer> ();
        q.addLast(2);
        q.addLast(3);
        StdOut.println(q.removeFirst());
        q.addFirst(5);
        q.addLast(6);
        StdOut.println(q.removeLast());
        StdOut.println(q.removeFirst());
        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@5da0660c10563aa0f5caa1bb4b8e6dd0@"
"b02611016","4","1.26","179488","@a111212fa3e7008e9dbcc5571526f879@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    first2 =null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        first1.item=item;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        N--;
        if(N<0){throw new NoSuchElementException();}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        
        //if (isEmpty1()) last = null;   // to avoid loitering
         N--;
         if(N<0){throw new NoSuchElementException();}
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@a111212fa3e7008e9dbcc5571526f879@"
"b02611016","0","1.27","174416","@21e1d32443554e22d517d0b5ec27a4fb@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    first2 =null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        first1.item=item;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        N--;
        if(N<0){throw new NoSuchElementException();}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        
        //if (isEmpty1()) last = null;   // to avoid loitering
         N--;
         if(N<0){throw new NoSuchElementException();}
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first2);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first2) {
            current = first2;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@21e1d32443554e22d517d0b5ec27a4fb@"
"b02611023","7","1.48","180624","@9b3bb01b287aa1ca4cc3861b28014281@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    //private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null; 
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() <= 0) {
            N = 0;
            while(s_first.pop()!=null){
                s_first.pop();
            }
            while(s_last.pop()!=null){
                s_last.pop();
            }
            throw new NoSuchElementException();
        } else {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {
        while(count>0){
            s_first.push(temp.pop());
            count--;
        }
        if (size() <= 0) {
            N = 0;
            while(s_first.pop()!=null){
                s_first.pop();
            }
            while(s_last.pop()!=null){
                s_last.pop();
            }
            throw new NoSuchElementException();
        } else {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            }
            else{
                Item item = s_first.pop();
                N--;
                return item;
            }
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@9b3bb01b287aa1ca4cc3861b28014281@"
"b02611016","1","0.97","102512","@2705ab431aea03a1ac36e8c1701f6651@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;   
     private Node<Item>  first3;
     private Node<Item> last3;   
    // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    last3=null;
    first2 =null;
    first3=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public boolean isEmpty5()                 // is the deque empty?
   {return first3 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst2 = first3;
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        first3=new Node<Item>();
       last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        last1.item = item;
        first.next = oldfirst;
        first3.next = oldfirst2;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast1 = last3;
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        last3 = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        last3.item = item;
        first1.item=item;
        last3.next = null;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        if (isEmpty5()) first3 = last3;
        else           oldlast1.next = last3;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        first3=first3.next;
        N--;
        if(N<0){throw new NoSuchElementException();}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        
        //if (isEmpty1()) last = null;   // to avoid loitering
          first3=first3.next; 
        N--;
         if(N<0){throw new NoSuchElementException();}
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {   return new ListIterator<Item>(first3);
  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
      
         public ListIterator(Node<Item>first3) {
            current = first3;
        }
    
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeLast());
             //System.out.println(deque.removeLast());
          //   System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@2705ab431aea03a1ac36e8c1701f6651@"
"b02611016","4","0.93","102544","@4d6ed6c32c640d178136a60719d3c5a2@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
   private Node<Item> first1;
   private Node<Item> last1;
   private Node<Item>last2;
   private Node<Item>  first2;
    private Node<Item> last;   
     private Node<Item>  first3;
     private Node<Item> last3;   
    // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
    first1=null;
    last1=null;
    last2=null;
    last3=null;
    first2 =null;
    first3=null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
     public boolean isEmpty1()                 // is the deque empty?
   {return first1 == null;}
   public boolean isEmpty2()                 // is the deque empty?
   {return last1 == null;}
   public boolean isEmpty3()                 // is the deque empty?
   {return first2 == null;}
   public boolean isEmpty4()                 // is the deque empty?
   {return last2 == null;}
   public boolean isEmpty5()                 // is the deque empty?
   {return first3 == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
 
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
       Node<Item> oldfirst2 = first3;
       Node<Item> oldfirst = first;
       Node<Item> oldlast=last1;
        first3=new Node<Item>();
       last1 = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        first3.item = item;
        last1.item = item;
        first.next = oldfirst;
        first3.next = oldfirst2;
        //last.pre=oldlast;
       // first2=first;
        //if (isEmpty()) first2 = first;
        //else first.pre=first;
         if (isEmpty4()&&oldlast==null) {last2 = first; }
         else if (isEmpty4()&&oldlast!=null) { last2 = first; last1=oldlast; }
        else oldlast.pre=last1;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast1 = last3;
       Node<Item> oldlast = last;
       Node<Item> oldfirst = first1;
        last = new Node<Item>();
        last3 = new Node<Item>();
        first1=new Node<Item>();
        last.item = item;
        last3.item = item;
        first1.item=item;
        last3.next = null;
        last.next=oldlast;
        //first.pre=oldfirst;
       // first1=last;
         // if (isEmpty1()) first1 = first;
         //else first.pre =first;
        if (isEmpty3()&&oldfirst==null) {first2 = first1; }
        else if (isEmpty3()&&oldfirst!=null) {first2 = last; first1=oldfirst; }
         else oldfirst.pre =first1;
      //if (isEmpty1()) first1 = last;
        if (isEmpty5()) first3 = last3;
        else           oldlast1.next = last3;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {//if (isEmpty()) throw new NoSuchElementException();
       Item item;
        if(first!=null)
        { item = first.item;        // save item to return
        first = first.next;          }  // delete first node
        else
        {  item = first2.item;        // save item to return
        first2 = first2.pre; }
      //  first=first1.pre;
        first3=first3.next;
        N--;
        if(N<0){throw new NoSuchElementException();}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { //if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
       last = last.next;
       //first=first2.pre;
        if(item==null)
        { item = last2.item;        // save item to return
        last2 = last2.pre; }
        
        //if (isEmpty1()) last = null;   // to avoid loitering
          first3=first3.next; 
        N--;
         if(N<0){throw new NoSuchElementException();}
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {   return new ListIterator<Item>(first3);
  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
      
         public ListIterator(Node<Item>first3) {
            current = first3;
        }
    
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addLast(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeLast());
             //System.out.println(deque.removeLast());
          //   System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@4d6ed6c32c640d178136a60719d3c5a2@"
"b02611023","7","1.51","171328","@8bce90b28f3168b7ce5b45113830e0ff@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    //private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            while (s_first.pop() != null) {
                s_first.pop();
            }
            while (s_last.pop() != null) {
                s_last.pop();
            }
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        while (count > 0) {
            s_first.push(temp.pop());
            count--;
        }
        if (size() > 0) {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            } else {
                Item item = s_first.pop();
                N--;
                return item;
            }
            
        } else {
            while (s_first.pop() != null) {
                s_first.pop();
            }
            while (s_last.pop() != null) {
                s_last.pop();
            }
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@8bce90b28f3168b7ce5b45113830e0ff@"
"b02611016","7","1.4","176320","@b521f0bddac7c12d899dbaeb49a4547c@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeLast());
            // System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@b521f0bddac7c12d899dbaeb49a4547c@"
"b02611023","7","1.45","178832","@92f46a0c55a38682833eb140e78a83ae@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    //private Node<Item> oldfirst, oldlast;
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();
    Stack<Item> s_first = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        //oldfirst = null;
        //oldlast = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            /*while (s_first.pop() != null) {
             s_first.pop();
             }
             while (s_last.pop() != null) {
             s_last.pop();
             }*/
            s_last = new Stack<Item>();
            s_first = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        while (count > 0) {
            s_first.push(temp.pop());
            count--;
        }
        if (size() > 0) {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            } else {
                Item item = s_first.pop();
                N--;
                return item;
            }

        } else {
            /*while (s_first.pop() != null) {
             s_first.pop();
             }
             while (s_last.pop() != null) {
             s_last.pop();
             }*/
            s_last = new Stack<Item>();
            s_first = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@92f46a0c55a38682833eb140e78a83ae@"
"b02611016","7","1.44","171584","@b521f0bddac7c12d899dbaeb49a4547c@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addLast(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeLast());
            // System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@b521f0bddac7c12d899dbaeb49a4547c@"
"b02611016","7","1.38","177072","@f712e65e86d2d02740ca67b9796c6fa4@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@f712e65e86d2d02740ca67b9796c6fa4@"
"b02611016","0","1.47","168944","@c6bb4cf475cf165b678027361083a1e0@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last) {
            current = last;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@c6bb4cf475cf165b678027361083a1e0@"
"b02611023","7","1.48","178176","@de07a63b60c83bafeca9443d396fad99@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private int num;
    private int count;
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
        num = 0;
        count = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
            count++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size()==0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
            num++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (num > 0) {
                Item item = s_last.pop();
                N--;
                num--;
                return item;
            } else {
                while (count > 0) {
                    s_last.push(temp.pop());
                    count--;
                }
                Item item = s_last.pop();
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//
//    }
}

@de07a63b60c83bafeca9443d396fad99@"
"b02611016","5","1.29","179120","@5dcbb77abfcff59d50faf0fd57768f2b@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
      /*  Item item = first.item;
        first = first.next;*/
   Item item = last.item;
        last = last.pre;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
       /* Item item = last.item;
        last = last.pre;*/
        //first=first.pre;
        Item item = first.item;
        first = first.next;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
               System.out.println(deque.size());
           //  System.out.println(deque.removeLast());
            // System.out.println(deque.removeLast());
          
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@5dcbb77abfcff59d50faf0fd57768f2b@"
"b02611016","0","1.33","175952","@6d25054a02a55cc314a8e61223dd8432@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
      /*  Item item = first.item;
        first = first.next;*/
   Item item = last.item;
        last = last.pre;
        N--;
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
       /* Item item = last.item;
        last = last.pre;*/
        //first=first.pre;
        Item item = first.item;
        first = first.next;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last) {
            current = last;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeLast());
               System.out.println(deque.size());
           //  System.out.println(deque.removeLast());
            // System.out.println(deque.removeLast());
          
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@6d25054a02a55cc314a8e61223dd8432@"
"r04945021","7","1.48","185744","@50d3d3fed7efb0a10ab5f062deea1ef7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node<Item> first;
private Node<Item> last;
private int counter;

private class Node<Item>
{
    Item item;
    Node<Item> next;
    Node<Item> pre;
}
    public Deque(){
    first=null;
    last=null;
    counter=0;
    }// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
            first = new Node();
            first.item = item;
            first.next = null;
            first.pre = null;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        counter++;
    }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
      if(isEmpty()){
          first=last;
          
      }
       Node<Item> oldlast =last;
       last = new Node();
       last.item=item;
       last.next=null;
       
       if(isEmpty()) first=last;
       else {
           last.pre=oldlast;
           oldlast.next=last;
       }
       counter++;
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       counter--;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    last=last.pre;
    counter--;
    System.out.println(counter);
    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       Iterator<Item> ite=new Iterator<Item>(){
       private Node<Item> current=first;
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
           
           Item item = current.item;
           current = current.next;          
           return item;
       }
   };
       return ite;
   }
        
       
       // return an iterator over items in order from front to end   
  
  
      //static  
        
    public static void main(String[] args) throws Exception {
        Deque<String> de=new <String>Deque();
        
        
        de.addLast(""He"");
        de.addLast(""A"");
        de.addLast(""B"");
        int Si=de.size();
      Iterator ii=de.iterator();
        
        
        while(ii.hasNext()){
          System.out.println(ii.next());
           
           
       
        }
        

        
    }

}

  

    
@50d3d3fed7efb0a10ab5f062deea1ef7@"
"b03704074","0","1.29","179120","@5ffbc0e23c7fff36da46f2037894541d@import java.util.Iterator;
import java.util.*;
public class Deques<Item> implements Iterable<Item>{
private int count = 0;
private Node first = null;
private Node last = null;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deques(){
    Deques deques = new Deques();}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return count == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(size()==0)  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(size()==0)  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}

    
    
    
    
    
    public static void main(String[] args) {
       
    }
    
}

@5ffbc0e23c7fff36da46f2037894541d@"
"b03704074","0","0","0","@11bf3658d2c2ac882f51d259864056c8@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count = 0;
private Node first = null;
private Node last = null;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    Deque deques = new Deque();}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return count == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(size()==0)  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(size()==0)  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}

    
    
    
    
    
    public static void main(String[] args) {
       
    }
    
}

@11bf3658d2c2ac882f51d259864056c8@"
"b03704074","0","0","0","@cd58c9678865f0c4f0db2d7d34a1dfc2@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count = 0;
private Node first = null;
private Node last = null;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    Deque Item = new Deque();}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return count == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(size()==0)  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(size()==0)  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}

    
    
    
    
    
    public static void main(String[] args) {
       
    }
    
}

@cd58c9678865f0c4f0db2d7d34a1dfc2@"
"b03704074","4","0.83","102496","@2e7bcd1af7bbdef217b0d8edb137e366@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return count == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(size()==0)  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(size()==0)  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}

    
    
    
    
    
    public static void main(String[] args) {
       
    }
    
}

@2e7bcd1af7bbdef217b0d8edb137e366@"
"b03704074","4","0.83","98704","@20d0a1107f88350a669f2b7101898c2f@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       System.out.println(deque.last);
    }
    
}

@20d0a1107f88350a669f2b7101898c2f@"
"b02611016","8","1.08","102432","@2a476875b5b542d75c8aed6bbb954ae3@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
           if(N==0){first=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return last.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             System.out.println(deque.removeLast());
             System.out.println(deque.removeFirst());
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
             System.out.println(deque.iterator().next());
             System.out.println(deque.iterator());
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@2a476875b5b542d75c8aed6bbb954ae3@"
"b02611016","0","1.07","102448","@bb63deedfd4a5540fea11c79beca083c@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(last);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> last) {
            current = last; 
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.pre; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeLast());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     
               //  System.out.println(deque.iterator().next());
                System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@bb63deedfd4a5540fea11c79beca083c@"
"b02611016","8","1.4","179040","@7c18d71b1421e8295bb56380425ab686@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   {return new ListIterator<Item>(first);  }
   
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        public ListIterator(Node<Item> first) {
            current = first; 
        }
        
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) {throw new NoSuchElementException();}
            else{Item item = current.item;
            current = current.next; 
            return item;}
        }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            /*for(int i=0;i<24;i++){
            deque.addLast(data[i]);
             System.out.println(deque.peek());
            }
             System.out.println(deque.removeLast());*/
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
             System.out.println(deque.removeLast());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     
               //  System.out.println(deque.iterator().next());
            System.out.println(deque.removeLast());   
             //  System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@7c18d71b1421e8295bb56380425ab686@"
"b01b01039","7","1.28","183456","@373116c0b083280e90ebc2eee39ac7fa@import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
	
	private Node<Item> first;
	private Node<Item> last;
	private int n;
	
	private static class Node<Item> {
		private Item item;
		private Node<Item> next;
		private Node<Item> pre;
	}

	// construct an empty deque
	public Deque(){
		first = null;
		last = null;
		n = 0;
	}
	
	private void first_D(Item item){
		first = new Node();
		first.item = item;
		last = first;
		n++;
	}
	
	private Item last_D(){
		Item item = first.item;
		first = null;
		last = null;
		n--;
		return(item);
	}
	
	// is the deque empty?
	public boolean isEmpty(){
		if(n == 0)return true;
		else return false;
	}

	// return the number of items on the deque
	public int size(){
		return n;
	}
	
	// add the item to the front
	public void addFirst(Item item){
		if(n == 0){
			first_D(item);
		}else{
			Node old_first = first;
			first = new Node();
			first.item = item;
			first.next = old_first;
			old_first.pre = first;
			n++;
		}
	}
	
	// add the item to the end
	public void addLast(Item item){
		if(n == 0){
			first_D(item);
		}else{
			Node old_last = last;
			last = new Node();
			last.item = item;
			last.pre = old_last;
			old_last.next = last;
			n++;
		}
	}

	// remove and return the item from the front
	public Item removeFirst(){
		Item item;
		if(n == 1){
			item = last_D();
		}else{
			item = first.item;
			first = first.next;
			first.pre = null;
			n--;
		}
		return(item);
	}

	// remove and return the item from the end
	public Item removeLast(){
		Item item;
		if(n == 1){
			item = last_D();
		}else{
			item = last.item;
			last = last.pre;
			last.next = null;
			n--;
		}
		return(item);
	}

	public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
	
	// unit testing
	public static void main(String[] args){
		String input = new String();
		if(args.length == 0){
			Scanner scanner = new Scanner(System.in);
			System.out.printf(""Input text :"");
			input = scanner.nextLine();
		}else{
			input = args[0];
		}
		String[] Input = input.split("" "");
		
		
		Deque<String> deque = new Deque<String>();
		
		for(String s : Input){
			System.out.println(""Add first :"" + s);
			deque.addFirst(s);
		}
		
		for(String s : deque){
			System.out.println(""deque : "" + s);
		}
		
		System.out.println(deque.isEmpty());
		while(deque.size() > 0){
			if(deque.size()%2==0){
				System.out.println(""Remove last  : "" + deque.removeLast());
			}else{
				System.out.println(""Remove first : "" + deque.removeFirst());
			}
		}
		System.out.println(deque.isEmpty());
	}

}

@373116c0b083280e90ebc2eee39ac7fa@"
"b01b01039","9","1.41","185312","@bd9813601e7e1cc8f48d055540825031@import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
	
	private Node<Item> first;
	private Node<Item> last;
	private int n;
	
	private static class Node<Item> {
		private Item item;
		private Node<Item> next;
		private Node<Item> pre;
	}

	// construct an empty deque
	public Deque(){
		first = null;
		last = null;
		n = 0;
	}
	
	private void first_D(Item item){
		if(item == null){throw new java.lang.NullPointerException();}
		first = new Node();
		first.item = item;
		last = first;
		n++;
	}
	
	private Item last_D(){
		Item item = first.item;
		first = null;
		last = null;
		n--;
		return(item);
	}
	
	// is the deque empty?
	public boolean isEmpty(){
		if(n == 0)return true;
		else return false;
	}

	// return the number of items on the deque
	public int size(){
		return n;
	}
	
	// add the item to the front
	public void addFirst(Item item){
		if(n == 0){
			first_D(item);
		}else{
			Node old_first = first;
			first = new Node();
			first.item = item;
			first.next = old_first;
			old_first.pre = first;
			n++;
		}
	}
	
	// add the item to the end
	public void addLast(Item item){
		if(n == 0){
			first_D(item);
		}else{
			Node old_last = last;
			last = new Node();
			last.item = item;
			last.pre = old_last;
			old_last.next = last;
			n++;
		}
	}

	// remove and return the item from the front
	public Item removeFirst(){
		Item item;
		if(n == 0){
			throw new java.util.NoSuchElementException();
		}else if(n == 1){
			item = last_D();
		}else{
			item = first.item;
			first = first.next;
			first.pre = null;
			n--;
		}
		return(item);
	}

	// remove and return the item from the end
	public Item removeLast(){
		Item item;
		if(n == 0){
			throw new java.util.NoSuchElementException();
		}else if(n == 1){
			item = last_D();
		}else{
			item = last.item;
			last = last.pre;
			last.next = null;
			n--;
		}
		return(item);
	}

	public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
	
	// unit testing
	public static void main(String[] args){
		/*
		String input = new String();
		if(args.length == 0){
			Scanner scanner = new Scanner(System.in);
			System.out.printf(""Input text :"");
			input = scanner.nextLine();
		}else{
			input = args[0];
		}
		String[] Input = input.split("" "");
			
		Deque<String> deque = new Deque<String>();
		
		for(String s : Input){
			System.out.println(""Add first :"" + s);
			deque.addFirst(s);
		}
		
		for(String s : deque){
			System.out.println(""deque : "" + s);
		}
		
		System.out.println(deque.isEmpty());
		while(deque.size() > 0){
			if(deque.size()%2==0){
				System.out.println(""Remove last  : "" + deque.removeLast());
			}else{
				System.out.println(""Remove first : "" + deque.removeFirst());
			}
		}
		System.out.println(deque.isEmpty());
		*/
		Deque<Integer> deque = new Deque<Integer>();
		
		Integer[] i_list = {1,2,3,4,5};
		for(Integer i : i_list){
			System.out.println(i);
			System.out.println(""Add first :"" + i);
			deque.addFirst(i);
		}
		
		for(Integer i : deque){
			System.out.println(""deque : "" + i);
		}
		
		System.out.println(deque.isEmpty());
		while(deque.size() > 0){
			if(deque.size()%2==0){
				System.out.println(""Remove last  : "" + deque.removeLast());
			}else{
				System.out.println(""Remove first : "" + deque.removeFirst());
			}
		}
		System.out.println(deque.isEmpty());
		
		
	}

}

@bd9813601e7e1cc8f48d055540825031@"
"b01b01039","10","0.145","179360","@a9c66039763e8e7345670ea59cf98de3@import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
	
	private Node<Item> first;
	private Node<Item> last;
	private int n;
	
	private static class Node<Item> {
		private Item item;
		private Node<Item> next;
		private Node<Item> pre;
	}

	// construct an empty deque
	public Deque(){
		first = null;
		last = null;
		n = 0;
	}
	
	private void first_D(Item item){
		//if(item == null){throw new java.lang.NullPointerException();}
		first = new Node();
		first.item = item;
		last = first;
		n++;
	}
	
	private Item last_D(){
		Item item = first.item;
		first = null;
		last = null;
		n--;
		return(item);
	}
	
	// is the deque empty?
	public boolean isEmpty(){
		if(n == 0)return true;
		else return false;
	}

	// return the number of items on the deque
	public int size(){
		return n;
	}
	
	// add the item to the front
	public void addFirst(Item item){
		if(item == null){throw new java.lang.NullPointerException();}
		if(n == 0){
			first_D(item);
		}else{
			Node old_first = first;
			first = new Node();
			first.item = item;
			first.next = old_first;
			old_first.pre = first;
			n++;
		}
	}
	
	// add the item to the end
	public void addLast(Item item){
		if(item == null){throw new java.lang.NullPointerException();}
		if(n == 0){
			first_D(item);
		}else{
			Node old_last = last;
			last = new Node();
			last.item = item;
			last.pre = old_last;
			old_last.next = last;
			n++;
		}
	}

	// remove and return the item from the front
	public Item removeFirst(){
		Item item;
		if(n == 0){
			throw new java.util.NoSuchElementException();
		}else if(n == 1){
			item = last_D();
		}else{
			item = first.item;
			first = first.next;
			first.pre = null;
			n--;
		}
		return(item);
	}

	// remove and return the item from the end
	public Item removeLast(){
		Item item;
		if(n == 0){
			throw new java.util.NoSuchElementException();
		}else if(n == 1){
			item = last_D();
		}else{
			item = last.item;
			last = last.pre;
			last.next = null;
			n--;
		}
		return(item);
	}

	public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
	
	// unit testing
	public static void main(String[] args){
		/*
		String input = new String();
		if(args.length == 0){
			Scanner scanner = new Scanner(System.in);
			System.out.printf(""Input text :"");
			input = scanner.nextLine();
		}else{
			input = args[0];
		}
		String[] Input = input.split("" "");
			
		Deque<String> deque = new Deque<String>();
		
		for(String s : Input){
			System.out.println(""Add first :"" + s);
			deque.addFirst(s);
		}
		
		for(String s : deque){
			System.out.println(""deque : "" + s);
		}
		
		System.out.println(deque.isEmpty());
		while(deque.size() > 0){
			if(deque.size()%2==0){
				System.out.println(""Remove last  : "" + deque.removeLast());
			}else{
				System.out.println(""Remove first : "" + deque.removeFirst());
			}
		}
		System.out.println(deque.isEmpty());
		*/
		Deque<Integer> deque = new Deque<Integer>();
		
		Integer[] i_list = {1,2,3,4,5};
		for(Integer i : i_list){
			System.out.println(i);
			System.out.println(""Add first :"" + i);
			deque.addFirst(i);
		}
		
		for(Integer i : deque){
			System.out.println(""deque : "" + i);
		}
		
		System.out.println(deque.isEmpty());
		while(deque.size() > 0){
			if(deque.size()%2==0){
				System.out.println(""Remove last  : "" + deque.removeLast());
			}else{
				System.out.println(""Remove first : "" + deque.removeFirst());
			}
		}
		System.out.println(deque.isEmpty());
		
		
	}

}

@a9c66039763e8e7345670ea59cf98de3@"
"b02611016","8","1.39","177360","@1df23642ca5139d0ba579a7704974498@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            //for(int i=0;i<N;i++){
            if (!hasNext()) {throw new NoSuchElementException();}
            else{
                Item item = current.item;
            current = current.next; 
            //System.out.println(item);
             return item ;
            }
   //         }
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     
          //   deque.addLast(data[3]);
               //  System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
             //  System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@1df23642ca5139d0ba579a7704974498@"
"r04921105","0","1.41","185312","@0e9ce9a9dfe28cfe9202f5f0121179cd@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
   //public Deque()                     // construct an empty deque
   //public boolean isEmpty();          // is the deque empty?
   //public int size()                  // return the number of items on the deque
   //public void addLast(Item item)     // insert the item at the end
   //public Item removeFirst()          // delete and return the item at the front
   //public Item removeLast()           // delete and return the item at the end
   //public Iterator<Item> iterator()   // return an iterator over items in order from front to end
   ///iterator implementation should support the operations next() and hasNext()

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack
    private Node debug;

    // helper linked list class
    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
        debug = new Node();
        debug.item = (Item) ""Empty stack"";
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        System.out.println(""Add First"");
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            System.out.println(""Message: First was equal to NULL."");
            test();
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++;
        test();  
    }
    
    public Item removeFirst(){
        System.out.println(""Remove First"");       
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        test();
        return item;
    }
    
    public void addLast(Item item){
        System.out.println(""add last"");        
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
        test();
    }
    
    public Item removeLast() {
        System.out.println(""remove last"");
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        test();
        return lastItem;
    }    
    
    /**
     * Return an iterator to the stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator()  { return new ListIterator();  }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        //change to private not
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

     public void test() {
         boolean empty = (first == null)? true : false;
         System.out.println(""Is Empty: "" + empty);
         System.out.println(""Stack count: "" +N);
         System.out.print(""Stack: First ~~~~> "");
         if (N >0){
             Iterator iter =  iterator();
             while(iter.hasNext() ){
                 System.out.print(iter.next());
                 System.out.print("" | "");
             }
         }
         if(last != null){
             System.out.print(last.item);
         }
         System.out.println("" <~~~~ Last"");           
    }
    /*
    public static void main(String[] args) {
        Deque<String> s = new Deque<String>();
        //                      TESTING
        //
        //             KEY      FUNCTION        ACTION 
        //               -    removeFirst();    Remove First Entry in Stack
        //               /    removeLast();     Remove Last Entry in Stack
        //               +    addLast();        Add ""+"" to Last Position of Stack
        //(any other char)    addFirst();       Add String to First Position of Stack
        while (true) {
           String item = System.out.readString();
           if (item.equals(""/"")){
               System.out.println(s.removeLast());
           }
           if(item.equals(""+"")){
               s.addLast(item);
           }
            if (!item.equals(""-"") && !item.equals(""/"") && !item.equals(""+"") ) s.addFirst(item);
            else if (!item.equals(""/"") && !item.equals(""+"")) System.out.println(s.removeFirst());
        }
    }
}

@0e9ce9a9dfe28cfe9202f5f0121179cd@"
"r04921105","0","0.98","102464","@873eb3e8ffc0e14efc8bfcb05a6f16ca@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
   //public Deque()                     // construct an empty deque
   //public boolean isEmpty();          // is the deque empty?
   //public int size()                  // return the number of items on the deque
   //public void addLast(Item item)     // insert the item at the end
   //public Item removeFirst()          // delete and return the item at the front
   //public Item removeLast()           // delete and return the item at the end
   //public Iterator<Item> iterator()   // return an iterator over items in order from front to end
   ///iterator implementation should support the operations next() and hasNext()

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack
    private Node debug;

    // helper linked list class
    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
        debug = new Node();
        debug.item = (Item) ""Empty stack"";
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        System.out.println(""Add First"");
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            System.out.println(""Message: First was equal to NULL."");
            test();
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++;
        test();  
    }
    
    public Item removeFirst(){
        System.out.println(""Remove First"");       
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        test();
        return item;
    }
    
    public void addLast(Item item){
        System.out.println(""add last"");        
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
        test();
    }
    
    public Item removeLast() {
        System.out.println(""remove last"");
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        test();
        return lastItem;
    }    
    
    /**
     * Return an iterator to the stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator()  { return new ListIterator();  }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        //change to private not
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

     public void test() {
         boolean empty = (first == null)? true : false;
         System.out.println(""Is Empty: "" + empty);
         System.out.println(""Stack count: "" +N);
         System.out.print(""Stack: First ~~~~> "");
         if (N >0){
             Iterator iter =  iterator();
             while(iter.hasNext() ){
                 System.out.print(iter.next());
                 System.out.print("" | "");
             }
         }
         if(last != null){
             System.out.print(last.item);
         }
         System.out.println("" <~~~~ Last"");           
    }
    /*
    public static void main(String[] args) {
        Deque<String> s = new Deque<String>();
        //                      TESTING
        //
        //             KEY      FUNCTION        ACTION 
        //               -    removeFirst();    Remove First Entry in Stack
        //               /    removeLast();     Remove Last Entry in Stack
        //               +    addLast();        Add ""+"" to Last Position of Stack
        //(any other char)    addFirst();       Add String to First Position of Stack
        while (true) {
           String item = System.out.readString();
           if (item.equals(""/"")){
               System.out.println(s.removeLast());
           }
           if(item.equals(""+"")){
               s.addLast(item);
           }
            if (!item.equals(""-"") && !item.equals(""/"") && !item.equals(""+"") ) s.addFirst(item);
            else if (!item.equals(""/"") && !item.equals(""+"")) System.out.println(s.removeFirst());
        }
    }
    */
}

@873eb3e8ffc0e14efc8bfcb05a6f16ca@"
"r04945021","8","1.43","182256","@2298c1b965ab230058f460595aa52c5a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node<Item> first;
private Node<Item> last;
private int counter;

private class Node<Item>
{
    Item item;
    Node<Item> next;
    Node<Item> pre;
}
    public Deque(){
    first=null;
    last=null;
    counter=0;
    }// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            first.next = null;
            first.pre = null;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new <Item>Node();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        counter++;
    }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
     else if(isEmpty()){
         last = new Node<Item>();
         last.item = item;
            last.next = null;
            last.pre = null;
          first=last;
          
      }
     else{
       Node<Item> oldlast =last;
       last = new <Item>Node();
       last.item=item;
       last.next=null;
       last.pre=oldlast;
       oldlast.next=last;
     }
           

       counter++;
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       counter--;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    last.pre.next=null;
    last=last.pre;
    if(isEmpty()) first=null;
    counter--;
    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){          
       return new ListIterator<Item>(first);      
       // return an iterator over items in order from front to end   
   }
   
   private class ListIterator<Item> implements Iterator<Item>
   {
            
       private Node<Item> current;
       public ListIterator(Node first) {
            current = first;
        }
   
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
           
           Item item = current.item;
           current = current.next;          
           return item;
       }
   }
  
      //static  
        
    public static void main(String[] args) throws Exception {
        Deque<Integer> de=new <Integer>Deque();
       
        int a=5;
        de.addFirst(5);
       de.addLast(6);
       de.addLast(4);
        
//                while(ii.hasNext()){
//          System.out.println(ii.next());     
//        }
        de.removeLast();
        System.out.println();

      Iterator ii=de.iterator();
        
        while(ii.hasNext()){
          System.out.println(ii.next());     
        }
        

        
    }

}

  

    
@2298c1b965ab230058f460595aa52c5a@"
"r04921105","0","0.99","102512","@b3e9a22e0a5a0740e80d8dd21d523978@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
   //public Deque()                     // construct an empty deque
   //public boolean isEmpty();          // is the deque empty?
   //public int size()                  // return the number of items on the deque
   //public void addLast(Item item)     // insert the item at the end
   //public Item removeFirst()          // delete and return the item at the front
   //public Item removeLast()           // delete and return the item at the end
   //public Iterator<Item> iterator()   // return an iterator over items in order from front to end
   ///iterator implementation should support the operations next() and hasNext()

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack
    private Node debug;

    // helper linked list class
    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
        debug = new Node();
        debug.item = (Item) ""Empty stack"";
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        System.out.println(""Add First"");
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            System.out.println(""Message: First was equal to NULL."");
            test();
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++;
        test();  
    }
    
    public Item removeFirst(){
        System.out.println(""Remove First"");       
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        test();
        return item;
    }
    
    public void addLast(Item item){
        System.out.println(""add last"");        
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
        test();
    }
    
    public Item removeLast() {
        System.out.println(""remove last"");
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        test();
        return lastItem;
    }    
    
    /**
     * Return an iterator to the stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator()  { return new ListIterator();  }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        //change to private not
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

     public void test() {
         boolean empty = (first == null)? true : false;
         System.out.println(""Is Empty: "" + empty);
         System.out.println(""Stack count: "" +N);
         System.out.print(""Stack: First ~~~~> "");
         if (N >0){
             Iterator iter =  iterator();
             while(iter.hasNext() ){
                 System.out.print(iter.next());
                 System.out.print("" | "");
             }
         }
         if(last != null){
             System.out.print(last.item);
         }
         System.out.println("" <~~~~ Last"");           
    }
    
    public static void main(String[] args) {
        
        Deque deq = new Deque();
    
        
    }
    
}

@b3e9a22e0a5a0740e80d8dd21d523978@"
"b02611016","8","1.41","183792","@75951a0503d39f32054d4bcc4af9a835@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
       Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {String str=null;Item item;
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else{
                 item = current.item;
            current = current.next; 
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
         /*   Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             deque.addLast(data[4]);
              deque.addFirst(data[6]);
               deque.addFirst(data[7]);*/
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
          /*  System.out.println(deque.removeLast());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@75951a0503d39f32054d4bcc4af9a835@"
"r04921105","0","1.5","163952","@88d9e11c5beb4871e6e0c05112c8ae5a@import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.List;
//import java.util.ArrayList;
//import java.lang.NullPointerException;
//import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
   
    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack
    private Node debug;

    // helper linked list class
    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
        debug = new Node();
        debug.item = (Item) ""Empty stack"";
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        System.out.println(""Add First"");
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            System.out.println(""Message: First was equal to NULL."");
            //test();
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++;
        //test();  
    }
    
    public Item removeFirst(){
        System.out.println(""Remove First"");       
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        //test();
        return item;
    }
    
    public void addLast(Item item){
        System.out.println(""add last"");        
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
        //test();
    }
    
    public Item removeLast() {
        System.out.println(""remove last"");
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        //test();
        return lastItem;
    }    
    
    /**
     * Return an iterator to the stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator()  { return new ListIterator();  }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        //change to private not
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }
/*
     public void test() {
         boolean empty = (first == null)? true : false;
         System.out.println(""Is Empty: "" + empty);
         System.out.println(""Stack count: "" +N);
         System.out.print(""Stack: First ~~~~> "");
         if (N >0){
             Iterator iter =  iterator();
             while(iter.hasNext() ){
                 System.out.print(iter.next());
                 System.out.print("" | "");
             }
         }
         if(last != null){
             System.out.print(last.item);
         }
         System.out.println("" <~~~~ Last"");           
    }
    */
    public static void main(String[] args) {
        
        Deque deq = new Deque();
        deq.isEmpty();
        deq.addFirst(3);
        //deq.addLast(4);
        //deq.isEmpty();
        //deq.size();
        //deq.removeFirst();
        //deq.isEmpty();
        //deq.removeLast();
       // deq.isEmpty();
        
        
        
        
        
    }
    
}

@88d9e11c5beb4871e6e0c05112c8ae5a@"
"b03611033","0","0","0","@742913eec2e8d385582be3d39337b910@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private Node oldlast, oldfirst;

    private class Node {

        Item item;
        Node next;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            if (isEmpty()) {
                first = new Node();
                first.item = item;
                last = first;
            } else {
                first = new Node();
                first.item = item;
                first.next = oldfirst;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator();
    }

    private class ListIterator implements Iterable<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator<Item> iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }

    public static void main(String[] args) throws Exception {   // unit testing
        
        Deque deque=new Deque();
        deque.addFirst(""yyy"");
        deque.addLast(""fff"");
        deque.addLast(""sss"");
        String f =null;
        //deque.addFirst(f);
        
        StdOut.println(deque.size());
        StdOut.println(deque.removeFirst());

    }
}

@742913eec2e8d385582be3d39337b910@"
"b03611033","0","0","0","@b0360663dcf4b66dcd5be2c58ea68d78@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private Node oldlast, oldfirst;

    private class Node {

        Item item;
        Node next;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            if (isEmpty()) {
                first = new Node();
                first.item = item;
                last = first;
            } else {
                first = new Node();
                first.item = item;
                first.next = oldfirst;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = last.item;
            last = oldlast;
            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator();
    }

    private class ListIterator implements Iterable<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        
    }

    public static void main(String[] args) throws Exception {   // unit testing
        


    }
}

@b0360663dcf4b66dcd5be2c58ea68d78@"
"r04921105","0","0.96","101472","@3cfc0256729f244d5eff7d8250173c4c@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.List;
import java.util.ArrayList;
//import java.lang.NullPointerException;
//import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
   
    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack
    private Node debug;

    // helper linked list class
    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
        debug = new Node();
        debug.item = (Item) ""Empty stack"";
    }
    
    public int size(){
        System.out.print(""size=""+N);
        return N;
    }
    
    public boolean isEmpty(){
        boolean empty = (first == null)? true : false;
         System.out.println(""Is Empty: "" + empty);
        
        return first == null;
        
            
        
    }
    
    public void addFirst(Item item){
        System.out.println(""Add First"");
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            //System.out.println(""Message: First was equal to NULL."");
            test();
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++;
        test();  
    }
    
    public Item removeFirst(){
        System.out.println(""Remove First"");       
        if (isEmpty()){
            // new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        test();
        return item;
    }
    
    public void addLast(Item item){
        System.out.println(""add last"");        
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
        test();
    }
    
    public Item removeLast() {
        System.out.println(""remove last"");
        if (isEmpty()){
            new NoSuchElementException(""The Queue is empty you big dummy"");
            return debug.item;
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        test();
        return lastItem;
    }    
    
    /**
     * Return an iterator to the stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator()  { return new ListIterator();  }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator implements Iterator<Item> {
        //change to private not
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

     public void test() {
         boolean empty = (first == null)? true : false;
         //System.out.println(""Is Empty: "" + empty);
         //System.out.println(""Stack size: "" +N);
         System.out.print(""Stack: First > "");
         if (N >0){
             Iterator iter =  iterator();
             while(iter.hasNext() ){
                 System.out.print(iter.next());
                 System.out.print("" | "");
             }
         }
         if(last != null){
             System.out.print(last.item);
         }
         System.out.println("" < Last"");           
    }
    
    public static void main(String[] args) {
        
        Deque deq = new Deque();
        deq.iterator();
        //deq.size();
        //deq.isEmpty();
        deq.addFirst(3);
        //deq.addLast(4);
        //deq.isEmpty();
        //deq.addLast(5);
        //deq.isEmpty();
        //deq.size();
        //deq.removeFirst();
        //deq.removeFirst();
        //deq.isEmpty();
        //deq.removeLast();
        //deq.isEmpty();
        
        
        
        
        
    }
    
}

@3cfc0256729f244d5eff7d8250173c4c@"
"r04945021","10","0.138","177952","@506cc93927b018b24cad0d05c5405791@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//remove ans static
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
private Node<Item> first;
private Node<Item> last;
private int counter;

private class Node<Item>
{
    Item item;
    Node<Item> next;
    Node<Item> pre;
}
    public Deque(){
    first=null;
    last=null;
    counter=0;
    }// construct an empty deque

   public boolean isEmpty()
   {return first ==null;}
// is the deque empty?

   public int size()
   {
       return counter;
   }                     // return the number of items on the deque

    public void addFirst(Item item) {

        if (item == null) {
            throw new java.lang.NullPointerException();
        }
       else if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            first.next = null;
            first.pre = null;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new <Item>Node();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        counter++;
    }
// add the item to the front

   public void addLast(Item item){
       if(item==null) throw new java.lang.NullPointerException();
     else if(isEmpty()){
         last = new Node<Item>();
         last.item = item;
            last.next = null;
            last.pre = null;
          first=last;
          
      }
     else{
       Node<Item> oldlast =last;
       last = new <Item>Node();
       last.item=item;
       last.next=null;
       last.pre=oldlast;
       oldlast.next=last;
     }
           

       counter++;
   }// add the item to the end

   public Item removeFirst(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
       Item item=first.item;
       first=first.next;
       if (isEmpty()) last=null;
       counter--;
       return item;
               }// remove and return the item from the front

   public Item removeLast(){
       if(isEmpty()) throw new java.util.NoSuchElementException();
    Item item = last.item;
    if(first==last){
        first=null;
    }else{
    last.pre.next=null;
    last=last.pre;
    }
    counter--;
    return item;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){          
       return new ListIterator<Item>(first);      
       // return an iterator over items in order from front to end   
   }
   
   private class ListIterator<Item> implements Iterator<Item>
   {
            
       private Node<Item> current;
       public ListIterator(Node first) {
            current = first;
        }
   
       public boolean hasNext(){
           return current !=null;
       }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public Item next()
       {
           if(!hasNext()) throw new java.util.NoSuchElementException();
           
           Item item = current.item;
           current = current.next;          
           return item;
       }
   }
  
      //static  
        
    public static void main(String[] args) throws Exception {
        Deque<Integer> de=new <Integer>Deque();
       
        int a=5;
        de.addFirst(5);
       de.addLast(6);
       de.addLast(4);
        de.addFirst(3);
//                while(ii.hasNext()){
//          System.out.println(ii.next());     
//        }
       
       de.removeLast();
         de.removeLast();
         de.removeLast();
         de.removeFirst();
         de.addFirst(5);
       de.addLast(6);
       de.addLast(4);
        de.addFirst(3);
        de.removeFirst();
      Iterator ii=de.iterator();
        
        while(ii.hasNext()){
          System.out.println(ii.next());     
        }
        

        
    }

}

  

    
@506cc93927b018b24cad0d05c5405791@"
"r04921105","8","1.42","185872","@ac5332e9b0bc2806143c2464e8f28130@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
//import java.lang.NullPointerException;
//import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
        private List<Item> list;

    /**
     * construct an empty deque
     */
    public Deque() {
        list = new LinkedList<Item>();
    }

    /**
     * is the deque empty?
     * @return
     */
    public boolean isEmpty() {
        return list.isEmpty();
    }

    /**
     * return the number of items on the deque
     * @return
     */
    public int size() {
        return list.size();
    }

    /**
     * insert the item at the front
     * @param item
     */
    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(0, item);
    }

    /**
     * insert the item at the end
     * @param item
     */
    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(item);
    }

    /**
     * delete and return the item at the front
     * @return
     */
    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(0);
    }

    /**
     * delete and return the item at the end
     * @return
     */
    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(list.size() - 1);
    }

    private class DequeIterator<E> implements Iterator<E> {
        public boolean hasNext() {
            return size() > 0;
        }
        public E next() {
            if (isEmpty()) {
                throw new java.util.NoSuchElementException();
            }
            return (E) removeFirst();
        }
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }
    }

    /**
     * return an iterator over items in order from front to end
     * @return
     */
    public Iterator<Item> iterator() {
        return this.new DequeIterator<Item>();
    }
   
    
    public static void main(String[] args) {
        
        Deque<Integer> q = new Deque<Integer>();
                             
        for (int i = 0; i < 5;i++) {
            q.addFirst(i);
        }
        q.addLast(5); 
        
        //Iterator<Integer> iterator = q.iterator();
         //while (iterator != null) {
         //    System.out.printf(""%d,"", iterator);
        // }
         //System.out.printf(""\n"", args);
        
        
        
        
        
    }
    
}

@ac5332e9b0bc2806143c2464e8f28130@"
"b02611023","5","1.43","184608","@99252b0913093c1c5f0dfa4f3a374fff@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size()==0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        temp.pop();
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while(!temp.isEmpty()){
                    s_last.push(temp.pop());
                }
               Item item = s_last.pop();
                N--;
                while(!s_last.isEmpty()){
                    temp.push(s_last.pop());
                }
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.addFirst(f);
//        d.removeFirst();
//        d.removeFirst();
//        d.removeLast();
//        d.removeFirst();
//        System.out.println(d.removeLast());
//        
//    }
}

@99252b0913093c1c5f0dfa4f3a374fff@"
"r04522616","4","0.47","98528","@96a9db68e4be41f0a23f1010e29fc9ce@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) first = last;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        first.pre = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        last.next = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@96a9db68e4be41f0a23f1010e29fc9ce@"
"r04921105","8","1.45","180192","@b1c4e282bb0063532aa49b93bb74930a@import java.util.Iterator;
//import java.util.NoSuchElementException;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
//import java.lang.NullPointerException;
//import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
        private List<Item> list;

    public Deque() {
        list = new ArrayList<Item>();
    }

    /**
     * is the deque empty?
     * @return
     */
    public boolean isEmpty() {
        return list.isEmpty();
    }

    /**
     * return the number of items on the deque
     * @return
     */
    public int size() {
        return list.size();
    }

    /**
     * insert the item at the front
     * @param item
     */
    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(0, item);
    }

    /**
     * insert the item at the end
     * @param item
     */
    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(item);
    }

    /**
     * delete and return the item at the front
     * @return
     */
    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(0);
    }

    /**
     * delete and return the item at the end
     * @return
     */
    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(list.size() - 1);
    }

    private class DequeIterator<E> implements Iterator<E> {
        public boolean hasNext() {
            return size() > 0;
        }
        public E next() {
            if (isEmpty()) {
                throw new java.util.NoSuchElementException();
            }
            return (E) removeFirst();
        }
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }
    }

    /**
     * return an iterator over items in order from front to end
     * @return
     */
    public Iterator<Item> iterator() {
        return this.new DequeIterator<Item>();
    }
   
    
    public static void main(String[] args) {
        
        Deque<Integer> q = new Deque<Integer>();
                             
        for (int i = 0; i < 5;i++) {
            q.addFirst(i);
        }
        q.addLast(5); 
        
        //Iterator<Integer> iterator = q.iterator();
         //while (iterator != null) {
         //    System.out.printf(""%d,"", iterator);
        // }
         //System.out.printf(""\n"", args);
        
        
        
        
        
    }
    
}

@b1c4e282bb0063532aa49b93bb74930a@"
"r04921105","8","1.46","172192","@b1c4e282bb0063532aa49b93bb74930a@import java.util.Iterator;
//import java.util.NoSuchElementException;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
//import java.lang.NullPointerException;
//import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {
        private List<Item> list;

    public Deque() {
        list = new ArrayList<Item>();
    }

    /**
     * is the deque empty?
     * @return
     */
    public boolean isEmpty() {
        return list.isEmpty();
    }

    /**
     * return the number of items on the deque
     * @return
     */
    public int size() {
        return list.size();
    }

    /**
     * insert the item at the front
     * @param item
     */
    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(0, item);
    }

    /**
     * insert the item at the end
     * @param item
     */
    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(item);
    }

    /**
     * delete and return the item at the front
     * @return
     */
    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(0);
    }

    /**
     * delete and return the item at the end
     * @return
     */
    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(list.size() - 1);
    }

    private class DequeIterator<E> implements Iterator<E> {
        public boolean hasNext() {
            return size() > 0;
        }
        public E next() {
            if (isEmpty()) {
                throw new java.util.NoSuchElementException();
            }
            return (E) removeFirst();
        }
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }
    }

    /**
     * return an iterator over items in order from front to end
     * @return
     */
    public Iterator<Item> iterator() {
        return this.new DequeIterator<Item>();
    }
   
    
    public static void main(String[] args) {
        
        Deque<Integer> q = new Deque<Integer>();
                             
        for (int i = 0; i < 5;i++) {
            q.addFirst(i);
        }
        q.addLast(5); 
        
        //Iterator<Integer> iterator = q.iterator();
         //while (iterator != null) {
         //    System.out.printf(""%d,"", iterator);
        // }
         //System.out.printf(""\n"", args);
        
        
        
        
        
    }
    
}

@b1c4e282bb0063532aa49b93bb74930a@"
"b02611023","7","1.47","176688","@55e7afb99d68f778ba649ea6a824c9a6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size()==0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        //temp.pop();
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while(!temp.isEmpty()){
                    s_last.push(temp.pop());
                }
               Item item = s_last.pop();
                N--;
                while(!s_last.isEmpty()){
                    temp.push(s_last.pop());
                }
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""0"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeLast());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        //d.removeFirst();
//        d.addLast(""7"");
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//    }
}

@55e7afb99d68f778ba649ea6a824c9a6@"
"r04522616","5","0.6","102368","@6395e8e28461fddd84b7593aa9a3e118@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@6395e8e28461fddd84b7593aa9a3e118@"
"r04522616","10","0.136","181520","@b4483c82a5881be5c642110e344692d3@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
//    public Item peek() {
//        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
//        return first.item;
//    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
//    public String toString() {
//        StringBuilder s = new StringBuilder();
//        for (Item item : this)
//            s.append(item + "" "");
//        return s.toString();
//    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@b4483c82a5881be5c642110e344692d3@"
"r04522627","5","0.58","98496","@67fcce986068b6e851048ce28f392ae3@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
//    public Item peek() {
//        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
//        return first.item;
//    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
//    public String toString() {
//        StringBuilder s = new StringBuilder();
//        for (Item item : this)
//            s.append(item + "" "");
//        return s.toString();
//    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@67fcce986068b6e851048ce28f392ae3@"
"r04522627","10","0.142","177568","@34402c614d7b54c71ebd05aef4ce9e69@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
//    public Item peek() {
//        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
//        return first.item;
//    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
//    public String toString() {
//        StringBuilder s = new StringBuilder();
//        for (Item item : this)
//            s.append(item + "" "");
//        return s.toString();
//    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@34402c614d7b54c71ebd05aef4ce9e69@"
"r04921105","3","0.36","101568","@a23eca0c8c5ef34b06841d7894f56ac9@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int n;
    private Node<Item> first;
    private Node<Item> last;
    
   private class Node<item>{
            private Item item;
            Node<Item> pre;
            Node<Item> next;
    }
    public Deque(){
            first= new Node<Item>();
            last=new Node<Item>();
            first.item=null;
            first.pre=null;
            first.next=last;
            last.item=null;
            last.pre=first;
            last.next=null;
            n=0;      
    }
    public boolean isEmpty(){
        return (n==0);
    }
    public int size(){
        return n;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.pre = first;
        first.next.pre = firstItem;
        first.next = firstItem;
        n++;
    }
    public void addLast(Item item){
        if(item ==null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item=item;
        lastItem.next=last;
        lastItem.pre=last.pre;
        last.next.pre=lastItem;
        last.next=lastItem;
        n++;          
    }
    
    public Item removeFirst(){
    if(isEmpty()){
        throw new NoSuchElementException();
        }
        Node<Item> firstItem = first.next;
        firstItem.next.pre = first;
        first.next = firstItem.next;
        n--;
        return firstItem.item;
    }       
    
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.pre;
        lastItem.pre.next = last;
        last.pre = lastItem.pre;
        n--;
        return lastItem.item;
    }  
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }
    
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current.next.item != null;}
        public void remove()      { throw new UnsupportedOperationException(); }
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();{
            current = (Node<Item>) current.next; 
            return (Item) current.item;}
        }
    }   
    public static void main(String[] args) {

    }  
    
}

@a23eca0c8c5ef34b06841d7894f56ac9@"
"r04522627","0","0","0","@714933b6abb705c4ee6626793a0a081a@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return (first == null  && last == null);
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
//    public Item peek() {
//        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
//        return first.item;
//    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
//    public String toString() {
//        StringBuilder s = new StringBuilder();
//        for (Item item : this)
//            s.append(item + "" "");
//        return s.toString();
//    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@714933b6abb705c4ee6626793a0a081a@"
"r04921105","10","0.142","180096","@4a4dfdd22f8bf3c3dba15ba642383262@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.previous = null;
        first.next = last;
        last.item = null;
        last.previous = first;
        last.next = null;
        N = 0;        
    }

   public boolean isEmpty(){
        return (N == 0);
    }                 
         
   public int size(){
        return N;     
    }                      

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.previous = last.previous;
        last.previous.next = lastItem;
        last.previous = lastItem;
        N++;
    }       

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.previous = first;
        first.next.previous = firstItem;
        first.next = firstItem;
        N++;
    }             

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.previous = first;
        first.next = firstItem.next;
        N--;
        return firstItem.item;
    }               

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.previous;
        lastItem.previous.next = last;
        last.previous = lastItem.previous;
        N--;
        return lastItem.item;
    }                 

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next.item != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
 
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {

    }  

}


@4a4dfdd22f8bf3c3dba15ba642383262@"
"r04522627","10","0.141","170912","@c55ea07abe9ba8a216f3bf2909e951af@
import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return (first == null  || last == null);
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
//    public Item peek() {
//        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
//        return first.item;
//    }

    
    public void addFirst(Item item)          // add the item to the front
    {
        if(item == null)  throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
    public void addLast(Item item)           // add the item to the end
    {   
        if(item == null)  throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst()                // remove and return the item from the front
    {   
        
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           // to avoid loitering
        else first.pre = null;
        return item;
    
    }
    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        
        N--;
        if (isEmpty()) 
        {
            first = null;
            last = null;
        }           
        else last.next = null;
        return item;
    }
            /**
     * Adds the item to this queue.
     * @param item the item to add
     */
   /* public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }*/

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    /*public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }*/

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
//    public String toString() {
//        StringBuilder s = new StringBuilder();
//        for (Item item : this)
//            s.append(item + "" "");
//        return s.toString();
//    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    @Override
    public Iterator<Item> iterator()  {
        return new ListIterator<>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext()  { return current != null;                     }
        @Override
        public void remove()      { throw new UnsupportedOperationException();  }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
//        Deque<String> q = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) q.enqueue(item);
//            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }
}

@c55ea07abe9ba8a216f3bf2909e951af@"
"r04921105","8","1.44","175632","@221077dfc69eb0b5a4cb5f1dab91d04d@import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;

public class Deque<Item> implements Iterable<Item> {
        private List<Item> list;

    public Deque() {
        list = new LinkedList<Item>();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public int size() {
        return list.size();
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(0, item);
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        list.add(item);
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(0);
    }


    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        return (Item) list.remove(list.size() - 1);
    }
    
    public Iterator<Item> iterator() {
        return this.new DequeIterator<Item>();
    }
    
    private class DequeIterator<Item> implements Iterator<Item> {
        public boolean hasNext() {
            return size() > 0;
        }
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            return (Item) removeFirst();
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }


       
    
    public static void main(String[] args) {
        
       
       
    }
    
}
@221077dfc69eb0b5a4cb5f1dab91d04d@"
"r04921105","1","0.24","102416","@c3db8e70a3ff2031b3309d09412f145c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int n; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.pre = null;
        first.next = last;
        last.item = null;
        last.pre = first;
        last.next = null;
        n = 0;        
    }

   public boolean isEmpty(){
        return (n == 0);
    }                 
         
   public int size(){
        return n;     
    }                      

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.pre = last.pre;
        last.pre.next = lastItem;
        last.pre = lastItem;
        n++;
    }       

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.pre = first;
        first.next.pre = firstItem;
        first.next = firstItem;
        n++;
    }             

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.pre = first;
        first.next = firstItem.next;
        n--;
        return firstItem.item;
    }               

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.pre;
        lastItem.pre.next = last;
        last.pre = lastItem.pre;
        n--;
        return lastItem.item;
    }                 

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next.item != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!isEmpty()) throw new NoSuchElementException();
 
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {
        
    }  

}



@c3db8e70a3ff2031b3309d09412f145c@"
"r04921105","10","0.14","180272","@4645f3e1415e4f8a4fbe1844a5dc87e4@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int n; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.pre = null;
        first.next = last;
        last.item = null;
        last.pre = first;
        last.next = null;
        n = 0;        
    }

   public boolean isEmpty(){
        return (n == 0);
    }                 
         
   public int size(){
        return n;     
    }                      

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.pre = last.pre;
        last.pre.next = lastItem;
        last.pre = lastItem;
        n++;
    }       

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.pre = first;
        first.next.pre = firstItem;
        first.next = firstItem;
        n++;
    }             

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.pre = first;
        first.next = firstItem.next;
        n--;
        return firstItem.item;
    }               

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.pre;
        lastItem.pre.next = last;
        last.pre = lastItem.pre;
        n--;
        return lastItem.item;
    }                 

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next.item != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
 
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {
        
    }  

}



@4645f3e1415e4f8a4fbe1844a5dc87e4@"
"r04921105","3","0.72","102432","@422bd6bebebdff0eb53a20834beb976e@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int n; 
    private Node<Item> first; 
    private Node<Item> last;
    
    private class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }
    public Deque() {
        first = new Node<Item>();
        last  = new Node<Item>();
        first.item = null;
        first.pre = null;
        first.next = last;
        last.item = null;
        last.pre = first;
        last.next = null;
        n = 0;        
    }

   public boolean isEmpty(){
        return (n == 0);
    }                 
         
   public int size(){
        return n;     
    }                      

   public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> lastItem = new Node<Item>();
        lastItem.item = item;
        lastItem.next = last;
        lastItem.pre = last.pre;
        //last.pre.next = lastItem;
        last.pre = lastItem;
        n++;
    }       

   public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> firstItem = new Node<Item>();
        firstItem.item = item;
        firstItem.next = first.next;
        firstItem.pre = first;
       // first.next.pre = firstItem;
        first.next = firstItem;
        n++;
    }             

   public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> firstItem = first.next;
        firstItem.next.pre = first;
        first.next = firstItem.next;
        n--;
        return firstItem.item;
    }               

   public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Node<Item> lastItem = last.pre;
        lastItem.pre.next = last;
        last.pre = lastItem.pre;
        n--;
        return lastItem.item;
    }                 

   public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }         
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current.next.item != null;                     }
        public void remove()      { throw new UnsupportedOperationException(); }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
 
            current = current.next; 
            return current.item;
        }
    }   
    
   public static void main(String[] args) {
        
    }  

}



@422bd6bebebdff0eb53a20834beb976e@"
"r04921105","0","1.31","170384","@87e054bfc1a7e6d97eaa2f2c2c84c9fa@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
  

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack

    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++; 
    }
    
    public Item removeFirst(){
       
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        return item;
    }
    
    public void addLast(Item item){  
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
    }
    
    public Item removeLast() {
        
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        return lastItem;
    }    
    

    public Iterator<Item> iterator()  { return new ListIterator();  }

    private class ListIterator implements Iterator<Item> {
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

    
    
    public static void main(String[] args) {
       
    }
}
@87e054bfc1a7e6d97eaa2f2c2c84c9fa@"
"r04921105","0","1.29","185328","@87e054bfc1a7e6d97eaa2f2c2c84c9fa@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
  

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack

    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        N = 0;
        first = null;
        last = null;
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    
    public void addFirst(Item item){
        
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++; 
    }
    
    public Item removeFirst(){
       
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        return item;
    }
    
    public void addLast(Item item){  
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
    }
    
    public Item removeLast() {
        
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        return lastItem;
    }    
    

    public Iterator<Item> iterator()  { return new ListIterator();  }

    private class ListIterator implements Iterator<Item> {
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

    
    
    public static void main(String[] args) {
       
    }
}
@87e054bfc1a7e6d97eaa2f2c2c84c9fa@"
"r04921105","0","1.39","182960","@f14d9f8497c24d431ea5df648965ff56@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
  

    private int N;          // size of the stack
    private Node first;     // Position 0 of stack
    private Node last;      // Position N-1 of Stack

    private class Node {
        private Item item;
        private Node next = null;
        private Node previous = null;
    }
    
    public Deque(){
        first = new Node();
        last  = new Node();
        first.item = null;
        first.previous = null;
        first.next = last;
        last.item = null;
        last.previous = first;
        last.next = null;
        N = 0; 
    }
    
    public int size(){
        return N;
    }
    
    public boolean isEmpty(){
        return N == 0;
    }
    
    public void addFirst(Item item){
        
        if(first == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        
        Node oldFirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        first.previous = null;
        oldFirst.previous = first;
        N++; 
    }
    
    public Item removeFirst(){
       
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item item =first.item;
        if (first.next != null){
            first = first.next;
            first.previous = null;
        } else {
            first = null;
            last = null;
        }
        N--;
        return item;
    }
    
    public void addLast(Item item){  
        if(first == null || last == null) {
            first = new Node();
            first.item = item;
            last = first;
            N++;
            return;
        }
        Node newLast = new Node();
        newLast.item = item;
        newLast.previous = last;
        last.next = newLast;
        last = newLast;
        last.next = null;
        N++;
    }
    
    public Item removeLast() {
        
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item lastItem = last.item;
        if(last.previous != null && first.next != null){
            last = last.previous;
            last.next = null;
        } else{
            last = null;
            first = null;
        }
        N--;
        return lastItem;
    }    
    

    public Iterator<Item> iterator()  { return new ListIterator();  }

    private class ListIterator implements Iterator<Item> {
        public Node current = first;
        public boolean hasNext()  { return current.next != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }

    
    
    public static void main(String[] args) {
       
    }
}
@f14d9f8497c24d431ea5df648965ff56@"
"r04921028","0","0","0","@d49fc83a1c31c7784c98a2b019c6d5f0@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;
public class Deque<Item>  implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last;
        
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
   }
}

@d49fc83a1c31c7784c98a2b019c6d5f0@"
"r04921028","0","1.29","185328","@b56ed53026dad29e785e89adde437127@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;

public class Deque implements Iterable
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last;
        
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
   }
}

@b56ed53026dad29e785e89adde437127@"
"r04921028","0","0","0","@e389d2cf85ee1dd5cb0aec4d405be418@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last; 
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@e389d2cf85ee1dd5cb0aec4d405be418@"
"r04921028","0","0","0","@ac095f3b71f3a9472c5e4a9e64a0bd4e@public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last; 
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
//            Deque <String> s = new Deque<String>();
//            s.addFirst(""2"");
//            s.addFirst(""1"");
//            s.addLast(""3"");
//            s.addLast(""4"");
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
   }
}

@ac095f3b71f3a9472c5e4a9e64a0bd4e@"
"r04921028","0","0","0","@b8fa1f04e3800c51a47b26fd57b12b78@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last; 
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
//            Deque <String> s = new Deque<String>();
//            s.addFirst(""2"");
//            s.addFirst(""1"");
//            s.addLast(""3"");
//            s.addLast(""4"");
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
   }
}

@b8fa1f04e3800c51a47b26fd57b12b78@"
"r04921028","0","0","0","@bebd750461b97a232bb8ccc1c676f4c1@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private class Node {
        private Item item;
        private Node next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node oldlast = last; 
        last = new Deque.Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node current;

        public ListIterator(Deque.Node first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = (Item) current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@bebd750461b97a232bb8ccc1c676f4c1@"
"r04921028","0","0","0","@0f0448238d363235f0a0543f27877e60@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private class Node {
         Item item;
         Node next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node oldlast = last; 
        last = new Deque.Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator iterator()         // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator<Item> implements Iterator<Item> 
    {
        private Deque.Node current;

        public ListIterator(Deque.Node first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = (Item) current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@0f0448238d363235f0a0543f27877e60@"
"r04921028","0","0","0","@9344c8cde30f6cb71e4f3e98e1c4748a@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private class Node {
        private Item item;
        private Node next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node oldlast = last; 
        last = new Deque.Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator<Item> iterator()       // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator implements Iterator<Item> 
    {
        private Deque.Node current;

        public ListIterator(Deque.Node first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@9344c8cde30f6cb71e4f3e98e1c4748a@"
"r04921028","0","0","0","@bdb043f9b1b7dff4b56a56cc8f5ebeb7@import java.util.Iterator;


public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private class Node {
        private Item item;
        private Node next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node oldlast = last; 
        last = new Deque.Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator<Item> iterator()       // return an iterator over items in order from front to end
    {
        return new ListIterator();
    }
    private class ListIterator implements Iterator<Item> 
    {
        private Deque.Node current;

        public ListIterator(Deque.Node first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@bdb043f9b1b7dff4b56a56cc8f5ebeb7@"
"r04921028","5","1.5","176432","@e19154de29202b139db049d21bd203f9@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;


public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue
    private Node temp;     // pre end of queue
    
   private class Node {
         Item item;
         Node next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node oldlast = last; 
        last = new Deque.Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node current;

        public ListIterator(Deque.Node first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = (Item) current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}

@e19154de29202b139db049d21bd203f9@"
"r04921028","5","1.58","182032","@f757c2e6ca3839a86c6a6e1fd43c7417@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last; 
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       temp = null;
       N--;
       return item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
   }
}
@f757c2e6ca3839a86c6a6e1fd43c7417@"
"b99611017","3","0.36","102384","@f5783ae7cbc48810aaad94ef628c99fe@
import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldFirst;
        N++;
    }

    public void addLast(Item item) {
        Node<Item> oldLast = last;
        last = new Node<>();
        last.item = item;
        oldLast.next = last;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        if (N > 1) {
            Node<Item> oldLast = null;
            oldLast = last;

        } else {
            last = null;
        }
        return item;
    }
    
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

   

}

@f5783ae7cbc48810aaad94ef628c99fe@"
"b02611023","6","1.47","178496","@77e5bb3c0f946775c28715c5fd57efc1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return (first == null)&&(last == null);
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@77e5bb3c0f946775c28715c5fd57efc1@"
"b02611023","7","1.46","178704","@b9c8d5c901d840eec138c0c410dc3979@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@b9c8d5c901d840eec138c0c410dc3979@"
"b02611023","7","1.48","170640","@e7ae04879426c328118ba0b5097cdc64@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return size()==0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@e7ae04879426c328118ba0b5097cdc64@"
"b02611023","6","0.85","102640","@849385f1d842bc596bbc00bd978a64b6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (size()==0) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@849385f1d842bc596bbc00bd978a64b6@"
"b02611023","6","0.85","102656","@e3da3d21c6463b9a58b3c1745b8f0fe5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (N==0) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@e3da3d21c6463b9a58b3c1745b8f0fe5@"
"b02611023","1","0.27","99440","@759be3f68084e4b4f631cc6146d502b3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    public int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return N != 0;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String a = null;
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(b);
//        d.addLast(c);
//       d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.size());
//    }
}

@759be3f68084e4b4f631cc6146d502b3@"
"b03611041","7","1.4","177280","@86c94cdb522eecea01af481f9eb6a51a@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first=first.next;
        N--;
        if(N==1)first=last;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last=last.prev;
        N--;       
        if(N==1)first=last;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@86c94cdb522eecea01af481f9eb6a51a@"
"b03611041","7","0.83","102464","@f9969098a9ee9820c2ae01e68dfdf6ac@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first=first.next;
        first.prev=null;
        N--;
        if(N==1)last=first;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last=last.prev;
        last.next=null;
        N--;
        if(N==1)first=last;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@f9969098a9ee9820c2ae01e68dfdf6ac@"
"b03611041","7","1.48","172880","@562bd10ad5b94520ac91a206c5e51be4@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first=first.next;
//        first.prev=null;
        N--;
        if(N==1)last=first;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last=last.prev;
//        last.next=null;
        N--;
        if(N==1)first=last;
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@562bd10ad5b94520ac91a206c5e51be4@"
"b03611041","8","1.38","183360","@53c2ff17881d01e30718c271fa171923@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first=first.next;
//        first.prev=null;
        N--;
        if(N==1)last=first;
        if(N==0){
            first=null;
            last=null;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last=last.prev;
//        last.next=null;
        N--;
        if(N==1)first=last;
        if(N==0){
            first=null;
            last=null;
        }
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@53c2ff17881d01e30718c271fa171923@"
"b03704074","3","0.83","102384","@a1173bb3de1f45975ede5288ee90a3ac@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;

private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;
    }// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(first == null && last == null){
        first = new Node();
        last = new Node();
        first.item = item;
        last.item = item;
        count++;   }
    else {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        oldfirst.pre = first;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(first == null && last == null){
        first = new Node();
        last = new Node();
        first.item = item;
        last.item = item;
        count++;   }
    else {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        oldlast.next = last;
        
        count++;
    }
    
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque<Integer> deque = new Deque();
       //deque.addLast(1);
       //deque.addFirst(14);
       deque.addFirst(11);
       deque.addLast(78);
       //deque.addFirst(55);
       deque.addLast(8);
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
       
    }
    
}

@a1173bb3de1f45975ede5288ee90a3ac@"
"b03704074","4","0.83","102464","@de2d2517ec2230c328dc44080e4a95cf@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else{
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else{
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       //deque.addLast(1);
       //deque.addFirst(14);
       deque.addFirst(11);
       deque.addLast(78);
       //deque.addFirst(55);
       deque.addLast(8);
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@de2d2517ec2230c328dc44080e4a95cf@"
"b02611016","2","0.24","102528","@ae25c5a2b3b92ca07defdc067d5999b8@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {String str=null;Item item;
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else{current = current.next; 
                 item = current.item;
            //current = current.next; 
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
               System.out.println(deque.removeFirst());
             Iterator a=  deque.iterator();
               System.out.println(a);
               System.out.println(a.next());
           // System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
          /*  System.out.println(deque.removeLast());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@ae25c5a2b3b92ca07defdc067d5999b8@"
"b02611016","2","0.22","102416","@972e33b5639d6b8fe591a92d12cea2d7@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else{ current = current.next; 
                 Item item = current.item;
            //current = current.next; 
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
               System.out.println(deque.removeFirst());
             Iterator a=  deque.iterator();
               System.out.println(a);
               //System.out.println(a.next());
              // System.out.println(a.next());
            
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
               System.out.println(a.next());
                 System.out.println(a.next());
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@972e33b5639d6b8fe591a92d12cea2d7@"
"b03611041","7","0.8","102384","@b23058b07246209746fc5cbc4546d3fc@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldfirst=first;
        first=new Node<Item>();
        first.item=item;
        first.next=oldfirst;
        if(oldfirst!=null)oldfirst.prev=first;
        N++;
        if(N==1)last=first;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.prev=oldlast;
        if(oldlast!=null)oldlast.next=last;
        N++;
        if(N==1)first=last;
    }

    public Item removeFirst() {
        if(N==0)throw new NoSuchElementException();
        Item item=first.item;
        first.next.prev=null;
        first=first.next;
        N--;
        if(N==1)last=first;
        if(N==0){
            first=null;
            last=null;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.prev.next=null;
        last=last.prev;
        N--;
        if(N==1)first=last;
        if(N==0){
            first=null;
            last=null;
        }
        return item;
    }

    public boolean isEmpty() {
        if (N == 0) return true;
        else return false;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@b23058b07246209746fc5cbc4546d3fc@"
"b03611041","4","0.82","102112","@597c25593fa616de23985dc2306b2515@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        if(isEmpty()){
            first=last;
        }else {
            last.prev=oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if (N == 1) last = first;
        else if (N == 0) {
            first = null;
            last = null;
        }else
            first = first.next;
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        N--;
        if(N==1)first=last;
        else if(N==0){
            first=null;
            last=null;
        }else
            last=last.prev;
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@597c25593fa616de23985dc2306b2515@"
"b03704074","3","1.19","173312","@742a9ca27a45465a96211ab88f413394@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        last = new Node();
        last.item = item;
        first = new Node();
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        last = new Node();
        last.item = item;
        first = new Node();
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       deque.addLast(1);
       deque.addFirst(2);
       deque.addFirst(3);
       deque.addLast(4);
       deque.addFirst(5);
       deque.addLast(6);
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@742a9ca27a45465a96211ab88f413394@"
"b02611016","8","0.96","102448","@fe557dbda166c7aea3373f4665f8cf7c@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
    
       //first=check;
           if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else if(count==0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
            current = current.next; 
            
             count=count-1; return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
            
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                 Iterator a=  deque.iterator();
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@fe557dbda166c7aea3373f4665f8cf7c@"
"b02611016","0","0.82","102112","@685e77378e2a3ab845cecce64e69ae75@ System.out.println(a.next());
@685e77378e2a3ab845cecce64e69ae75@"
"b02611016","7","1.41","178928","@ca13321734ae75eb4fd00833dcf10a54@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
       // if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
      // if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
           // else if(count==0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
               current = current.next;  
             count=count-1;
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
                 Iterator a=  deque.iterator();
                  System.out.println(a.next());
                   System.out.println(a.next());
                    System.out.println(a.next());
                     System.out.println(a.next()); 
                     System.out.println(a.next());
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
             //Iterator a=  deque.iterator();
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@ca13321734ae75eb4fd00833dcf10a54@"
"b02611016","7","0.83","102352","@16b0ebd84b745533e5c5a503b7861311@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
       // if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
      // if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else if(count==0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
               current = current.next;  
             count=count-1;
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
                 Iterator a=  deque.iterator();
                  System.out.println(a.next());
                   System.out.println(a.next());
                    System.out.println(a.next());
                     System.out.println(a.next()); 
                     System.out.println(a.next());
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
             //Iterator a=  deque.iterator();
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@16b0ebd84b745533e5c5a503b7861311@"
"b02611016","7","0.83","102448","@a7284e175ced0fe22dbe3ca18adf20bb@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
       // if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
      // if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else if(count<0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
               current = current.next;  
             count=count-1;
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
                 Iterator a=  deque.iterator();
                  System.out.println(a.next());
                   System.out.println(a.next());
                    System.out.println(a.next());
                     System.out.println(a.next()); 
                     System.out.println(a.next());
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
             //Iterator a=  deque.iterator();
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@a7284e175ced0fe22dbe3ca18adf20bb@"
"b02611016","7","0.82","102368","@a7284e175ced0fe22dbe3ca18adf20bb@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
       // if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
      // if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
            else if(count<0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
               current = current.next;  
             count=count-1;
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
                 Iterator a=  deque.iterator();
                  System.out.println(a.next());
                   System.out.println(a.next());
                    System.out.println(a.next());
                     System.out.println(a.next()); 
                     System.out.println(a.next());
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
             //Iterator a=  deque.iterator();
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@a7284e175ced0fe22dbe3ca18adf20bb@"
"b02611016","10","0.139","183056","@4fb44c3a3e24c8a790824ba8a2cce273@
import java.util.Iterator;
import java.util.NoSuchElementException;
//import java.util.InputMismatchException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Lab304
 */
public class Deque<Item> implements Iterable<Item> {

     private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    
    
     private static class Node<Item> {
        private Item item;
        private Node<Item> next;
          private Node<Item> pre;
    }
    public Deque()                           // construct an empty deque
    {first = null;
    last  = null;
        N = 0;}
   
    public boolean isEmpty()                 // is the deque empty?
   {return first == null;}
      public boolean isEmpty1()                 // is the deque empty?
   {return last == null;}
   public int size()                        // return the number of items on the deque
   { return N;}
   
    
   public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public void addFirst(Item item)          // add the item to the front
   { if(item==null){throw new NullPointerException();}
   /*if(first==null&&last==null){
        last=new Node<Item>();
        last.item = item;}*/
       Node<Item> oldfirst = first;
      // Node<Item>oldlast=last;
        //last = new Node<Item>();
        first = new Node<Item>();
        first.item = item;
        //last.item = item;
        first.next = oldfirst;
         if (isEmpty1()) last = first;
         else oldfirst.pre=first;
        //oldlast.next=last;
        N++;}
   
   public void addLast(Item item)           // add the item to the end
   {if(item==null){throw new NullPointerException();}
     Node<Item> oldlast = last;
       //Node<Item> oldfirst = first;
        last = new Node<Item>();
        //first=new Node<Item>();
        last.item = item;
        last.pre=oldlast;
        //first.item=item;
        if (isEmpty()) first = last;
        else  oldlast.next =last ;
        N++;}
   
   public Item removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        //last=last.next;
        N--;
        if(N==0){first=null;last=null;}
        return item; }
   
   public Item removeLast()                 // remove and return the item from the end
   { if (isEmpty1()) throw new NoSuchElementException();
        Item item = last.item;
       // (last.pre).next=null;
        last = last.pre;
        N--;
       if(N==0){first=null;last=null;}
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }
    
     
   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
   { return new ListIterator();  }
   
    private class ListIterator implements Iterator<Item> {
        private Node<Item> current=first;
        int count=N;
       // public ListIterator(Node<Item> first) { }
//        current = first; 
        public boolean hasNext()  { return current != null;                     }
        
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            
            if (!hasNext()) {throw new NoSuchElementException();}
           // else if(count<0) {throw new NoSuchElementException();}
            else{ //current = current.next; 
                 Item item = current.item;
               current = current.next;  
             count=count-1;
             if(count==0){current=null;}
             return item;
           // System.out.println(item);
        }
            
            
        //return null ;
        
    }
    }
   
           /**
     * @param args the command line arguments
     */
           
    public static void main(String[] args) {
            Deque deque = new Deque() ; 
            String test;
            test=""( ( ( 1 + ( 12 * 5 ) ) - ( 3 * 4 ) ) + ( 4 / 5 ) )"";
            String[]data=test.split("" "");
            
            deque.addLast(data[3]);
             //System.out.println(deque.iterator().next());
             deque.addLast(data[4]);
                deque.addFirst(data[6]);
               deque.addFirst(data[7]);
                
               System.out.println(deque.removeFirst());
        
               //System.out.println(a.next());
              // System.out.println(a.next());
             //Iterator a=  deque.iterator();
            System.out.println(deque.removeFirst());
           // deque.addLast(data[3]);
           
            System.out.println(deque.removeLast());
                 Iterator a=  deque.iterator();
           
               System.out.println(a);
            Iterator b=deque.iterator();
      
            //   System.out.println(deque.iterator().next());
             //  System.out.println(deque.iterator());
             System.out.println(deque.removeFirst());
             
               System.out.println(a.next());
                 System.out.println(a.next());
                    System.out.println(a.next());
                           
         /*      System.out.println(deque.iterator().next());
               System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());
                 System.out.println(deque.iterator().next());
                 System.out.println(deque.iterator());
            System.out.println(deque.removeFirst());     */
          //   deque.addLast(data[3]);
           //      System.out.println(deque.iterator().next());
        //    System.out.println(deque.removeLast());   
                  //    System.out.println(deque.removeLast());  
           //    System.out.println(deque.iterator());
           
             //System.out.println(deque.removeFirst());
            // System.out.println(deque.removeLast());
           //  System.out.println(deque.iterator().next());
            // deque.iterator().remove();
       /* Deque<String> D = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) D.addFirst(item);
            else if (!D.isEmpty()) StdOut.print(D.removeFirst() + "" "");
        }
       // StdOut.println(""("" + D.size() + "" left on deque)"");
       throw new NullPointerException();*/
    }

    
    
}
        // TODO code application logic here

  
    


@4fb44c3a3e24c8a790824ba8a2cce273@"
"b03704074","7","1.46","172544","@5b96f413f2dee18006f9c6512448933c@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       deque.addLast(1);
       deque.addFirst(2);
       deque.addFirst(3);
       deque.addLast(4);
       deque.addFirst(5);
       deque.addLast(6);
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@5b96f413f2dee18006f9c6512448933c@"
"r04228002","3","0.36","102400","@eaf61e0cd1be1d1c84552a3c8c997fc4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        //private Node<Item> up;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        //first.next=last;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        if (N==1){
            last=first;
        }
        else{
            first.next = oldfirst;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        else {
           last.next = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        if (first.next==last){
            first = last;
        }
        else{
            first = first.next;
        }
        N--;
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        if (last.next==first){
            last=first;
        }
        else{
            last=last.next;
        }
        N--;
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@eaf61e0cd1be1d1c84552a3c8c997fc4@"
"b03704074","0","0.24","102336","@0833878f36e2345c9266e09ea4eae055@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        current = current.next;
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            //current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.removeLast();
       deque.addFirst(5);
       
       deque.addLast(6);
       deque.removeLast();
       deque.removeLast();
       deque.addLast(7);
       deque.removeLast();
       //deque.removeLast();
       //deque.removeLast();
       //deque.removeFirst();
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@0833878f36e2345c9266e09ea4eae055@"
"r04921028","7","1.06","100944","@6f6685169227a94cc3d171fae322891a@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import  java.util.NoSuchElementException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
       Deque.Node<Item> oldfirst = first;
        if(last == null){last = first;}
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Deque.Node<Item> oldlast = last; 
        last = new Deque.Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else         oldlast.next = last;
        N++;
   
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
       Item item = last.item;
       temp = first;
       
       for(int i=1;i<N-1;i++){
           temp = temp.next;
       }
       last = temp;
       last.next = null;
       temp = null;
       N--;
       if(N==0){first = null; last = null;}
       return item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.N);
//            System.out.println(s.N);
            
   }
}

@6f6685169227a94cc3d171fae322891a@"
"b03704074","7","1.52","183104","@54a269f527811934194914f948e9c95a@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addFirst(5);
       deque.removeLast();
       deque.addLast(6);
       deque.removeLast();
       deque.addLast(7);
       
       deque.removeLast();
       deque.removeLast();
       deque.addFirst(99);
       //deque.removeFirst();
       //deque.removeFirst();
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@54a269f527811934194914f948e9c95a@"
"b03704074","9","1.42","173312","@22f08a067672a89bc0995d066fc0d699@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addFirst(5);
       deque.addLast(6);
       deque.addLast(7);
       deque.addFirst(99);
       deque.removeLast();
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@22f08a067672a89bc0995d066fc0d699@"
"b03704074","7","0.81","102464","@cc3d9a6956c7d7cfc91bd37b3c7323fc@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        first.pre = null;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addFirst(5);
       deque.addLast(6);
       deque.addLast(7);
       deque.addFirst(99);
       deque.removeLast();
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@cc3d9a6956c7d7cfc91bd37b3c7323fc@"
"b03704074","9","1.39","179072","@833f8a0e50cb59e102777f15ce6f4e67@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addFirst(5);
       deque.removeLast();
       deque.addLast(6);
       deque.addLast(7);
       deque.addFirst(99);
       deque.removeLast();
       deque.removeLast();
       //StdOut.println(deque.last.pre.pre.item);
       
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@833f8a0e50cb59e102777f15ce6f4e67@"
"r04921028","8","1.4","181056","@ec1d65277426e01b004d415883afe050@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        public Node<Item> left, right;
        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) { throw new NullPointerException(); }
            this.item = item;
        }
        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }                

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
        Node<Item> prevHead = first;
        Node<Item> newHead = new Node<Item>(item);
        if (prevHead != null) {
          newHead.connectRight(prevHead);
        } else {
          last = newHead;
        }
        first = newHead;
         N++;
   }

   public void addLast(Item item)           // add the item to the end
   {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = last;
        if (prevTail != null) {
          prevTail.connectRight(newTail);
        } else {
          first = newTail;
        }
        last = newTail;
        N++;
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.right;            // delete first node
        
        N--;
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) {
           throw new java.util.NoSuchElementException();
       }
        N--;
        Node<Item> prevTail = last;
        last = prevTail.left;
        prevTail.left = null;
        if (last != null) last.right = null;
        return prevTail.item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
            System.out.println(s.N);
//            System.out.println(s.N);
            
   }
}

@ec1d65277426e01b004d415883afe050@"
"r04921028","8","1.39","174560","@927c7bd1beb5178a11eecf998138450b@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        public Node<Item> left, right;
        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) { throw new NullPointerException(); }
            this.item = item;
        }
        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }         
   public void checkInvariants() {
    assert N >= 0;
    assert N > 0 || (first == null && last == null);
    assert (first == null && last == null) || (first != null && last != null);
  }

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
        Node<Item> prevHead = first;
        Node<Item> newHead = new Node<Item>(item);
        if (prevHead != null) {
          newHead.connectRight(prevHead);
        } else {
          last = newHead;
        }
        first = newHead;
         N++;
         checkInvariants();
   }

   public void addLast(Item item)           // add the item to the end
   {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = last;
        if (prevTail != null) {
          prevTail.connectRight(newTail);
        } else {
          first = newTail;
        }
        last = newTail;
        N++;
        checkInvariants();
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.right;            // delete first node
        
        N--;
        checkInvariants();
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) {
           throw new java.util.NoSuchElementException();
       }
        N--;
        Node<Item> prevTail = last;
        last = prevTail.left;
        prevTail.left = null;
        if (last != null) last.right = null;
        checkInvariants();
        return prevTail.item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            
            System.out.println(s.N);
//          System.out.println(s.N);
            
   }
}

@927c7bd1beb5178a11eecf998138450b@"
"r04921028","10","0.139","185888","@c42f47e222643c0b5eabe3160697b1ae@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        public Node<Item> left, right;
        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) { throw new NullPointerException(); }
            this.item = item;
        }
        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }         
   public void checkInvariants() {
    assert N >= 0;
    assert N > 0 || (first == null && last == null);
    assert (first == null && last == null) || (first != null && last != null);
  }

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
        Node<Item> prevHead = first;
        Node<Item> newHead = new Node<Item>(item);
        if (prevHead != null) {
          newHead.connectRight(prevHead);
        } else {
          last = newHead;
        }
        first = newHead;
         N++;
         checkInvariants();
   }

   public void addLast(Item item)           // add the item to the end
   {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = last;
        if (prevTail != null) {
          prevTail.connectRight(newTail);
        } else {
          first = newTail;
        }
        last = newTail;
        N++;
        checkInvariants();
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.right;            // delete first node
        
        N--;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) {
           throw new java.util.NoSuchElementException();
       }
        N--;
        Node<Item> prevTail = last;
        last = prevTail.left;
        prevTail.left = null;
        if (last != null) last.right = null;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return prevTail.item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            
            System.out.println(s.N);
//          System.out.println(s.N);
            
   }
}

@c42f47e222643c0b5eabe3160697b1ae@"
"b03704074","8","1.03","102448","@0adf1d257ce6766474f60d364c52e667@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else if(last.item == first.item){
        Item item = last.item;
        last = null;
        first = null;
        return item;}
        else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addLast(5);
       deque.addLast(6);
       deque.removeLast();
       deque.removeLast();
       deque.removeLast();
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@0adf1d257ce6766474f60d364c52e667@"
"b03704074","8","1.07","102448","@c49d9784a3677afb30f0a2ff5f5363e4@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else if(last == first){
        Item item = last.item;
        last = null;
        first = null;
        return item;}
        else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addLast(4);
       deque.addLast(5);
       deque.addLast(6);
       deque.removeLast();
       deque.removeLast();
       deque.removeLast();
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@c49d9784a3677afb30f0a2ff5f5363e4@"
"b03704074","10","0.133","182624","@f855db06148e852c62acc75d1f79d694@import java.util.Iterator;
import java.util.*;
public class Deque<Item> implements Iterable<Item>{
private int count;
private Node first;
private Node last;
private class Node{
   Item item;
   Node next;
   Node pre;}
public Deque(){
    count = 0;
    first = null;
    last = null;}// construct an empty deque
public boolean isEmpty(){            // is the deque empty?
    return size() == 0;}
public int size(){                   // return the number of items on the deque
    return count;}
public void addFirst (Item item){     // add the item to the front
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newfirst = new Node();
        //newfirst.item = item;
        first.pre = newfirst;
        Node oldfirst = first;
        first = new Node();
        first = newfirst;
        first.item = item;
        first.next = oldfirst;
        count++;
    }
}
public void addLast(Item item){         // add the item to the end
    if(item == null) throw new NullPointerException();
    else if(isEmpty()){
        first = new Node();
        last = new Node();
        last.item = item;
        first.item = item;
        first = last;
        count++;
    }
    else{
        Node newlast = new Node();
        //newlast.item = item;
        last.next = newlast;
        Node oldlast = last;
        last = new Node();
        last = newlast;
        last.item = item;
        last.pre = oldlast;
        count++;
    }
}
public Item removeFirst(){                        // remove and return the item from the front
    if(isEmpty())  throw new NoSuchElementException(); 
    else {
        Item item = first.item;
        first = first.next;
        count--;
        return item;
    }
}
public Item removeLast(){                           // remove and return the item from the end
    if(isEmpty())  throw new NoSuchElementException(); 
    else if(last == first){
        Item item = last.item;
        last = null;
        first = null;
        count--;
        return item;}
        else{
        Item item = last.item;
        last = last.pre;
        last.next = null;
        count--;
        return item;
    }
}
public Iterator iterator(){
    return new ListIterator();
}
private class ListIterator implements Iterator<Item>{
    private Node current = first;
    public boolean hasNext(){
        return current != null;
    }
    public void remove(){
        throw new UnsupportedOperationException();
    }
    public Item next(){
        if(hasNext()){
            Item item = current.item;
            current = current.next;
            return item;
        }
        else throw new NoSuchElementException(); 
    }
}


    
    public static void main(String[] args) {
       Deque deque = new Deque();
       
       deque.addFirst(4);
        deque.removeLast();
       deque.addLast(5);
       deque.addLast(6);
      
       deque.removeLast();
       deque.removeLast();
       Iterator<Integer> i = deque.iterator();
        while (i.hasNext())
        {
        int s = i.next();
        StdOut.println(s);
        }
       
    }
    
}
@f855db06148e852c62acc75d1f79d694@"
"b99611017","3","0.36","100256","@6f786059bc96507f1b07012e333d96a7@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldLast = last;
        last = new Node<>();
        last.item = item;
        oldLast.next = last;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        if (N > 1) {
            Node<Item> oldLast = null;
            oldLast = last;

        } else {
            last = null;
        }
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@6f786059bc96507f1b07012e333d96a7@"
"b99611017","3","0.37","102432","@4655b2319ccc72a7826dd6623d1430fa@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldLast = last;
        last = new Node<>();
        last.item = item;
        oldLast.next = last;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        if (N > 1) {
            Node<Item> oldLast = null;
            oldLast = last;

        } else {
            last = null;
        }
        N--;
        return item;
        
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@4655b2319ccc72a7826dd6623d1430fa@"
"r04228002","4","0.48","98992","@5e2b9014af4f8b19e9cdc8c09c528695@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        //private Node<Item> up;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        //first.next=last;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        if (N==1){
            last=first;
        }
        else{
            first.next = oldfirst;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        else {
           last.next = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (first.next==last){
            first = last;
        }
        else{
            first = first.next;
        }
        
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (last.next==first){
            last=first;
        }
        else{
            last=last.next;
        }
        N--;
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@5e2b9014af4f8b19e9cdc8c09c528695@"
"r03723070","3","1.2","180272","@8675b432c1146559c4660d325d74dd64@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last=null;
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item){// add the item to the front     
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.next = oldfirst;
       oldfirst.prev = first;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (last==null)
           last = first;
       last.next = new Node();
       last.next.item = item;
       last.next.prev = last;
       last = last.next;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       Item a = first.item;
       Node oldfirst = first;
       first = first.next;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       Item a = last.item;
       Node oldlast = last;
       last= last.prev;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        return thisnode.item;}
    public void remove() {}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.addLast((double)1);
   }
       // unit testing

}

@8675b432c1146559c4660d325d74dd64@"
"r03723070","3","1.21","175920","@b082cee3b59786ab810d2246e17e608b@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last=null;
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item){// add the item to the front     
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.next = oldfirst;
       oldfirst.prev = first;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (last==null)
           last = first;
       last.next = new Node();
       last.next.item = item;
       last.next.prev = last;
       last = last.next;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       Item a = first.item;
       Node oldfirst = first;
       first = first.next;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       Item a = last.item;
       Node oldlast = last;
       last= last.prev;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        return thisnode.item;}
    public void remove() {}
}
   /*public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.addLast((double)1);
   }*/
       // unit testing

}

@b082cee3b59786ab810d2246e17e608b@"
"r03723070","4","1.38","180272","@1815d0f3097db47ff0589f5d583b33cb@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last=null;
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.next = oldfirst;
       oldfirst.prev = first;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       if (last==null)
           last = first;
       last.next = new Node();
       last.next.item = item;
       last.next.prev = last;
       last = last.next;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Item a = first.item;
       Node oldfirst = first;
       first = first.next;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Item a = last.item;
       Node oldlast = last;
       last= last.prev;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==null)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@1815d0f3097db47ff0589f5d583b33cb@"
"r03723070","0","0.36","102384","@cc546f1b027db92bbe32b20155026802@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last = new Node();
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldnext = first.next;
       first.next = new Node();
       first.next.item = item;
       first.next.prev = first;
       first.next.next = oldnext;
       oldnext.prev = first.next;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       Node oldprev = last.prev;
       last.prev = new Node();
       last.prev.item = item;
       last.prev.prev = oldprev;
       last.prev.next = last;
       oldprev.next = last.prev;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldfirst = first.next;
       Item a = oldfirst.item;
       first.next = oldfirst.next;
       oldfirst.next.prev = first;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldlast = last.prev;
       Item a = oldlast.item;
       last.prev = oldlast.prev;
       oldlast.prev.next = last;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==null)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@cc546f1b027db92bbe32b20155026802@"
"r04228002","2","0.24","102384","@4d62495b7e23b95dd6a513233f263bca@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        //private Node<Item> up;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        //first.next=last;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        if (N==1){
            last=first;
        }
        else if(N==2){
            last.next=first;
            first.next=last;
        }
        else{
            first.next = oldfirst;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        else if (N==2){
            first.next=last;
            last.next=first;
        }
        else {
           last.next = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            first = last;
        }
        else if(N==2){
            first = first.next;
            last.next=first;
        }
        else{
            first = first.next;
        }
        
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            last=first;
        }
        else if (N==2){
            last=last.next;
            first.next=last;
        }
        else{
            last=last.next;
        }
        
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@4d62495b7e23b95dd6a513233f263bca@"
"r04228002","2","0.23","102912","@4069fba8dd6eb7abe4ae9f9265d02e65@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        //private Node<Item> up;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        //first.next=last;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        if (N==1){
            last=first;
        }
        else if(N==2){
            last.next=first;
            first.next=last;
        }
        else{
            first.next = oldfirst;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        else if (N==2){
            first.next=last;
            last.next=first;
        }
        else {
           last.next = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            first = last;
        }
        else if(N==2){
            first = first.next;
            last.next=first;
        }
        else{
            first = first.next;
        }
        
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            last=first;
        }
        else if (N==2){
            last=last.next;
            first.next=last;
        }
        else{
            last=last.next;
        }
        
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@4069fba8dd6eb7abe4ae9f9265d02e65@"
"r03723070","0","0.36","102400","@2fb4bd0ef6e39c434bb01d7c03add4e7@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last = new Node();
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldnext = first.next;
       first.next = new Node();
       first.next.item = item;
       first.next.prev = first;
       first.next.next = oldnext;
       oldnext.prev = first.next;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       Node oldprev = last.prev;
       last.prev = new Node();
       last.prev.item = item;
       last.prev.next = oldprev;
       last.prev.prev = last;
       oldprev.next = last.prev;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldfirst = first.next;
       Item a = oldfirst.item;
       first.next = oldfirst.next;
       oldfirst.next.prev = first;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldlast = last.prev;
       Item a = oldlast.item;
       last.prev = oldlast.prev;
       oldlast.prev.next = last;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==null)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@2fb4bd0ef6e39c434bb01d7c03add4e7@"
"r03723070","0","0","0","@f4af9dccc76e1efb57a07259709bd983@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last = new Node();
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldnext = first.next;
       first.next = new Node();
       first.next.item = item;
       first.next.prev = first;
       first.next.next = oldnext;
       oldnext.prev = first.next;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       Node oldprev = last.prev;
       last.prev = new Node();
       last.prev.item = item;
       last.prev.next = oldprev;
       last.prev.prev = last;
       oldprev.next = last.prev;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldfirst = first.next;
       Item a = oldfirst.item;
       first.next = oldfirst.next;
       oldfirst.next.prev = first;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldlast = last.prev;
       Item a = oldlast.item;
       last.prev = oldlast.prev;
       oldlast.prev.next = last;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=null;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==last)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@f4af9dccc76e1efb57a07259709bd983@"
"b99611017","3","0.36","100032","@a8d8b18e4247fc7c43911fa2883ba8ec@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldLast = last;
        last = new Node<>();
        last.item = item;
        oldLast.next = last;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        if (first.next == null || last.next == null) {
            first = null;
            last = null;
        }

        return item;

    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@a8d8b18e4247fc7c43911fa2883ba8ec@"
"b99611017","3","0.36","102288","@9b591669ea8f7cfb6cec8e40721b7f56@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldLast = last;
        last = new Node<>();
        last.item = item;
        oldLast.next = last;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        if (first.next == null || last.next == null) {
            first = null;
            last = null;
        }
        N--;
        return item;

    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@9b591669ea8f7cfb6cec8e40721b7f56@"
"b01502105","3","1.38","183120","@630e3aebd172a10fd8d1b47275b49014@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    public boolean isEmpty() {                 // is the deque empty?
        return (first == null || last == null);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        if (isEmpty()){last = first;}
        else{first.next = oldfirst;}
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()){first = last;}
        else {last.previous = oldlast;}
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) first = null;
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
//    public static void main(String[] args) {
//
//    }

}
@630e3aebd172a10fd8d1b47275b49014@"
"b01502105","3","0.83","100560","@c7ab4c9b43eec561be65a39a576ad9a4@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    public boolean isEmpty() {                 // is the deque empty?
//        return (first == null && last == null);
         return(N==0);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        if (isEmpty()){last = first;}
        else{first.next = oldfirst;}
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()){first = last;}
        else {last.previous = oldlast;}
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Deque first underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;}
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Deque last underflow"");
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) {first = null;}
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
//    public static void main(String[] args) {
//
//    }
}
@c7ab4c9b43eec561be65a39a576ad9a4@"
"b01502105","3","0.83","102480","@c47018609f3f6e2de8c0b3d441ffc7ce@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    public boolean isEmpty() {                 // is the deque empty?
        return (first == null && last == null);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        if (isEmpty()){last = first;}
        else{first.next = oldfirst;}
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()){first = last;}
        else {last.previous = oldlast;}
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Deque first underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;}
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Deque last underflow"");
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) {first = null;}
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
//    public static void main(String[] args) {
//
//    }
}

@c47018609f3f6e2de8c0b3d441ffc7ce@"
"b02611028","0","0","0","@ec170755ca1ad7599d70fcc50b56d828@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        N++;
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        oldfirst.previous = first;

        if (N == 1) {
            last = first;
        }

    }          // add the item to the front

    public void addLast(Item item) {
        N++;
        Node prelast = last;
        first = new Node();
        last.item = item;
        last.previous = prelast;
        prelast.next = last;
        if (N == 1) {
            first = last;
        }
    }           // add the item to the end

    public Item removeFirst() {
        N--;
        Item item = first.item;
        first = first.next;
        return (item);
    }                // remove and return the item from the front

    public Item removeLast() {
        N--;
        Item item = last.item;
        last = last.previous;
        return (item);
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        
    }   // unit testing
}

@ec170755ca1ad7599d70fcc50b56d828@"
"b02611028","5","1.19","183952","@2c00c3800c5497e077fe3d80beeaa290@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        N++;
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        
        

        if (N == 1) {
            last=first;
        }
        else oldfirst.previous = first;

    }          // add the item to the front

    public void addLast(Item item) {
        N++;
        Node prelast = last;
        last = new Node();
        last.item = item;
        last.previous = prelast;
        
        if (N == 1) {
            first = last;
        }
        else prelast.next = last;
    }           // add the item to the end

    public Item removeFirst() {
        N--;
        Item item = first.item;
        first = first.next;
        return (item);
    }                // remove and return the item from the front

    public Item removeLast() {
        N--;
        Item item = last.item;
        last = last.previous;
        return (item);
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
        /*public Item previous() {
            Item item = current.item;
            current = current.previous;
            return item;
        }*/
    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        /*Deque<String> q = new Deque<String>();
        q.addFirst(""fuck"");
        q.addFirst(""shit"");
        System.out.print(q.removeFirst());*/
    }   // unit testing
}

@2c00c3800c5497e077fe3d80beeaa290@"
"b02611028","5","1.18","178512","@45d47d085b1ee903526c34be3fc9beee@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        N++;
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;

        if (N == 1) {
            last = first;
        } else {
            oldfirst.previous = first;
        }
        
        if(item==null)throw new java.lang.NullPointerException();

    }          // add the item to the front

    public void addLast(Item item) {
        N++;
        Node prelast = last;
        last = new Node();
        last.item = item;
        last.previous = prelast;

        if (N == 1) {
            first = last;
        } else {
            prelast.next = last;
        }
        if(item==null)throw new java.lang.NullPointerException();
    }           // add the item to the end

    public Item removeFirst() {
        N--;
        Item item = first.item;
        first = first.next;
        return (item);
    }                // remove and return the item from the front

    public Item removeLast() {
        N--;
        Item item = last.item;
        last = last.previous;
        return (item);
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
        /*public Item previous() {
         Item item = current.item;
         current = current.previous;
         return item;
         }*/
    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        /*Deque<String> q = new Deque<String>();
         q.addFirst(""fuck"");
         q.addFirst(null);
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@45d47d085b1ee903526c34be3fc9beee@"
"b02611028","5","1.43","183312","@752e1b8cf4af6e26123daf9ae6f690ee@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        N++;
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;

        if (N == 1) {
            last = first;
        } else {
            oldfirst.previous = first;
        }

        if (item == null) {
            throw new java.lang.NullPointerException();
        }

    }          // add the item to the front

    public void addLast(Item item) {
        N++;
        Node prelast = last;
        last = new Node();
        last.item = item;
        last.previous = prelast;

        if (N == 1) {
            first = last;
        } else {
            prelast.next = last;
        }
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        }
        N--;
        Item item = first.item;
        first = first.next;
        return (item);
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        }
        N--;
        Item item = last.item;
        last = last.previous;
        return (item);
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() { throw new java.lang.UnsupportedOperationException(); }

        public Item next() {
            if(!hasNext())throw new java.util.NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
        /*public Item previous() {
         Item item = current.item;
         current = current.previous;
         return item;
         }*/
    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        /*Deque<String> q = new Deque<String>();
         q.addFirst(""fuck"");
         q.addFirst(null);
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@752e1b8cf4af6e26123daf9ae6f690ee@"
"b02611023","1","0.25","101632","@2414acff13fb7cf8799670539bd7c1fa@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack
    Stack<Item> s_last = new Stack<Item>();
    Stack<Item> temp = new Stack<Item>();

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            temp.push(item);
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            s_last.push(item);
            N++;
        }

    }

    public Item removeFirst() {
        if(!temp.isEmpty()){
            temp.pop();
        }
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            if (!s_last.isEmpty()) {
                Item item = s_last.pop();
                N--;
                return item;
            } else {
                while (!temp.isEmpty()) {
                    s_last.push(temp.pop());
                }
                Item item = s_last.pop();
                while (!s_last.isEmpty()) {
                    temp.push(s_last.pop());
                }
                N--;
                return item;
            }

        } else {
            s_last = new Stack<Item>();
            temp = new Stack<Item>();
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return N > 0;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.iterator().next());
//        System.out.println();
//        System.out.println();
//    }
}

@2414acff13fb7cf8799670539bd7c1fa@"
"r04631021","2","1.5","179936","@64b5ea6622d2fa8f077c1a636883c647@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) first = last ;
        else first.next = oldfirst ;
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@64b5ea6622d2fa8f077c1a636883c647@"
"r03525008","10","0.222","181664","@8db831b6667d923378699d995692fdb4@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by User on 2016/3/28.
 */
public class Deque <Item> implements Iterable {
//public class Deque <Item> {

    private Node first;
    private Node last;

    class Node{
        Item item;
        Node previous;
        Node next;
        Node (Item item){
            this.item=item;
        }

    }
    public Deque(){

    }
    public boolean isEmpty(){
        return first==null&&last==null;
    }
    public int size(){
        int num=0;
        Node temp=first;
        while(temp!=null){
            temp=temp.next;
            num+=1;
        }
        return num;
    }
    public void addFirst(Item item){
        if(item==null){
            throw new NullPointerException();
        }
        else {
            if (first == null && last == null) {
                first = new Node(item);
                last = first;
            } else {
                Node temp = first;
                //first.next.previous=temp;
                first = new Node(item);
                first.next = temp;
                temp.previous = first;
            }
        }
    }
    public void addLast(Item item){
        if(item==null){
            throw new NullPointerException();
        }
        else {
            if (first == null && last == null) {
                first = new Node(item);
                last = first;
            } else {
                Node temp = last;
                //last.previous.next=temp;
                last = new Node(item);
                last.previous = temp;
                temp.next = last;
            }
        }
    }
    public Item removeFirst(){
        if(size()==0){
            throw new NoSuchElementException();
        }
        else {
            Item item = first.item;
            if (size() == 1) {
                first = null;
                last = null;
            } else {
                first = first.next;
                first.previous = null;
            }
            return item;
        }
    }
    public Item removeLast(){
        if(size()==0){
            throw new NoSuchElementException();
        }
        else {
            Item item = last.item;
            if (size() == 1) {
                first = null;
                last = null;
            } else {
                last = last.previous;
                last.next = null;
            }
            return item;
        }

    }
/*    public void showDeque(){
        Node temp = first;
        while(temp!=null){
            System.out.println(temp.item);
            temp=temp.next;
        }
    }*/
    public Iterator iterator(){
        Iterator it = new Iterator(){
          Node temp = first;
            @Override
            public boolean hasNext(){
                return temp!=null;
            }
            @Override
            public void remove(){
                throw new UnsupportedOperationException();
            }
            @Override
            public Item next(){
                if(temp==null)
                    throw new NoSuchElementException();
                else {
                    Item item = temp.item;
                    temp=temp.next;
                    return item;
                }
            }


        };
        return it;
    }

   /* public static void main(String[] args) {

        Deque<String> deque = new Deque<String>();
        String s = null;
        deque.addLast(""This"");
        deque.addLast(""is"");
        deque.addLast(""a"");
        deque.addLast(""book"");
*//*        System.out.println(""size ""+deque.size());
        deque.showDeque();
        System.out.println(""remove ""+deque.removeFirst());
        System.out.println(""size ""+deque.size());
        deque.showDeque();
        System.out.println(""remove ""+deque.removeLast());
        System.out.println(""size ""+deque.size());
        deque.showDeque();
        System.out.println(""isEmpty ""+deque.isEmpty());
        deque.removeFirst();
        System.out.println(""size ""+deque.size());
        deque.removeLast();
        System.out.println(""size ""+deque.size());
        System.out.println(""isEmpty ""+deque.isEmpty());*//*
       // deque.addFirst(s);
       // deque.addLast(s);
       // deque.removeLast();
       // deque.removeFirst();
        Iterator it = deque.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }
        //it.next();
        //it.remove();
    }*/
}

@8db831b6667d923378699d995692fdb4@"
"b02611028","7","1.49","181392","@1699670ae40dc9eb766f147824d705b7@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;

            if (N == 1) {
                last = first;
            } else {
                oldfirst.previous = first;
            }

        }

    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node prelast = last;
            last = new Node();
            last.item = item;
            last.previous = prelast;

            if (N == 1) {
                first = last;
            } else {
                prelast.next = last;
            }
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        }
        N--;
        Item item = first.item;
        first = first.next;
        return (item);
    }                // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        }
        N--;
        Item item = last.item;
        last = last.previous;
        return (item);
    }                 // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    public class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        try {
            Deque<String> q = new Deque<String>();
            q.iterator().remove();
            /*q.addFirst(""fuck"");
             q.addLast(""shit"");
             q.addLast(""ass"");
             Iterator it=q.iterator();
             System.out.print(it.next());
             System.out.print(it.next());
             System.out.print(q.removeLast());*/
        } catch (java.lang.UnsupportedOperationException exception) {
            System.out.print(1);
        }
        /*System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@1699670ae40dc9eb766f147824d705b7@"
"b02611028","7","1.44","177520","@1e57361e0f2a7922194d725582df2447@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;

            if (N == 1) {
                last = first;
            } else {
                oldfirst.previous = first;
            }

        }

    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node prelast = last;
            last = new Node();
            last.item = item;
            last.previous = prelast;

            if (N == 1) {
                first = last;
            } else {
                prelast.next = last;
            }
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = first.item;
            first = first.next;
            return (item);
        }
    }       // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = last.item;
            last = last.previous;
            return (item);
        }
    }        // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    public class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }

    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        try {
            Deque<String> q = new Deque<String>();
            q.iterator().remove();
            /*q.addFirst(""fuck"");
             q.addLast(""shit"");
             q.addLast(""ass"");
             Iterator it=q.iterator();
             System.out.print(it.next());
             System.out.print(it.next());
             System.out.print(q.removeLast());*/
        } catch (java.lang.UnsupportedOperationException exception) {
            System.out.print(1);
        }
        /*System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@1e57361e0f2a7922194d725582df2447@"
"b02611028","7","0.84","102544","@87ad060898cdfe04f28bb91c509b8f16@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;

            if (N == 1) {
                last = first;
            } else {
                oldfirst.previous = first;
            }

        }

    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node prelast = last;
            last = new Node();
            last.item = item;
            last.previous = prelast;

            if (N == 1) {
                first = last;
            } else {
                prelast.next = last;
            }
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = first.item;
            first = first.next;
            first.previous=null;
            return (item);
        }
    }       // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = last.item;
            last = last.previous;
            last.next=null;
            return (item);
        }
    }        // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    public class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }

    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        try {
            Deque<String> q = new Deque<String>();
            q.iterator().remove();
            /*q.addFirst(""fuck"");
             q.addLast(""shit"");
             q.addLast(""ass"");
             Iterator it=q.iterator();
             System.out.print(it.next());
             System.out.print(it.next());
             System.out.print(q.removeLast());*/
        } catch (java.lang.UnsupportedOperationException exception) {
            System.out.print(1);
        }
        /*System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@87ad060898cdfe04f28bb91c509b8f16@"
"b02611028","7","0.81","102416","@a7a9a4d27af8f190e1ad4430ea75895c@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            first.previous=null;
            if (N == 1) {
                last = first;
            } else {
                oldfirst.previous = first;
            }

        }

    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node prelast = last;
            last = new Node();
            last.item = item;
            last.previous = prelast;
            last.next=null;

            if (N == 1) {
                first = last;
            } else {
                prelast.next = last;
            }
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = first.item;
            first = first.next;
            first.previous=null;
            return (item);
        }
    }       // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            Item item = last.item;
            last = last.previous;
            last.next=null;
            return (item);
        }
    }        // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    public class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }

    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        try {
            Deque<String> q = new Deque<String>();
            q.iterator().remove();
            /*q.addFirst(""fuck"");
             q.addLast(""shit"");
             q.addLast(""ass"");
             Iterator it=q.iterator();
             System.out.print(it.next());
             System.out.print(it.next());
             System.out.print(q.removeLast());*/
        } catch (java.lang.UnsupportedOperationException exception) {
            System.out.print(1);
        }
        /*System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@a7a9a4d27af8f190e1ad4430ea75895c@"
"b02611028","10","0.14","184592","@c2a6a70e9826c6b7179b216b19b6c4a2@import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node {

        Item item;
        Node next;
        Node previous;
    }
    private Node first = null;
    private Node last = null;
    int N;

    public Deque() {
        first = null;
        last = null;

        N = 0;
    }                           // construct an empty deque

    public boolean isEmpty() {
        return first == null;
    }                 // is the deque empty?

    public int size() {
        return N;
    }                        // return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            first.previous = null;
            if (N == 1) {
                last = first;
            } else {
                oldfirst.previous = first;
            }

        }

    }          // add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        } else {
            N++;
            Node prelast = last;
            last = new Node();
            last.item = item;
            last.previous = prelast;
            last.next = null;

            if (N == 1) {
                first = last;
            } else {
                prelast.next = last;
            }
        }
    }           // add the item to the end

    public Item removeFirst() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            if (N == 0) {
                Item item = first.item;
                first = last;
                first = null;
                last = null;
                return (item);
            } else {
                Item item = first.item;
                first = first.next;
                first.previous = null;
                return (item);
            }
        }
    }       // remove and return the item from the front

    public Item removeLast() {
        if (N == 0) {
            throw new java.util.NoSuchElementException();
        } else {
            N--;
            if (N == 0) {
                Item item = first.item;
                first = last;
                first = null;
                last = null;
                return (item);
            } else {
                Item item = last.item;
                last = last.previous;
                last.next = null;
                return (item);
            }
        }
    }        // remove and return the item from the end

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    public class ListIterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            } else {
                Item item = current.item;
                current = current.next;
                return item;
            }
        }

    }       // return an iterator over items in order from front to end

    public static void main(String[] args) {
        try {
            Deque<String> q = new Deque<String>();
            q.addLast(""fuck"");
            q.addLast(""shit"");
            System.out.print(q.removeLast());
            System.out.print(q.removeLast());
//            q.addFirst(""ass"");
//            System.out.print(q.removeFirst());
            /*q.addFirst(""fuck"");
             q.addLast(""shit"");
             q.addLast(""ass"");
             Iterator it=q.iterator();
             System.out.print(it.next());
             System.out.print(it.next());
             System.out.print(q.removeLast());*/
        } catch (java.lang.UnsupportedOperationException exception) {
            System.out.print(1);
        }
        /*System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());
         System.out.print(q.size());
         System.out.print(q.removeFirst());*/
    }   // unit testing
}

@c2a6a70e9826c6b7179b216b19b6c4a2@"
"b03611015","0","0.84","102544","@b2e3c5ee8a1f8ed8a8c9c9957a4a9a8e@package Deque;
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
    private class DequeIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private Node first = null;
    private Node last = null;
    private int size = 0;

    private class Node {
        private Item item;
        private Node next;
        private Node previous;
    }

    /*
     * construct an empty deque
     */
    public Deque() {
    }

    /*
     * is the deque empty?
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /*
     * return the number of items on the deque
     */
    public int size() {
        return size;
    }

    private void checkAdd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    /*
     * insert the item at the front
     */
    public void addFirst(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            first.previous = node;
            node.next = first;
            first = node;
        }
        size++;
    }

    /*
     * insert the item at the end
     */
    public void addLast(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            last.next = node;
            node.previous = last;
            last = node;
        }
        size++;
    }

    private void checkRemove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    /*
     * delete and return the item at the front
     */
    public Item removeFirst() {
        checkRemove();
        Item item = first.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node second = first.next;
            second.previous = null;
            first.next = null;
            first = second;
        }
        size--;
        return item;
    }

    /*
     * delete and return the item at the end
     */
    public Item removeLast() {
        checkRemove();
        Item item = last.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node oldLast = last;
            last = oldLast.previous;
            last.next = null;
            oldLast.previous = null;
            oldLast = null;
        }
        size--;
        return item;
    }

    /*
     * return an iterator over items in order from front to end
     * 
     * @see java.lang.Iterable#iterator()
     */
    public java.util.Iterator<Item> iterator() {
        return new DequeIterator();
    }
}
@b2e3c5ee8a1f8ed8a8c9c9957a4a9a8e@"
"r04921012","8","0.92","102272","@c29fde20d449063cc29fa2891ff442d2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package deque;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

/**
 *
 * @author steven
 */
public class Deque<T> implements Iterable{
    private ArrayList<T> list;

    
   public Deque(){
       list = new ArrayList();
   }// construct an empty deque

   public boolean isEmpty(){                 
       return list.isEmpty();
   } // is the deque empty?
   
   public int size()  {
       return list.size();
   }// return the number of items on the deque

   public void addFirst(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(0,item);
   }// add the item to the front

   public void addLast(T item){
       if(item==null)
           throw new NullPointerException();
       list.add(item);
   }// add the item to the end

   public T removeFirst(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       else{T a = null;
       a=list.get(0);
       list.remove(0);
       return a;}
       
   }// remove and return the item from the front

   public T removeLast(){
       if (list.isEmpty())
           throw new NoSuchElementException();
       else{T a=null;
       a=list.get(list.size()-1);
       list.remove(list.size()-1);
       return a;}
   }// remove and return the item from the end

   public Iterator iterator(){
       return list.iterator();
   }
   /*public class Iter implements Iterator<T>{
       public boolean hasNext(){
           return list.iterator().hasNext();
       }
       public void remove(){
           throws new UnsupportedOperationException();
       }
   }*/
// return an iterator over items in order from front to end
  /*private class Listiterator() implements Iterator<T>{
       public void remove(){throws new UnsupportedOperationException();}
       public T next(){
           
       }
   }*/
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque<String> a=new Deque<String>();
        String b=""b"";
        String c =""fdf"";
        a.addLast(b);
        //a.removeFirst();
        a.addFirst(c);
        Iterator it=a.iterator();
        it.remove();
        while (it.hasNext())
            System.out.println(it.next());*/
    }
    
}

@c29fde20d449063cc29fa2891ff442d2@"
"r04921074","9","1.37","178544","@6bf5b71ef5f80168a8b7e9dafa236b96@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<Item> implements Iterable<Item> {
  private class Node<Item> {
    public Node<Item> left, right;
    private final Item item;

    public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
  
  public static void main(String[] args){}   // unit testing
  
}
@6bf5b71ef5f80168a8b7e9dafa236b96@"
"b03611015","10","0.14","179344","@8b8c456ce1155beb5e3bba93ba65eaeb@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
    private class DequeIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private Node first = null;
    private Node last = null;
    private int size = 0;

    private class Node {
        private Item item;
        private Node next;
        private Node previous;
    }

    /*
     * construct an empty deque
     */
    public Deque() {
    }

    /*
     * is the deque empty?
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /*
     * return the number of items on the deque
     */
    public int size() {
        return size;
    }

    private void checkAdd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    /*
     * insert the item at the front
     */
    public void addFirst(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            first.previous = node;
            node.next = first;
            first = node;
        }
        size++;
    }

    /*
     * insert the item at the end
     */
    public void addLast(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            last.next = node;
            node.previous = last;
            last = node;
        }
        size++;
    }

    private void checkRemove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    /*
     * delete and return the item at the front
     */
    public Item removeFirst() {
        checkRemove();
        Item item = first.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node second = first.next;
            second.previous = null;
            first.next = null;
            first = second;
        }
        size--;
        return item;
    }

    /*
     * delete and return the item at the end
     */
    public Item removeLast() {
        checkRemove();
        Item item = last.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node oldLast = last;
            last = oldLast.previous;
            last.next = null;
            oldLast.previous = null;
            oldLast = null;
        }
        size--;
        return item;
    }

    /*
     * return an iterator over items in order from front to end
     * 
     * @see java.lang.Iterable#iterator()
     */
    public java.util.Iterator<Item> iterator() {
        return new DequeIterator();
    }
}
@8b8c456ce1155beb5e3bba93ba65eaeb@"
"r04921074","0","0","0","@5fff629ec6730336f0c86d2c7030c55c@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<Item> implements Iterable<Item> {
  private class Node<Item> {
    public Node<Item> left, right;
    private final Item item;

    public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        private ListIterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new ListIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
  
  public static void main(String[] args){}   // unit testing
  
}
@5fff629ec6730336f0c86d2c7030c55c@"
"r04228002","8","1.41","182048","@26c41a3dad8acff97bb66ae223104aca@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        //private Node<Item> up;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        //first.next=last;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        if (N==1){
            last=first;
        }
        else if(N==2){
            last.next=first;
            first.next=last;
        }
        else{
            first.next = oldfirst;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        else if (N==2){
            first.next=last;
            last.next=first;
        }
        else {
           last.next = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            first = last;
        }
        else if(N==2){
            first = first.next;
            last.next=first;
        }
        else{
            first = first.next;
        }
        
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            last=first;
        }
        else if (N==2){
            last=last.next;
            first.next=last;
        }
        else{
            last=last.next;
        }
        
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            if (current==last){
                current=null;
            }
            else{
                current = current.next; 
            }
             
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@26c41a3dad8acff97bb66ae223104aca@"
"r04631036","7","1.19","179088","@86c03791c3203c89f81add63434031dd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.util.ArrayDeque;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import  java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        //Item item;
        //Node next;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    
//    public Stack<Item> s;
//    private int N=0;
//    private Node<Item> first;
//    public Deque(){
//        ArrayDeque<Item> deque = new ArrayDeque<Item>();
//    }
//    public boolean isEmpty()
//    {
//        return first==null;
//    }
//    public int size()
//    {
//        return N;
//    }
//    public void addFirst(Item item)
//    {
//       Node<Item> oldfirst = first;
//        first = new Node<Item>();
//        first.item = item;
//        first.next = oldfirst;
//        N++; 
//    }
//    public void addLast(Item item)
//    {
//    Node<Item> oldfirst = first;
//        
//        N++; 
//    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NullPointerException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if(item ==null)
         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
        if(item ==null)
         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@86c03791c3203c89f81add63434031dd@"
"r04631036","7","1.19","176016","@a537baa9b5aae82530f9eca165608369@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import  java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NullPointerException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


//  public Deque() {
//  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if(item ==null)
         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
        if(item ==null)
         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@a537baa9b5aae82530f9eca165608369@"
"r04631025","0","1.41","182048","@bffcd71f3be269532de819f646768ea5@
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
        Deque<String> TT = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) TT.addFirst(item);
            else if (!TT.isEmpty()) StdOut.print(TT.removeLast() + "" "");
        }
        StdOut.println(""("" + TT.size() + "" left on queue)"");
        
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator iterator() {
        return new ListIterator<Item>(first);
    }

}

@bffcd71f3be269532de819f646768ea5@"
"r04631036","0","0","0","@8234ac080461d61ae09c37ad838eeb46@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */
public class Deque<Item> implements Iterable<Item> {

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NullPointerException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    private Node<Item> head, tail;
    private int size;

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        head.right = tail;
        tail.left = head;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void checkInvariants() {
        assert size >= 0;
        assert size > 0 || (head == null && tail == null);
        assert (head == null && tail == null) || (head != null && tail != null);
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
        if (item == null) {
            throw new NullPointerException();
        }
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
        if (item == null) {
            throw new NullPointerException();
        }
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        checkInvariants();
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        checkInvariants();
        return prevTail.item;
    }
}
//}


@8234ac080461d61ae09c37ad838eeb46@"
"r04631036","6","0.83","102416","@d39ef4def4888312276f005df7c659c7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import  java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new NoSuchElementException();
    }
    public Item next() {
      if (!hasNext()) { throw new NullPointerException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if(item ==null)
         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
        if(item ==null)
         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@d39ef4def4888312276f005df7c659c7@"
"r04631036","7","1.19","181632","@1e1335c8821b7ecc3338cbd341f03bfc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import  java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NullPointerException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if(item ==null)
         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
        if(item ==null)
         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@1e1335c8821b7ecc3338cbd341f03bfc@"
"r04631036","9","1.37","176736","@342b5d3013273ef607284473f9f5cc8d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import  java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
    if(item ==null)
         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
        if(item ==null)
         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@342b5d3013273ef607284473f9f5cc8d@"
"r04631025","0","0.83","102416","@3e20c555aec5c7b165b19e02bcadda06@
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
        Deque<String> TT = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) TT.addFirst(item);
            else if (!TT.isEmpty()) StdOut.print(TT.removeLast() + "" "");
        }
        StdOut.println(""("" + TT.size() + "" left on queue)"");
        
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator iterator() {
        return new ListIterator<Item>(first);
    }

}

@3e20c555aec5c7b165b19e02bcadda06@"
"r04631036","9","1.38","182944","@38a5a45758b0ee4309d10adfe5a38756@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@38a5a45758b0ee4309d10adfe5a38756@"
"r04631025","0","1.19","181632","@dd11bcf2361def6bb24348290743c55f@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item romoveFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
        Deque<String> TT = new Deque<String>();
         while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) TT.addFirst(item);
            else if (!TT.isEmpty()) StdOut.print(TT.removeLast() + "" "");
        }
        StdOut.println(""("" + TT.size() + "" left on queue)"");
        
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@dd11bcf2361def6bb24348290743c55f@"
"r04631036","9","1.39","176624","@1b7e1223c35228eefa41e1decfc31de3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@1b7e1223c35228eefa41e1decfc31de3@"
"r04631036","8","1.28","170992","@e4a653f4da7d5925884275e8e2731388@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
//    if (isEmpty()) {
//      throw new NoSuchElementException();
//    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
//    if (isEmpty()) {
//      throw new NoSuchElementException();
//    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@e4a653f4da7d5925884275e8e2731388@"
"r04631025","0","1.51","181872","@a2af35916edaf5fb43bbc5a6216c653a@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
        Deque<String> TT = new Deque<String>();
         while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) TT.addFirst(item);
            else if (!TT.isEmpty()) StdOut.print(TT.removeLast() + "" "");
        }
        StdOut.println(""("" + TT.size() + "" left on queue)"");
        
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@a2af35916edaf5fb43bbc5a6216c653a@"
"r04631025","0","1.55","186960","@3e8b5731af6fb45ffd1e9f322fea1749@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
//        Deque<String> TT = new Deque<String>();
//         while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) TT.addFirst(item);
//            else if (!TT.isEmpty()) StdOut.print(TT.removeLast() + "" "");
//        }
//        StdOut.println(""("" + TT.size() + "" left on queue)"");
        
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@3e8b5731af6fb45ffd1e9f322fea1749@"
"r04631023","10","0.163","172800","@3220d6dbd1358bceb895c69db10417c7@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private static final class NodeIterator<Item> implements Iterator<Item> {
        private Node<Item> next;

        public NodeIterator(final Deque<Item> deque) {
            if (deque.first != null) {
                this.next = deque.first;
            } else {
                this.next = deque.last;
            }
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            final Item item = next.item;
            next = next.next;
            return item;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private static final class Node<Item> {
        private Item item;
        private Node<Item> next;

        public Node(final Item i, final Node<Item> n) {
            item = i;
            next = n;
        }
    }

    private Node<Item> first = null;
    private Node<Item> last = null;
    private int size;

    public Deque() {
    }

    public boolean isEmpty() {
        return first == null && last == null;
    }

    public int size() {
        return size;
    }
    
    public void addFirst(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            first = new Node<Item>(item, last);
        } else {
            final Node<Item> newFirst = new Node<Item>(item, first);
            first = newFirst;
            if (last == null) {
                last = first.next;
            }
        }
        if (last == null) {
            last = first;
        }
        
        size++;
    }

    public void addLast(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (last == null) {
            last = new Node<Item>(item, null);
            if (first != null) {
                first.next = last;
            }
        } else {
            final Node<Item> newLast = new Node<Item>(item, null);
            final Node<Item> oldLast = last;
            oldLast.next = newLast;
            last = newLast;
            if (first == null) {
                first = oldLast;
            }
        }
        if (first == null) {
            first = last;
        }
        size++;
    }
    
    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }

        final Node<Item> oldFirst = first;
        if (oldFirst == last) {
            first = null;
            last = null;
        } else {
            final Node<Item> newFirst = first.next;
            first = newFirst;
        }
        size--;
        return oldFirst.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        final Node<Item> oldLast = last;

        if (first == last) {
            first = null;
            last = null;
        } else if (first != null) {
            final Node<Item> newLast = findPenultimateNode();
            newLast.next = null;
            last = newLast;
        } else {
            last = null;
        }
        size--;

        if (oldLast != null) {
            return oldLast.item;
        } else {
            return first.item;
        }
    }

    public Iterator<Item> iterator() {
        return new NodeIterator<Item>(this);
    }

    private Node<Item> findPenultimateNode() {
        Node<Item> newLast = first;
        while (newLast.next != null && newLast.next != last) {
            newLast = newLast.next;
        }
        return newLast;
    }
}
@3220d6dbd1358bceb895c69db10417c7@"
"r04631036","7","1.38","181104","@32d67daff7807193328f4a035df4e9c2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      //throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@32d67daff7807193328f4a035df4e9c2@"
"r04631036","9","1.38","176736","@1b7e1223c35228eefa41e1decfc31de3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
//}


@1b7e1223c35228eefa41e1decfc31de3@"
"r04631036","9","1.39","177296","@e6313b4698c59af56bc65975c4bb8ee5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

//  public void checkInvariants() {
//    assert size >= 0;
//    assert size > 0 || (head == null && tail == null);
//    assert (head == null && tail == null) || (head != null && tail != null);
//  }


  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    //checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    //checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    //checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    //checkInvariants();
    return prevTail.item;
  }
}
//}


@e6313b4698c59af56bc65975c4bb8ee5@"
"r04631025","4","0.48","98928","@de7078de1a639706a8375e6a3dbcabe3@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        first.item = item;
        last.next = last;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }

    public void addLast(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;

    }
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
       
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@de7078de1a639706a8375e6a3dbcabe3@"
"r03723070","3","0.36","99056","@342f739578e180774d30bf1e7148fad2@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last = new Node();
       first = new Node();
       first.next = last;         
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldnext = first.next;
       first.next = new Node();
       first.next.item = item;
       first.next.prev = first;
       first.next.next = oldnext;
       oldnext.prev = first.next;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       Node oldprev = last.prev;
       last.prev = new Node();
       last.prev.item = item;
       last.prev.next = last;
       last.prev.prev = oldprev;
       oldprev.next = last.prev;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldfirst = first.next;
       Item a = oldfirst.item;
       first.next = oldfirst.next;
       oldfirst.next.prev = first;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldlast = last.prev;
       Item a = oldlast.item;
       last.prev = oldlast.prev;
       oldlast.prev.next = last;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=last;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==last)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@342f739578e180774d30bf1e7148fad2@"
"r04631025","7","0.82","102416","@fce3428858e77be24e8776206930b292@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) first = last;
        
        N++;

    }

    public void addLast(Item item) {
        if(item==null) throw new NullPointerException(""input can't be null"");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
       
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@fce3428858e77be24e8776206930b292@"
"r04945022","0","1.16","169152","@fcb606a5124d787bbd2eb3a90d38569b@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private final DequeNode<Item> head;
    private final DequeNode<Item> tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode<Item>();
        tail = new DequeNode<Item>();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode<Item> first = head.next;
        final DequeNode<Item> node = new DequeNode<Item>();
        node.item = item;
        node.next = first;
        node.prev = head;
        head.next = node;
        first.prev = node;
        size++;
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode<Item> first = head.next;
        final DequeNode<Item> node = new DequeNode<Item>();
        node.item = item;
        node.next = first;
        node.prev = head;
        head.next = node;
        first.prev = node;
        size++;
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        final DequeNode<Item> first = head.next;
        final DequeNode<Item> next = first.next;
        next.prev = head;
        head.next = next;
        size--;

        return first.item;
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        final DequeNode<Item> last = tail.prev;
        final DequeNode<Item> prev = last.prev;
        tail.prev = prev;
        prev.next = tail;
        size--;

        return last.item;
     }
     
     
    private static class DequeNode<Item> {

        private Item item;

        private DequeNode<Item> next;

        private DequeNode<Item> prev;
    }
    
    
    public static void main(String[] args) throws IOException{
//        File inputfile = null; 
//        if(0 < args.length){
//            inputfile = new File(args[0]);
//        } else{
//            System.out.println(""file does not exist"");
//        }
        
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
    private class ListIterator implements Iterator<Item>{
    private DequeNode<Item> current = head;
    public boolean hasNext() { return current != null; }
    public void remove() { /* not supported */ }
    public Item next()
    {
    Item item = current.item;
    current = current.next;
    return item;
    }
    }
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@fcb606a5124d787bbd2eb3a90d38569b@"
"r03723070","10","0.134","175376","@273f327e5c533842f3087b9b4e106ff6@/*
 * To change this license firster, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
import java.util.Iterator;
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {
   //Deque > isEmpty > Node > last > 在做{}，所以順序有差
   public Deque(){
       last = new Node();
       first = new Node();
       first.next = last;  
       last.prev = first;
   }                           // construct an empty deque
   public boolean isEmpty(){return (size()==0);}                 // is the deque empty?
   class Node{
       Item item;
       Node next;
       Node prev;
       //int yes(){return 1+5;};
   }
   Node first;
   Node last;
   int size_of_Deque = 0;
   public int size(){return size_of_Deque;}                        // return the number of items on the deque
   public void addFirst(Item item)throws Exception{// add the item to the front     
       if (item==null)
           throw new NullPointerException();
       Node oldnext = first.next;
       first.next = new Node();
       first.next.item = item;
       first.next.prev = first;
       first.next.next = oldnext;
       oldnext.prev = first.next;
       ++size_of_Deque;
      //int y= first.yes();
   }

   public void addLast(Item item){
       if (item==null)
           throw new NullPointerException();
       Node oldprev = last.prev;
       last.prev = new Node();
       last.prev.item = item;
       last.prev.next = last;
       last.prev.prev = oldprev;
       oldprev.next = last.prev;
       ++size_of_Deque;
   }           // add the item to the end

   public Item removeFirst(){// remove and return the item from the front
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldfirst = first.next;
       Item a = oldfirst.item;
       first.next = oldfirst.next;
       oldfirst.next.prev = first;
       oldfirst = null;
       --size_of_Deque;
       return a;
   }

   public Item removeLast(){
       if (isEmpty())
           throw new java.util.NoSuchElementException();
       Node oldlast = last.prev;
       Item a = oldlast.item;
       last.prev = oldlast.prev;
       oldlast.prev.next = last;
       oldlast = null;
       --size_of_Deque;
       return a;
   }// remove and return the item from the end

   public Iterator<Item> iterator(){
       //public boolean hasNext() eturn (first.next==null);}
       return new InnerIterator();
   }// return an iterator over items in order from front to end
private class InnerIterator implements Iterator<Item>{
    private Node thisnode = first;
    public boolean hasNext(){return thisnode.next!=last;}
    public Item next(){
        thisnode = thisnode.next;
        if (thisnode==last)
            throw new java.util.NoSuchElementException();
        return thisnode.item;}
    public void remove() {throw new java.lang.UnsupportedOperationException();}
}
   public static void main(String[] args){
       Deque iaa = new Deque();
       iaa.removeLast();
   }
       // unit testing

}

@273f327e5c533842f3087b9b4e106ff6@"
"r04631034","7","0.94","102256","@17814d21f6913dad4b85b22c5fca12a0@import java.util.Iterator;
import java.util.LinkedList;

/**
 *

 */
public class Deque<Item> implements Iterable<Item> {
    public LinkedList<Item> queue;
    public Deque(){
        queue = new LinkedList<Item>();
    }
    public boolean isEmpty() {
        if (queue.size()==0) {
            return true;
        }
        else{
            return false;
        }
    }
    public int size() {
        return queue.size();
    }
    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        else{
            queue.addFirst(item);
        }
    }
    public void addLast(Item item) {
        //Item item = null;
        queue.addLast(item);
    }
    public Item removeFirst() {
        if (queue.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        else{
            Item first;
            first = queue.getFirst();
            queue.removeFirst();
            return first;
        }
        
    }
    public Item removeLast() {
        if (queue.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        else{
            Item last;
            last = queue.getLast();
            queue.removeLast();
            return last;
        }
    }
    public Iterator iterator() {
        Iterator iterator;
        iterator = queue.iterator();
        return iterator;
        
    }
    public static void main(String[] args) {
        
    }

}
@17814d21f6913dad4b85b22c5fca12a0@"
"r04945022","0","1.14","177152","@69d6d5f71781b94b48fc05643f660d69@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private final DequeNode<Item> head;
    private final DequeNode<Item> tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode<Item>();
        tail = new DequeNode<Item>();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode<Item> first = head.next;
        final DequeNode<Item> node = new DequeNode<Item>();
        node.item = item;
        node.next = first;
        node.prev = head;
        head.next = node;
        first.prev = node;
        size++;
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode<Item> last = tail.prev;
        final DequeNode<Item> node = new DequeNode<Item>();
        node.item = item;
        node.next = tail;
        node.prev = last;
        tail.prev = node;
        last.next = node;
        size++;
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        final DequeNode<Item> first = head.next;
        final DequeNode<Item> next = first.next;
        next.prev = head;
        head.next = next;
        size--;

        return first.item;
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        final DequeNode<Item> last = tail.prev;
        final DequeNode<Item> prev = last.prev;
        tail.prev = prev;
        prev.next = tail;
        size--;

        return last.item;
     }
     
     
    private static class DequeNode<Item> {

        private Item item;

        private DequeNode<Item> next;

        private DequeNode<Item> prev;
    }
    
    
    public static void main(String[] args) throws IOException{
       
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
    private class ListIterator implements Iterator<Item>{
    private DequeNode<Item> current = head;
    public boolean hasNext() { return current != null; }
    public void remove() { /* not supported */ }
    public Item next()
    {
    Item item = current.item;
    current = current.next;
    return item;
    }
    }
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@69d6d5f71781b94b48fc05643f660d69@"
"r04631025","7","0.82","102464","@867c1e1abfadc57ac3ea9a928463c800@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) last = first;       
        N++;
    }

    public void addLast(Item item) {
        if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
       
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@867c1e1abfadc57ac3ea9a928463c800@"
"r04945022","0","1.17","178800","@577abad856a6467684feb7bea828058d@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private final DequeNode head;
    private final DequeNode tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode();
        tail = new DequeNode();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode first = head.next;
        final DequeNode node = new DequeNode();
        node.item = item;
        node.next = first;
        node.prev = head;
        head.next = node;
        first.prev = node;
        size++;
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
        final DequeNode last = tail.prev;
        final DequeNode node = new DequeNode();
        node.item = item;
        node.next = tail;
        node.prev = last;
        tail.prev = node;
        last.next = node;
        size++;
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        final DequeNode first = head.next;
        final DequeNode next = first.next;
        next.prev = head;
        head.next = next;
        size--;

        return first.item;
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        final DequeNode last = tail.prev;
        final DequeNode prev = last.prev;
        tail.prev = prev;
        prev.next = tail;
        size--;

        return last.item;
     }
     
     
    private class DequeNode {

        private Item item;

        private DequeNode next;

        private DequeNode prev;
    }
    
    
    public static void main(String[] args) throws IOException{
       
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
    private class ListIterator implements Iterator<Item>{
    private DequeNode current = head;
    public boolean hasNext() { return current != null; }
    public void remove() { 
        throw new UnsupportedOperationException();
    /* not supported */ 
    }
    public Item next()
    {
    Item item = current.item;
    current = current.next;
    return item;
    }
    }
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@577abad856a6467684feb7bea828058d@"
"r04631034","3","0.36","102480","@af636189816210abbecb6d0b8116d907@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

          /**
           * @param args the command line arguments
           */
          private Node first, last;
          private int N;

          private class Node {

                    Item item;
                    Node next;
                    Node Previous;
          }

          public Deque() {
                    first = null;
                    last = null;
                    N = 0;
          }

          public boolean isEmpty() {
                    return first == null;
          }

          public int size() {
                    return N;
          }

          public void addLast(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldlast = last;
                              last = new Node();
                              last.item = item;
                              last.next = null;
                              last.Previous = null;
                              if (isEmpty()) {
                                        first = last;
                              } else {
                                        oldlast.next = last;
                                        last.Previous = oldlast;
                              }
                              N++;
                    }
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldfirst = first;
                              first = new Node();
                              first.item = item;
                              first.next = null;
                              first.Previous = null;
                              if (isEmpty()) {
                                        first = last;
                              } else {
                                        oldfirst.Previous = first;
                                        first.next = oldfirst;
                              }
                              N++;
                    }
          }

          public Item removeFirst() {
                    if (N == 0) {
                              throw new java.util.NoSuchElementException();
                    } else {

                              if (N == 1) {
                                        Node oldfirst = first;
                                        first.Previous = null;
                                        first.next = null;
                                        N--;
                                        return oldfirst.item;
                              } else {
                                        Node oldfirst = first;
                                        first = first.next;
                                        first.Previous = null;
                                        N--;
                                        return oldfirst.item;
                              }
                    }
          }

          public Item removeLast() {
                    if (N == 0) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              if (N == 1) {
                                        Node oldlast = last;
                                        last.Previous = null;
                                        last.next = null;
                                        N--;
                                        return oldlast.item;
                              } else {
                                        Node oldlast = last;
                                        last = last.next;
                                        last.Previous = null;
                                        N--;
                                        return oldlast.item;
                              }
                    }
          }

          public Iterator<Item> iterator() {
                    return new ListIterator();

          }

          private class ListIterator implements Iterator<Item> {

                    private Node current = first;
                    private int count = 1;

                    public boolean hasNext() {
                              return current != null;
                    }

                    public void remove() { /* not supported */

                              throw new java.lang.UnsupportedOperationException();
                    }

                    public Item next() {
                              Item item = current.item;
                              current = current.next;
                              if (count != N) {
                                        return item;
                              } else {
                                        throw new java.util.NoSuchElementException();
                              }
                    }
          }

          public static void main(String[] args) {
                    // TODO code application logic here
          }

}

@af636189816210abbecb6d0b8116d907@"
"r04631036","7","1.14","178832","@e507fbec315a920a7f45b8e86192f1e7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {
    private Node<Item> curr = head;
    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      //if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } 
    else {
      tail = newHead;
    }
    head = newHead;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@e507fbec315a920a7f45b8e86192f1e7@"
"r04631036","1","0.95","102224","@edf68f36a866417958ac7bda7926ec76@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {
    private Node<Item> curr = head;
    public boolean hasNext() {
      return curr.right != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } 
    else {
      tail = newHead;
    }
    head = newHead;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@edf68f36a866417958ac7bda7926ec76@"
"r04631036","0","0","0","@2a12e1e3a34c5ebb1630de2437ab37f9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {
    private Node<Item> curr = head;
    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (curr.right==null) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } 
    else {
      tail = newHead;
    }
    head = newHead;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@2a12e1e3a34c5ebb1630de2437ab37f9@"
"r04631025","7","0.83","102560","@85ffda106ec80223c9d6183993748baf@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;



public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    //first of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) last = first;                   
        N++;
    }

    public void addLast(Item item) {
        if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = null;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public static void main(String[] args) {
       
    }
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

}

@85ffda106ec80223c9d6183993748baf@"
"r04631034","0","0.12","100064","@d6537f600f741b8cce9c91c2d8fb5cb0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

          /**
           * @param args the command line arguments
           */
          private Node first, last;
          private int N;

          private class Node {

                    Item item;
                    Node next;
                    Node Previous;
          }

          public Deque() {
                    first = null;
                    last = null;
                    N = 0;
          }

          public boolean isEmpty() {
                    return first == null;
          }

          public int size() {
                    return N;
          }

          public void addLast(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldlast = last;
                              last = new Node();
                              last.item = item;
                              last.next = null;
                              last.Previous = null;
                              if (isEmpty()) {
                                        first = last;
                              } else {
                                        oldlast.next = last;
                                        last.Previous = oldlast;
                              }
                              N++;
                    }
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldfirst = first;
                              first = new Node();
                              first.item = item;
                              first.next = null;
                              first.Previous = null;
                              if (isEmpty()) {
                                        first = last;
                              } else {
                                        oldfirst.Previous = first;
                                        first.next = oldfirst;
                              }
                              N++;
                    }
          }

          public Item removeFirst() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {

                              if (N == 1) {
                                        Node oldfirst = first;
                                        first.Previous = null;
                                        first.next = null;
                                        first.item=null;
                                        N--;
                                        return oldfirst.item;
                              } else {
                                        Node oldfirst = first;
                                        first = first.next;
                                        first.Previous = null;
                                        N--;
                                        return oldfirst.item;
                              }
                    }
          }

          public Item removeLast() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              if (N == 1) {
                                        Node oldlast = last;
                                        last.Previous = null;
                                        last.next = null;
                                        last.item=null;
                                        N--;
                                        return oldlast.item;
                              } else {
                                        Node oldlast = last;
                                        last = last.Previous;
                                        last.next = null;
                                        N--;
                                        return oldlast.item;
                              }
                    }
          }

          public Iterator<Item> iterator() {
                    return new ListIterator();

          }

          private class ListIterator implements Iterator<Item> {

                    private Node current = first;
                    private int count = 1;

                    public boolean hasNext() {
                              return current != null;
                    }

                    public void remove() { /* not supported */

                              throw new java.lang.UnsupportedOperationException();
                    }

                    public Item next() {
                              Item item = current.item;
                              current = current.next;
                              count ++;
                              if (count != N) {
                                        return item;
                              } else {
                                        throw new java.util.NoSuchElementException();
                              }
                    }
          }

          public static void main(String[] args) {
                    // TODO code application logic here
          }

}

@d6537f600f741b8cce9c91c2d8fb5cb0@"
"b03611041","8","1.36","180832","@c9bda4d983991a879cca3ca4f19de93f@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        if(isEmpty()){
            first=last;
        }else {
            last.prev=oldlast;
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            first=first.next;
            if(N==1)
                last=first;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            last=last.prev;
            if(N==1)
                first=last;
        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@c9bda4d983991a879cca3ca4f19de93f@"
"r04631036","1","0.94","102368","@c802e4b7a41e8219141445d786b4eb89@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {
    private Node<Item> curr = head.right;
    public boolean hasNext() {
      return curr != tail;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } 
    else {
      tail = newHead;
    }
    head = newHead;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@c802e4b7a41e8219141445d786b4eb89@"
"r04631036","0","0.47","102528","@4218c44ec054750c4ffe1d862677c555@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {
    private Node<Item> curr = head.right;
    public boolean hasNext() {
      return curr != tail;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> toadd = new Node<Item>(item);
    Node<Item> before = head.right;
    head.right = toadd;
    toadd.left = head;
    before.left = toadd;
    toadd.right = before;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> togo = head.right;
    head.right = togo.right;
    head.right.left = head;
    togo.left = null;
    togo.right = null;
    return togo.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@4218c44ec054750c4ffe1d862677c555@"
"r04631036","0","0","0","@7757e178c71b11ee8c1997e33771348a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    public static void main(String[] args) {
        // TODO code application logic here
    }
     private final Node<Item> head = new Node<>(null);
  private final Node<Item> tail = new Node<>(null);
  private int size = 0;
    private class DequeIterator implements Iterator<Item> {
        
    private Node<Item> curr = head.right;
    public boolean hasNext() {
      return curr != tail;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  //private Node<Item> head, tail;
  //private int size;

  public Iterator<Item> iterator() {      
    return new DequeIterator();    
  }

  public Deque() {
       head.right = tail;
    tail.left  = head;
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> toadd = new Node<Item>(item);
    Node<Item> before = head.right;
    head.right = toadd;
    toadd.left = head;
    before.left = toadd;
    toadd.right = before;
    size++;
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      
        //head = newTail;
    }
    //tail = newTail;
    size++;
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> togo = head.right;
    head.right = togo.right;
    head.right.left = head;
    togo.left = null;
    togo.right = null;
    return togo.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    //tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    return prevTail.item;
  }
}
@7757e178c71b11ee8c1997e33771348a@"
"r04631036","1","0.12","98480","@bb4b3518e115f2e3fea96774dfa0e7f1@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()|| curr.right==null) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    //checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    //checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    //checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    //checkInvariants();
    return prevTail.item;
  }
}
@bb4b3518e115f2e3fea96774dfa0e7f1@"
"r04631036","7","1.16","177104","@d6d75d60a8921627debed02536075be7@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext() && curr.right==null) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    //checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    //checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    //checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    //checkInvariants();
    return prevTail.item;
  }
}
@d6d75d60a8921627debed02536075be7@"
"r04631036","9","1.38","184640","@e04de4eb63504ad7fcd282be56ffdead@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<Item> head, tail;
  private int size;

  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    //checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    //checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    //checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    //checkInvariants();
    return prevTail.item;
  }
}
@e04de4eb63504ad7fcd282be56ffdead@"
"r04945022","8","1.16","179136","@e082ce88f0cb33a100f77dade2a96999@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private DequeNode head;
    private DequeNode tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode();
        tail = new DequeNode();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
         if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
			size++;
       
         }
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
       if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.next = null;
			newNode.prev = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = tail;
			newNode.next = null;
			tail.next = newNode;
			tail = newNode;
			size++;
		}
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
            if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = head.item;
			DequeNode temp = head.next;
			head.next.prev = null;
			head.next = null;
			head = temp;
			size--;
			return item;
		}
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = tail.item;
			DequeNode temp = tail.prev;
			tail.prev.next = null;
			tail.prev = null;
			tail = temp;
			size--;
			return item;
		}
     }
     
     
    private class DequeNode {

        private Item item;

        private DequeNode next;

        private DequeNode prev;
    }
    
    
    public static void main(String[] args) throws IOException{
       
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
    private class ListIterator implements Iterator<Item>{
    private DequeNode current = head;
    public boolean hasNext() { return current != null; }
    public void remove() { 
        throw new UnsupportedOperationException();
    /* not supported */ 
    }
    public Item next()
    {
    Item item = current.item;
    current = current.next;
    return item;
    }
    }
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@e082ce88f0cb33a100f77dade2a96999@"
"r04945022","8","1.17","179440","@7d31b9c040e20fa3c17f4133ec2b3ad2@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private DequeNode head;
    private DequeNode tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode();
        tail = new DequeNode();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
         if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
			size++;
       
         }
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
       if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.next = null;
			newNode.prev = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = tail;
			newNode.next = null;
			tail.next = newNode;
			tail = newNode;
			size++;
		}
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
            if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = head.item;
			DequeNode temp = head.next;
			head.next.prev = null;
			head.next = null;
			head = temp;
			size--;
			return item;
		}
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = tail.item;
			DequeNode temp = tail.prev;
			tail.prev.next = null;
			tail.prev = null;
			tail = temp;
			size--;
			return item;
		}
     }
     
     
    private class DequeNode {

        private Item item;

        private DequeNode next;

        private DequeNode prev;
    }
    
    
    public static void main(String[] args) throws IOException{
       
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
    private class ListIterator implements Iterator<Item>{
    private DequeNode current = head;
    public boolean hasNext() { return current != null; }
    public void remove() { 
        throw new UnsupportedOperationException();
    /* not supported */ 
    }
    public Item next()
    {
    Item item = current.item;
    current = current.next;
    return item;
    }
    }
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@7d31b9c040e20fa3c17f4133ec2b3ad2@"
"r04631036","9","1.4","176256","@d2b54561ebe27fb701476609b3646056@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

/**
 *
 * @author Arthur
 */

public class Deque<Item> implements Iterable<Item> {
      private Node<Item> head, tail;
  private int size;

    private class Node<Item>{
        public Node<Item> left,right;
        private final Item item;
        public Node(Item item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }
          public void connectRight(Node<Item> other) {
      this.right = other;
      other.left = this;
    }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    
    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

    private Node<Item> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public Item next() {
      if (!hasNext()) { throw new NoSuchElementException (); }
      Item item = curr.item;
      curr = curr.right;
      return item;
    }
  }


  public Iterator<Item> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }
  public void addFirst(Item item) {
    Node<Item> prevHead = head;
    Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    //checkInvariants();
  }

  public void addLast(Item item) {
    Node<Item> newTail = new Node<Item>(item);
    Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    //checkInvariants();
  }

  public Item removeFirst() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    //checkInvariants();
    return prevHead.item;
  }

  public Item removeLast() {
    if (isEmpty()) {
      throw new NoSuchElementException();
    }
    size--;
    Node<Item> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    //checkInvariants();
    return prevTail.item;
  }
}
@d2b54561ebe27fb701476609b3646056@"
"r04631036","9","1.41","179472","@f5fd50e9ca310fa130793ebad10f3809@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    //@Override
//    public Iterator iterator() {
//        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
//    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        //checkInvariants();
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        //checkInvariants();
        return prevTail.item;
    }
}

@f5fd50e9ca310fa130793ebad10f3809@"
"r04631021","1","0.84","102336","@afac5c064787933c8a6faa5b705eade4@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) first = last ;
        else first.next = oldfirst ;
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@afac5c064787933c8a6faa5b705eade4@"
"r04631021","1","0.84","102384","@327bdaa882feb1352cc0ce3d7b8cb6c3@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) first = last ;
        else first.next = oldfirst ;
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last.next;            // delete first node
        N--;
        if (isEmpty()) first = null; 
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@327bdaa882feb1352cc0ce3d7b8cb6c3@"
"b03611003","0","1.41","179472","@f4c79764d746e549e02813ec21ec6610@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deques<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deques() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing

    }
}

@f4c79764d746e549e02813ec21ec6610@"
"r04631036","9","1.39","172560","@49632ba9560c90beb3daff80f988ff52@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@49632ba9560c90beb3daff80f988ff52@"
"r04631036","1","0.24","98416","@025fe4c4c2f5315ed970e160ea51f8d3@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext() || curr.left!=null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@025fe4c4c2f5315ed970e160ea51f8d3@"
"r04631036","1","0.24","102176","@a6861b68b86ccd1848a6496170ef6a9e@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext() || curr.right!=null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@a6861b68b86ccd1848a6496170ef6a9e@"
"r04631036","1","0.12","102480","@3131467fc98a0ed5f683d20b2af4f058@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext() || curr.right==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@3131467fc98a0ed5f683d20b2af4f058@"
"r04631036","1","0.12","100864","@71c82d74e89acfdce1db6985e8fd21b8@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext() || curr.left==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}
 
@71c82d74e89acfdce1db6985e8fd21b8@"
"r03945012","10","0.142","181488","@9998e9a04a9a75039b881a3831d1cdb7@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw04_Deque
 *
 * @author Robert
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;
    private Node<Item> last;
    private int N;

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        // is the deque empty?
        //return first == null || last == null;
        return size()==0;
    }

    public int size() {
        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {
        // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) {
            last = first;
        }
        else {
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        // new a memory to store
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) {
            first = last;
        }
        else {
            oldlast.next = last;    
        }
        N++;
    }

    public Item removeFirst() {
        // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Item removeLast() {
        // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.pre;
        last.next = null;
        if (size()==1){
            last = null;
            first = null;
        }
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            //StdOut.println(current);
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        // Test first in first out
        Deque<Integer> q = new Deque<> ();
        q.addLast(2);
        q.addLast(3);
        //q.addFirst(4567);
        Iterator it;
        it = q.iterator();
        StdOut.println(it.next());
        StdOut.println(it.next());
        //StdOut.println(it.next());        
        StdOut.println(""delete:""+ q.removeLast());
        Iterator it2;
        it2 = q.iterator();
        StdOut.println(it2.next());
//        StdOut.println(it2.next());
//        StdOut.println(it2.next());
//        StdOut.println(it.next());
//        StdOut.println(it.next());
        //StdOut.println(q.removeFirst());
//        StdOut.println(q.removeFirst());
//        q.addFirst(5);
//        q.addLast(6);
//        StdOut.println(q.removeLast());
//        StdOut.println(q.removeFirst());
//        StdOut.println(""("" + q.size() + "" left on queue)"");
    }

}

@9998e9a04a9a75039b881a3831d1cdb7@"
"r04631036","1","0.95","102352","@74080ff455fc5bb60070649a40d2559d@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr.right != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@74080ff455fc5bb60070649a40d2559d@"
"b03611003","0","0.12","100864","@71d6fc029eda7a832f06b74cac9d072e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package deques;

import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deques<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deques() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing

    }
}

@71d6fc029eda7a832f06b74cac9d072e@"
"r04631036","0","0","0","@5da40b29d2f2be27bf5d990f38a6e9ce@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return this != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@5da40b29d2f2be27bf5d990f38a6e9ce@"
"b03611003","0","0.95","102352","@e00f25ad5cc6e2b49dbe178843930208@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package deque;

import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing

    }
}

@e00f25ad5cc6e2b49dbe178843930208@"
"b01502105","6","0.69","102432","@2cfd67cd251f3f5f090ac3b530725a92@import java.lang.Iterable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.BufferedReader;
import java.io.FileReader;

public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    public boolean isEmpty() {                 // is the deque empty?
        return (N==0);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front

        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        
        if (isEmpty()) {first.next = null; last = first;}
        else{
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end

        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {last.previous = null; first = last;}
        else{
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Deque first underflow"");
        Item item = first.item;
        first = first.next;
        first.previous = null;
        N--;
        if (isEmpty()) {last = null; first = null;}
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Deque last underflow"");
        Item item = last.item;
        last = last.previous;
        last.next = null;
        N--;
        if (isEmpty()) {first = null; last = null;}
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
//            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public static void main(String[] args) {
      Deque<String> s = new Deque<String>();
      try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            StringBuilder everything = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                everything.append(line);
                everything.append("" "");
            }
            String[] data = everything.toString().split("" "");
            for(int i=0;i<data.length;i++){
                String item = data[i];               
                if (item.equals(""fa"")||item.equals(""fb"")||item.equals(""fc"")) s.addFirst(item); 
                else if (item.equals(""f-"")) StdOut.print(s.removeFirst() + "" "");
                else if (item.equals(""la"")||item.equals(""lb"")||item.equals(""lc"")) s.addLast(item);
                else if (item.equals(""l-"")) StdOut.print(s.removeLast() + "" "");           
                else throw new NoSuchElementException();
            }
      }
      catch(Exception ex){
          StdOut.println(""something wrong!!"");
      }
      System.out.printf(""\n"");
      Iterator<String> i = s.iterator();
      while (i.hasNext()){
            String a = i.next();
            System.out.printf(a + "" "");
      }
      System.out.printf(""\n"");
      System.out.println(""deque size = "" + s.size());
    }
}

@2cfd67cd251f3f5f090ac3b530725a92@"
"r04631036","9","1.35","181600","@b64e5d25ffb814ec98919b2173c31cce@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()||curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@b64e5d25ffb814ec98919b2173c31cce@"
"r04631036","8","1.39","183568","@0aeebe008de5277c85c97e1790c4d5df@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()||this.tail==null) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@0aeebe008de5277c85c97e1790c4d5df@"
"r04631023","10","0.162","180432","@bc2799cc7672d329ea46ae46784e499b@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    
    private Node<Item> first = null;
    private Node<Item> last = null;
    private int N = 0;
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;

        public Node(Item i, Node<Item> n) {
            item = i;
            next = n;
        }
    }

    public Deque() {
    }// construct an empty deque

    public boolean isEmpty() {
        return first == null && last == null;
    } // is the deque empty?


    public int size() {
        return N ;
    }// return the number of items on the deque


    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            first = new Node<Item>(item, last);
        } else {
            final Node<Item> newFirst = new Node<Item>(item, first);
            first = newFirst;
            if (last == null) {
                last = first.next;
            }
        }
        if (last == null) {
            last = first;
        }
        N++;
    }// add the item to the front


    public void addLast(Item item) {
    if (item == null) {
            throw new NullPointerException();
        }
        if (last == null) {
            last = new Node<Item>(item, null);
            if (first != null) {
                first.next = last;
            }
        } else {
            final Node<Item> newLast = new Node<Item>(item, null);
            final Node<Item> oldLast = last;
            oldLast.next = newLast;
            last = newLast;
            if (first == null) {
                first = oldLast;
            }
        }
        if (first == null) {
            first = last;
        }
        N++;
    }// add the item to the end


    public Item removeFirst() {
    if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Node<Item> oldFirst = first;
        if (oldFirst == last) {
            first = null;
            last = null;
        } else {
            Node<Item> newFirst = first.next;
            first = newFirst;
        }
        N--;
        return oldFirst.item;
    }// remove and return the item from the front


    public Item removeLast() {
    if (isEmpty()) {
            throw new NoSuchElementException();
        }
        final Node<Item> oldLast = last;
        if (first == last) {
            first = null;
            last = null;
        } else if (first != null) {
            Node<Item> newLast = first;
            while (newLast.next != null && newLast.next != last) {
            newLast = newLast.next;
        }
            newLast.next = null;
            last = newLast;
        } else {
            last = null;
        }
        N--;

        if (oldLast != null) {
            return oldLast.item;
        } else {
            return first.item;
        }
    }// remove and return the item from the end

    public Iterator<Item> iterator() {
        return new NodeIterator<Item>(this);
    }

    private class NodeIterator<Item> implements Iterator<Item> {
        private Node<Item> next;

        public NodeIterator(final Deque<Item> deque) {
            if (deque.first != null) {
                this.next = (Node<Item>) deque.first;
            } else {
                this.next = (Node<Item>) deque.last;
            }
        }
        public boolean hasNext() {
            return next != null;
        }
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            final Item item = next.item;
            next = next.next;
            return item;
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}
@bc2799cc7672d329ea46ae46784e499b@"
"r04631036","8","1.4","174656","@5bf54f9c2b30c5c8c7b6cf175ed3b424@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()||this.tail==null) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()||this.tail==null) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@5bf54f9c2b30c5c8c7b6cf175ed3b424@"
"r04631036","1","0.12","99152","@fa5262a05ce6432858e05468d359927a@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null || curr.left==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@fa5262a05ce6432858e05468d359927a@"
"b03611003","0","0","0","@366b74d1bf5db10083435e6d4c34fffd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing

    }
}

@366b74d1bf5db10083435e6d4c34fffd@"
"r04631034","8","1.15","184240","@6475cd5e81192d85e94a00c52ee848df@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

          /**
           * @param args the command line arguments
           */
          private Node first, last;
          private int N;

          private class Node {

                    Item item;
                    Node next;
                    Node Previous;
          }

          public Deque() {
                    first = null;
                    last = null;
                    N = 0;
          }

          public boolean isEmpty() {
                    return N == 0;
          }

          public int size() {
                    return N;
          }

          public void addLast(Item item) {
//                    if (item == null) {
//                              throw new java.lang.NullPointerException();
//                    } else {
                    Node oldlast = last;
                    last = new Node();
                    last.item = item;
                    last.next = null;
                    last.Previous = null;
                    if (isEmpty()) {
                              first = last;
                    } else {
                              oldlast.next = last;
                              last.Previous = oldlast;
                    }
                    N++;
//                    }
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldfirst = first;
                              first = new Node();
                              first.item = item;
                              first.next = null;
                              first.Previous = null;
                              if (isEmpty()) {
                                        last = first;
                              } else {
                                        oldfirst.Previous = first;
                                        first.next = oldfirst;
                              }
                              N++;
                    }
          }

          public Item removeFirst() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {

                              if (N == 1) {
                                        Node oldfirst = first;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldfirst.item;
                              } else {
                                        Node oldfirst = first;
                                        first = first.next;
                                        first.Previous = null;
                                        N--;
                                        return oldfirst.item;
                              }
                    }
          }

          public Item removeLast() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              if (N == 1) {
                                        Node oldlast = last;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldlast.item;
                              } else {
                                        Node oldlast = last;
                                        last = oldlast.Previous;
                                        last.next = null;
                                        N--;
                                        return oldlast.item;
                              }
                    }
          }

          public Iterator<Item> iterator() {
                    return new ListIterator();

          }

          private class ListIterator implements Iterator<Item> {

                    private Node current = first;

                    public boolean hasNext() {
                              return current != null;
                    }

                    public void remove() { /* not supported */

                              throw new java.lang.UnsupportedOperationException();
                    }

                    public Item next() {
                              Item item = current.item;
                              current = current.next;
                              if (item != null) {
                                        return item;
                              } else {
                                        throw new java.util.NoSuchElementException();
                              }

                    }
          }

          public static void main(String[] args) {
//                    // TODO code application logic here
//                    Deque<Integer> dq = new Deque<Integer>();
//                    dq.addFirst(1);
//
//                    dq.addLast(2);
//                    dq.addLast(3);
//
//                    dq.addFirst(2);
//                    dq.addFirst(3);
//                    System.out.println(dq.isEmpty());
//
//                    Iterator iter = dq.iterator();
//                    while (iter.hasNext()) {
//                              System.out.println(iter.next());
//                    }
//                    System.out.println("""");
//                  
//                    System.out.println(dq.removeFirst());
//
//                    System.out.println("""");
          }

}

@6475cd5e81192d85e94a00c52ee848df@"
"r04631036","7","1.16","175760","@e515b1cffeed1071d5b166becb06deca@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
//            if (!hasNext()|| curr.item==null) {
//                throw new NoSuchElementException();
//            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@e515b1cffeed1071d5b166becb06deca@"
"r04631036","1","0.12","98432","@f3533cf735ba5349d0ddb135dbe4e350@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null || curr.right == null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@f3533cf735ba5349d0ddb135dbe4e350@"
"r04631036","1","0.12","101504","@4e0eee4eee3cdfc09d049ef4c8b37c4d@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null ||(hasNext() && curr.right==null)) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@4e0eee4eee3cdfc09d049ef4c8b37c4d@"
"r04631036","9","1.38","176736","@69264db16369c02bdd88ef443dbcec7f@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (hasNext()) {
                Item item = curr.item;
                curr = curr.right;
                return item;

            } else {
                throw new NoSuchElementException();
            }
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head = null;
        this.tail = null;
        size = 0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@69264db16369c02bdd88ef443dbcec7f@"
"r04631036","1","0.95","102512","@a131ccb3e7d41b0e6c39a1141d0b1ff7@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr.right != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (hasNext()) {
                Item item = curr.item;
                curr = curr.right;
                return item;

            } else {
                throw new NoSuchElementException();
            }
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head = null;
        this.tail = null;
        size = 0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@a131ccb3e7d41b0e6c39a1141d0b1ff7@"
"r04631036","1","0.94","102336","@742a0f0989dafbf5a4a80dfffef626fa@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr.right != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (hasNext()) {
                Item item = curr.item;
                curr = curr.right;
                return item;

            } else {
                Item item = curr.item;
                return item;
            }
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head = null;
        this.tail = null;
        size = 0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@742a0f0989dafbf5a4a80dfffef626fa@"
"r04631036","7","1.13","179008","@2816525f7fcbe804b83375a8bf6a1814@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new UnsupportedOperationException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@2816525f7fcbe804b83375a8bf6a1814@"
"b01502105","7","1.44","175360","@9cf6707519313174f81a12cdcdd66062@import java.lang.Iterable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.BufferedReader;
import java.io.FileReader;

public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    public boolean isEmpty() {                 // is the deque empty?
        return (N==0);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front

        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        
        if (isEmpty()) {last = first;}
        else{
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end

        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {first = last;}
        else{
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
//        System.out.print(""removeFirst, N = ""+N+"" "");
        if (isEmpty()) throw new NoSuchElementException(""Deque first underflow"");
        Item item = first.item;
        if(N!=1){
            first = first.next;
            first.previous = null;
        }
        N--;
        if (isEmpty()) {last = null; first = null; return item;}
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
//        System.out.printf(""removeLast, N = ""+N+"" "");
        if (isEmpty()) throw new NoSuchElementException(""Deque last underflow"");
        Item item = last.item;
        if(N!=1){
            last = last.previous;
            last.next = null;
        }
        N--;
        if (isEmpty()) {first = null; last = null; return item;}
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public static void main(String[] args) {
      Deque<String> s = new Deque<String>();
      try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            StringBuilder everything = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                everything.append(line);
                everything.append("" "");
            }
            String[] data = everything.toString().split("" "");
            for(int i=0;i<data.length;i++){
                String item = data[i];               
                if (item.equals(""fa"")||item.equals(""fb"")||item.equals(""fc"")) s.addFirst(item); 
                else if (item.equals(""f-"")) StdOut.print(s.removeFirst() + "" "");
                else if (item.equals(""la"")||item.equals(""lb"")||item.equals(""lc"")) s.addLast(item);
                else if (item.equals(""l-"")) StdOut.print(s.removeLast() + "" "");           
                else throw new NoSuchElementException();
            }
            System.out.printf(""\n"");
      }
      catch(Exception ex){
          StdOut.println(""something wrong!!"");
      }
      Iterator<String> i = s.iterator();
      while (i.hasNext()){
            String a = i.next();
            System.out.printf(a + "" "");
      }
      System.out.printf(""\n"");
      System.out.println(""deque size = "" + s.size());
    }
}

@9cf6707519313174f81a12cdcdd66062@"
"r04631036","1","0.83","102384","@7359e762785cccfb94de91e80e555394@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr.right != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new UnsupportedOperationException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@7359e762785cccfb94de91e80e555394@"
"b03611003","0","1.14","182256","@ef9c580b4149e46d8bddc3c2c49b70d4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing
        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
        
    }
}

@ef9c580b4149e46d8bddc3c2c49b70d4@"
"r04631036","0","0","0","@67ce101e07bfc6e20ec20ffda89162be@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
        return prevTail.item;
    }
}

@67ce101e07bfc6e20ec20ffda89162be@"
"b03611003","0","0.72","102384","@4d5659765b2c8a341f453707886f0904@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }

    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        first.previous = null;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        last.next = null;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@4d5659765b2c8a341f453707886f0904@"
"r04631036","9","1.37","177648","@982ce3ecd2a8200ba3c593c02765524e@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        if(size==1)
            head.left=null;
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                if(size==1)
            head.right=null;
        return prevTail.item;
    }
}

@982ce3ecd2a8200ba3c593c02765524e@"
"r04631036","9","1.4","180960","@a1abff82ef90eb4c2c3600ca3b1ac2c6@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.left=null;
        size--;
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.right=null;
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@a1abff82ef90eb4c2c3600ca3b1ac2c6@"
"r04631036","9","1.4","176752","@a68dacee567410decc11a74af46d681d@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.left=null;
        size--;
        
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.right=null;
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@a68dacee567410decc11a74af46d681d@"
"r04631036","9","1.4","176624","@00625a9dfafca9fcae563186e1788a03@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.right=null;
        size--;
        
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.left=null;
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@00625a9dfafca9fcae563186e1788a03@"
"r04631036","9","1.42","170992","@257b344f70e895b207b284336e912e10@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
        {
            head.left=null;
            head.right=null;
        }
        size--;
        
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1){
            head.left=null;
            head.right=null;
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@257b344f70e895b207b284336e912e10@"
"r04631036","7","1.42","180272","@c416ced4426bc44bed8ad8359fe17e25@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            return curr != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
        {
            head.left=null;
            head.right=null;
            throw new java.util.NoSuchElementException();
        }
        size--;
        
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1){
            head.left=null;
            head.right=null;
            throw new java.util.NoSuchElementException();
        }
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@c416ced4426bc44bed8ad8359fe17e25@"
"r04631036","10","0.14","177872","@fa58c593852affe9833586e8dc39c3d8@

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.Queue;
import java.util.Stack;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head, tail;
    private int size;

    private class Node<Item> {

        public Node<Item> left, right;
        private final Item item;

        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) {
                throw new NullPointerException();
            }
            this.item = item;
        }

        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }
    private class DequeIterator implements Iterator<Item> {

        private Node<Item> curr = head;

        public boolean hasNext() {
            if(size!=0)
            return curr != null;
            else 
                return false;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()|| curr.item==null) {
                throw new NoSuchElementException();
            }
            Item item = curr.item;
            curr = curr.right;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public Deque() {
        this.head=null;
        this.tail=null;
        size=0;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public void addFirst(Item item) {
        Node<Item> prevHead = head;
        Node<Item> newHead = new Node<Item>(item);
//    if(item ==null)
//         throw new NullPointerException ();
        if (prevHead != null) {
            newHead.connectRight(prevHead);
        } else {
            tail = newHead;
        }
        head = newHead;
        size++;
        //checkInvariants();
    }

    public void addLast(Item item) {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = tail;
//        if(item ==null)
//         throw new NullPointerException ();
        if (prevTail != null) {
            prevTail.connectRight(newTail);
        } else {
            head = newTail;
        }
        tail = newTail;
        size++;
        //checkInvariants();
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.left=null;
        size--;
        
        Node<Item> prevHead = head;
        head = prevHead.right;
        prevHead.right = null;
        if (head != null) {
            head.left = null;
        }
        
        return prevHead.item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if(size==1)
            head.right=null;
        size--;
        Node<Item> prevTail = tail;
        tail = prevTail.left;
        prevTail.left = null;
        if (tail != null) {
            tail.right = null;
        }
                
        return prevTail.item;
    }
}

@fa58c593852affe9833586e8dc39c3d8@"
"b99611017","3","0.34","99392","@0ac5ea4122737734fd55138b6ba5ff09@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> starter=null;
        Node<Item> buff=null;
        last.next=starter;
        buff=last;
        last=starter;
        starter=buff;
        last.item=item;
        N++;

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        if (first.next == null || last.next == null) {
            first = null;
            last = null;
        }
        N--;
        return item;

    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@0ac5ea4122737734fd55138b6ba5ff09@"
"r04631006","0","1.42","180272","@89798199df38aadcf6a720545a93efc3@public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() { // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;

    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {          // add the item to the front
        if (item == null) {
            throw new NullPointerException(""Deque underflow"");
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        if (item == null) {
            throw new NullPointerException(""Deque underflow"");
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;

    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException(""Deque underflow"");
        }
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException(""Deque underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
        }
        return item;
    }

    public Iterator iterator() {      // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);

    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {   // unit testing

    }
}
@89798199df38aadcf6a720545a93efc3@"
"b03611003","6","0.68","102432","@606a3233467cf680e5d8e5ad362af43d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {     // add the item to the front
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst(){       // remove and return the item from the front
        Item A = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        Item A = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@606a3233467cf680e5d8e5ad362af43d@"
"b99611017","3","1.15","165744","@d492ca9c73d310fb54d3df4981017f2b@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldFirst = first;
        first = new Node<>();
        first.item = item;

        first.next = oldFirst;
        N++;

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldlast = last;
        last = new Node<>();

        last.next = oldlast;

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        if (first.next == null || last.next == null) {
            first = null;
            last = null;
        }
        N--;
        return item;

    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Deque test=new Deque();
        test.addFirst(1);
        test.addFirst(123);
        test.addLast(654);
        System.out.println(test.size());
        // TODO code application logic here
    }

}

@d492ca9c73d310fb54d3df4981017f2b@"
"r04631006","0","0.34","99392","@6b55f3308fc4e2a704be02427c677e4a@public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() { // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;

    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {          // add the item to the front
        if (item == null) {
            throw new  java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        if (item == null) {
            throw new  java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;

    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
        }
        return item;
    }

    public Iterator<Item> iterator() {      // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);

    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {   // unit testing

    }
}

@6b55f3308fc4e2a704be02427c677e4a@"
"r04631006","0","0.71","102512","@18bad6b288b513cd42ab1718795902d2@import java.util.Iterator;
//import java.util.NoSuchElementException;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() { // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;

    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {          // add the item to the front
        if (item == null) {
            throw new  java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        if (item == null) {
            throw new  java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;

    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
        }
        return item;
    }

    public Iterator<Item> iterator() {      // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);

    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {   // unit testing

    }
}

@18bad6b288b513cd42ab1718795902d2@"
"b03611003","7","0.82","100096","@689457c0de04ca3194b62530211ba594@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item){
        if(item == null){
            throw new java.lang.NullPointerException();
        }
    }
    
    public void addFirst(Item item) {     // add the item to the front
       checkadd(item);
       if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
       checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove(){
        if(isEmpty()){
            throw new java.util.NoSuchElementException();
        }
    }
    
    public Item removeFirst(){       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            if(current == null){
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
            throw new java.lang.UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@689457c0de04ca3194b62530211ba594@"
"r04631021","1","0.84","102432","@e86aa6f14511185492dc9a3699ceb8ba@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) first = last ;
        else first.next = oldfirst ;
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public boolean hasPrevious(){return current != null ;}
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           if(!hasPrevious())throw new NoSuchElementException();
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@e86aa6f14511185492dc9a3699ceb8ba@"
"b03611003","7","0.84","102544","@c8697f5a5e5a8829032a9a176afd0c0a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item){
        if(item == null){
            throw new NullPointerException();
        }
    }
    
    public void addFirst(Item item) {     // add the item to the front
       checkadd(item);
       if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
       checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove(){
        if(isEmpty()){
            throw new java.util.NoSuchElementException();
        }
    }
    
    public Item removeFirst(){       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        first = first.next;
        first.previous = null;
        N--;
        return A;        
    }

    public Item removeLast(){        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        last = last.previous;
        last.next = null;
        N--;
        return A;        
    }

    public Iterator iterator(){  // return an iterator over items in order from front to end
        return new Listiterator();        
    }
    
    public class Listiterator implements Iterator<Item>{
        private Node current = first;
        
        public boolean hasNext(){
            return current != null;
        }
        public Item next(){
            if(current == null){
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
        public void remove(){
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@c8697f5a5e5a8829032a9a176afd0c0a@"
"r04631006","0","0.72","102400","@472021ea904311355f4563fc30fbf60a@
import java.util.Iterator;
//import java.util.NoSuchElementException;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() { // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return first == null;

    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {          // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;

    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) {
            first = null;   // to avoid loitering
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;   // to avoid loitering
        }
        return item;
    }

    public Iterator<Item> iterator() {      // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);

    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {   // unit testing
        try {
            Deque de = new Deque();
            de.addFirst(""you"");
            de.addFirst(""are"");
            System.out.printf(""%s"", de.removeFirst());
//            System.out.printf(""%s"", de.removeLast());
            de.removeLast();
        } catch (java.util.NoSuchElementException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}
@472021ea904311355f4563fc30fbf60a@"
"r04631004","0","0.84","102432","@b7a30de898e15c48f5af5e83fe1a3721@import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Po-Lin
 */
public class Deques<Item> implements Iterable<Item> {

    private Node<Item> head;     // top of Deques
    private Node<Item> tail;      //down of Deques
    private int N;                // size of the Deques

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> left;
        private Node<Item> right;
    }

    /**
     * Initializes an empty Deques.
     */
    public Deques() {
        head = null;
        tail = null;
        N = 0;
    }

    /**
     * Returns true if this stack is empty.
     *
     * @return true if this Deques is empty; false otherwise
     */
    public boolean isEmpty() {
        return (head == null && tail == null);
    }

    /**
     * Returns the number of items in this stack.
     *
     * @return the number of items in this Deques
     */
    public int size() {
        return N;
    }

    /**
     * Adds the item to this Deques.
     *
     * @param item the item to add
     */
    public void addFirst(Item item) {   //addFirst
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            head = new Node<Item>();
            tail = head;
            head.item = item;
            head.right = null;
            N++;
        } else {
            Node<Item> oldfirst = head;
            head = new Node<Item>();
            head.item = item;
            head.right = oldfirst;
            oldfirst.left = head;
            N++;
        }
    }

    public void addLast(Item item) {   //addLast
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            tail = new Node<Item>();
            head = tail;
            tail.item = item;
            tail.left = null;
            N++;
        } else {
            Node<Item> oldfirst = tail;
            tail = new Node<Item>();
            tail.item = item;
            tail.left = oldfirst;
            oldfirst.right = tail;
            N++;
        }
    }

    /**
     * Removes and returns the item most recently added to this Deques.
     *
     * @return the item most recently added
     * @throws NoSuchElementException if this stack is empty
     */
    public Item removeFirst() {  //removeFirst() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = head.item;        // save item to return
        // delete first node
        if (head.right != null) {
            head = head.right;
            head.left = null;
        } else {
            tail = null;
            head = null;
        }
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() {  //removeLast() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = tail.item;        // save item to return
        // delete first node
        if (tail.left != null) {
            tail = tail.left;
            tail.right = null;
        } else {
            tail = null;
            head = null;
        }

        N--;
        return item;                   // return the saved item
    }

    /**
     * Returns an iterator to this stack that iterates through the items in LIFO
     * order.
     *
     * @return an iterator to this stack that iterates through the items in LIFO
     * order
     */
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(head);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> head) {
            current = head;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }

    /**
     * Unit tests the <tt>Stack</tt> data type.
     */
    public static void main(String[] args) {
        
    }
}

@b7a30de898e15c48f5af5e83fe1a3721@"
"b03611003","0","0.84","102432","@aed760607dd87b924d8dc3b459879f65@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            first = first.next;
            first.previous = null;
            N--;
            return A;
        }
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            last = last.previous;
            last.next = null;
            N--;
            return A;
        }
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@aed760607dd87b924d8dc3b459879f65@"
"b03611003","7","1.06","102416","@0fdbd57c32910b41378bc1c31ac930a6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            first = first.next;
            first.previous = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            last = last.previous;
            last.next = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@0fdbd57c32910b41378bc1c31ac930a6@"
"r04631004","0","0.72","102400","@b7a30de898e15c48f5af5e83fe1a3721@import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Po-Lin
 */
public class Deques<Item> implements Iterable<Item> {

    private Node<Item> head;     // top of Deques
    private Node<Item> tail;      //down of Deques
    private int N;                // size of the Deques

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> left;
        private Node<Item> right;
    }

    /**
     * Initializes an empty Deques.
     */
    public Deques() {
        head = null;
        tail = null;
        N = 0;
    }

    /**
     * Returns true if this stack is empty.
     *
     * @return true if this Deques is empty; false otherwise
     */
    public boolean isEmpty() {
        return (head == null && tail == null);
    }

    /**
     * Returns the number of items in this stack.
     *
     * @return the number of items in this Deques
     */
    public int size() {
        return N;
    }

    /**
     * Adds the item to this Deques.
     *
     * @param item the item to add
     */
    public void addFirst(Item item) {   //addFirst
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            head = new Node<Item>();
            tail = head;
            head.item = item;
            head.right = null;
            N++;
        } else {
            Node<Item> oldfirst = head;
            head = new Node<Item>();
            head.item = item;
            head.right = oldfirst;
            oldfirst.left = head;
            N++;
        }
    }

    public void addLast(Item item) {   //addLast
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            tail = new Node<Item>();
            head = tail;
            tail.item = item;
            tail.left = null;
            N++;
        } else {
            Node<Item> oldfirst = tail;
            tail = new Node<Item>();
            tail.item = item;
            tail.left = oldfirst;
            oldfirst.right = tail;
            N++;
        }
    }

    /**
     * Removes and returns the item most recently added to this Deques.
     *
     * @return the item most recently added
     * @throws NoSuchElementException if this stack is empty
     */
    public Item removeFirst() {  //removeFirst() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = head.item;        // save item to return
        // delete first node
        if (head.right != null) {
            head = head.right;
            head.left = null;
        } else {
            tail = null;
            head = null;
        }
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() {  //removeLast() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = tail.item;        // save item to return
        // delete first node
        if (tail.left != null) {
            tail = tail.left;
            tail.right = null;
        } else {
            tail = null;
            head = null;
        }

        N--;
        return item;                   // return the saved item
    }

    /**
     * Returns an iterator to this stack that iterates through the items in LIFO
     * order.
     *
     * @return an iterator to this stack that iterates through the items in LIFO
     * order
     */
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(head);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> head) {
            current = head;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }

    /**
     * Unit tests the <tt>Stack</tt> data type.
     */
    public static void main(String[] args) {
        
    }
}

@b7a30de898e15c48f5af5e83fe1a3721@"
"r04631004","0","0.72","102400","@9aa6546073d15967f5661bd967a64c5a@

import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Po-Lin
 */
public class Deques<Item> {

    private Node<Item> head;     // top of Deques
    private Node<Item> tail;      //down of Deques
    private int N;                // size of the Deques

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> left;
        private Node<Item> right;
    }

    /**
     * Initializes an empty Deques.
     */
    public Deques() {
        head = null;
        tail = null;
        N = 0;
    }

    /**
     * Returns true if this stack is empty.
     *
     * @return true if this Deques is empty; false otherwise
     */
    public boolean isEmpty() {
        return (head == null && tail == null);
    }

    /**
     * Returns the number of items in this stack.
     *
     * @return the number of items in this Deques
     */
    public int size() {
        return N;
    }

    /**
     * Adds the item to this Deques.
     *
     * @param item the item to add
     */
    public void addFirst(Item item) {   //addFirst
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            head = new Node<Item>();
            tail = head;
            head.item = item;
            head.right = null;
            N++;
        } else {
            Node<Item> oldfirst = head;
            head = new Node<Item>();
            head.item = item;
            head.right = oldfirst;
            oldfirst.left = head;
            N++;
        }
    }

    public void addLast(Item item) {   //addLast
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            tail = new Node<Item>();
            head = tail;
            tail.item = item;
            tail.left = null;
            N++;
        } else {
            Node<Item> oldfirst = tail;
            tail = new Node<Item>();
            tail.item = item;
            tail.left = oldfirst;
            oldfirst.right = tail;
            N++;
        }
    }

    /**
     * Removes and returns the item most recently added to this Deques.
     *
     * @return the item most recently added
     * @throws NoSuchElementException if this stack is empty
     */
    public Item removeFirst() {  //removeFirst() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = head.item;        // save item to return
        // delete first node
        if (head.right != null) {
            head = head.right;
            head.left = null;
        } else {
            tail = null;
            head = null;
        }
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() {  //removeLast() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = tail.item;        // save item to return
        // delete first node
        if (tail.left != null) {
            tail = tail.left;
            tail.right = null;
        } else {
            tail = null;
            head = null;
        }

        N--;
        return item;                   // return the saved item
    }

    /**
     * Returns an iterator to this stack that iterates through the items in LIFO
     * order.
     *
     * @return an iterator to this stack that iterates through the items in LIFO
     * order
     */
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(head);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> head) {
            current = head;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }

    /**
     * Unit tests the <tt>Stack</tt> data type.
     */
    public static void main(String[] args) {
        
    }
}

@9aa6546073d15967f5661bd967a64c5a@"
"r04631004","10","0.14","174096","@53eb4a1067f69e064230ba5fd0fe3099@
import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Po-Lin
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> head;     // top of Deques
    private Node<Item> tail;      //down of Deques
    private int N;                // size of the Deques

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> left;
        private Node<Item> right;
    }

    /**
     * Initializes an empty Deques.
     */
    public Deque() {
        head = null;
        tail = null;
        N = 0;
    }

    /**
     * Returns true if this stack is empty.
     *
     * @return true if this Deques is empty; false otherwise
     */
    public boolean isEmpty() {
        return (head == null && tail == null);
    }

    /**
     * Returns the number of items in this stack.
     *
     * @return the number of items in this Deques
     */
    public int size() {
        return N;
    }

    /**
     * Adds the item to this Deques.
     *
     * @param item the item to add
     */
    public void addFirst(Item item) {   //addFirst
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            head = new Node<Item>();
            tail = head;
            head.item = item;
            head.right = null;
            N++;
        } else {
            Node<Item> oldfirst = head;
            head = new Node<Item>();
            head.item = item;
            head.right = oldfirst;
            oldfirst.left = head;
            N++;
        }
    }

    public void addLast(Item item) {   //addLast
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            tail = new Node<Item>();
            head = tail;
            tail.item = item;
            tail.left = null;
            N++;
        } else {
            Node<Item> oldfirst = tail;
            tail = new Node<Item>();
            tail.item = item;
            tail.left = oldfirst;
            oldfirst.right = tail;
            N++;
        }
    }

    /**
     * Removes and returns the item most recently added to this Deques.
     *
     * @return the item most recently added
     * @throws NoSuchElementException if this stack is empty
     */
    public Item removeFirst() {  //removeFirst() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = head.item;        // save item to return
        // delete first node
        if (head.right != null) {
            head = head.right;
            head.left = null;
        } else {
            tail = null;
            head = null;
        }
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() {  //removeLast() 
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = tail.item;        // save item to return
        // delete first node
        if (tail.left != null) {
            tail = tail.left;
            tail.right = null;
        } else {
            tail = null;
            head = null;
        }

        N--;
        return item;                   // return the saved item
    }

    /**
     * Returns an iterator to this stack that iterates through the items in LIFO
     * order.
     *
     * @return an iterator to this stack that iterates through the items in LIFO
     * order
     */
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(head);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> head) {
            current = head;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }

    /**
     * Unit tests the <tt>Stack</tt> data type.
     */
    public static void main(String[] args) {
        
    }
}

@53eb4a1067f69e064230ba5fd0fe3099@"
"b03611003","0","1.06","102416","@bf7bf629abcb3c1f0a5c7c57d9f2d337@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package deque;

import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            first = first.next;
//            first.previous = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            last = last.previous;
//            last.next = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@bf7bf629abcb3c1f0a5c7c57d9f2d337@"
"b03611003","6","1.43","178848","@76e77b9e7bb349150d8ebe09d5ec2137@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            first = first.next;
//            first.previous = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            last = last.previous;
//            last.next = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@76e77b9e7bb349150d8ebe09d5ec2137@"
"r04631034","5","0.58","102480","@218755a658e5df46940a3427cc50192e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

     /**
      * @param args the command line arguments
      */
     private Node first, last;
     private int N;

     private class Node {

          Item item;
          Node next;
          Node Previous;
     }

     public Deque() {
          first = null;
          last = null;
          N = 0;
     }

     public boolean isEmpty() {
          return N == 0;
     }

     public int size() {
          return N;
     }

     public void addLast(Item item) {
//                    if (item == null) {
//                              throw new java.lang.NullPointerException();
//                    } else {
          Node oldlast = last;
          last = new Node();
          last.item = item;
          last.next = null;
          last.Previous = null;
          if (isEmpty()) {
               first = last;
          } else {
               oldlast.next = last;
               last.Previous = oldlast;
          }
          N++;
//                    }
     }

     public void addFirst(Item item) {
          if (item == null) {
               throw new java.lang.NullPointerException();
          } else {
               Node oldfirst = first;
               first = new Node();
               first.item = item;
               first.next = null;
               first.Previous = null;
               if (isEmpty()) {
                    first = last;
               } else {
                    oldfirst.Previous = first;
                    first.next = oldfirst;
               }
               N++;
          }
     }

     public Item removeFirst() {
          if (isEmpty()) {
               throw new java.util.NoSuchElementException();
          } else {

               if (N == 1) {
                    Node oldfirst = first;
                    first = null;
                    last = null;
                    N--;
                    return oldfirst.item;
               } else {
                    Node oldfirst = first;
                    first = first.next;
                    first.Previous = null;
                    N--;
                    return oldfirst.item;
               }
          }
     }

     public Item removeLast() {
          if (isEmpty()) {
               throw new java.util.NoSuchElementException();
          } else {
               if (N == 1) {
                    Node oldlast = last;
                    first = null;
                    last = null;
                    N--;
                    return oldlast.item;
               } else {
                    Node oldlast = last;
                    last = oldlast.Previous;
                    last.next = null;
                    N--;
                    return oldlast.item;
               }
          }
     }

     public Iterator<Item> iterator() {
          return new ListIterator();

     }

     private class ListIterator implements Iterator<Item> {

          private Node current = first;

          public boolean hasNext() {
               return current != null;
          }

          public void remove() { /* not supported */

               throw new java.lang.UnsupportedOperationException();
          }

          public Item next() {
               Item item = current.item;
               current = current.next;
               if (item != null) {
                    return item;
               } else {
                    throw new java.util.NoSuchElementException();
               }

          }
     }

     public static void main(String[] args) {
          // TODO code application logic here
//          Deque<Integer> dq = new Deque<Integer>();
//          System.out.println(""first"" + dq.isEmpty());
//
//          dq.addLast(4);
//          dq.addLast(5);
//          dq.addFirst(1);
//          dq.addFirst(2);
//
//          dq.addFirst(3);
//          System.out.println(""sec"" + dq.isEmpty());
////
//
////          while (iter.hasNext()) {
////               System.out.println(""iteraotr ""+iter.next());
////          }
////          System.out.println(""check"");
//          System.out.println(""remove "" + dq.removeFirst());
////          Iterator iter = dq.iterator();
////          while (iter.hasNext()) {
////               System.out.println(""iteraotr"" + iter.next());
////          }
//          System.out.println(""remove "" + dq.removeLast());
//          System.out.println(""remove "" + dq.removeLast());
//
//          System.out.println(""remove "" + dq.removeLast());
//
////          System.out.println(""remove "" + dq.removeLast());
//          System.out.println(""remove "" + dq.removeLast());
//
//          System.out.println(""check"");
//
//          dq.addLast(3);
//          dq.addFirst(1);
//          Iterator iter = dq.iterator();
//          while (iter.hasNext()) {
//               System.out.println(iter.next());
//               System.out.println(""check"");
//
//          }
//
//          System.out.println("""");
     }

}

@218755a658e5df46940a3427cc50192e@"
"r04631034","8","1.15","179200","@a0f2d43a27175c2335bef15b98e4262a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

          /**
           * @param args the command line arguments
           */
          private Node first, last;
          private int N;

          private class Node {

                    Item item;
                    Node next;
                    Node Previous;
          }

          public Deque() {
                    first = null;
                    last = null;
                    N = 0;
          }

          public boolean isEmpty() {
                    return N == 0;
          }

          public int size() {
                    return N;
          }

          public void addLast(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                    Node oldlast = last;
                    last = new Node();
                    last.item = item;
                    last.next = null;
                    last.Previous = null;
                    if (isEmpty()) {
                              first = last;
                    } else {
                              oldlast.next = last;
                              last.Previous = oldlast;
                    }
                    N++;
                    }
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldfirst = first;
                              first = new Node();
                              first.item = item;
                              first.next = null;
                              first.Previous = null;
                              if (isEmpty()) {
                                        last = first;
                              } else {
                                        oldfirst.Previous = first;
                                        first.next = oldfirst;
                              }
                              N++;
                    }
          }

          public Item removeFirst() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {

                              if (N == 1) {
                                        Node oldfirst = first;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldfirst.item;
                              } else {
                                        Node oldfirst = first;
                                        first = first.next;
                                        first.Previous = null;
                                        N--;
                                        return oldfirst.item;
                              }
                    }
          }

          public Item removeLast() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              if (N == 1) {
                                        Node oldlast = last;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldlast.item;
                              } else {
                                        Node oldlast = last;
                                        last = oldlast.Previous;
                                        last.next = null;
                                        N--;
                                        return oldlast.item;
                              }
                    }
          }

          public Iterator<Item> iterator() {
                    return new ListIterator();

          }

          private class ListIterator implements Iterator<Item> {

                    private Node current = first;

                    public boolean hasNext() {
                              return current != null;
                    }

                    public void remove() { /* not supported */

                              throw new java.lang.UnsupportedOperationException();
                    }

                    public Item next() {
                              Item item = current.item;
                              current = current.next;
                              if (item != null) {
                                        return item;
                              } else {
                                        throw new java.util.NoSuchElementException();
                              }

                    }
          }

          public static void main(String[] args) {
//                    // TODO code application logic here
//                    Deque<Integer> dq = new Deque<Integer>();
//                    dq.addFirst(1);
//
//                    dq.addLast(2);
//                    dq.addLast(3);
//
//                    dq.addFirst(2);
//                    dq.addFirst(3);
//                    System.out.println(dq.isEmpty());
//
//                    Iterator iter = dq.iterator();
//                    while (iter.hasNext()) {
//                              System.out.println(iter.next());
//                    }
//                    System.out.println("""");
//                  
//                    System.out.println(dq.removeFirst());
//
//                    System.out.println("""");
          }

}
@a0f2d43a27175c2335bef15b98e4262a@"
"b03611003","7","1.08","102320","@019fe4ae0b7afbe49daeb9015489b12f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldfirst = first;
            first = first.next;
            first.previous = null;
            oldfirst.next = null;
            oldfirst = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldlast = last;
            last = last.previous;
            last.next = null;
            oldlast.previous = null;
            oldlast = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@019fe4ae0b7afbe49daeb9015489b12f@"
"b03611003","7","1.07","102512","@e5a514d5249fd9ff252de450ce2bc1bb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return first == null;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldfirst = first;
            first = oldfirst.next;
            first.previous = null;
            oldfirst.next = null;
            oldfirst = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldlast = last;
            last = oldlast.previous;
            last.next = null;
            oldlast.previous = null;
            oldlast = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@e5a514d5249fd9ff252de450ce2bc1bb@"
"b03611003","7","0.95","102384","@ffb2419ec53b5d3fd11e28673fb7d7c6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N = 0;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return N == 0;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldfirst = first;
            first = oldfirst.next;
            first.previous = null;
            oldfirst.next = null;
            N--;
        }
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldlast = last;
            last = oldlast.previous;
            last.next = null;
            oldlast.previous = null;
            N--;
        }
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@ffb2419ec53b5d3fd11e28673fb7d7c6@"
"b03611003","10","0.139","178480","@fd131f9b4a4c632fd26ae7b803455b80@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;

/**
 *
 * @author 士齊
 */
public class Deque<Item> implements Iterable<Item> {

    private Node first = null;
    private Node last = null;
    private int N = 0;

    private class Node {

        Item item;
        Node next;
        Node previous;
    }

    public Deque() {          // construct an empty deque

    }

    public boolean isEmpty() {    // is the deque empty?
        return N == 0;
    }

    public int size() {   // return the number of items on the deque
        return N;
    }

    public void checkadd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    public void addFirst(Item item) {     // add the item to the front
        checkadd(item);
        if (first == null) {
            first = new Node();
            first.item = item;
            last = first;
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {      // add the item to the end
        checkadd(item);
        if (last == null) {
            last = new Node();
            last.item = item;
            first = last;
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public void checkremove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    public Item removeFirst() {       // remove and return the item from the front
        checkremove();
        Item A = first.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldfirst = first;
            first = oldfirst.next;
            first.previous = null;
            oldfirst.next = null;
        }
        N--;
        return A;
    }

    public Item removeLast() {        // remove and return the item from the end
        checkremove();
        Item A = last.item;
        if (N == 1) {
            first = null;
            last = null;
        } else {
            Node oldlast = last;
            last = oldlast.previous;
            last.next = null;
            oldlast.previous = null;
        }
        N--;
        return A;
    }

    public Iterator iterator() {  // return an iterator over items in order from front to end
        return new Listiterator();
    }

    public class Listiterator implements Iterator<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
//            not support
            throw new UnsupportedOperationException();
        }
    }

    public static void main(String[] args) { // unit testing
//        
//        Deque DEQ = new Deque<Integer>();
//        
//        int a = 1;
//        int b = 2;
//        int c = 3;
//        
//        
//        DEQ.addFirst(a);
//        DEQ.addFirst(b);
//        DEQ.addLast(c);
//        DEQ.iterator();
//        for(String k : Deque)
//            System.out.println(k);
//            
//        
    }
}

@fd131f9b4a4c632fd26ae7b803455b80@"
"b03611035","6","1.49","174976","@7c51f668386316557c49584aac4bf13a@import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.util.Iterator;
public class Deque<Item> implements Iterable<Item>{    
    
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> oldlast;
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }    
    
    public Deque(){
        first=null;
        last=null;
        N=0;
    }
    public boolean isEmpty(){// is the deque empty?    
        return first == null;
    }
    public int size(){// return the number of items on the deque
        return N;
    }
    public void addFirst(Item item){// add the item to the front
        //if(item==null) throw new NullPointerException();
        Node <Item>oldfirst=first;
        first=new Node<>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    public void addLast(Item item){// add the item to the end
        //if(item==null) throw new NullPointerException();
        oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else  oldlast.next = last;
        N++;
    }
    public Item removeFirst(){// remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;     
    }
    public Item removeLast(){// remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = oldlast;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
   public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    
    public static void main(String[] args) {
        
    }
}

@7c51f668386316557c49584aac4bf13a@"
"b03611035","6","1.45","183152","@2664487e80ae3d166dff1319aff71b4a@import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.util.Iterator;
public class Deque<Item> implements Iterable<Item>{    
    
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> oldlast;
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }    
    
    public Deque(){
        first=null;
        last=null;
        N=0;
    }
    public boolean isEmpty(){// is the deque empty?    
        return first == null;
    }
    public int size(){// return the number of items on the deque
        return N;
    }
    public void addFirst(Item item){// add the item to the front
        //if(item==null) throw new NullPointerException();
        Node <Item>oldfirst=first;
        first=new Node<>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    public void addLast(Item item){// add the item to the end
        //if(item==null) throw new NullPointerException();
        oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else  oldlast.next = last;
        N++;
    }
    public Item removeFirst(){// remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;     
    }
    public Item removeLast(){// remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = oldlast;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
   public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    
    public static void main(String[] args) {
        
    }
}

@2664487e80ae3d166dff1319aff71b4a@"
"r04631006","5","0.71","102480","@e58011230adc4e83a9a9d34f22828019@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        oldfirst.front = first;
//        oldfirst.front = first;
//        if (isEmpty()) {
//            last = first;
//        } else {
//            oldfirst.front = first;
//            first = oldfirst.front;
//        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        try {
            Deque de = new Deque();
            de.addLast(""you"");
            de.addFirst(""are"");
            de.addLast(""good"");
            de.addFirst(""!"");
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeFirst());
            de.removeLast();

        } catch (java.util.NoSuchElementException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}
@e58011230adc4e83a9a9d34f22828019@"
"r04631021","1","1.05","179376","@8c3a1aa309553a2ea1f80628049c07e1@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) {
            first = last ;      
        }
        else 
        {
            first.next = oldfirst ;
            oldfirst.previous = first ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last . previous ;
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       /*public Item previous(){
           Item item = current.item ;
           Item item1 = current.previous.item ;
           current = pre.next ;
           return item1 ;
       }*/
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque test = new Deque( ) ;
        test.addLast(""z"");
        test.addLast(""o"");
        test.addLast(""o"");
        test.addLast(""t"");
        test.addLast(""o"");
        test.addLast(""p"");
        test.addLast(""i"");
        test.addLast(""a"");
        System.out.println(test.first.item) ;
        test.removeLast() ;
        System.out.println(test.last.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@8c3a1aa309553a2ea1f80628049c07e1@"
"r04631021","1","1.06","180864","@2458cff70815902c4cb4f5ae225861b6@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) {
            first = last ;      
        }
        else 
        {
            first.next = oldfirst ;
            oldfirst.previous = first ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       /*public Item previous(){
           Item item = current.item ;
           Item item1 = current.previous.item ;
           current = pre.next ;
           return item1 ;
       }*/
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque test = new Deque( ) ;
        test.addLast(""z"");
        test.addLast(""o"");
        test.addLast(""o"");
        test.addLast(""t"");
        test.addLast(""o"");
        test.addLast(""p"");
        test.addLast(""i"");
        test.addLast(""a"");
        System.out.println(test.first.item) ;
        test.removeLast() ;
        System.out.println(test.last.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@2458cff70815902c4cb4f5ae225861b6@"
"r04631021","1","1.05","185728","@c951155d699efc6750ec27e4d807d369@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) {
            first = last ;      
        }
        else 
        {
            first.next = oldfirst ;
            oldfirst.previous = first ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       /*public Item previous(){
           Item item = current.item ;
           Item item1 = current.previous.item ;
           current = pre.next ;
           return item1 ;
       }*/
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque test = new Deque( ) ;
        test.addLast(""z"");
        test.addLast(""o"");
        test.addLast(""o"");
        test.addLast(""t"");
        test.addLast(""o"");
        test.addLast(""p"");
        test.addLast(""i"");
        test.addLast(""a"");
        System.out.println(test.first.item) ;
        test.removeLast() ;
        System.out.println(test.last.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;*/
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@c951155d699efc6750ec27e4d807d369@"
"b03611041","8","1.38","178656","@f01dffae4f237f15713ea017f79464fe@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.prev=first;
            first.prev=null;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        if(isEmpty()){
            first=last;
        }else {
            last.prev=oldlast;
            oldlast.next=last;
            last.next=null;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            first=first.next;
            if(N==1)
                last=first;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            last=last.prev;
            if(N==1)
                first=last;
        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@f01dffae4f237f15713ea017f79464fe@"
"b03611041","8","1.38","175328","@853a5fab777c033ba669c7508c7c2540@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.prev=null;
        if (isEmpty()) {
            last = first;
        } else {
            first.next = oldfirst;
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;

        if(isEmpty()){
            first=last;
        }else {
            last.prev=oldlast;
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            first=first.next;
            if(N==1)
                last=first;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;

        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            last=last.prev;
            if(N==1)
                first=last;
        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@853a5fab777c033ba669c7508c7c2540@"
"f02631008","4","1.05","179376","@68b944790a04813217d2382c89fb2074@
import java.util.*;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
/**
 *
 * @author philip
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of queue
    private Node<Item> NodNxt;     // end of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previ;
    }
    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    /**
     * Returns true if this queue is empty.
     *
     * @return <tt>true</tt> if this queue is empty; <tt>false</tt> otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }
    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    /**
     * Adds the item to this queue.
     *
     * @param  item the item to add
     */
    public void addFirst(Item item) {
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        //first.next = oldfirst;
        if (isEmpty()) first = last;
        else{
            first.next = oldfirst;
            oldfirst.previ = first;
        }
        N++;
    }
    public void addLast(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else{
            oldlast.next = last;
            last.previ = oldlast;
            
        }
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;//A
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.previ;
        last.next = null;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    public static void main(String[] args) {

        /*Deque<String> qe = new Deque<String>();

        qe.addLast(""a"");
        qe.addLast(""b"");
        qe.addLast(""c"");
        qe.addLast(""d"");
        //qe.addFirst(""a"");
        qe.removeFirst();
        qe.removeFirst();
        qe.removeFirst();
        qe.addLast(""a"");
        //qe.removeLast();

        Iterator it=qe.iterator();

        System.out.println(""Initial Size of Queue :""+qe.size());

        while(it.hasNext())
        {
            String iteratorValue=(String)it.next();
            System.out.println(""Queue Next Value :""+iteratorValue);
        }

        System.out.println(""Final Size of Queue :""+qe.size());*/
    
    }
    
}

@68b944790a04813217d2382c89fb2074@"
"b03611041","8","1.41","179152","@350d4f44653ea92124eb6a7f0534ac0b@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(isEmpty()){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            first=first.next;
            if(N==1)
                last=first;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;

        N--;
        if(N==0){
            first=null;
            last=null;
        }else{
            last=last.prev;
            if(N==1)
                first=last;
        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@350d4f44653ea92124eb6a7f0534ac0b@"
"b03611041","8","1.41","169680","@4c6300bdbf0f62f23431758e807f3e9f@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
//        first.prev=null;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
//        last.next=null;
        last.prev=oldlast;
        if(isEmpty()){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
            last=first;
        }else{
            first=first.next;
            if(N==1)
                last=first;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;

        N--;
        if(N==0){
            first=null;
            last=null;
            first=last;

        }else{
            last=last.prev;
            if(N==1)
                first=last;
        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@4c6300bdbf0f62f23431758e807f3e9f@"
"r04631006","5","0.71","102352","@9f7b4fb9ed0d727ef6589cd2d7379e9e@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        oldfirst.front = first;
//        oldfirst.front = first;
//        if (isEmpty()) {
//            last = first;
//        } else {
//            oldfirst.front = first;
//            first = oldfirst.front;
//        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    public static void main(String[] args) {
        try {
            Deque de = new Deque();
            de.addLast(0);
            de.addFirst(1);
            de.addLast(2);
            de.addFirst(3);
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeLast());
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeLast());
//            de.removeLast();
//de.removeLast();
        } catch (java.lang.NullPointerException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}
@9f7b4fb9ed0d727ef6589cd2d7379e9e@"
"r04631006","5","0.72","102512","@0671c6e8fd6fab2b6f8656e0f012165a@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        oldfirst.front = first;
//        oldfirst.front = first;
//        if (isEmpty()) {
//            last = first;
//        } else {
//            oldfirst.front = first;
//            first = oldfirst.front;
//        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    public static void main(String[] args) {
        try {
            Deque de = new Deque();
            de.addLast(0);
            de.addFirst(1);
            de.addLast(2);
            de.addFirst(3);
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeLast());
            System.out.printf(""%s"", de.removeFirst());
            System.out.printf(""%s"", de.removeLast());
//            de.removeLast();
//de.removeLast();
        } catch (java.lang.NullPointerException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}
@0671c6e8fd6fab2b6f8656e0f012165a@"
"r04631006","5","0.71","102352","@56fdf125d5726036a66cd311e5173c19@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        oldfirst.front = first;
//        oldfirst.front = first;
//        if (isEmpty()) {
//            last = first;
//        } else {
//            oldfirst.front = first;
//            first = oldfirst.front;
//        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    public static void main(String[] args) {


    }
}

@56fdf125d5726036a66cd311e5173c19@"
"b99611017","3","0.36","102528","@9bd796d7c34edcf07715c6b27abc88d5@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {
            Node<Item> oldFirst = first;
            first = new Node<>();
            last = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;

        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item=item;
        oldlast.next=last;
        
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        if(N==1)
        {
            first=null;
            Item item=last.item;
            last=null;
            return item;
        }
        else{
        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        if (first.next == null || last.next == null) {
            first = null;
            last = null;
        }
        
        N--;
        return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();
        test.addFirst(1);
        test.addFirst(1);
        test.removeLast();
       test.removeLast();
        
        System.out.println(test.size());
        // TODO code application logic here
    }

}

@9bd796d7c34edcf07715c6b27abc88d5@"
"b01703032","10","0.152","166384","@47b1c53c3d1b09151f8b0714669d990c@import java.util.Iterator;
import java.util.NoSuchElementException;


public class Deque<E> implements Iterable {

    private Object[] elementData;
    private int size;
    private static final int DEFAULT_SIZE = 10;

    public Deque(){
        this.elementData = new Object[DEFAULT_SIZE];
        size = 0;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    public void addFirst(E e){
        if(e == null) throw new NullPointerException();
        for(int i = size++ ; i > 0 ; i--)
            elementData[i] = elementData[i-1];
        elementData[0] = e;
        resize();
    }

    public void addLast(E e){
        if(e == null) throw new NullPointerException();
        elementData[size++] = e;
        resize();
    }

    public E removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        E first = (E) elementData[0];
        for(int i = 0 ; i < size-1 ; i++)
            elementData[i] = elementData[i+1];
        size--;
        resize();
        return first;
    }

    public E removeLast(){
        if(isEmpty()) throw new NoSuchElementException();
        resize();
        return (E) elementData[size--];
    }



    private void resize(){
        if(size == elementData.length){
            Object[] copy = new Object[2*elementData.length];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        } else if (size <= elementData.length/4){
            Object[] copy = new Object[elementData.length/2];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        }
    }


    public String toString(){
        String s = ""["";
        for(int i = 0; i < size; i++)
            s += elementData[i] + "","";
        s = s.substring(0,s.length()-1)+""]"";
        return s;
    }


    @Override
    public Iterator<E> iterator() {
        Iterator<E> iterator = new Iterator<E>() {

            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public E next() {
                if(!hasNext()) throw new NoSuchElementException();
                return (E) elementData[index++];
            }

            public void remove(){
                throw new UnsupportedOperationException();
            }

        };
        return iterator;
    }
}
@47b1c53c3d1b09151f8b0714669d990c@"
"b03611041","8","1.37","182608","@e4027ca873ce30f21d1b47c64fa7b82c@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
//        first.prev=null;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
//        last.next=null;
        last.prev=oldlast;
        if(isEmpty()){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                first = last;
            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                last = first;
            else
                last = last.prev;

        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@e4027ca873ce30f21d1b47c64fa7b82c@"
"b03611041","8","1.38","182768","@4099a09d4ebcd446a158661a48de3afc@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(isEmpty()){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                first = last;
            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                last = first;
            else
                last = last.prev;

        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@4099a09d4ebcd446a158661a48de3afc@"
"b03611041","8","1.36","171168","@cc9c170ccf5632b0edeabea28d1ee7dd@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                first = last;
            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                last = first;
            else
                last = last.prev;

        }
        return item;
    }

    public boolean isEmpty() {
        return first==null||last==null;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@cc9c170ccf5632b0edeabea28d1ee7dd@"
"b03611041","8","1.37","181168","@7876d90d8afbc649306e3183ec0ae19f@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                first = last;
            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                last = first;
            else
                last = last.prev;

        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@7876d90d8afbc649306e3183ec0ae19f@"
"b99611017","3","0.36","99600","@432210869a6f2728f3eddf2601bb9f12@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == last;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {
            Node<Item> oldFirst = first;
            first = new Node<>();
            last = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;

        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item=item;
        oldlast.next=last;
        
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        if (first.next == null && last.next == null) {
            first = null;
            Item item=last.item;
            last = null;
            N--;
            return item;
            
        }
        else{
        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        
        
        
        N--;
        return item;
        }
    }     
    

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();
        test.addFirst(1);
        test.addFirst(1);
        test.removeFirst();
        test.removeLast();
        
        System.out.println(test.size());
        // TODO code application logic here
    }

}

@432210869a6f2728f3eddf2601bb9f12@"
"b03611041","8","1.39","182688","@f8b02c139eee6aa3eab53fe27e6c5b9e@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                first = last;
            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
            if (N == 1)
                last = first;
            else
                last = last.prev;

        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>();
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current= (Node<Item>) first;

//        public ListIterator(Node<Item> first){
//            current=first;
//        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }

    }

    public static void main(String[] args) {
    }

}

@f8b02c139eee6aa3eab53fe27e6c5b9e@"
"b03611035","7","1.45","180704","@72ab0f6a037eea6601857ab9cc302e79@import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.util.Iterator;
public class Deque<Item> implements Iterable<Item>{    
    
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> oldlast;
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }    
    
    public Deque(){
        first=null;
        last=null;
        oldlast=null;
        N=0;
    }
    public boolean isEmpty(){// is the deque empty?    
        return first == null;
    }
    public int size(){// return the number of items on the deque
        return N;
    }
    public void addFirst(Item item){// add the item to the front
        if(item==null) throw new NullPointerException();
        Node <Item>oldfirst=first;
        first=new Node<>();
        first.item = item;
        if(isEmpty()) {
            first=last;
            first.next=null;
        }
        else first.next = oldfirst;
        N++;
    }
    public void addLast(Item item){// add the item to the end
        if(item==null) throw new NullPointerException();
        oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else  oldlast.next = last;
        N++;
    }
    public Item removeFirst(){// remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if(first==last){
            first.next=null;
        }
        
        if (isEmpty()) {
            last = null;
            oldlast=null;
        }   // to avoid loitering
        return item;     
    }
    public Item removeLast(){// remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = oldlast;
        N--;
        if(first==last){
            first.next=null;
        }
        
        if (isEmpty()) {
            last = null;
            oldlast=null;
        }   // to avoid loitering
        return item;
    }
   public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    
    public static void main(String[] args) {
        Deque<String> gg=new Deque<String>();
        gg.addLast(""統神4"");
        gg.addFirst(""統神1"");
        gg.addFirst(""統神2"");
        gg.addFirst(""統神3"");
        gg.addLast(""統神4"");
        gg.addLast(""統神5"");
        gg.addLast(""統神6"");
        System.out.println(gg.removeFirst());
        System.out.println(gg.removeFirst());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeFirst());
        System.out.println(gg.removeFirst());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeLast());
        System.out.println(gg.removeFirst());
       
        
    }
}

@72ab0f6a037eea6601857ab9cc302e79@"
"b03611041","8","1.38","174528","@4171c1cdee08a21f8134a2cda28d7f2f@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                first = last;
//            else
                first = first.next;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                last = first;
//            else
                last = last.prev;
        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }
    }

    public static void main(String[] args) {
    }

}

@4171c1cdee08a21f8134a2cda28d7f2f@"
"b03611041","0","1.39","182688","@6289951ae9b7ed71e6c98bd65e9ade92@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
//        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                first = last;
//            else
                first = first.next;
            first.prev=null;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
//        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                last = first;
//            else
                last = last.prev;
            last.next=null
        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }
    }

    public static void main(String[] args) {
    }

}

@6289951ae9b7ed71e6c98bd65e9ade92@"
"b03611041","10","0.141","180752","@5b9d6a923c1eaa60085a7ef23d8852ce@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
//        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                first = last;
//            else
                first = first.next;
            first.prev=null;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
//        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                last = first;
//            else
                last = last.prev;
            last.next=null;
        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }
    }

    public static void main(String[] args) {
    }

}

@5b9d6a923c1eaa60085a7ef23d8852ce@"
"b01502105","10","0.141","176848","@b740c3ef0129ba65299a7587c11eef70@//import java.lang.Iterable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.io.BufferedReader;
import java.io.FileReader;

public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of deque
    private Node<Item> last;     // end of deque
    private int N;               // number of elements on deque
    
    private class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    
    public Deque(){                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty() {                 // is the deque empty?
        return (N==0);
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addFirst(Item item) {         // add the item to the front
        if (item.equals(""null"")){throw new NullPointerException();}
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.previous = null;
        if (isEmpty()) {last = first;}
        else{
            first.next = oldfirst;
            oldfirst.previous = first;
        }
        N++;
    }

    public void addLast(Item item) {           // add the item to the end
        if (item.equals(""null"")){throw new NullPointerException();}
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {first = last;}
        else{
            last.previous = oldlast;
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {                // remove and return the item from the front
        if (isEmpty()) throw new NoSuchElementException(""Deque first underflow"");
        Item item = first.item;
        if(N!=1){
            first = first.next;
            first.previous = null;
        }
        N--;
        if (isEmpty()) {last = null; first = null; return item;}
        return item;
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) throw new NoSuchElementException(""Deque last underflow"");
        Item item = last.item;
        if(N!=1){
            last = last.previous;
            last.next = null;
        }
        N--;
        if (isEmpty()) {first = null; last = null; return item;}
        return item;
    }

    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current ;
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public static void main(String[] args) {
      Deque<String> s = new Deque<String>();
      try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            StringBuilder everything = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                everything.append(line);
                everything.append("" "");
            }
            String[] data = everything.toString().split("" "");
            for(int i=0;i<data.length;i++){
                String item = data[i];               
                if (item.equals(""fa"")||item.equals(""fb"")||item.equals(""fc"")) s.addFirst(item); 
                else if (item.equals(""f-"")) StdOut.print(s.removeFirst() + "" "");
                else if (item.equals(""la"")||item.equals(""lb"")||item.equals(""lc"")) s.addLast(item);
                else if (item.equals(""l-"")) StdOut.print(s.removeLast() + "" "");           
                else throw new NoSuchElementException();
            }
            System.out.printf(""\n"");
      }
      catch(Exception ex){
          StdOut.println(""something wrong!!"");
      }
      Iterator<String> i = s.iterator();
      while (i.hasNext()){
            String a = i.next();
            System.out.printf(a + "" "");
      }
      System.out.printf(""\n"");
      System.out.println(""deque size = "" + s.size());
    }
}

@b740c3ef0129ba65299a7587c11eef70@"
"b03611041","10","0.134","174496","@475ae2b19f4c33b209d2f97e0c35b2d1@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Sunny on 3/25/16.
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first, last;
    private int N;

    private class Node<Item> {
        private Node<Item> next;
        private Node<Item> prev;
        private Item item;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
//        first.prev=null;
        if (N==0) {
            last = first;
        } else {
            oldfirst.prev=first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item==null)throw new NullPointerException();
        Node<Item> oldlast=last;
        last=new Node<Item>();
        last.item=item;
//        last.next=null;
        last.prev=oldlast;
        if(N==0){
            first=last;
        }else {
            oldlast.next=last;
        }
        N++;
    }

    public Item removeFirst() {
        if (N == 0) throw new NoSuchElementException();
        Item item = first.item;
//        first.prev=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                first = last;
//            else
                first = first.next;
            first.prev=null;
        }
        return item;
    }

    public Item removeLast() {
        if(N==0)throw new NoSuchElementException();
        Item item=last.item;
//        last.next=null;
        N--;
        if(N==0){
            first=null;
            last=null;
//            first=last;
        }else {
//            if (N == 1)
//                last = first;
//            else
                last = last.prev;
            last.next=null;
        }
        return item;
    }

    public boolean isEmpty() {
        return N==0;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;

        public ListIterator(Node<Item> first){
            current=first;
        }

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if(!hasNext())throw new NoSuchElementException();
            Item item=current.item;
            current=current.next;
            return item;
        }
    }

    public static void main(String[] args) {
    }

}

@475ae2b19f4c33b209d2f97e0c35b2d1@"
"r04945039","3","1.38","181856","@8cf21fea0936c6948c0e0d10e0215fab@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

	private int inisize;	 // initial size of deque
	private Node first;      // index of first item
    private Node last;       // index of last item

	// construct an empty deque
	public Deque() {}
	   

	// is the deque empty?
	public boolean isEmpty() {
		return first == null;
	}                

	// return the number of items on the deque
	public int size() {
		return inisize;
	}                       


	// add the item to the front
	public void addFirst(Item item) {
		throwIfNull(item);
		Node newFirst = new Node();
		newFirst.item = item;
		if(!isEmpty()){
			newFirst.next = first;
			first.previous = newFirst;
		}
		first = newFirst;
		if(last == null) last = first;

		inisize++;
	}         



	// add the item to the end
	public void addLast(Item item) {
		throwIfNull(item);
		Node newLast = new Node();
		newLast.item = item;
		if(last!=null){
		last.next = newLast;
		newLast.previous = last;
		}
		
		if(isEmpty()) first = last;
		inisize++;
	}          

	// remove and return the item from the front
	public Item removeFirst() {
		throwIfEmpty();
		Node oldFirst = first;
		first = first.next;

		if(isEmpty())last=null;
		else first.previous=null;

		inisize--;
		return oldFirst.item;
		}              


	// remove and return the item from the end
	public Item removeLast() {
		throwIfEmpty();
		Node oldLast = last;
		last.previous = last;
		if (last==null) first=null;
		else last.next=null;

		inisize--;
		return oldLast.item;

	}                


	// return an iterator over items in order from front to end
	@Override
	public Iterator<Item> iterator() {return new ListIterator();}
	private class ListIterator implements Iterator<Item>{
		private Node current = first;

		
		
		public boolean hasNext(){
			return current != null;
		}

		public Item next(){
			if (current == null) throw new NoSuchElementException();

			Item item = current.item;
			current = current.next;
			return item;
		}

		public void remove(){
		throw new UnsupportedOperationException();
		}


	}        

	
private class Node {
        Item item;
        Node next;
        Node previous;
    }

    private void throwIfEmpty() {
        if (isEmpty())
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

	public static void main(String[] args) {
		
		
	} 



}




@8cf21fea0936c6948c0e0d10e0215fab@"
"b02611012","0","1.38","174528","@b28e56ef869cf688c54aceb5f5ea6e63@
import java.util.Iterator;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.pre = oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.pre;
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@b28e56ef869cf688c54aceb5f5ea6e63@"
"b02611012","7","0.83","102464","@868382092eefb77ec9e550fcbf62a5d0@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.pre = oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.pre;
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@868382092eefb77ec9e550fcbf62a5d0@"
"r03228006","7","1.48","175136","@78c47db43d4c40464359dc59028c696f@import java.util.Iterator;
import java.util.NoSuchElementException;

    
    public class Deque<Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private Node oldlast;
    private int N;
    
    private class Node{
          Item item;
          Node next;}
    
   public Deque()                           // construct an empty deque
       { 
       first = null;
       last = null;
       N = 0;
       }            
           
   public boolean isEmpty()                 // is the deque empty?
   {
     return ((first==null)|(last==null));    
   }
   public int size()                        // return the number of items on the deque
   {
       return N;
   } 
   public void addFirst(Item item)          // add the item to the front
   {
       if(item==null){throw new NullPointerException();}
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       if (isEmpty()) last = first;//if last is empty
       else           first.next =oldfirst;
       N++;
   }
   public void addLast(Item item)          // add the item to the end
   {
       if(item==null){throw new NullPointerException();}
       oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if (isEmpty()) first = last;//if first is empty
       else           oldlast.next=last;
       N++;
   } 
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // 
        return item;
   }

   public Item removeLast()                 // remove and return the item from the 
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        last = oldlast;
        N--;
        if (isEmpty()) {last = null;} // to avoid loitering
        return item;   
   }

   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
     {return new ListIterator();}
   private class ListIterator implements Iterator<Item>
     {
       private Node current = first;
       public boolean hasNext(){ return current !=null;}
       public void remove()    { throw new UnsupportedOperationException(); }
       public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
     }
   
   public static void main(String[] args)   // unit testing
   {
       Deque<String> s = new Deque<String>();
       String a = ""2"";
       String b = ""3"";
       s.addFirst(a);
       s.addLast(b);
       System.out.println(s.removeLast());
       System.out.println(s.removeFirst());
       s.addFirst(a);
       System.out.println(s.size());
   }
    
    
}

@78c47db43d4c40464359dc59028c696f@"
"b02611023","8","0.94","102416","@03fc98d73d0e131398f1531d5b1410c0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last, find;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            find = first;
            if (size() == 1) {
                Item item = find.item;
                find.next = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        break;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                find.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.addLast(e);
//        d.addFirst(e);
//        d.addFirst(f);
//        System.out.println(d.removeFirst());
//        d.addFirst(""4"");
//        d.addFirst(""5"");
//        d.addFirst(""6"");
//        d.addLast(""7"");
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeFirst());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@03fc98d73d0e131398f1531d5b1410c0@"
"b02611012","7","0.8","102416","@d968fdb1206ea8257bd7b5494f3ae871@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.pre = oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        if (first == last) {
            first.next = null;
        }
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.pre;
        if (first == last) {
            last.pre = null;
        }
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@d968fdb1206ea8257bd7b5494f3ae871@"
"b02611023","8","0.96","102304","@734e595ee64ea7e9f3071d76fb4caf25@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last, find;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            find = first;
            if (size() == 1) {
                Item item = find.item;
                find = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        break;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                find.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@734e595ee64ea7e9f3071d76fb4caf25@"
"r04631006","5","0.81","102384","@e68ca574f4d059ccdb26a326856bbe06@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;
        oldfirst.front = first;
//        oldfirst.front = first;
//        if (isEmpty()) {
//            last = first;
//        } else {
//            oldfirst.front = first;
//            first = oldfirst.front;
//        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }
}
@e68ca574f4d059ccdb26a326856bbe06@"
"r04945039","3","1.5","180656","@623d1da243c66f1678ad208aeb2f1196@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

	private int inisize;	 // initial size of deque
	private Node first;      // index of first item
    private Node last;       // index of last item

	// construct an empty deque
	public Deque() {}
	   

	// is the deque empty?
	public boolean isEmpty() {
		return first == null;
	}                

	// return the number of items on the deque
	public int size() {
		return inisize;
	}                       


	// add the item to the front
	public void addFirst(Item item) {
		throwIfNull(item);
		Node newFirst = new Node();
		newFirst.item = item;
                newFirst.previous = null;
		if(!isEmpty()){
			newFirst.next = first;
			first.previous = newFirst;
		}
		first = newFirst;
		if(last == null) last = first;

		inisize++;
	}         



	// add the item to the end
	public void addLast(Item item) {
		throwIfNull(item);
		Node newLast = new Node();
		newLast.item = item;
                newLast.next=null;
		if(last!=null){
		last.next = newLast;
		newLast.previous = last;
		}
		
		if(isEmpty()) first = last;
		inisize++;
	}          

	// remove and return the item from the front
	public Item removeFirst() {
		throwIfEmpty();
		Node oldFirst = first;
		first = first.next;

		if(isEmpty())last=null;
		else first.previous=null;

		inisize--;
		return oldFirst.item;
		}              


	// remove and return the item from the end
	public Item removeLast() {
		throwIfEmpty();
		Node oldLast = last;
		last = last.previous;
		if (last==null) first=null;
		else last.next=null;

		inisize--;
		return oldLast.item;

	}                


	// return an iterator over items in order from front to end
	@Override
public Iterator<Item> iterator() {
            return new ListIterator();  }
       
	private class ListIterator implements Iterator<Item>{
		private Node current = first;

		@Override
		public boolean hasNext(){
			return current != null;
		}
@Override
		public Item next(){
			if (current == null) throw new NoSuchElementException();

			Item item = current.item;
			current = current.next;
			return item;
		}
@Override
		public void remove(){
		throw new UnsupportedOperationException();
		}


	}        

	
private class Node {
        Item item;
        Node next;
        Node previous;
    }

    private void throwIfEmpty() {
        if (isEmpty ()&& last==null)
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

	public static void main(String[] args) {
	/*	
                Deque<Integer> tryyy = new Deque<Integer>();
                tryyy.addFirst(-3);
                tryyy.addFirst(-13);
                //tryyy.addFirst(3);
                tryyy.removeLast();
                Iterator<Integer> cal = tryyy.iterator();
              
                while(cal.hasNext()){              
               System.out.println(cal.next());               
                }
                
                tryyy.removeLast();
                tryyy.removeFirst();
               
                */
	} 



}
@623d1da243c66f1678ad208aeb2f1196@"
"r04945039","3","1.48","182688","@32378cfd40148da416e8a9bce1eb1e3b@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

	private int inisize;	 // initial size of deque
	private Node first=null;      // index of first item
    private Node last=null;       // index of last item

	// construct an empty deque
	public Deque() {}
	   

	// is the deque empty?
	public boolean isEmpty() {
		return first == null;
	}                

	// return the number of items on the deque
	public int size() {
		return inisize;
	}                       


	// add the item to the front
	public void addFirst(Item item) {
		throwIfNull(item);
		Node newFirst = new Node();
		newFirst.item = item;
                newFirst.previous = null;
		if(!isEmpty()){
			newFirst.next = first;
			first.previous = newFirst;
		}
		first = newFirst;
		if(last == null) last = first;

		inisize++;
	}         



	// add the item to the end
	public void addLast(Item item) {
		throwIfNull(item);
		Node newLast = new Node();
		newLast.item = item;
                newLast.next=null;
		if(last!=null){
		last.next = newLast;
		newLast.previous = last;
		}
		
		if(isEmpty()) first = last;
		inisize++;
	}          

	// remove and return the item from the front
	public Item removeFirst() {
		throwIfEmpty();
		Node oldFirst = first;
		first = first.next;

		if(isEmpty())last=null;
		else first.previous=null;

		inisize--;
		return oldFirst.item;
		}              


	// remove and return the item from the end
	public Item removeLast() {
		throwIfEmpty();
		Node oldLast = last;
		last = last.previous;
		if (last==null) first=null;
		else last.next=null;

		inisize--;
		return oldLast.item;

	}                


	// return an iterator over items in order from front to end
	@Override
public Iterator<Item> iterator() {
            return new ListIterator();  }
       
	private class ListIterator implements Iterator<Item>{
		private Node current = first;

		@Override
		public boolean hasNext(){
			return current != null;
		}
@Override
		public Item next(){
			if (current == null) throw new NoSuchElementException();

			Item item = current.item;
			current = current.next;
			return item;
		}
@Override
		public void remove(){
		throw new UnsupportedOperationException();
		}


	}        

	
private class Node {
        Item item;
        Node next;
        Node previous;
    }

    private void throwIfEmpty() {
        if (isEmpty ())
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

	public static void main(String[] args) {
	/*	
                Deque<Integer> tryyy = new Deque<Integer>();
                tryyy.addFirst(-3);
                tryyy.addFirst(-13);
                tryyy.addFirst(53);
                tryyy.removeLast();                         
                tryyy.removeLast();
                tryyy.removeFirst();
                Iterator<Integer> cal = tryyy.iterator();      
                while(cal.hasNext()){              
               System.out.println(cal.next());               
                }
               */
	} 



}
@32378cfd40148da416e8a9bce1eb1e3b@"
"r04945039","3","1.46","188000","@11d288d92bf2e57c70f8077225fb2c55@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

	private int inisize=0;	 // initial size of deque
	private Node first=null;      // index of first item
    private Node last=null;       // index of last item

	// construct an empty deque
	public Deque() {}
	   

	// is the deque empty?
	public boolean isEmpty() {
		return first == null;
	}                

	// return the number of items on the deque
	public int size() {
		return inisize;
	}                       


	// add the item to the front
	public void addFirst(Item item) {
		throwIfNull(item);
		Node newFirst = new Node();
		newFirst.item = item;
                newFirst.previous = null;
		if(!isEmpty()){
			newFirst.next = first;
			first.previous = newFirst;
		}
		first = newFirst;
		if(last == null) last = first;

		inisize++;
	}         



	// add the item to the end
	public void addLast(Item item) {
		throwIfNull(item);
		Node newLast = new Node();
		newLast.item = item;
                newLast.next=null;
		if(last!=null){
		last.next = newLast;
		newLast.previous = last;
		}
		
		if(isEmpty()) first = last;
		inisize++;
	}          

	// remove and return the item from the front
	public Item removeFirst() {
		throwIfEmpty();
		Node oldFirst = first;
		first = first.next;

		if(isEmpty())last=null;
                //System.out.println(""Empty!"");}
		else first.previous=null;

		inisize--;
		return oldFirst.item;
		}              


	// remove and return the item from the end
	public Item removeLast() {
		throwIfEmpty();
		Node oldLast = last;
		last = last.previous;
		if (last==null) first=null;
                //System.out.println(""Empty!"");}
		else last.next=null;

		inisize--;
		return oldLast.item;

	}                


	// return an iterator over items in order from front to end
	@Override
public Iterator<Item> iterator() {
            return new ListIterator();  }
       
	private class ListIterator implements Iterator<Item>{
		private Node current = first;

		@Override
		public boolean hasNext(){
			return current != null;
		}
@Override
		public Item next(){
			if (current == null) throw new NoSuchElementException();

			Item item = current.item;
			current = current.next;
			return item;
		}
@Override
		public void remove(){
		throw new UnsupportedOperationException();
		}


	}        

	
private class Node {
        Item item;
        Node next;
        Node previous;
    }

    private void throwIfEmpty() {
        if (isEmpty ())
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

	public static void main(String[] args) {
	/*	
                Deque<Integer> tryyy = new Deque<Integer>();
                tryyy.addFirst(-3);
                tryyy.addFirst(-13);
                tryyy.addFirst(53);
                tryyy.removeLast();                         
                tryyy.removeLast();
                tryyy.addLast(98);
                System.out.println(tryyy.size());
                Iterator<Integer> cal = tryyy.iterator();      
               cal.next();
               
               */
	} 



}

@11d288d92bf2e57c70f8077225fb2c55@"
"b02611023","8","0.93","102480","@ef55f67a1006e8b702332b7e4c5a0bec@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last, find;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            find = first;
            if (size() == 1) {
                Item item = first.item;
                first = first.next;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        break;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                find.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@ef55f67a1006e8b702332b7e4c5a0bec@"
"b02611023","7","1.85","177280","@6c44e3675a14048dfa8a51980bbe255b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last, find;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            find = first;
            while (find.next != null) {
                find = find.next;
            }
            Item item = find.item;
            find = find.next;
            N--;
            return item;

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@6c44e3675a14048dfa8a51980bbe255b@"
"b02611023","7","1.77","186240","@338e4a28a39ea54560424bf8b3e44c5f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

    public Item removeLast() {
        if (size() > 0) {
            Node<Item> find = first;
            while (find.next != null) {
                find = find.next;
            }
            Item item = find.item;
            find = find.next;
            N--;
            return item;

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@338e4a28a39ea54560424bf8b3e44c5f@"
"r04525016","9","1.08","102416","@7418c475c8fb144c49aa325e5b4529f2@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < s.length; i++) {
                s2[i] = s[i];
            }
            Object[] s = s2;
        } else if (size < s.length / 4) {
            int sizeTemp = 0;
            if (s.length % 2 != 0) {
                sizeTemp = s.length + 1;
            }
            Object[] s2 = new Object[sizeTemp / 2];
            Object[] s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i + 1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }
        }

        return new qwert();
    }
}

@7418c475c8fb144c49aa325e5b4529f2@"
"r04525016","9","1.08","101344","@7418c475c8fb144c49aa325e5b4529f2@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < s.length; i++) {
                s2[i] = s[i];
            }
            Object[] s = s2;
        } else if (size < s.length / 4) {
            int sizeTemp = 0;
            if (s.length % 2 != 0) {
                sizeTemp = s.length + 1;
            }
            Object[] s2 = new Object[sizeTemp / 2];
            Object[] s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i + 1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }
        }

        return new qwert();
    }
}

@7418c475c8fb144c49aa325e5b4529f2@"
"r04525016","9","1.09","102464","@e5567420a9565348ec9be9c47d95e6ff@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < s.length; i++) {
                s2[i] = s[i];
            }
            Object[] s = s2;
        } else if (size < s.length / 4) {
            int sizeTemp = 0;
            if (s.length % 2 != 0) {
                sizeTemp = s.length + 1;
            }
            Object[] s2 = new Object[sizeTemp / 2];
            Object[] s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i + 1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }

        return new qwert();
    }
}

@e5567420a9565348ec9be9c47d95e6ff@"
"r04525016","9","1.08","102448","@9decabf56044dc04d6aa3ef87307ee8d@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        } else if (size < s.length / 4) {
            int sizeTemp = 0;
            if (s.length % 2 != 0) {
                sizeTemp = s.length + 1;
            }
            Object[] s2 = new Object[sizeTemp / 2];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i + 1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }

        return new qwert();
    }
}

@9decabf56044dc04d6aa3ef87307ee8d@"
"r04525016","9","1.07","102368","@a31d508b406bf74a35a51636cb107882@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        } else if (size < s.length / 4) {
            Object[] s2 = new Object[s.length / 2];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i + 1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }

        return new qwert();
    }
}

@a31d508b406bf74a35a51636cb107882@"
"b02611023","8","0.95","102336","@86bf9f756568e1792f92a9c23ceca762@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (size() == 0) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (size() > 0) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

     public Item removeLast() {
        if (size() > 0) {
            Node<Item> find = first;
            if (size() == 1) {
                Item item = find.item;
                first = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        break;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                find.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(d.removeLast());
//        System.out.println(d.removeLast());
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@86bf9f756568e1792f92a9c23ceca762@"
"r04525016","10","0.147","165248","@4a5165715f02a12d3b9c0a00d77a8f5a@import java.util.Iterator;
import java.util.NoSuchElementException;


/**
 * Created by PG on 2016/3/26.
 */
public class Deque<Item> implements Iterable<Item> {

    private Object[] s;
    private int size;

    private void resize() {
        if (size == s.length) {
            Object[] s2 = new Object[2 * s.length];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        } else if (size < s.length / 4) {
            Object[] s2 = new Object[s.length / 2];
            for (int i = 0; i < size; i++) {
                s2[i] = s[i];
            }
            s = s2;
        }
    }

    // construct an empty deque
    public Deque() {
        s = new Object[10];
        size = 0;
    }


    // is the deque empty?
    public boolean isEmpty() {
        return (size == 0);
    }

    public int size() {
        return size;
    }

    // add the item to the front
    public void addFirst(Item item) {
        resize();
        if (item == null) {
            throw new NullPointerException();
        } else {
            for (int i = size - 1; i >= 0; i--) {
                s[i+1] = s[i];
            }
            s[0] = item;
            size++;
        }
    }

    // add the item to the end
    public void addLast(Item item) {
        resize();
        if (item == null) {
            throw new NullPointerException();
        } else {
            s[size] = item;
            size++;
        }
    }

    public Item removeFirst() {
        resize();
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            Object item = s[0];
            for (int i = 1; i < size; i++) {
                s[i - 1] = s[i];
            }
            s[size - 1] = null;
            size--;
            return (Item) item;
        }
    }

    // remove and return the item from the end
    public Item removeLast() {
        resize();
        if (size == 0) {
            throw new NoSuchElementException();
        } else {
            size--;
            Object item = s[size];
            s[size] = null;
            return (Item) item;
        }
    }


    public void print() {
        for (int i = 0; i < 10; i++) {
            System.out.print(s[i] + "" , "");
        }
        System.out.println("""");
    }


    @Override
    public Iterator<Item> iterator() {

        class qwert implements Iterator<Item> {

            int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public Item next() {
                if (hasNext()) {
                    return (Item) s[index++];
                } else {
                    throw new NoSuchElementException();
                }
            }


            public void remove() {
                throw new UnsupportedOperationException();
            }
        }

        return new qwert();
    }
}

@4a5165715f02a12d3b9c0a00d77a8f5a@"
"b02611023","8","1.06","102368","@bd1728b230ac07565f6521a81b1f28ad@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (!isEmpty()) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

     public Item removeLast() {
        if (!isEmpty()) {
            Node<Item> find = first;
            if (size() == 1) {
                Item item = find.item;
                first = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        break;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                find.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(d.removeLast());
        //System.out.println(d.removeLast());
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@bd1728b230ac07565f6521a81b1f28ad@"
"r03525006","6","0.96","102400","@68200464b749605a8affc445d266e2b1@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[10];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i > arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@68200464b749605a8affc445d266e2b1@"
"r03525006","8","1.08","102320","@3bc10575cb7f0a42e9817f0ffe3d42f6@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[100];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i > arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        arraySize--;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@3bc10575cb7f0a42e9817f0ffe3d42f6@"
"r03525006","8","1.06","107056","@603ddfc7af4f83426d91ec524ba0fd7b@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[1000];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i > arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        arraySize--;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@603ddfc7af4f83426d91ec524ba0fd7b@"
"r03525006","8","1.44","175104","@85de328104baee38a5ce5f471929ca89@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[100000];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i > arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        arraySize--;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@85de328104baee38a5ce5f471929ca89@"
"r03525006","8","1.07","102256","@df7f8f435d6c96c9c62ded0830cbe85e@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[10000];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i > arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        arraySize--;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@df7f8f435d6c96c9c62ded0830cbe85e@"
"r03525006","10","0.152","163264","@059a4f1f6e463f5469a0bf4f280edb5c@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 * Created by Cavitation on 2016/3/26.
 */
public class Deque<T> implements Iterable<T>{

    private Object[] dequeArray;
    public int arraySize;

    public Deque() {
        this.dequeArray = new Object[100000];
        arraySize = 0;
    }

    public boolean isEmpty() {
        return arraySize == 0;
    }

    public int size() {
        return arraySize;
    }

    public void addFirst(T item) {
        if (item == null) throw new NullPointerException();
        if (arraySize != 0) {
            for (int i = arraySize; i > 0; i--) {
                dequeArray[i] = dequeArray[i-1];
            }
        }
        dequeArray[0] = item;
        arraySize++;
    }

    public void addLast(T item) {
        if (item == null) throw new NullPointerException();

        if (dequeArray.length > arraySize) {
            dequeArray[arraySize] = item;
        }
        arraySize++;
    }

    public T removeFirst() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[0];
        dequeArray[0] = null;
        for (int i = 0; i < arraySize-1; i++) {
            dequeArray[i] = dequeArray[i+1];
        }
        arraySize--;
        return returnItem;
    }
//
    public T removeLast() {
        if(isEmpty()) throw new NoSuchElementException();
        T returnItem = (T) dequeArray[arraySize];
        dequeArray[arraySize-1] = null;
        arraySize--;
        return returnItem;
    }

    @Override
    public Iterator<T> iterator() {
        Iterator<T> iter = new Iterator<T>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return index < arraySize;
            }
            @Override
            public T next() {
                if (!hasNext()) throw new NoSuchElementException();

                index++;
                return (T) dequeArray[index-1];
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
        return iter;
    }
}

@059a4f1f6e463f5469a0bf4f280edb5c@"
"b02611023","7","0.83","102416","@bcaa001d59c756423d930dfe29344929@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (!isEmpty()) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

     public Item removeLast() {
        if (!isEmpty()) {
            Node<Item> find = first;
            if (size() == 1) {
                Item item = find.item;
                first = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        last = find;
                    }
                    find = find.next;
                }
                Item item = find.next.item;
                last.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(d.removeLast());
        //System.out.println(d.removeLast());
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@bcaa001d59c756423d930dfe29344929@"
"b02611023","10","0.17","173424","@3835063c6ae30c8006bdc32f4b2a6908@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;                // size of the stack
    private Node<Item> first, last;         // top of stack

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldfirst = first;
            first = new Node();
            first.item = item;
            first.next = null;
            if (size() == 0) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (!isEmpty()) {
            Item item = first.item;
            first = first.next;
            N--;
            return item;
        } else {
            throw new NoSuchElementException();
        }
    }

     public Item removeLast() {
        if (!isEmpty()) {
            Node<Item> find = first;
            if (size() == 1) {
                Item item = find.item;
                first = null;
                N--;
                return item;
            } else {
                while (find.next != null) {
                    if (find.next.next == null) {
                        last = find;
                    }
                    find = find.next;
                }
                Item item = find.item;
                last.next = null;
                N--;
                return item;
            }

        } else {
            throw new NoSuchElementException();
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

//    public static void main(String[] args) {
//
//        Deque<String> d = new Deque<String>();
//        String b = ""5"";
//        String c = ""1"";
//        String e = ""2"";
//        String f = ""3"";
//        d.addFirst(b);
//        d.addLast(c);
//        d.addLast(e);
//        d.removeLast();
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(d.removeLast());
        //System.out.println(d.removeLast());
//        Iterator a = d.iterator();
//        System.out.println(a.next());
//        System.out.println(a.next());
//        d.removeFirst();
//        d.removeLast();
//        System.out.println(a.next());
//    }
}

@3835063c6ae30c8006bdc32f4b2a6908@"
"r03228006","7","1.42","184880","@99107f9d112f2102db7cd29bdab5c654@import java.util.Iterator;
import java.util.NoSuchElementException;

    
    public class Deque<Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private Node oldlast;
    private int N;
    
    private class Node{
          Item item;
          Node next;}
    
   public Deque()                           // construct an empty deque
       { 
       first = null;
       last = null;
       oldlast = null;
       N = 0;
       }            
           
   public boolean isEmpty()                 // is the deque empty?
   {
     return ((first==null)|(last==null));    
   }
   public int size()                        // return the number of items on the deque
   {
       return N;
   } 
   public void addFirst(Item item)          // add the item to the front
   {
       if(item==null){throw new NullPointerException();}
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       if (isEmpty()) last = first;//if last is empty
       else first.next =oldfirst;
       N++;
   }
   public void addLast(Item item)          // add the item to the end
   {
       if(item==null){throw new NullPointerException();}
       oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if (isEmpty()) first = last;//if first is empty
       else  oldlast.next=last;
       if(first.next==null){first.next = last;}//if 目前只有first
       N++;
   } 
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;
                        first= null;
                        oldlast = null;}//if deque null 
        return item;
   }

   public Item removeLast()                 // remove and return the item from the 
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        last = oldlast;
        last.next = null;
        N--;
        if (isEmpty()) {last = null;
                        first = null;
                        oldlast = null;} // to avoid loitering
        return item;   
   }

   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
     {return new ListIterator();}
   private class ListIterator implements Iterator<Item>
     {
       private Node current = first;
       public boolean hasNext(){ return current !=null;}
       public void remove()    { throw new UnsupportedOperationException(); }
       public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            else {Item item = current.item;
            current = current.next; 
            return item;}
        }
     }
   
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public static void main(String[] args)   // unit testing
   {
       Deque<String> s = new Deque<String>();
       String a = ""2"";
       String b = ""3"";
       s.addFirst(a);
       s.addLast(b);
       System.out.println(s.removeLast());
       System.out.println(s.removeFirst());
       Iterator<String> i = s.iterator();
       while (i.hasNext())
          {
           String j = i.next();
           StdOut.println(j);
          }
       //s.addFirst(a);
       System.out.println(s.size());
   }
}

@99107f9d112f2102db7cd29bdab5c654@"
"r03228006","7","1.44","171056","@4799b794a53cbb854b5f3c721148bbe5@import java.util.Iterator;
import java.util.NoSuchElementException;

    
    public class Deque<Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private Node oldlast;
    private int N;
    
    private class Node{
          Item item;
          Node next;}
    
   public Deque()                           // construct an empty deque
       { 
       first = null;
       last = null;
       oldlast = null;
       N = 0;
       }            
           
   public boolean isEmpty()                 // is the deque empty?
   {
     return ((first==null)|(last==null));    
   }
   public int size()                        // return the number of items on the deque
   {
       return N;
   } 
   public void addFirst(Item item)          // add the item to the front
   {
       if(item==null){throw new NullPointerException();}
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       if (isEmpty()) last = first;//if last is empty
       else first.next =oldfirst;
       N++;
   }
   public void addLast(Item item)          // add the item to the end
   {
       if(item==null){throw new NullPointerException();}
       oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if (isEmpty()) first = last;//if first is empty
       else  {oldlast.next=last;
             if(first.next==null){first.next = last;}}//if 目前只有first
       N++;
   } 
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;
                        first= null;
                        oldlast = null;}//if deque null 
        return item;
   }

   public Item removeLast()                 // remove and return the item from the 
   {
        if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");
        Item item = last.item;
        last = oldlast;
        last.next = null;
        N--;
        if (isEmpty()) {last = null;
                        first = null;
                        oldlast = null;} // to avoid loitering
        return item;   
   }

   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
     {return new ListIterator();}
   private class ListIterator implements Iterator<Item>
     {
       private Node current = first;
       public boolean hasNext(){ return current !=null;}
       public void remove()    { throw new UnsupportedOperationException(); }
       public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            else {Item item = current.item;
            current = current.next; 
            return item;}
        }
     }
   
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public static void main(String[] args)   // unit testing
   {
       Deque<String> s = new Deque<String>();
       String a = ""2"";
       String b = ""3"";
       s.addFirst(a);
       s.addFirst(a);
       s.addLast(b);
       s.addLast(b);
       System.out.println(s.removeLast());
       System.out.println(s.removeFirst());
       s.addLast(a);
       Iterator<String> i = s.iterator();
       while (i.hasNext())
          {
           String j = i.next();
           StdOut.println(j);
          }
       System.out.println(s.size());
   }
}

@4799b794a53cbb854b5f3c721148bbe5@"
"r03228006","7","1.44","184448","@945dc352173b24e2d948f2505ca803f1@import java.util.Iterator;
import java.util.NoSuchElementException;

    
    public class Deque<Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private Node oldlast;
    private int N;
    
    private class Node{
          Item item;
          Node next;}
    
   public Deque()                           // construct an empty deque
       { 
       first = null;
       last = null;
       oldlast = null;
       N = 0;
       }            
           
   public boolean isEmpty()                 // is the deque empty?
   {
     return ((first==null)|(last==null));    
   }
   public int size()                        // return the number of items on the deque
   {
       return N;
   } 
   public void addFirst(Item item)          // add the item to the front
   {
       if(item==null){throw new NullPointerException();}
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       if (isEmpty()) last = first;//if last is empty
       else first.next =oldfirst;
       N++;
   }
   public void addLast(Item item)          // add the item to the end
   {
       if(item==null){throw new NullPointerException();}
       oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if (isEmpty()) first = last;//if first is empty
       else  {oldlast.next=last;
             if(first.next==null){first.next = last;}}//if 目前只有first
       N++;
   } 
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;
                        first= null;
                        oldlast = null;}//if deque null 
        return item;
   }

   public Item removeLast()                 // remove and return the item from the 
   {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = oldlast;
        last.next = null;
        N--;
        if (isEmpty()) {last = null;
                        first = null;
                        oldlast = null;} // to avoid loitering
        return item;   
   }

   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
     {return new ListIterator();}
   private class ListIterator implements Iterator<Item>
     {
       private Node current = first;
       public boolean hasNext(){ return current !=null;}
       public void remove()    { throw new UnsupportedOperationException(); }
       public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            else {Item item = current.item;
            current = current.next; 
            return item;}
        }
     }
   
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public static void main(String[] args)   // unit testing
   {
       Deque<String> s = new Deque<String>();
       String a = ""2"";
       String b = ""3"";
       s.addFirst(a);
       s.addFirst(a);
       s.addLast(b);
       s.addLast(b);
       System.out.println(s.removeLast());
       System.out.println(s.removeFirst());
       System.out.println(s.removeFirst());
       System.out.println(s.removeFirst());
       s.addLast(a);
       System.out.println(s.removeFirst());
       System.out.println(s.removeFirst());
       Iterator<String> i = s.iterator();
       while (i.hasNext())
          {
           String j = i.next();
           StdOut.println(j);
          }
       System.out.println(s.size());
   }
}

@945dc352173b24e2d948f2505ca803f1@"
"r04631034","8","0.89","102544","@6832ee776ea76a5e5b94a48a03937893@
import java.util.Iterator;
import java.util.LinkedList;

/**
 *
 *
 */
public class Deque<Item> implements Iterable<Item> {

          public LinkedList<Item> queue;

          public Deque() {
                    queue = new LinkedList<Item>();
          }

          public boolean isEmpty() {
                    if (queue.size() == 0) {
                              return true;
                    } else {
                              return false;
                    }
          }

          public int size() {
                    return queue.size();
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              queue.addFirst(item);
                    }
          }

          public void addLast(Item item) {
                    //Item item = null;
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              queue.addLast(item);
                    }
          }

          public Item removeFirst() {
                    if (queue.isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              Item first;
                              first = queue.getFirst();
                              queue.removeFirst();
                              return first;
                    }

          }

          public Item removeLast() {
                    if (queue.isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              Item last;
                              last = queue.getLast();
                              queue.removeLast();
                              return last;
                    }
          }

          public Iterator iterator() {
                    Iterator iterator;
                    iterator = queue.iterator();
                    return iterator;

          }

          public static void main(String[] args) {

          }

}


@6832ee776ea76a5e5b94a48a03937893@"
"r04631034","10","0.137","179424","@052e5c03c747487164341994028d1cbc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author user import java.util.*;
 */
public class Deque<Item> implements Iterable<Item> {

          /**
           * @param args the command line arguments
           */
          private Node first, last;
          private int N;

          private class Node {

                    Item item;
                    Node next;
                    Node Previous;
          }

          public Deque() {
                    first = null;
                    last = null;
                    N = 0;
          }

          public boolean isEmpty() {
                    return N == 0;
          }

          public int size() {
                    return N;
          }

          public void addLast(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldlast = last;
                              last = new Node();
                              last.item = item;
                              last.next = null;
                              last.Previous = null;
                              if (isEmpty()) {
                                        first = last;
                              } else {
                                        oldlast.next = last;
                                        last.Previous = oldlast;
                              }
                              N++;
                    }
          }

          public void addFirst(Item item) {
                    if (item == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              Node oldfirst = first;
                              first = new Node();
                              first.item = item;
                              first.next = null;
                              first.Previous = null;
                              if (isEmpty()) {
                                        last = first;
                              } else {
                                        oldfirst.Previous = first;
                                        first.next = oldfirst;
                              }
                              N++;
                    }
          }

          public Item removeFirst() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {

                              if (N == 1) {
                                        Node oldfirst = first;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldfirst.item;
                              } else {
                                        Node oldfirst = first;
                                        first = first.next;
                                        first.Previous = null;
                                        N--;
                                        return oldfirst.item;
                              }
                    }
          }

          public Item removeLast() {
                    if (isEmpty()) {
                              throw new java.util.NoSuchElementException();
                    } else {
                              if (N == 1) {
                                        Node oldlast = last;
                                        first = null;
                                        last = null;
                                        N--;
                                        return oldlast.item;
                              } else {
                                        Node oldlast = last;
                                        last = oldlast.Previous;
                                        last.next = null;
                                        N--;
                                        return oldlast.item;
                              }
                    }
          }

          public Iterator<Item> iterator() {
                    return new ListIterator();

          }

          private class ListIterator implements Iterator<Item> {

                    private Node current = first;

                    public boolean hasNext() {
                              return current != null;
                    }

                    public void remove() { /* not supported */

                              throw new java.lang.UnsupportedOperationException();
                    }

                    public Item next() {
                              if (!hasNext()) {
                                        throw new NoSuchElementException();
                              }
                              Item item = current.item;
                              current = current.next;
                              return item;

                    }
          }

          public static void main(String[] args) {
//                    // TODO code application logic here
//                    Deque<Integer> dq = new Deque<Integer>();
//                    dq.addFirst(1);
//
//                    dq.addLast(2);
//                    dq.addLast(3);
//
//                    dq.addFirst(2);
//                    dq.addFirst(3);
//                    System.out.println(dq.isEmpty());
//
//                    Iterator iter = dq.iterator();
//                    while (iter.hasNext()) {
//                              System.out.println(iter.next());
//                    }
//                    System.out.println("""");
//                  
//                    System.out.println(dq.removeFirst());
//
//                    System.out.println("""");
          }

}

@052e5c03c747487164341994028d1cbc@"
"r04631021","2","0.72","102416","@07477d5fd019b6581b6e50f7e5f9e8eb@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) {
            first = last ;      
        }
        else 
        {
            first.next = oldfirst ;
            oldfirst.previous = first ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
                }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       /*public Item previous(){
           Item item = current.item ;
           Item item1 = current.previous.item ;
           current = pre.next ;
           return item1 ;
       }*/
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque test = new Deque( ) ;
        test.addLast(""z"");
        test.addLast(""o"");
        test.addLast(""o"");
        test.addLast(""t"");
        test.addLast(""o"");
        test.addLast(""p"");
        test.addLast(""i"");
        test.addLast(""a"");
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeLast() ;
        //System.out.println(test.last.item) ;
        test.addLast(""o"");
        System.out.println(test.first.item) ;
        test.removeLast() ;
        //System.out.println(test.last.item) ;
       
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@07477d5fd019b6581b6e50f7e5f9e8eb@"
"r04631006","8","1.39","180368","@b223bf6bda83b30113f40db9d4073ca1@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.front = first;
        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;
        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {


    }
}
@b223bf6bda83b30113f40db9d4073ca1@"
"r04631021","2","0.71","102320","@60614bae4e50bd5bf860b8f4e1c46998@
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>() ;
        first.item = item ;
        if(isEmpty()) {
            first = last ;      
        }
        else 
        {
            first.next = oldfirst ;
            oldfirst.previous = first ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
                }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       /*public Item previous(){
           Item item = current.item ;
           Item item1 = current.previous.item ;
           current = pre.next ;
           return item1 ;
       }*/
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*Deque test = new Deque( ) ;
        test.addLast(""z"");
        test.addLast(""o"");
        test.addLast(""o"");
        test.addLast(""t"");
        test.addLast(""o"");
        test.addLast(""p"");
        test.addLast(""i"");
        test.addLast(""a"");
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        test.removeLast() ;
        //System.out.println(test.last.item) ;
        test.addLast(""o"");
        System.out.println(test.first.item) ;
        test.removeLast() ;*/
        //System.out.println(test.last.item) ;
       
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@60614bae4e50bd5bf860b8f4e1c46998@"
"r03228006","10","0.16","181328","@7efeaba7f9092550aaad0b40f800b0da@import java.util.Iterator;
import java.util.NoSuchElementException;

    
    public class Deque<Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private Node oldlast;
    public Node current;
    private int N;
    
    private class Node{
          Item item;
          Node next;}
    
   public Deque()                           // construct an empty deque
       { 
       first = null;
       last = null;
       oldlast = null;
       N = 0;
       }            
           
   public boolean isEmpty()                 // is the deque empty?
   {
     return ((first==null)|(last==null));    
   }
   public int size()                        // return the number of items on the deque
   {
       return N;
   } 
   public void addFirst(Item item)          // add the item to the front
   {
       if(item==null){throw new NullPointerException();}
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       if (isEmpty()) last = first;//if last is empty
       else first.next =oldfirst;
       N++;
   }
   public void addLast(Item item)          // add the item to the end
   {
       if(item==null){throw new NullPointerException();}
       oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if (isEmpty()) first = last;//if first is empty
       else  {oldlast.next=last;
             if(first.next==null){first.next = last;}}//if 目前只有first
       N++;
   } 
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {last = null;
                        first= null;
                        oldlast = null;}//if deque null 
        return item;
   }

   public Item removeLast()                 // remove and return the item from the 
   {
        if (isEmpty()) throw new NoSuchElementException();
        //private Node current = first;
        Item item = last.item;
        Node test=first;
        if(N>3){
               last = oldlast;
               for (int k = 0 ; k< N-3 ; k++){
               test = test.next;}
               oldlast = test;
               last.next = null;
               }
        if(N==3){
               last = oldlast;
               oldlast=first;
               last.next = null;
                }
        if(N==2){last = first;
                 last.next = null;}
        if(N==1){last = null;}
        N--;
        if (isEmpty()) {last = null;
                        first = null;
                        oldlast = null;} // to avoid loitering
        return item;   
   }

   public Iterator<Item> iterator()         // return an iterator over items in order from front to end
     {return new ListIterator();}
   private class ListIterator implements Iterator<Item>
     {
       public Node current = first;
       public boolean hasNext(){ return current !=null;}
       public void remove()    { throw new UnsupportedOperationException(); }
       public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            else {Item item = current.item;
            current = current.next; 
            return item;}
        }
     }
   
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
   
   public static void main(String[] args)   // unit testing
   {
       Deque<String> s = new Deque<String>();
       String a = ""2"";
       String b = ""3"";
       s.addLast(b);
       s.addLast(b);
       s.addFirst(a);
       s.addFirst(a);
       System.out.println(s.removeLast());
       System.out.println(s.removeLast());
       System.out.println(s.removeLast());
       System.out.println(s.removeLast());
       //s.addLast(a);
       //System.out.println(s.removeFirst());
       //System.out.println(s.removeFirst());
       Iterator<String> i = s.iterator();
       while (i.hasNext())
          {
           String j = i.next();
           StdOut.println(j);
          }
       //System.out.println(s.size());
   }
}

@7efeaba7f9092550aaad0b40f800b0da@"
"r04631006","8","1.43","170384","@7b5d824f726f5152f797529613d4a894@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;

        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.front = first;

        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last.next=null;
        last = last.front;

        N--;
        if (N == 1) {
            first = last;
        }
        if (isEmpty()) {
            first = null;
            last = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first.front=null;
        first = first.next;

        N--;
        if (N == 1) {
            last = first;
        }

        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {

    }
}
@7b5d824f726f5152f797529613d4a894@"
"r04631006","10","0.144","175664","@2377b8eebb5643b6b18fc25c8b362adb@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.front = first;
        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;

        N--;
        if (N == 1) {
            first = last;
        } 
        if (isEmpty()) {
            first = null;
            last = null;
        } else {
            last.next = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;

        N--;
        if (N == 1) {
            last = first;
        }
        if (isEmpty()) {
            last = null;
            first = null;
        } else {
            first.front = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {



    }
}
@2377b8eebb5643b6b18fc25c8b362adb@"
"r04631023","10","0.162","183328","@376157ddb644d47f5ff482ecddea2156@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first = null;
    private Node<Item> last = null;
    private int N = 0;

    private class Node<Item> {

        private Item item;
        private Node<Item> next;

        public Node(Item i, Node<Item> j) {
            item = i;
            next = j;
        }
    }

    public Deque() {
    }// construct an empty deque

    public boolean isEmpty() {
        return first == null;
    } // is the deque empty?

    public int size() {
        return N;
    }// return the number of items on the deque

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        N++;
        if (first == null) {
            first = new Node<Item>(item, last);
            last = first;
        } else {
            Node<Item> newFirst = new Node<Item>(item, first);
            if (last == first) {
                first = newFirst;
                last = first.next;
            } else {
                newFirst.next = first;
                first = newFirst;
            }
        }
    }// add the item to the front

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        N++;
        if (last == null) {
            last = new Node<Item>(item, null);
            first = last;
        } else {
            Node<Item> newLast = new Node<Item>(item, null);
            if (last == first) {
                last = newLast;
                first.next = last;
            } else {
                last.next = newLast;
                last = newLast;
            }
        }
    }// add the item to the end

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        N--;
        Item item = first.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            first = first.next;
        }
        return item;
    }// remove and return the item from the front

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        N--;
        Item item = last.item;
        if (first == last) {
            first = null;
            last = null;
            return item;
        } else {
            Node<Item> newLast = first;
            while (newLast.next != last) {
                newLast = newLast.next;
            }
            newLast.next = null;
            last = newLast;
            return item;
        }
    }// remove and return the item from the end

    public Iterator<Item> iterator() {
        return new NodeIterator<Item>(this);
    }

    private class NodeIterator<Item> implements Iterator<Item> {

        private Node<Item> next;

        public NodeIterator(Deque<Item> deque) {
                this.next = (Node<Item>) deque.first;
        }

        public boolean hasNext() {
            return next != null;
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = next.item;
            next = next.next;
            return item;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}

@376157ddb644d47f5ff482ecddea2156@"
"b02611012","7","0.84","102512","@d968fdb1206ea8257bd7b5494f3ae871@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.pre = oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        if (first == last) {
            first.next = null;
        }
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.pre;
        if (first == last) {
            last.pre = null;
        }
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    }

}

@d968fdb1206ea8257bd7b5494f3ae871@"
"b02611012","7","1.35","182832","@8bc75bac18ab2ee51d60887c84fd9780@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.pre = oldlast;
        }
        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (first == last) {
            first.next = null;
        } else {
            first = first.next;            // delete first node
        }
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return

        if (first == last) {
            last.pre = null;
        } else {
            last = last.pre;
        }
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addFirst(""fuck"");
        d.removeLast();

        // TODO code application logic here
    }

}

@8bc75bac18ab2ee51d60887c84fd9780@"
"b02611012","7","1.38","175008","@47c64d3d7966efed70bd077d001a8c3e@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (first == last) {
            first.next = null;
        } else {
            first = first.next;            // delete first node
        }
        first.pre = null;
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return

        if (first == last) {
            last.pre = null;
        } else {
            last = last.pre;
        }
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addFirst(""fuck"");
        d.removeLast();

        // TODO code application logic here
    }

}

@47c64d3d7966efed70bd077d001a8c3e@"
"b02611012","8","0.94","102544","@502d71ea5e8c206130fc87bc7633432a@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private void elseif(boolean b) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            first = last;
            first.next = null;
            first.pre = null;
        } else {
            first = first.next; 
            first.pre = null;// delete first node
        }
        
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        if (N==1) {
            last = null;
        } else if (N==2) {
            first = last;
            last.pre = null;
            first.pre = null;
        } else {
            last = last.pre;            // delete first node
            first.pre = null;
        }
        
        last.next = null;          // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addLast(""a"");
        d.addLast(""b"");
        d.removeFirst();
        d.removeFirst();
        d.addLast(""c"");
        System.out.printf(d.removeFirst());

        // TODO code application logic here
    }
}

@502d71ea5e8c206130fc87bc7633432a@"
"b02611012","8","1.07","102512","@3f60691dd456fe33f077ba3667e009c3@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private void elseif(boolean b) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            first = last;
            first.next = null;
            first.pre = null;
        } else {
            first = first.next; 
            first.pre = null;// delete first node
        }
        
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        if (N==1) {
            last = null;
        } else if (N==2) {
            first = last;
            last.pre = null;
            first.pre = null;
            last.next = null; 
        } else {
            last = last.pre;            // delete first node
            first.pre = null;
            last.next = null; 
        }
        
                 // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addLast(""a"");
        d.addFirst(""c"");
        d.addLast(""b"");
        d.addFirst(""c"");
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
        d.addFirst(""d"");
        System.out.printf(d.removeFirst());

        // TODO code application logic here
    }
}

@3f60691dd456fe33f077ba3667e009c3@"
"b03611011","0","1.38","175008","@e2c0f65d0e89506e7ed4aec18a250d2a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;
import javax.xml.soap.Node;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first, last;     // top of stack
    private int N;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pervious;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pervious = null;
        N++;
    }

    public void addLast(Item item) // add the item to the end
    {
        Deque.Node<Item> newlast = new Deque.Node<Item>();
        newlast.item = item;
        newlast.pervious = last;
        last.next = newlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

//    public Item removeLast() // remove and return the item from the end
//    {
//
//    }
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.iterator();
            Iterator e=d.iterator();
            while (e.hasNext()) {
                StdOut.println(e.next());
            }
        }

    }
}

@e2c0f65d0e89506e7ed4aec18a250d2a@"
"b02611012","8","1.08","102544","@2319275bf4f926cb0a3231377d0357c5@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private void elseif(boolean b) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            first = last;
            first.next = null;
            first.pre = null;
        } else {
            first = first.next; 
            first.pre = null;// delete first node
        }
        
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        if (N==1) {
            last = null;
        } else if (N==2) {
            first = last;
            last.pre = null;
            last.next = null; 
        } else {
            last = last.pre; 
            last.next = null; 
        }
        
                 // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addLast(""a"");
        d.addFirst(""c"");
        d.addLast(""b"");
        d.addFirst(""c"");
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
        d.addFirst(""d"");
        System.out.printf(d.removeFirst());

        // TODO code application logic here
    }
}

@2319275bf4f926cb0a3231377d0357c5@"
"b02611012","8","1.08","102464","@fc127d5bceffaa96e0f47525b335487a@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private void elseif(boolean b) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            first = last;
            first.next = null;
            first.pre = null;
        } else {
            first = first.next; 
            first.pre = null;// delete first node
        }
        
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        if (N==1) {
            last = null;
        } else if (N==2) {
            last = first;
            last.pre = null;
            last.next = null; 
        } else {
            last = last.pre; 
            last.next = null; 
        }
        
                 // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addLast(""a"");
        d.addFirst(""c"");
        d.addLast(""b"");
        d.addFirst(""c"");
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
        d.addFirst(""d"");
        System.out.printf(d.removeFirst());

        // TODO code application logic here
    }
}

@fc127d5bceffaa96e0f47525b335487a@"
"b02611012","10","0.139","173712","@73cce77a643e5a1f295952c251b2ec7a@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;// top of stack
    private Node<Item> last;
    private int N;                // size of the stack

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    private void elseif(boolean b) {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            first = new Node<Item>();
            first.item = item;
            last = first;
        } else {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            first.pre = null;
            oldfirst.pre = first;
        }
        N++;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (isEmpty()) {
            last = new Node<Item>();
            last.item = item;
            first = last;
        } else {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            oldlast.next = last;
            last.pre = oldlast;
        }

        N++;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            first = last;
            first.next = null;
            first.pre = null;
        } else {
            first = first.next; 
            first.pre = null;// delete first node
        }
        
        N--;
        return item;
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        if (N==1) {
            first = null;
            last = null;
        } else if (N==2) {
            last = first;
            last.pre = null;
            last.next = null; 
        } else {
            last = last.pre; 
            last.next = null; 
        }
        
                 // delete first node
        N--;
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Deque<String> d = new Deque<String>();
        d.addLast(""a"");
        d.addFirst(""c"");
        d.addLast(""b"");
        d.addFirst(""c"");
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
        d.addFirst(""d"");
        System.out.printf(d.removeFirst());

        // TODO code application logic here
    }
}

@73cce77a643e5a1f295952c251b2ec7a@"
"r02b48003","5","1.24","172016","@91c8c98e6fb5a0b7f1f1789db95e137b@
import java.util.Iterator;

/**
 *
 * @author clint
 */
public class Deque<Item> implements Iterable<Item> {
    private Node first; // pointer at the front
    private Node last;  // pointer at the back
    private int size;   // number of elements
    
    private class Node {
        /* the basic building block in the class */
        Node prev;
        Item item;
        Node next;
    } // end inner class Node
    
    public Deque() {
        /* construct an empty deque */
        first = null;
        last = null;
        size = 0;
    } // end constructor
    
    public boolean isEmpty() {
        /* is the deque empty? */
        return first == null;
    } // end func isEmpty
    
    public int size() {
        /* return the number of items on the deque */
        return size;
    } // end func size
    
    public void addFirst(Item item) {
        /* add the item to the front */
        if (first == null) {
            // if empty: set a new node
            first = new Node(); // create a new node
            first.prev = null;  // set previous point to null
            first.item = item;  // assign item
            first.next = null;  // set next point to null
            last = first;       // update reference last
        } else {
            // if not empty
            Node oldFirst = first; 
            first = new Node();    // create a new node
            first.prev = null;     // set previous point to null
            first.item = item;     // assign item
            first.next = oldFirst; // set next point to original first node
            oldFirst.prev = first; // original first node point back to new first node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addFirst
    
    public void addLast(Item item) {
        /* add the item to the end */
        if (last == null) {
            // if empty: set a new node
            last = new Node();  // create a new node
            last.prev = null;   // set previous point to null
            last.item = item;   // assign item
            last.next = null;   // set next point to null
            first = last;       // update reference first
        } else {
            // if empty: set a new node
            Node oldLast = last;
            last = new Node();    // create a new node
            last.prev = oldLast;  // set previous point to original last node
            last.item = item;     // assign item
            last.next = null;     // set next point to null
            oldLast.next = last;  // original last node point to new last node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addLast
    
    public Item removeFirst() {
        /* remove and return the item from the front */
        // if empty, return null
        if (first == null) { return null; } 
        
        // if not empty, 
        // get the first item and move the first pointer to the next node
        Item item = first.item;             
        first = first.next;
        
        // if the next node is not null, set previous to null
        if (first != null) { first.prev = null; } 
        
        // decrement size and return
        if (size > 0) { size -= 1; }
        return item;
    } // end func removeFirst
    
    public Item removeLast() {
        /* remove and return the item from the end */
        // if empty, return null
        if (last == null) { return null; }
        
        // if not empty, 
        // get the last item and move the first pointer to the previous node
        Item item = last.item;
        last = last.prev;
        if (last != null) { last.prev = null; }
        
        // decrement size
        if (size > 0) { size -= 1; }
        return item;
    }  // end func removeLast
    
    @Override
    public Iterator<Item> iterator() {
        /* return an iterator over items in order from front to end */
        return new DequeIterator();
    } // end func iterator
    
    private class DequeIterator implements Iterator<Item> {
        // initiation
        private Node current = first;
        
        @Override
        public boolean hasNext() {
            return current != null;
        } // end func hasNext
        
        @Override
        public Item next() {
            Item item = current.item;
            current   = current.next;
            return item;
        } // end func next
    } // end inner class DequeIterator
    
    @Override
    public boolean equals(Object obj) {
        Deque<Item> that = (Deque) obj;
        Item[] arr01 = (Item[]) new Object[size];
        Item[] arr02 = (Item[]) new Object[size];
        int idx;
        
        idx = 0;
        for (Item item : this) {
            arr01[idx] = item;
            idx += 1;        
        } // end loop for
        
        idx = 0;
        for (Item item : that) {
            arr02[idx] = item;
            idx += 1;
        } // end loop for
        
        for (idx = 0; idx < size; idx += 1){
            if (arr01[idx] != arr02[idx]) { return false; }
        } // end loop for
        
        return true;
    } // end func equals
    
    public static void main(String[] args) {
        Deque<Integer> dequeInt01 = new Deque<>();
        Deque<Integer> dequeInt02 = new Deque<>();
        dequeInt01.addFirst(0);
        dequeInt01.addFirst(0);
        dequeInt02.addFirst(0);
        dequeInt02.addFirst(1);
        System.out.println(dequeInt01.equals(dequeInt02));
        //System.out.println(dequeInt.removeFirst());
        //System.out.println(dequeInt.removeFirst());
        //for (Integer num : dequeInt) {
        //    System.out.println(num);
        //}
    }
} // end class 

@91c8c98e6fb5a0b7f1f1789db95e137b@"
"r02b48003","7","1.52","180800","@cd1558d80b916c1aa91e2156ca773d1a@
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;

/**
 *
 * @author clint
 */
public class Deque<Item> implements Iterable<Item> {
    private Node first; // pointer at the front
    private Node last;  // pointer at the back
    private int size;   // number of elements
    
    private class Node {
        /* the basic building block in the class */
        Node prev;
        Item item;
        Node next;
    } // end inner class Node
    
    public Deque() {
        /* construct an empty deque */
        first = null;
        last = null;
        size = 0;
    } // end constructor
    
    public boolean isEmpty() {
        /* is the deque empty? */
        return first == null;
    } // end func isEmpty
    
    public int size() {
        /* return the number of items on the deque */
        return size;
    } // end func size
    
    public void addFirst(Item item) {
        /* add the item to the front */
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            // if empty: set a new node
            first = new Node(); // create a new node
            first.prev = null;  // set previous point to null
            first.item = item;  // assign item
            first.next = null;  // set next point to null
            last = first;       // update reference last
        } else {
            // if not empty
            Node oldFirst = first; 
            first = new Node();    // create a new node
            first.prev = null;     // set previous point to null
            first.item = item;     // assign item
            first.next = oldFirst; // set next point to original first node
            oldFirst.prev = first; // original first node point back to new first node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addFirst
    
    public void addLast(Item item) {
        /* add the item to the end */
        // Throw a java.lang.NullPointerException if the client attempts to add a null item
        if (item == null) {
            throw new NullPointerException();
        }
        
        if (last == null) {
            // if empty: set a new node
            last = new Node();  // create a new node
            last.prev = null;   // set previous point to null
            last.item = item;   // assign item
            last.next = null;   // set next point to null
            first = last;       // update reference first
        } else {
            // if empty: set a new node
            Node oldLast = last;
            last = new Node();    // create a new node
            last.prev = oldLast;  // set previous point to original last node
            last.item = item;     // assign item
            last.next = null;     // set next point to null
            oldLast.next = last;  // original last node point to new last node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addLast
    
    public Item removeFirst() {
        /* remove and return the item from the front */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (first == null) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the first item and move the first pointer to the next node
        Item item = first.item;             
        first = first.next;
        
        // if the next node is not null, set previous to null
        if (first != null) { first.prev = null; } 
        
        // decrement size and return
        if (size > 0) { size -= 1; }
        return item;
    } // end func removeFirst
    
    public Item removeLast() {
        /* remove and return the item from the end */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (last == null) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the last item and move the first pointer to the previous node
        Item item = last.item;
        last = last.prev;
        if (last != null) { last.prev = null; }
        
        // decrement size
        if (size > 0) { size -= 1; }
        return item;
    }  // end func removeLast
    
    @Override
    public Iterator<Item> iterator() {
        /* return an iterator over items in order from front to end */
        return new DequeIterator();
    } // end func iterator
    
    private class DequeIterator implements Iterator<Item> {
        // initiation
        private Node current = first;
        
        @Override
        public boolean hasNext() {
            return current != null;
        } // end func hasNext
        
        @Override
        // throw a java.util.NoSuchElementException 
        // if the client calls the next() method in the iterator and
        // there are no more items to return.
        public Item next() {
            if (current == null) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current   = current.next;
            return item;
        } // end func next
        
        @Override
        // throw UnsupportedOperationException 
        // if the client calls the remove() method in the iterator
        public void remove() {
             throw new UnsupportedOperationException();
        }
    } // end inner class DequeIterator
    
    @Override
    public boolean equals(Object obj) {
        Deque<Item> that = (Deque) obj;
        Item[] arr01 = (Item[]) new Object[size];
        Item[] arr02 = (Item[]) new Object[size];
        int idx;
        
        idx = 0;
        for (Item item : this) {
            arr01[idx] = item;
            idx += 1;        
        } // end loop for
        
        idx = 0;
        for (Item item : that) {
            arr02[idx] = item;
            idx += 1;
        } // end loop for
        
        for (idx = 0; idx < size; idx += 1){
            if (arr01[idx] != arr02[idx]) { return false; }
        } // end loop for
        
        return true;
    } // end func equals
    
    public static void main(String[] args) {
        Deque<Integer> dequeInt01 = new Deque<>();
        Deque<Integer> dequeInt02 = new Deque<>();
        dequeInt01.addFirst(0);
        dequeInt01.addFirst(1);
        dequeInt02.addFirst(0);
        dequeInt02.addFirst(1);
        System.out.println(dequeInt01.equals(dequeInt02));
        //System.out.println(dequeInt.removeFirst());
        //System.out.println(dequeInt.removeFirst());
        //for (Integer num : dequeInt) {
        //    System.out.println(num);
        //}
    }
} // end class 

@cd1558d80b916c1aa91e2156ca773d1a@"
"r02b48003","7","0.84","102400","@46599d8de3e21916d95f73cf173973f4@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author clint
 */
public class Deque<Item> implements Iterable<Item> {
    private Node first; // pointer at the front
    private Node last;  // pointer at the back
    private int size;   // number of elements
    
    private class Node {
        /* the basic building block in the class */
        Node prev;
        Item item;
        Node next;
    } // end inner class Node
    
    public Deque() {
        /* construct an empty deque */
        first = null;
        last = null;
        size = 0;
    } // end constructor
    
    public boolean isEmpty() {
        /* is the deque empty? */
        return first == null;
    } // end func isEmpty
    
    public int size() {
        /* return the number of items on the deque */
        return size;
    } // end func size
    
    public void addFirst(Item item) {
        /* add the item to the front */
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            // if empty: set a new node
            first = new Node(); // create a new node
            first.prev = null;  // set previous point to null
            first.item = item;  // assign item
            first.next = null;  // set next point to null
            last = first;       // update reference last
        } else {
            // if not empty
            Node oldFirst = first; 
            first = new Node();    // create a new node
            first.prev = null;     // set previous point to null
            first.item = item;     // assign item
            first.next = oldFirst; // set next point to original first node
            oldFirst.prev = first; // original first node point back to new first node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addFirst
    
    public void addLast(Item item) {
        /* add the item to the end */
        // Throw a java.lang.NullPointerException if the client attempts to add a null item
        if (item == null) {
            throw new NullPointerException();
        }
        
        if (last == null) {
            // if empty: set a new node
            last = new Node();  // create a new node
            last.prev = null;   // set previous point to null
            last.item = item;   // assign item
            last.next = null;   // set next point to null
            first = last;       // update reference first
        } else {
            // if empty: set a new node
            Node oldLast = last;
            last = new Node();    // create a new node
            last.prev = oldLast;  // set previous point to original last node
            last.item = item;     // assign item
            last.next = null;     // set next point to null
            oldLast.next = last;  // original last node point to new last node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addLast
    
    public Item removeFirst() {
        /* remove and return the item from the front */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the first item and move the first pointer to the next node
        Item item = first.item;             
        first = first.next;
        
        // if the next node is not null, set previous to null
        if (first != null) { first.prev = null; } 
        
        // decrement size and return
        if (size > 0) { size -= 1; }
        return item;
    } // end func removeFirst
    
    public Item removeLast() {
        /* remove and return the item from the end */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the last item and move the first pointer to the previous node
        Item item = last.item;
        last = last.prev;
        if (last != null) { last.prev = null; }
        
        // decrement size
        if (size > 0) { size -= 1; }
        return item;
    }  // end func removeLast
    
    @Override
    public Iterator<Item> iterator() {
        /* return an iterator over items in order from front to end */
        return new DequeIterator();
    } // end func iterator
    
    private class DequeIterator implements Iterator<Item> {
        // initiation
        private Node current = first;
        
        @Override
        public boolean hasNext() {
            return current != null;
        } // end func hasNext
        
        @Override
        // throw a java.util.NoSuchElementException 
        // if the client calls the next() method in the iterator and
        // there are no more items to return.
        public Item next() {
            if (current == null) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current   = current.next;
            return item;
        } // end func next
        
        @Override
        // throw UnsupportedOperationException 
        // if the client calls the remove() method in the iterator
        public void remove() {
             throw new UnsupportedOperationException();
        }
    } // end inner class DequeIterator
    
    @Override
    public boolean equals(Object obj) {
        Deque<Item> that = (Deque) obj;
        Item[] arr01 = (Item[]) new Object[size];
        Item[] arr02 = (Item[]) new Object[size];
        int idx;
        
        idx = 0;
        for (Item item : this) {
            arr01[idx] = item;
            idx += 1;        
        } // end loop for
        
        idx = 0;
        for (Item item : that) {
            arr02[idx] = item;
            idx += 1;
        } // end loop for
        
        for (idx = 0; idx < size; idx += 1){
            if (arr01[idx] != arr02[idx]) { return false; }
        } // end loop for
        
        return true;
    } // end func equals
    
    public static void main(String[] args) {
        Deque<Integer> dequeInt01 = new Deque<>();
        Deque<Integer> dequeInt02 = new Deque<>();
        dequeInt01.addFirst(0);
        dequeInt01.addFirst(1);
        dequeInt02.addFirst(0);
        dequeInt02.addFirst(1);
        System.out.println(dequeInt01.equals(dequeInt02));
        //System.out.println(dequeInt.removeFirst());
        //System.out.println(dequeInt.removeFirst());
        //for (Integer num : dequeInt) {
        //    System.out.println(num);
        //}
    }
} // end class 

@46599d8de3e21916d95f73cf173973f4@"
"r04921044","10","0.139","181344","@846346ecf5d48504ebbc9c85caa5e83f@
import java.util.Iterator;

public class Deque<T> implements Iterable<T> {

    private class Node {
        T value;
        Node previous;
        Node next;
    }

    int N;
    Node head;
    Node tail;

    public Deque() {
        N = 0;

        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.previous = head;
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    public void addFirst(T t) {
        if (t == null) {
            throw new NullPointerException();
        }

        N++;

        Node item = new Node();
        item.value = t;

        Node oldFirst = head.next;
        head.next = item;
        item.next = oldFirst;
        oldFirst.previous = item;
        item.previous = head;
    }

    public void addLast(T t) {
        if (t == null) {
            throw new java.lang.NullPointerException();
        }

        N++;

        Node item = new Node();
        item.value = t;

        Node oldLast = tail.previous;
        tail.previous = item;
        item.previous = oldLast;
        oldLast.next = item;
        item.next = tail;
    }

    public T removeFirst() {
        if (head.next == tail) {
            throw new java.util.NoSuchElementException();
        }

        N--;

        Node oldFirst = head.next;

        head.next = oldFirst.next;
        head.next.previous = head;

        return oldFirst.value;
    }

    public T removeLast() {
        if (head.next == tail) {
            throw new java.util.NoSuchElementException();
        }

        N--;

        Node oldLast = tail.previous;

        tail.previous = oldLast.previous;
        tail.previous.next = tail;

        return oldLast.value;
    }

    private class NodeIterator implements Iterator<T> {
        Node pointer = head;

        public boolean hasNext() {
            return pointer.next != tail;
        }

        public T next() {
            pointer = pointer.next;
            if (pointer == tail) {
                throw new java.util.NoSuchElementException();
            }

            return pointer.value;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }
    }

    public Iterator<T> iterator() {
        return new NodeIterator();
    }

    public static void main(String[] args) {

        /*
        java.lang.NullPointerException if the client attempts to add a null item;
        java.util.NoSuchElementException if the client attempts to remove an item from an empty deque;
        java.lang.UnsupportedOperationException if the client calls the remove() method in the iterator;
        java.util.NoSuchElementException if the client calls the next() method in the iterator and there are no more items to return
        */

        try { // add null
            Deque<Integer> dq = new Deque<>();
            dq.addFirst(null);
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.NullPointerException"");
            System.out.println(""Result is: "" + e);
        }

        try { // add null
            Deque<Integer> dq = new Deque<>();
            dq.addLast(null);
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.NullPointerException"");
            System.out.println(""Result is: "" + e);
        }

        try { // remove on empty
            Deque<Integer> dq = new Deque<>();
            Integer popped = dq.removeFirst();
            System.out.println(popped);
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.NoSuchElementException"");
            System.out.println(""Result is: "" + e);
        }

        try { // remove on empty
            Deque<Integer> dq = new Deque<>();
            Integer popped = dq.removeLast();
            System.out.println(popped);
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.NoSuchElementException"");
            System.out.println(""Result is: "" + e);
        }

        try { // call iterator remove
            Deque<Integer> dq = new Deque<>();
            Iterator<Integer> it = dq.iterator();
            it.remove();
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.UnsupportedOperationException"");
            System.out.println(""Result is: "" + e);
        }

        try { // call iterator next on null
            Deque<Integer> dq = new Deque<>();
            Iterator<Integer> it = dq.iterator();
            it.next();
        } catch (Exception e) {
            System.out.println(""Expecting: java.lang.NoSuchElementException"");
            System.out.println(""Result is: "" + e);
        }

        try { // push first, pop first
            Deque<Integer> dq = new Deque<>();
            dq.addFirst(new Integer(1));
            Integer popped = dq.removeFirst();
            System.out.println(popped);
        } catch (Exception e) {
            System.out.println(""Error!!!"");
            System.out.println(e);
        }

        try { // iterator
            Deque<Integer> dq = new Deque<>();
            for (int i=0; i<5; ++i) {
                dq.addFirst(new Integer(i));
            }
            for (int i=10; i<15; ++i) {
                dq.addLast(new Integer(i));
            }

            Iterator<Integer> it = dq.iterator();
            while (it.hasNext()) {
                System.out.print(it.next() + "" "");
            }
            System.out.println();
        } catch (Exception e) {
            System.out.println(""Error!!!"");
            System.out.println(e);
        }

        try { // push last, pop first
            Deque<Integer> dq = new Deque<>();
            dq.addLast(new Integer(1));
            Integer popped = dq.removeFirst();
            System.out.println(popped);
        } catch (Exception e) {
            System.out.println(""Error!!!"");
            System.out.println(e);
        }
    }

}
@846346ecf5d48504ebbc9c85caa5e83f@"
"r04945039","10","0.142","178080","@b00148028d4890d8ce54109a108ab2e0@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

	private int inisize=0;	 // initial size of deque
	private Node first;      // index of first item
    private Node last;       // index of last item

	// construct an empty deque
	public Deque() {}
	   

	// is the deque empty?
	public boolean isEmpty() {
		return first == null;
	}                

	// return the number of items on the deque
	public int size() {
		return inisize;
	}                       


	// add the item to the front
	public void addFirst(Item item) {
		throwIfNull(item);
		Node newFirst = new Node();
		newFirst.item = item;
                                newFirst.previous = null;
		if(!isEmpty()){
			newFirst.next = first;
			first.previous = newFirst;
		}
		first = newFirst;
		if(last == null) last = first;

		inisize++;
	}         



	// add the item to the end
	public void addLast(Item item) {
		throwIfNull(item);
		Node newLast = new Node();
		newLast.item = item;
                                newLast.next=null;
		if(last!=null){
		last.next = newLast;
		newLast.previous = last;
		}
		last = newLast;
		if(isEmpty()) first = last;
		inisize++;
	}          

	// remove and return the item from the front
	public Item removeFirst() {
		throwIfEmpty();
		Node oldFirst = first;
		first = first.next;

		if(isEmpty())last=null;
         		else first.previous=null;

		inisize--;
		return oldFirst.item;
		}              


	// remove and return the item from the end
	public Item removeLast() {
		throwIfEmpty();
		Node oldLast = last;
		last = last.previous;
		if (last==null) first=null;
                //System.out.println(""Empty!"");}
		else last.next=null;

		inisize--;
		return oldLast.item;

	}                


	// return an iterator over items in order from front to end
	@Override
public Iterator<Item> iterator() {
            return new ListIterator();  }
       
	private class ListIterator implements Iterator<Item>{
		private Node current = first;

		@Override
		public boolean hasNext(){
			return current != null;
		}
@Override
		public Item next(){
			if (current == null) throw new NoSuchElementException();

			Item item = current.item;
			current = current.next;
			return item;
		}
@Override
		public void remove(){
		throw new UnsupportedOperationException();
		}


	}        

	
private class Node {
        Item item;
        Node next;
        Node previous;
    }

    private void throwIfEmpty() {
        if (isEmpty ())
            throw new NoSuchElementException();
    }

    private void throwIfNull(Item item) {
        if (item == null)
            throw new NullPointerException();
    }

	public static void main(String[] args) {
		
//                Deque<Integer> tryyy = new Deque<Integer>();
//                System.out.println(tryyy.removeLast());
//                tryyy.addFirst(-3);               
//                tryyy.addFirst(-16456);
//                tryyy.addFirst(53);                           
//                tryyy.removeFirst();
//                tryyy.removeLast();
//                tryyy.removeLast(); 
                //System.out.println(tryyy.first.item);
                //System.out.println(tryyy.first.next.item);
                //System.out.println(tryyy.first.next.next.item);
                //System.out.println(tryyy.first.next.next.next.item);
//                System.out.println(tryyy.last);
//                System.out.println(tryyy.last.previous.item);
//                System.out.println(tryyy.last.previous.previous.item);
//                System.out.println(tryyy.last.previous.previous.previous.item);
                
                //System.out.println(tryyy.size());
//                Iterator<Integer> cal = tryyy.iterator();      
//                cal.next();
               
               
	} 



}
@b00148028d4890d8ce54109a108ab2e0@"
"b99611017","7","1.71","177168","@9e825a7cc16f698f2dab95b9a2489e9c@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if(N==0){
            
            last=new Node<>();
            first=last;
            last.item=item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if(N==0){
            
            last=new Node<>();
            first=last;
            last.item=item;
            N++;
        }
        else{
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item=item;
        oldlast.next=last;
        
        N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        if (first.next == null && last.next == null) {
            first = null;
            Item item=last.item;
            last = null;
            N--;
            return item;
            
        }
        else{
        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        
        
        
        N--;
        return item;
        }
    }     
    

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();
        test.addLast(654);
        test.addLast(""五六七"");
        System.out.println(test.removeFirst());
        
        
        System.out.println(test.size());
        // TODO code application logic here
    }

}

@9e825a7cc16f698f2dab95b9a2489e9c@"
"b02611026","7","1.54","184160","@4032257a05ceaa0c1ded41e04ebf5c84@import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;   
    
    public int count = 0;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
       
    public Deque(){        
        first = null;
        last  = null;
        N = 0;
    }
    public boolean isEmpty(){
        return first == null;
    }
    public int size(){
        return N;
    }
    public void addFirst(Item item){    //push
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    public void addLast(Item item){//enquene
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;     
    }
    public Item removeFirst(){  //dequene
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast(){   //pop
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    public static void main(String[] args) {
        Queue<String> q = new Queue<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) q.enqueue(item);
            else if (!q.isEmpty()) StdOut.print(q.dequeue() + "" "");
        }
        StdOut.println(""("" + q.size() + "" left on queue)"");       
    }
    
}

@4032257a05ceaa0c1ded41e04ebf5c84@"
"f02631008","7","1.42","174848","@ad1e2ed3350a1f087ce520721814471c@
import java.util.*;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
/**
 *
 * @author philip
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previ;
    }
    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    /**
     * Returns true if this queue is empty.
     *
     * @return <tt>true</tt> if this queue is empty; <tt>false</tt> otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }
    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    /**
     * Adds the item to this queue.
     *
     * @param  item the item to add
     */
    public void addFirst(Item item) {
        Node<Item> newfirst;
        newfirst = new Node<Item>();
        newfirst.item = item;
        newfirst.previ = null;
        newfirst.next = null;
        if (isEmpty()){
            first = newfirst;
            last = first;
        }
        else{
            newfirst.next = first;
            first.previ = newfirst;
            first = newfirst;
        }
        N++;
    }
    public void addLast(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previ = null;
        if (isEmpty()){
            first = last;
//            last = first;
        }
        else{
            oldlast.next = last;
            last.previ = oldlast;
            //last.next = null;
        }
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()){
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        //first = first.next;
        if(N > 1){
            first = first.next;
            first.previ = null;
        }
        if(N == 1){
            //first = null;
            //first.next = null;
            //last = null;
        }
        N--;
        if(N == 0){
            last = null;
            first = null;
            //first.previ = null;
            //first.next = null;
            N = 0;
        }
        if (isEmpty()) last = null;   // to avoid loitering
        return item;//A
    }
    public Item removeLast() {
        if (isEmpty()){
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = last.item;
        //last = last.previ;
        //last.next = null;
        if(N > 1){
            last = last.previ;
            last.next = null;
            //last.previ = null;
        }
        if(N == 1){
            last.previ = null;
            last = null;
            first = null;
        }
        N--;
        if(N == 0){
            first = null;
            last = null;
            N = 0;
        }
        if (isEmpty()){
            first = null;
            last = null;
        }   // to avoid loitering
        return item;
    }
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    public static void main(String[] args) {

        /*Deque<String> qe = new Deque<String>();

//        qe.addLast(""a"");
//        qe.addLast(""b"");
        qe.addLast(""c"");
        qe.addLast(""d"");
        qe.addFirst(""a"");
        qe.addFirst(""b"");
//        qe.addLast(""c"");
        qe.removeLast();
        qe.removeFirst();
        qe.removeFirst();
        //qe.removeFirst();
        qe.removeLast();
        //qe.removeLast();
        //qe.removeLast();
//        qe.addLast(""a"");
        qe.addFirst(""a"");
        //qe.removeLast();

        Iterator it=qe.iterator();

        System.out.println(""Initial Size of Queue :""+qe.size());

        while(it.hasNext())
        {
            String iteratorValue=(String)it.next();
            System.out.println(""Queue Next Value :""+iteratorValue);
        }

        System.out.println(""Final Size of Queue :""+qe.size());*/
    
    }
    
}

@ad1e2ed3350a1f087ce520721814471c@"
"f02631008","10","0.14","182400","@844011835eedf8d7a8b1c659b26ea574@
import java.util.*;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
/**
 *
 * @author philip
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> previ;
    }
    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    /**
     * Returns true if this queue is empty.
     *
     * @return <tt>true</tt> if this queue is empty; <tt>false</tt> otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }
    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    /**
     * Adds the item to this queue.
     *
     * @param  item the item to add
     */
    public void addFirst(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        Node<Item> newfirst;
        newfirst = new Node<Item>();
        newfirst.item = item;
        newfirst.previ = null;
        newfirst.next = null;
        if (isEmpty()){
            first = newfirst;
            last = first;
        }
        else{
            newfirst.next = first;
            first.previ = newfirst;
            first = newfirst;
        }
        N++;
    }
    public void addLast(Item item) {
        if(item == null){
            throw new NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previ = null;
        if (isEmpty()){
            first = last;
//            last = first;
        }
        else{
            oldlast.next = last;
            last.previ = oldlast;
            //last.next = null;
        }
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item item = first.item;
        //first = first.next;
        if(N > 1){
            first = first.next;
            first.previ = null;
        }
        if(N == 1){
            //first = null;
            //first.next = null;
            //last = null;
        }
        N--;
        if(N == 0){
            last = null;
            first = null;
            //first.previ = null;
            //first.next = null;
            N = 0;
        }
        if (isEmpty()) last = null;   // to avoid loitering
        return item;//A
    }
    public Item removeLast() {
        if (isEmpty()){
            throw new NoSuchElementException();
        }
        Item item = last.item;
        //last = last.previ;
        //last.next = null;
        if(N > 1){
            last = last.previ;
            last.next = null;
            //last.previ = null;
        }
        if(N == 1){
            last.previ = null;
            last = null;
            first = null;
        }
        N--;
        if(N == 0){
            first = null;
            last = null;
            N = 0;
        }
        if (isEmpty()){
            first = null;
            last = null;
        }   // to avoid loitering
        return item;
    }
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    public static void main(String[] args) {

        /*Deque<String> qe = new Deque<String>();

//        qe.addLast(""a"");
//        qe.addLast(""b"");
        qe.addLast(""c"");
        qe.addLast(""d"");
        qe.addFirst(""a"");
        qe.addFirst(""b"");
//        qe.addLast(""c"");
        qe.removeLast();
        qe.removeFirst();
        qe.removeFirst();
        //qe.removeFirst();
        qe.removeLast();
        qe.removeLast();
        //qe.removeLast();
//        qe.addLast(""a"");
//        qe.addFirst(""a"");
        //qe.removeLast();

        Iterator it=qe.iterator();

        System.out.println(""Initial Size of Queue :""+qe.size());

        while(it.hasNext())
        {
            String iteratorValue=(String)it.next();
            System.out.println(""Queue Next Value :""+iteratorValue);
        }

        System.out.println(""Final Size of Queue :""+qe.size());*/
    
    }
    
}

@844011835eedf8d7a8b1c659b26ea574@"
"r04631026","0","1.54","184160","@92556c3a4b27ccfa647831694fac240b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Yue
 */
public class Dequeue {
    public class Deque<T> implements Iterable<T> {
        private class Node<T> {
            public Node<T> left, right;
            private final T item;
            public Node(T item) {
                // FIXME: maybe it's a bad practice to throw exception in constructor
                if (item == null) {
                    throw new NullPointerException();
                }
                this.item = item;
            }
            public void connectRight(Node<T> other) {
                this.right = other;
                other.left = this;
            }
        }
        private class DequeIterator implements Iterator<T> {
            private Node<T> curr = head;
            public boolean hasNext() {
                return curr != null;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                T item = curr.item;
                curr = curr.right;
                return item;
            }
        }
        private Node<T> head, tail;
        private int size;
        public Iterator<T> iterator() {
            return new DequeIterator();
        }

        public Deque() {
        }

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public void checkInvariants() {
            assert size >= 0;
            assert size > 0 || (head == null && tail == null);
            assert (head == null && tail == null) || (head != null && tail != null);
        }

        public void addFirst(T item) {
            Node<T> prevHead = head;
            Node<T> newHead = new Node<T>(item);
            if (prevHead != null) {
                newHead.connectRight(prevHead);
            } else {
                tail = newHead;
            }
            head = newHead;
            size++;
            checkInvariants();
        }

        public void addLast(T item) {
            Node<T> newTail = new Node<T>(item);
            Node<T> prevTail = tail;
            if (prevTail != null) {
                prevTail.connectRight(newTail);
            } else {
                head = newTail;
            }
            tail = newTail;
            size++;
            checkInvariants();
        }

        public T removeFirst() {
            if (isEmpty()) {
                throw new java.util.NoSuchElementException();
            }
            size--;
            Node<T> prevHead = head;
            head = prevHead.right;
            prevHead.right = null;
            if (head != null) {
                head.left = null;
            }
            checkInvariants();
            return prevHead.item;
        }

        public T removeLast() {
            if (isEmpty()) {
                throw new java.util.NoSuchElementException();
            }
            size--;
            Node<T> prevTail = tail;
            tail = prevTail.left;
            prevTail.left = null;
            if (tail != null) {
                tail.right = null;
            }
            checkInvariants();
            return prevTail.item;
        }
    }
}
@92556c3a4b27ccfa647831694fac240b@"
"b03611033","0","1.54","184160","@63ac0041dac3ed506e6eb14ea08065fc@
import edu.princeton.cs.algs4.Stack;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private Node oldlast, oldfirst;

    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
       
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
                //last.previous=first.previous;
            } else{
                last.previous =oldlast;
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.previous =null;
            if (isEmpty()) {
                last = first;
            } else {
                first.next = oldfirst;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first.item = null;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = last.item;
            last = last.previous;
            N--;
            return item;
        }
    }

    @Override
    public Iterator<Item>  iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator(first);
    }

    private class ListIterator implements Iterable<Item> {
        private Node current;
        public ListIterator(Node first) {
            current = first;
        }
        public boolean hasNext() {
            return current != null;
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }

    public static void main(String[] args) throws Exception {   // unit testing
/*
        Deque deque = new Deque();
        
        //Iterator it = deque.iterator();
        
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addFirst(6);
        deque.addLast(7);
        deque.addLast(8);
        String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
/       
        Iterator it = deque.iterator();
        while(it.hasNext()){
            StdOut.println(it.next());
        }
     */   
    }
   
}


@63ac0041dac3ed506e6eb14ea08065fc@"
"b99611017","1","0.24","98736","@8c2126b88befa23f1bbcd9199f58c1d5@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if(N==0){
            
            first=new Node<>();
            last=first;
            first.item=item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if(N==0){
            
            last=new Node<>();
            first=last;
            last.item=item;
            N++;
        }
        else{
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item=item;
        oldlast.next=last;
        
        N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        
        if (first.next == null && last.next == null) {
            first = null;
            Item item=last.item;
            last = null;
            N--;
            return item;
            
        }
        else{
        Node<Item> starter = null;
        Node<Item> buff = null;
        starter = first;
        Item item = last.item;
        buff = first;
        while (first.next != last && first.next != null) {
            first = first.next;
            buff = first;
        }
        first = starter;
        last = buff;
        
        
        
        N--;
        return item;
        }
    }     
    

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return N>0;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();
        Iterator a;
        a=test.iterator();
        test.addFirst(""..."");
     
        test.addFirst('5');

        System.out.println(a.next());
        
        
        System.out.println(test.size());
        // TODO code application logic here
    }

}

@8c2126b88befa23f1bbcd9199f58c1d5@"
"b99611017","7","1.75","187744","@deacaa9fce55ee00dfff8b526988568b@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            first = new Node<>();
            last = first;
            first.item = item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            last = new Node<>();
            first = last;
            last.item = item;
            N++;
        } else {
            Node<Item> oldlast = last;
            last = new Node<>();
            last.item = item;
            oldlast.next = last;

            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        if (first.next == null && last.next == null) {
            first = null;
            Item item = last.item;
            last = null;
            N--;
            return item;

        } else {
            Node<Item> starter = null;
            Node<Item> buff = null;
            starter = first;
            Item item = last.item;
            buff = first;
            while (first.next != last && first.next != null) {
                first = first.next;
                buff = first;
            }
            first = starter;
            last = buff;

            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();

        test.addFirst(""..."");

        test.addFirst('5');
        Iterator a;
        a = test.iterator();
        System.out.println(a.next());

        System.out.println(test.size());
        // TODO code application logic here
    }

}

@deacaa9fce55ee00dfff8b526988568b@"
"b02611026","7","1.5","181168","@73fa8ab5f92a12533a770d23ab2b8a3d@import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;   
       
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
       
    public Deque(){        
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return first == null;
    }
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){    //push
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        assert check();
    }
    
    public void addLast(Item item){     //enquene
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        }
        else{
            oldlast.next = last;
        }
        N++;     
        assert check();
    }
    public Item removeFirst(){  //dequene
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;
        }   // to avoid loitering
        assert check();
        return item;
    }
    public Item removeLast(){   //pop
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        assert check();
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);  
    }    
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext(){ 
            return current != null;                    
        }
        public void remove(){ 
            throw new UnsupportedOperationException();  
        }

        public Item next() {
            if (!hasNext()){
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    private boolean check() {
        if (N == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (N == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null; x = x.next) {
               numberOfNodes++;
            }
            if (numberOfNodes != N) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
               lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    } 
    
    public static void main(String[] args) {
//        Queue<String> q = new Queue<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) {
//                q.enqueue(item);
//            }
//            else if (!q.isEmpty()) {
//                StdOut.print(q.dequeue() + "" "");
//            }
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");       
//        
        Deque<String> d = new Deque<String>();
        
        d.addLast("""");
        d.addFirst("""");
        if(d.isEmpty())
            System.out.printf(""is Empty"");        
        else
            System.out.printf(""Not empty"");
        
        System.out.printf(d.removeFirst());
    }
    
}

@73fa8ab5f92a12533a770d23ab2b8a3d@"
"b02611026","8","1.49","176368","@0fc8149fdd94f17efb733177037512fc@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {    //push
        if (item != null) {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            N++;
        } else {
            throw new NullPointerException(""add null"");
        }
    }

    public void addLast(Item item) {     //enquene
        if (item != null) {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }
        else {
            throw new NullPointerException(""add null"");
        }
    }

    public Item removeFirst() {  //dequene
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;
        }   // to avoid loitering

        return item;
    }

    public Item removeLast() {   //pop
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;

        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
//        Queue<String> q = new Queue<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) {
//                q.enqueue(item);
//            }
//            else if (!q.isEmpty()) {
//                StdOut.print(q.dequeue() + "" "");
//            }
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");       
//        
        Deque<String> d = new Deque<String>();

        d.addLast(""1"");
        //d.addFirst("""");
        if (d.isEmpty()) {
            System.out.printf(""is Empty"");
        } else {
            System.out.printf(""Not empty"");
        }

        System.out.printf(d.removeFirst());
        System.out.printf(d.removeFirst());
        
    }

}

@0fc8149fdd94f17efb733177037512fc@"
"r04945008","10","0.139","175648","@d05231fedaa1faf25c725cee43cc7b44@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque <Item> implements Iterable<Item> {
    private Node first;
    private Node last;
    private int numberOfItems;

    private class Node {
        private Item item;
        private Node next;
        private Node prev;

        Node(Item item) {
            this.item = item;
            this.next = null;
            this.prev = null;
        }
    }

    private class DequeIterator implements Iterator<Item> {
        private Node current;

        public DequeIterator() {
            this.current = first;
        }

        public boolean hasNext() { return current != null;                      }
        public void remove()     { throw new UnsupportedOperationException();   }

        public Item next() {
            if (!this.hasNext()) { throw new NoSuchElementException();          }
            else {
                Node node = current;
                current = current.next;
                return node.item;
            }
        }
    }

    public Deque() {
        this.first = null;
        this.last = null;
        this.numberOfItems = 0;
    }

    public boolean isEmpty() {
        return this.size() == 0;
    }

    public int size() {
        return this.numberOfItems;
    }

    public void addFirst(Item item) {
        if (item == null) { throw new NullPointerException();   }

        if (this.isEmpty()) {
            this.first = new Node(item);
            this.last = first;
        } else {
            Node node = new Node(item);
            node.next = this.first;
            this.first.prev = node;
            this.first = node;
        }
        this.numberOfItems++;
    }

    public void addLast(Item item) {
        if (item == null) { throw new NullPointerException();   }

        if (this.isEmpty()) {
            this.last = new Node(item);
            this.first = last;
        } else {
            Node node = new Node(item);
            this.last.next = node;
            node.prev = this.last;
            this.last = node;
        }
        this.numberOfItems++;
    }

    public Item removeFirst() {
        if (this.isEmpty()) { throw new NoSuchElementException(); }

        Node node = this.first;
        if (this.size() == 1) {
            this.first = null;
            this.last = null;
        } else {
            this.first.next.prev = null;
            this.first = this.first.next;
        }
        this.numberOfItems--;
        node.next = null;
        return node.item;
    }

    public Item removeLast() {
        if (this.isEmpty()) { throw new NoSuchElementException(); }

        Node node = this.last;
        if (this.size() == 1) {
            this.first = null;
            this.last = null;
        } else {
            this.last.prev.next = null;
            //this.last.prev = null;
            this.last = this.last.prev;
        }
        this.numberOfItems--;
        node.next = null;
        return node.item;
    }

    public Iterator<Item> iterator() {
        return new DequeIterator();
    }

    public static void main(String[] args) {
        //Deque<String> deq1 = new Deque<String>();
        Deque<Integer> deq2 = new Deque<Integer>();

        System.out.println(""deq2: "" + deq2.toString());
        System.out.println(""size: "" + deq2.size());

        deq2.addFirst(1);
        deq2.addFirst(2);
        deq2.addFirst(3);
        deq2.addFirst(4);
        deq2.addFirst(5);


        System.out.println(""deq2: "" + deq2.toString());

        deq2.removeLast();
        System.out.println(""deq2: "" + deq2.toString());

        deq2.removeFirst();
        deq2.removeFirst();
        System.out.println(""deq2: "" + deq2.toString());
        System.out.println(""size: "" + deq2.size());

        deq2.removeLast();
        deq2.removeLast();
        System.out.println(""deq2: "" + deq2.toString());

        deq2.addFirst(1);
        deq2.addLast(2);
        System.out.println(""deq2: "" + deq2.toString());

        deq2.addFirst(3);
        deq2.addLast(4);
        System.out.println(""deq2: "" + deq2.toString());

        System.out.println(""size: "" + deq2.size());



        Iterator itr = deq2.iterator();

        //System.out.println(itr.);
        System.out.println(itr.next());
        System.out.println(itr.next());
        System.out.println(itr.next());
        System.out.println(itr.next());
        //System.out.println(itr.next());

    }
}
@d05231fedaa1faf25c725cee43cc7b44@"
"b99611017","8","1.72","174288","@c737d7a8fe744cb6bf82b80e13c1da09@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            first = new Node<>();
            last = first;
            first.item = item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            last = new Node<>();
            first = last;
            last.item = item;
            N++;
        } else {
            Node<Item> oldlast = last;
            last = new Node<>();
            last.item = item;
            oldlast.next = last;

            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        Item item = first.item;
        first = first.next;
        N--;
        return item;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        if (first==last) {
            first = null;
            Item item = last.item;
            last = null;
            N--;
            return item;

        } else {
            Node<Item> starter = null;
            Node<Item> buff = null;
            starter = first;
            Item item = last.item;
            buff = first;
            while (first.next != last && first.next != null) {
                first = first.next;
                buff = first;
            }
            first = starter;
            last = buff;

            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();

        test.addFirst(""..."");

        test.addFirst('G');
        test.addFirst(87987);
        test.removeLast();
        test.removeLast();
        test.removeLast();
        Iterator a;
        a = test.iterator();
        System.out.println(a.hasNext());

        System.out.println(test.size());
        // TODO code application logic here
    }

}

@c737d7a8fe744cb6bf82b80e13c1da09@"
"b99611017","8","1.66","171120","@9ba9491c2184e54a904408e1a5971d14@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            first = new Node<>();
            last = first;
            first.item = item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            last = new Node<>();
            first = last;
            last.item = item;
            N++;
        } else {
            Node<Item> oldlast = last;
            last = new Node<>();
            last.item = item;
            oldlast.next = last;

            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        if(first==last)
        {
            Item item = first.item;
            first=null;
            last=null;
            N--;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        N--;
        return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        if (first==last) {
            first = null;
            Item item = last.item;
            last = null;
            N--;
            return item;

        } else {
            Node<Item> starter = null;
            Node<Item> buff = null;
            starter = first;
            Item item = last.item;
            buff = first;
            while (first.next != last && first.next != null) {
                first = first.next;
                buff = first;
            }
            first = starter;
            last = buff;

            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();

        test.addFirst(""..."");

        test.addFirst('G');
        test.addFirst(87987);
        test.removeLast();
        test.removeLast();
        test.removeLast();
        Iterator a;
        a = test.iterator();
        System.out.println(a.hasNext());

        System.out.println(test.size());
        // TODO code application logic here
    }

}

@9ba9491c2184e54a904408e1a5971d14@"
"b03611033","0","0","0","@11a3926194457efd5eb4a81d1f06b30d@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private Node oldlast, oldfirst,temp;

    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        oldlast=null;
        oldfirst=null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
                temp=last;
            } else{
                if(oldlast!=null){
                    last.previous =oldlast;
                    oldlast.next = last;
                if(N==1) {
                    first.next=last;
                    last.previous=first;
                }
                }
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.previous =null;
            if (isEmpty()) {
                last = first;
                temp=first;
            } else {
                first.next = oldfirst;
                if(N==1) last=first.next;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first.item = null;
            first = first.next;
            N--;
            return item;
        }
    }

    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = last.item;
            if(!last.equals(temp)) {
                item = last.item;
                last = last.previous;
            } else {
                
            }
            N--;
            return item;
        }
    }

    
    @Override
    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator();
    }

    private class ListIterator implements Iterable<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator<Item> iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }


    public static void main(String[] args) throws Exception {   // unit testing

        Deque deque = new Deque();
        
        //Iterator it = deque.iterator();
        
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(8);
        //String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
       for(int i=0;i<8;i++)
       StdOut.println(deque.removeLast());
       
       /*
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
       */
        //Iterator it = deque.iterator();
        //while(it.hasNext()){
            //StdOut.println(it.next());
        //}
        
    }
   
}


@11a3926194457efd5eb4a81d1f06b30d@"
"b03611033","0","0","0","@d85a9ed75f5e2eabbaa956273dbeaa32@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private boolean judge;
    private Node first, last;
    private Node oldlast, oldfirst,temp;

    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        oldlast=null;
        oldfirst=null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
                temp=last;
                judge=true;
            } else{
                if(oldlast!=null){
                    last.previous =oldlast;
                    oldlast.next = last;
                if(N==1) {
                    first.next=last;
                    last.previous=first;
                }
                }
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.previous =null;
            if (isEmpty()) {
                last = first;
                temp=first;
                judge=true;
            } else {
                first.next = oldfirst;
                if(N==1) last=first.next;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first.item = null;
            first = first.next;
            N--;
            return item;
        }
    }
    
    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            
            Node help=first;
            if(!last.equals(temp) && judge) {
                item = last.item;
                last = last.previous;
            } 
            else if(last.equals(temp)){
                while(first!=temp)
                {
                    last=first;
                    first=first.next;
                }
                item=first.item;
                first=help;
                judge=false;
            }
            else {
                Node temp2=last;
                while(first!=temp2)
                {
                    last=first;
                    first=first.next;
                }
                item=first.item;
                first=help;
            }
            N--;
            return item;
        }
    }

    
    @Override
    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator();
    }

    private class ListIterator implements Iterable<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator<Item> iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }


    public static void main(String[] args) throws Exception {   // unit testing

        Deque deque = new Deque();
        
        //Iterator it = deque.iterator();
        
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(8);
        //String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
       
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeFirst());
        
        StdOut.println("""");
        
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(0);
        
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeFirst());
        
        //Iterator it = deque.iterator();
        //while(it.hasNext()){
            //StdOut.println(it.next());
        //}
        
    }
   
}


@d85a9ed75f5e2eabbaa956273dbeaa32@"
"b03611033","0","0","0","@0e906b8175d8672b567e96bc86fefe6b@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private Node oldlast, oldfirst,temp;

    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldlast = last;
            last = new Node();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
                temp=last;
            } else{
                if(oldlast!=null){
                    last.previous =oldlast;
                    oldlast.next = last;
                if(N==1) {
                    first.next=last;
                    last.previous=first;
                }
                }
            }
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            oldfirst = first;
            first = new Node();
            first.item = item;
            first.previous =null;
            if (isEmpty()) {
                last = first;
                temp=first;
            } else {
                first.next = oldfirst;
                if(N==1) last=first.next;
            }
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            item = first.item;
            first.item = null;
            first = first.next;
            N--;
            return item;
        }
    }
    
    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item;
            Node help=first;
            if(!last.equals(temp)) {
                item = last.item;
                last.item=null;
                last = last.previous;
            } 
            else {
                while(first!=temp)
                {
                    addLast(first.item);
                    first=first.next;
                }
                item = first.item;
                first.item=null;
                first=help;
            }
            N--;
            return item;
        }
    }

    
    @Override
    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator();
    }

    private class ListIterator implements Iterable<Item> {

        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            Item item = current.item;
            if (hasNext()) {
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator<Item> iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }


    public static void main(String[] args) throws Exception {   // unit testing

        Deque deque = new Deque();
        
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(8);
        //String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
       
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeFirst());
        
        StdOut.println("""");
        
        for(int i=0;i<2;i++)
        deque.addFirst(i);
        
        for(int i=0;i<8;i++){
            StdOut.println(deque.removeLast());
            deque.addFirst(i);
        }
        /*
        Iterator it = deque.iterator();
        while(it.hasNext()){
            StdOut.println(it.next());
        }
        */
    }
   
}


@0e906b8175d8672b567e96bc86fefe6b@"
"b03611011","0","1.4","180768","@94b79b06132b1a028718b64384895b75@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private Node<Item> origin;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){origin = new Deque.Node<Item>();origin=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if (M == 0 && N != 0) {
            last = new Deque.Node<Item>();
            last.item = item;
            origin.next = last;
            last.previous=origin;
        }else if(M==0&&N==0){//都還沒
            origin =new Deque.Node<Item>();
            last = new Deque.Node<Item>();
            last.item = item;
            origin = last;
        }else{
        Deque.Node<Item> oldlast = new Deque.Node<Item>();
        oldlast=last;
        last = new Deque.Node<Item>();
        last.item=item;
        last.previous=oldlast;
        oldlast.next=last;
        }
        N++;
        M++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        Deque.Node<Item> current;
        current = first;
        while(current!=null&&N>0){
            Item item = current.item;
            current = current.next;
            N--;
            StdOut.println(item);
        } 
        current = last;
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeFirst();
            d.removeLast();
            Iterator e = d.iterator();
        }
    }
}

@94b79b06132b1a028718b64384895b75@"
"b03611011","2","1.4","183104","@7b13f692dbaa05bcb2876ea7c9df43bc@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private Node<Item> origin;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){origin = new Deque.Node<Item>();origin=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if (M == 0 && N != 0) {
            last = new Deque.Node<Item>();
            last.item = item;
            origin.next = last;
            last.previous=origin;
        }else if(M==0&&N==0){//都還沒
            origin =new Deque.Node<Item>();
            last = new Deque.Node<Item>();
            last.item = item;
            origin = last;
        }else{
        Deque.Node<Item> oldlast = new Deque.Node<Item>();
        oldlast=last;
        last = new Deque.Node<Item>();
        last.item=item;
        last.previous=oldlast;
        oldlast.next=last;
        }
        N++;
        M++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeFirst();
            d.removeLast();
            Iterator e = d.iterator();
            while (e.hasNext()&&d.N>0) {
                d.N--;
                e.next();
            }

        }
    }
}

@7b13f692dbaa05bcb2876ea7c9df43bc@"
"b03611011","3","1.41","177024","@acdc0f5c1aec1b612bb82f9db2b3d880@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private Node<Item> origin;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){origin = new Deque.Node<Item>();origin=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
        if (M == 0 && N != 0) {
            last = new Deque.Node<Item>();
            last.item = item;
            origin.next = last;
            last.previous=origin;
        }else if(M==0&&N==0){//都還沒
            origin =new Deque.Node<Item>();
            last = new Deque.Node<Item>();
            last.item = item;
            origin = last;
        }else{
        Deque.Node<Item> oldlast = new Deque.Node<Item>();
        oldlast=last;
        last = new Deque.Node<Item>();
        last.item=item;
        last.previous=oldlast;
        oldlast.next=last;
        }
        N++;
        M++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeFirst();
            d.removeLast();
            Iterator e = d.iterator();
            while (e.hasNext()&&d.N>0) {
                d.N--;
                e.next();
            }

        }
    }
}

@acdc0f5c1aec1b612bb82f9db2b3d880@"
"b03611011","3","1.4","184640","@7447d2f9dc871c524130567253f8d0dc@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private Node<Item> origin;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){origin = new Deque.Node<Item>();origin=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
        if (M == 0 && N != 0) {
            last = new Deque.Node<Item>();
            last.item = item;
            origin.next = last;
            last.previous=origin;
        }else if(M==0&&N==0){//都還沒
            origin =new Deque.Node<Item>();
            last = new Deque.Node<Item>();
            last.item = item;
            origin = last;
        }else{
        Deque.Node<Item> oldlast = new Deque.Node<Item>();
        oldlast=last;
        last = new Deque.Node<Item>();
        last.item=item;
        last.previous=oldlast;
        oldlast.next=last;
        }
        N++;
        M++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeFirst();


        }
    }
}

@7447d2f9dc871c524130567253f8d0dc@"
"r04631021","2","1.43","170688","@05fcf89dbad2aae1a8a5a5a762ee389d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/*import edu.princeton.cs.algs4.Queue;
import java.io.*;
import java.util.Scanner;*/
import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*
        Deque test = new Deque( ) ;
        test.addFirst(""z"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        test.addFirst(""o"");
        test.addFirst(""o"");
        test.addFirst(""t"");
        test.addFirst(""o"");
        test.addFirst(""p"");
        test.addFirst(""i"");
        test.addFirst(""a"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.size()) ;
//        System.out.println(test.last.item) ;
        test.addFirst(""o"");
        System.out.println(test.first.item) ;
        //test.addLast(""a"") ;
        //test.removeLast() ;
        //System.out.println(test.last.item) ;
       */
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}

@05fcf89dbad2aae1a8a5a5a762ee389d@"
"r04631021","2","1.39","174160","@ce416bf50514b8ae34381aa5745f8d87@

import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*
        Deque test = new Deque( ) ;
        test.addFirst(""z"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        test.addFirst(""o"");
        test.addFirst(""o"");
        test.addFirst(""t"");
        test.addFirst(""o"");
        test.addFirst(""p"");
        test.addFirst(""i"");
        test.addFirst(""a"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.size()) ;
//        System.out.println(test.last.item) ;
        test.addFirst(""o"");
        System.out.println(test.first.item) ;
        //test.addLast(""a"") ;
        //test.removeLast() ;
        //System.out.println(test.last.item) ;
       */
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@ce416bf50514b8ae34381aa5745f8d87@"
"b03611033","0","0","0","@4691b87015c0c9977e4b05685f34bb00@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node temp=new Node();
            if (isEmpty()) {
                temp.next=null;
                temp.previous=null;
                first=temp;
                last=temp;
            } else {
                last.next=temp;
                temp.previous=last;
                temp.next=null;
                last=temp;
            }
            last.item=item;
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node newNode=new Node();
            if (isEmpty()) {
                newNode.next=null;
                newNode.previous=null;
                first=newNode;
                last=newNode;
            } else {
                first.previous=newNode;
                newNode.next=first;
                newNode.previous=null;
                first=newNode;
                
            }
            first.item=item;
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item=first.item;
            if (first.next == null) {
                first = null;
                last = null;
            } else {
                first = first.next;
                first.previous = null;
            }
            N--;
            return item;
        }
    }
    
    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item=last.item;
            if (first.next == null) {
                first = null;
                last = null;
            } else {
                last = last.previous;
                last.next = null;
            }
        
            N--;
            return item;
        }
    }

    
    @Override
    public Iterator<Item> iterator() {         // return an iterator over items in order from front to end
        return (Iterator<Item>) new ListIterator(first);
    }

    private class ListIterator implements Iterable<Item> {
        private Node current ;
        public ListIterator(Node first) {
            current=first;
        }
        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item Next() {
            if (hasNext()) {
                Item item = current.item;
                current = current.next;
                return item;
            } else {
                throw new NoSuchElementException();
            }
        }

        @Override
        public Iterator<Item> iterator() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    }


    public static void main(String[] args) throws Exception {   // unit testing
 /*
        Deque deque = new Deque();
       
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(8);
        //String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
       
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeFirst());
        
        StdOut.println("""");
        
        for(int i=0;i<8;i++)
        deque.addLast(i);
        
        for(int j=0;j<8;j++){
            StdOut.println(deque.removeFirst());
            //deque.addFirst(j);
        }
        
        Iterator it = deque.iterator();
        while(it.hasNext()){
            StdOut.println(it.next());
        }
        */
    }
   
}


@4691b87015c0c9977e4b05685f34bb00@"
"b03611033","10","0.138","172864","@e92c0fcba26bf34d2b902236c87789db@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node first, last;
    private class Node {
        Item item;
        Node next;
        Node previous;
    }

    public Deque() {                           // construct an empty deque
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {                 // is the deque empty?
        return N == 0;
    }

    public int size() {                        // return the number of items on the deque
        return N;
    }

    public void addLast(Item item) {          // add the item to the end
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node temp=new Node();
            if (isEmpty()) {
                first=temp;
                last=temp;
            } else {
                last.next=temp;
                temp.previous=last;
                temp.next=null;
                last=temp;
            }
            last.item=item;
            N++;
        }
    }

    public void addFirst(Item item) {           // add the item to the front
        if (item == null) {
            throw new NullPointerException();
        } else {
            Node temp=new Node();
            if (isEmpty()) {
                
                first=temp;
                last=temp;
            } else {
                first.previous=temp;
                temp.next=first;
                temp.previous=null;
                first=temp;
                
            }
            first.item=item;
            N++;
        }
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item=first.item;
            if (first.next == null) {
                first = null;
                last = null;
            } else {
                first = first.next;
                first.previous = null;
            }
            N--;
            return item;
        }
    }
    
    public Item removeLast() {                 // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        } else {
            Item item=last.item;
            if (first.next == null) {
                first = null;
                last = null;
            } else {
                last = last.previous;
                last.next = null;
            }
            N--;
            return item;
        }
    }
    
    @Override
    public Iterator<Item> iterator(){ return new ListIterator();}
    
    private class ListIterator implements Iterator<Item>
    {
        private Node current =first;
        
        @Override
        public boolean hasNext() { return current != null;}    
        @Override
        public void remove() { throw new UnsupportedOperationException();}
        @Override
        public Item next()
        {
            if(!hasNext()){ throw new NoSuchElementException();}
            Item item = current.item;
            current = current.next;
            return item;
        }
    
    }
   


    public static void main(String[] args) throws Exception {   // unit testing
 
        Deque deque = new Deque();
       
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        deque.addFirst(5);
        deque.addLast(6);
        deque.addFirst(7);
        deque.addLast(8);
        //String f = null;
        //deque.addFirst(f);

       // StdOut.println(deque.size());
       /*
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeLast());
        StdOut.println(deque.removeFirst());
        StdOut.println(deque.removeFirst());
        
        StdOut.println("""");
        
        for(int i=0;i<8;i++)
        deque.addLast(i);
        
        for(int j=0;j<8;j++){
            StdOut.println(deque.removeFirst());
            //deque.addFirst(j);
        }
        */
        Iterator it = deque.iterator();
        while(it.hasNext()){
            StdOut.println(it.next());
        }
        
    }
   
}


@e92c0fcba26bf34d2b902236c87789db@"
"r04631041","7","1.15","181376","@2d08b0b13cf3c3a61a7f412568e7f8d2@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator();}
    private class ListIterator implements Iterator<Item>
    {
       private Node current=first;
       public boolean hasNext() {return current!=null;}
       public void remove() {}
       public Item next()
               {
                   Item item=current.item;
                   current=current.next;
                   return item;
               }
    }
    private Node first;
    private Node last;
    private  int number;
    private class Node
    {
        Item item;
        Node next;
        Node previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        if (number==0){
           first=null;
           last=null;
       }
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       if (number==0){
           first=null;
           last=null;
       }
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        testing.addLast(""i"");
        testing.addFirst(""b"");
        testing.addLast(""j"");
        testing.addFirst(""k"");
        testing.addFirst(""p"");
        testing.addLast(""q"");
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
         //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@2d08b0b13cf3c3a61a7f412568e7f8d2@"
"r04921115","3","0.36","102352","@c88ca141d960d0126fd87e48dd0a5b36@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return first == null;
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.next = oldfirst;
       if(oldfirst == null){
    	   last = first;
       }else{
    	   oldfirst.prev = first;
       }
       N++;
   }
   
//add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       oldlast.next = last;
       last.prev = oldlast;
       N++;
   }
   
//remove front
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   N--;
	   if(N==0){
		   last = null;
		   first = null;
	   }else{
		   first = first.next;
		   first.prev = null;
	   }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   N--;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       public boolean hasNext()  { return current != null;                     }
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> s = new Deque<String>();
//       while (!StdIn.isEmpty()) {
//       	   String item = StdIn.readString();
//       	   s.addFirst(item);
//       	   String item2 = StdIn.readString();
//    	   s.addFirst(item2);
//    	   String item3 = StdIn.readString();
//       	   s.addFirst(item3);
//       	   String pop = s.removeFirst();
//       	   StdOut.print(pop+"""");
//       	   s.addFirst(item);
//           if (!item.equals(""-"")) s.removefirst(item);
//           else if (!s.isEmpty()) StdOut.print(s.pop() + "" "");
//       }
//       StdOut.println(""("" + s.size() + "" left on stack)"");
   }
}
@c88ca141d960d0126fd87e48dd0a5b36@"
"r04631041","7","1.29","172736","@9d746eacfea33f736ecdbbd23d1cf94c@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      //{ throw new UnsupportedOperationException();  }
        {};
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node<Item> newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node<Item> newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        if (number==0){
           first=null;
           last=null;
       }
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       if (number==0){
           first=null;
           last=null;
       }
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        testing.addLast(""i"");
        testing.addFirst(""b"");
        testing.addLast(""j"");
        testing.addFirst(""k"");
        testing.addFirst(""p"");
        testing.addLast(""q"");
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}
@9d746eacfea33f736ecdbbd23d1cf94c@"
"r04631041","7","1.27","171824","@f6b550dea7eba65db711047f3b402d7e@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      //{ throw new UnsupportedOperationException();  }
        {};
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node<Item> newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node<Item> newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        if (number==0){
           first=null;
           last=null;
       }
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node<Item> oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       if (number==0){
           first=null;
           last=null;
       }
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        //testing.addLast(""i"");
        //testing.addFirst(""b"");
        //testing.addLast(""j"");
        //testing.addFirst(""k"");
        //testing.addFirst(""p"");
        //testing.addLast(""q"");
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        testing.addFirst(""sd"");
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@f6b550dea7eba65db711047f3b402d7e@"
"r04631041","7","1.27","174240","@4648951c87765f2271d99f8386942c47@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node<Item> newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node<Item> newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        if (number==0){
           first=null;
           last=null;
       }
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node<Item> oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       if (number==0){
           first=null;
           last=null;
       }
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        //testing.addLast(""i"");
        //testing.addFirst(""b"");
        //testing.addLast(""j"");
        //testing.addFirst(""k"");
        //testing.addFirst(""p"");
        //testing.addLast(""q"");
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
         System.out.println(testing.removeLast());
        testing.addFirst(""sd"");
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        //i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@4648951c87765f2271d99f8386942c47@"
"r04631041","7","1.29","176512","@5bc05c1702a518db2fbd02e18f9a9d63@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node<Item> newFirst=new Node<Item>();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node<Item> newLast=new Node<Item>();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
       assert check();
        if (number==0){
           first=null;
           last=null;
       }
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node<Item> oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       if (number==0){
           first=null;
           last=null;
       }
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        //testing.addLast(""i"");
        //testing.addFirst(""b"");
        //testing.addLast(""j"");
        //testing.addFirst(""k"");
        //testing.addFirst(""p"");
        //testing.addLast(""q"");
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
         System.out.println(testing.removeLast());
        testing.addFirst(""sd"");
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        //i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@5bc05c1702a518db2fbd02e18f9a9d63@"
"r04228002","10","0.136","178128","@6f209b6867a6cb8c3896cb3a2d3d241f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Lenovo
 */
public class Deque<Item> implements Iterable<Item>{

    /**
     * @param args the command line arguments
     */
    private Node<Item> first;     // first of deque
    private Node<Item> last;      // last of deque
    private int N;                // size of deque
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> past;
    }
    
    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    // is the deque empty?
    public boolean isEmpty(){
        return (first == null);
    }     
    
    // return the number of items on the deque
    public int size(){
        return N;
    }
    
    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        N++;
        
        if (N==1){
            last=first;
        }
        /*
        else if(N==2){
            last.next=first;
            first.next=last;
        }
                */
        else{
            first.next = oldfirst;
            oldfirst.past=first;
        }
    }
    
    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        N++;
        if (N==1){
            first=last;
        }
        /*
        else if (N==2){
            first.next=last;
            last.next=first;
        }
                */
        else {
           last.past = oldlast;
           oldlast.next = last; 
        }
    }
    
    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        N--;
        if (N==0){
            first=null;
            last=null;
        }
        else if (N==1){
            first = last;
        }
        /*
        else if(N==2){
            first = first.next;
            last.next=first;
        }
                */
        else{
            first = first.next;
            first.past=null;
        }
        
        return item;
    }
    
    // remove and return the item from the end
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        N--;
        if (N == 0){
            first=null;
            last=null;
        }
        else if (N==1){
            last=first;
        } 
        /*
        else if (N==2){
            last=last.next;
            first.next=last;
        }
                */
        else{
            last=last.past;
            last.next=null;
        }
        
        return item; 
    }
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }  
    
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        
        public boolean hasNext()  { return current!= null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;  
            return item;
        }
    }

    
    // unit testing        
    public static void main(String[] args) {
        
    }
}

@6f209b6867a6cb8c3896cb3a2d3d241f@"
"r03522826","0","1.27","174240","@2a6cf8c17aa55e69fc24e1a4fb69a733@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deques<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
    }
    
    public Deques(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            Deques<String> s = new Deques<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addLast(data[2]);
            System.out.print(s.size()+""\n"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.print(s.isEmpty());
        }
    }
    
}
@2a6cf8c17aa55e69fc24e1a4fb69a733@"
"r03522826","0","1.29","176512","@676b345616d962d2a482c4963ff3e952@package deques;



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deques<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
    }
    
    public Deques(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            Deques<String> s = new Deques<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addLast(data[2]);
            System.out.print(s.size()+""\n"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.print(s.isEmpty());
        }
    }
    
}

@676b345616d962d2a482c4963ff3e952@"
"b03106003","2","0.94","102464","@a5e73a45ca97a1932181f45e36a65084@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Sophia
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node first;
    private Node last;
    
    private class Node{
        private Item item;
        private Node next;
        private Node previous;
    
    }
    
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
        //assert check();
    
    }
    public boolean isEmpty(){
        return first == null;
    }
   // return the number of items on the deque
   public int size(){
       return N;
   }
   // add the item to the front
   public void addFirst(Item item){
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.previous = null;
       if(last == null){
           first.next = null;
           last = first;
       }else{
           first.next = oldfirst;
           oldfirst.previous = first;
       }
       N++;
   }
   // add the item to the end
   public void addLast(Item item){
       Node oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if(first == null){
           last.previous = null;
           last = first;
       }else{
           last.previous = oldlast;
           oldlast.next = last;
       }
       N++;
   }
   // remove and return the item from the front
   public Item removeFirst(){
       if(first == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = first.item;
       first = first.next;
       first.previous = null;
       N--;
       if(first == null){
           last = null;
       }
       return item;
   }
   
// remove and return the item from the end
   public Item removeLast(){
   if(last == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = last.item;
       last = last.previous;
       last.next = null;
       N--;
       if(last == null){
           first = null;
       }
       return item;
   
   }
   // unit testing
   public static void main(String[] args){}  

    @Override
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public Iterator remove() {
        throw new UnsupportedOperationException();
    }
    
}

@a5e73a45ca97a1932181f45e36a65084@"
"r03522826","3","0.78","102416","@ff02571bf269bd585e309ef7c56949ac@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.next;
        N--;
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addLast(data[2]);
            System.out.print(s.size()+""\n"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.print(s.isEmpty());
        }
    }
    
}

@ff02571bf269bd585e309ef7c56949ac@"
"b03106003","3","0.93","102368","@9d05906e6ddb7b410756d956b3a227aa@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Sophia
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node first;
    private Node last;
    
    private class Node{
        private Item item;
        private Node next;
        private Node previous;
    
    }
    
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
        //assert check();
    
    }
    public boolean isEmpty(){
        return first == null;
    }
   // return the number of items on the deque
   public int size(){
       return N;
   }
   // add the item to the front
   public void addFirst(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.previous = null;
       if(last == null){
           first.next = null;
           last = first;
       }else{
           first.next = oldfirst;
           oldfirst.previous = first;
       }
       N++;
   }
   // add the item to the end
   public void addLast(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if(first == null){
           last.previous = null;
           last = first;
       }else{
           last.previous = oldlast;
           oldlast.next = last;
       }
       N++;
   }
   // remove and return the item from the front
   public Item removeFirst(){
       if(first == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = first.item;
       first = first.next;
       first.previous = null;
       N--;
       if(first == null){
           last = null;
       }
       return item;
   }
   
// remove and return the item from the end
   public Item removeLast(){
   if(last == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = last.item;
       last = last.previous;
       last.next = null;
       N--;
       if(last == null){
           first = null;
       }
       return item;
   
   }
   // unit testing
   public static void main(String[] args){
   
   }  

    @Override
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public Iterator remove() {
        throw new UnsupportedOperationException();
    }
    
}
@9d05906e6ddb7b410756d956b3a227aa@"
"b99611017","10","0.168","175040","@a444fbed4a5f5ead096936642ded2411@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {

        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {

        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            first = new Node<>();
            last = first;
            first.item = item;
            N++;
        } else {
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;

            first.next = oldFirst;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException(""There is an exception"");
        }
        if (N == 0) {

            last = new Node<>();
            first = last;
            last.item = item;
            N++;
        } else {
            Node<Item> oldlast = last;
            last = new Node<>();
            last.item = item;
            oldlast.next = last;

            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }
        if(first==last)
        {
            Item item = first.item;
            first=null;
            last=null;
            N--;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        N--;
        return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException(""Queue underflow"");
        }

        if (first==last) {
            first = null;
            Item item = last.item;
            last = null;
            N--;
            return item;

        } else {
            Node<Item> starter = null;
            Node<Item> buff = null;
            starter = first;
            Item item = last.item;
            buff = first;
            while (first.next != last ) {
                first = first.next;
                buff = first;
            }
            first = starter;
            last = buff;
            last.next=null;

            N--;
            return item;
        }
    }

    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        Deque test = new Deque();

        test.addFirst(""..."");

        
        test.removeLast();
        Iterator a;
        a = test.iterator();
        System.out.println(a.hasNext());

        System.out.println(test.size());
        // TODO code application logic here
    }

}

@a444fbed4a5f5ead096936642ded2411@"
"r04631021","2","1.42","172896","@fa3ea730bd59d6cb71e2b3752de79288@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*
        Deque test = new Deque( ) ;
        test.addFirst(""z"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        test.addFirst(""o"");
        test.addFirst(""o"");
        test.addFirst(""t"");
        test.addFirst(""o"");
        test.addFirst(""p"");
        test.addFirst(""i"");
        test.addFirst(""a"");
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeFirst() ;
        System.out.println(test.first.item) ;
        System.out.println(test.size()) ;
        test.removeLast() ;
        System.out.println(test.size()) ;
//        System.out.println(test.last.item) ;
        test.addFirst(""o"");
        System.out.println(test.first.item) ;
        //test.addLast(""a"") ;
        //test.removeLast() ;
        //System.out.println(test.last.item) ;
       */
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@fa3ea730bd59d6cb71e2b3752de79288@"
"r03849033","0","1.28","177120","@994f0c90679d7da7188c7cbb08605dc2@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
     before.next=after;
     after.previous=before;
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size>0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     size++;
     Node node = new Node();
     node.item=item;//sets new node equal to the item
     node.previous=before;//sets new node's previous to before which is the beginning sentinel
     node.next=before.next;//sets new node's next to the old first node which was befores next.
     before.next.previous=node;//sets old first item's previous to the new Node making the old first second in the list.
     before.next=node;//sets before's next to the new Node making the new Node first in the list.

    }
    public void addLast(Item item)           // insert the item at the end
    {
     size++;
     Node node = new Node();
     node.item=item;//sets node item to item
     node.next=after;//sets new node's next to after 
     after.previous.next=node;//sets old last node's next to the new node 
     node.previous=after.previous;//sets new node's previous to old last node
     after.previous=node;//now after's previous is the new node making it last in the list.


    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Node first= before.next;//gets the first node.
     Node second=first.next;//gets the second element in the list
     second.previous=before;//sets second's previous to before
     before.next=second;//sets before's next to second
     return first.item;


    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Node last = after.previous;//sets last node
     Node second2Last= after.previous.previous;//sets second2Last
     second2Last.next=after;//sets second2Last's next to after
     after.previous=second2Last;//sets after's previous to second2last
     return last.item;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=after;

     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 /**
  * @param args
  */
 public static void main(String[] args) {
  // TODO Auto-generated method stub
  Deque d = new Deque();

  d.addFirst(1);
  d.addLast(2);
  d.addFirst(3);
  Iterator i = d.iterator();
  System.out.println(i.hasNext());
  while(i.hasNext()){
   System.out.println(i.next());
  }


 }

}
@994f0c90679d7da7188c7cbb08605dc2@"
"b03106003","3","1.39","184960","@84f96c80c51d5d5da5714900da4ec938@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Sophia
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node first;
    private Node last;
    
    private class Node{
        private Item item;
        private Node next;
        private Node previous;
    
    }
    
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    
    }
    public boolean isEmpty(){
        return first == null;
    }
   // return the number of items on the deque
   public int size(){
       return N;
   }
   // add the item to the front
   public void addFirst(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.previous = null;
       if(last == null){
           first.next = null;
           last = first;
       }else{
           first.next = oldfirst;
           oldfirst.previous = first;
       }
       N++;
   }
   // add the item to the end
   public void addLast(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if(first == null){
           last.previous = null;
           last = first;
       }else{
           last.previous = oldlast;
           oldlast.next = last;
       }
       N++;
   }
   // remove and return the item from the front
   public Item removeFirst(){
       if(first == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = first.item;
       first = first.next;

       N--;
       if(first == null){
           last = null;
       }else{
           first.previous = null;
       }
       return item;
   }
   
// remove and return the item from the end
   public Item removeLast(){
   if(last == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = last.item;
       last = last.previous;
       N--;
       if(last == null){
           first = null;
       }else{
           last.next = null;
       }
       return item;
   
   }
   // unit testing


    @Override
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public Iterator remove() {
        throw new UnsupportedOperationException();
    }
       public static void main(String[] args){
           Deque<String> d = new Deque<String>();
           d.addFirst(""3"");
           d.addFirst(""5"");
           //d.addFirst(""5"");
           System.out.println(d.removeFirst());
           System.out.println(d.removeLast());
           
   
   }  
    
    
}

@84f96c80c51d5d5da5714900da4ec938@"
"b03611011","7","1.46","177680","@14dac9fe13ea61ce32fcc6130324b0f3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){last=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;
            last.previous = oldlast;
            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException(""Stack underflow"");
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeFirst();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
//            Iterator e = d.iterator();
//            while (e.hasNext()&&d.N>0) {
//                d.N--;
//                System.out.println(e.next());
//            }
        }
    }
}
@14dac9fe13ea61ce32fcc6130324b0f3@"
"b03106003","3","1.38","177536","@9564d94495c0674d0e90e9adcb813621@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Sophia
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;
    private Node first;
    private Node last;
    
    private class Node{
        private Item item;
        private Node next;
        private Node previous;
    
    }
    
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    
    }
    public boolean isEmpty(){
        return first == null;
    }
   // return the number of items on the deque
   public int size(){
       return N;
   }
   // add the item to the front
   public void addFirst(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.previous = null;
       if(last == null){
           first.next = null;
           last = first;
       }else{
           first.next = oldfirst;
           oldfirst.previous = first;
       }
       N++;
   }
   // add the item to the end
   public void addLast(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if(first == null){
           last.previous = null;
           last = first;
       }else{
           last.previous = oldlast;
           oldlast.next = last;
       }
       N++;
   }
   // remove and return the item from the front
   public Item removeFirst(){
       if(first == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = first.item;
       first = first.next;

       N--;
       if(first == null){
           last = null;
       }else{
           first.previous = null;
       }
       return item;
   }
   
// remove and return the item from the end
   public Item removeLast(){
   if(last == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = last.item;
       last = last.previous;
       N--;
       if(last == null){
           first = null;
       }else{
           last.next = null;
       }
       return item;
   
   }
   // unit testing


    @Override
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    public Iterator remove() {
        throw new UnsupportedOperationException();
    }
    
       public static void main(String[] args){
           Deque<String> d = new Deque<String>();
           d.addFirst(""3"");
           d.addFirst(""4"");
           d.addFirst(""5"");
           //System.out.println(d.size());
           //System.out.println(d.removeFirst());
           //System.out.println(d.removeLast());
           d.addFirst(""3"");
           d.addFirst(""5"");
           d.addFirst(""9"");
           d.addLast(""1"");
           //System.out.println(d.size());
           Iterator<String> i = d.iterator();
           System.out.println(i.next());
           System.out.println(i.next());
           while(i.hasNext()){
                System.out.println(i.next());       
           }
           System.out.println(d.isEmpty());
           System.out.println(d.removeLast());
           System.out.println(d.removeLast());
           System.out.println(d.removeLast());
           System.out.println(d.removeFirst());
           System.out.println(d.removeLast());
           System.out.println(d.removeLast());
           System.out.println(d.removeLast());
           //System.out.println(d.removeLast());
           
   }  
    
    
}
@9564d94495c0674d0e90e9adcb813621@"
"r04945022","10","0.139","181312","@3302c9f709429847f3f3337c5f772823@import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

/**
 *
 * @author Daniel
 */
public class Deque<Item> implements Iterable<Item>{
    private int size;
    private DequeNode head;
    private DequeNode tail;
    
    public Deque() {
        size = 0;
        head = new DequeNode();
        tail = new DequeNode();
        head.next = tail;
        tail.prev = head;
    }
     public boolean isEmpty(){
         return size == 0;
     }
     public int size() {
         return size;
     }
     public void addFirst(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
         if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = null;
			newNode.next = head;
			head.prev = newNode;
			head = newNode;
			size++;
       
         }
     }
     public void addLast(Item item) {
         if (item == null) {
            throw new NullPointerException();
        }
       if (size == 0) {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.next = null;
			newNode.prev = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			DequeNode newNode = new DequeNode();
			newNode.item = item;
			newNode.prev = tail;
			newNode.next = null;
			tail.next = newNode;
			tail = newNode;
			size++;
		}
     }
     public Item removeFirst() {
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
            if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = head.item;
			DequeNode temp = head.next;
			head.next.prev = null;
			head.next = null;
			head = temp;
			size--;
			return item;
		}
     }
     public Item removeLast(){
         if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        if (size == 1) {
			Item item = head.item;
			head = null;
			tail = null;
			size--;
			return item;
		} else {
			Item item = tail.item;
			DequeNode temp = tail.prev;
			tail.prev.next = null;
			tail.prev = null;
			tail = temp;
			size--;
			return item;
		}
     }
     
     
    private class DequeNode {

        private Item item;

        private DequeNode next;

        private DequeNode prev;
    }
    
    
    public static void main(String[] args) throws IOException{
       
        // TODO code application logic here
    }

    @Override
    public Iterator iterator() {
      return new ListIterator();
//        throw new UnsupportedOperationException(""Not supported yet.""); 
    }
   private class ListIterator implements Iterator<Item> {
		
		private DequeNode ptr;
		private Item i;
		
		public ListIterator()
		{
			ptr = head;
		}

		@Override
		public boolean hasNext() {
			// TODO Auto-generated method stub
			if (ptr == null)
				return false;
			else
				return true;
		}

		@Override
		public Item next() {
			// TODO Auto-generated method stub
			if (!hasNext())
				throw new java.util.NoSuchElementException();
			else {
				i = ptr.item;
				ptr = ptr.next;
				return i;
			}

		}

		public void remove() {
			throw new UnsupportedOperationException();
		}

	}
//    public class Node{
//        Item item;
//        Node next;
//    }
    
}

@3302c9f709429847f3f3337c5f772823@"
"b03611011","7","1.46","177776","@50f7b4b29317d24c3b23f5562d19d5bb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(N==0){last=first;}
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;
            last.previous = oldlast;
            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            
            d.removeLast();
            d.removeLast();
            d.removeLast();
//            d.removeFirst();
//            d.removeFirst();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.removeFirst();
            Iterator e = d.iterator();
            while (e.hasNext()&&d.N>0) {
                d.N--;
                System.out.println(e.next());

            }
        }
    }
}
@50f7b4b29317d24c3b23f5562d19d5bb@"
"b03106003","10","0.14","179328","@26d6f1c9a6f6098d3ef5fc5846ea86d0@
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author Sophia
 */
public class Deque<Item> implements Iterable<Item>{
    private int N = 0;
    private Node first = null;
    private Node last = null;
    
    private class Node{
        private Item item;
        private Node next = null;
        private Node previous = null;
    
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        boolean flag = false;
        if (first == null){
            flag = true;
        }
        return flag;
    }
   // return the number of items on the deque
   public int size(){
       return N;
   }
   // add the item to the front
   public void addFirst(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldfirst = first;
       first = new Node();
       first.item = item;
       first.previous = null;
       if(last == null){
           first.next = null;
           last = first;
       }else{
           first.next = oldfirst;
           oldfirst.previous = first;
       }
       N++;
   }
   // add the item to the end
   public void addLast(Item item){
       if(item == null){
           throw new java.lang.NullPointerException();
       }
       Node oldlast = last;
       last = new Node();
       last.item = item;
       last.next = null;
       if(first == null){
           last.previous = null;
           first = last;
       }else{
           last.previous = oldlast;
           oldlast.next = last;
       }
       N++;
   }
   // remove and return the item from the front
   public Item removeFirst(){
       if(first == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = first.item;
       first = first.next;

       N--;
       if(first == null){
           last = null;
       }else{
           first.previous = null;
       }
       return item;
   }
   
// remove and return the item from the end
   public Item removeLast(){
   if(last == null){
           throw new java.util.NoSuchElementException();
       }
       Item item = last.item;
       last = last.previous;
       N--;
       if(last == null){
           first = null;
       }else{
           last.next = null;
       }
       return item;
   
   }
   // unit testing


    @Override
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator() {
        return new ListIterator();
    }
    
    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null;}
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
       public static void main(String[] args){
           Deque<String> d = new Deque<String>();
           d.addLast(""3"");
           d.addFirst(""4"");
           //d.addFirst(""5"");
           Iterator<String> i = d.iterator();
           //i.remove();
           //d.addFirst(""5"");
           //d.addFirst(""6"");
           //d.addLast(""6"");
           //d.removeLast();
           //System.out.println(d.size());
           System.out.print(d.removeFirst());
           for(String s : d){
               System.out.print( s + "" "");
           }
           
   }  
    
    
}

@26d6f1c9a6f6098d3ef5fc5846ea86d0@"
"r03522826","2","0.24","99136","@6a69e70b43a020404a48f0f9a7bf9dc5@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        if(1 == N){last = first;}
        else if(2 == N){last.previous = first;}
        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
        if(1 == N){first = last;}
        else if(2 == N){first.next = last;}
        else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@6a69e70b43a020404a48f0f9a7bf9dc5@"
"r04945009","9","1.41","178576","@bad3826e33f91572b4e38a11acb54b60@import java.util.Iterator;
import java.util.NoSuchElementException;


class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
@bad3826e33f91572b4e38a11acb54b60@"
"r04631046","0","0.14","179328","@94fd91b888ed95c959c5d0c898ed3a9b@

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i <= N; i++) {
                data[i + 1] = olddata[i];
            }
            data[0] = item;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i <= N; i++) {
                data[i] = olddata[i];
            }
            data[N] = item;
            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current[0];
            saved = (Item[]) (new Object[N]);
            saved = current;
            current = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                current[i] = saved[i + 1];
            }
            N--;
            return item;
        }
    }

    public static void main(String[] args) {

    }

}

@94fd91b888ed95c959c5d0c898ed3a9b@"
"r04631046","0","0","0","@61b979ebb9ac14bd9207a2e3369eb09a@
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i <= N; i++) {
                data[i + 1] = olddata[i];
            }
            data[0] = item;
            N++;
        }
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i <= N; i++) {
                data[i] = olddata[i];
            }
            data[N] = item;
            N++;
        }
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current[0];
            saved = (Item[]) (new Object[N]);
            saved = current;
            current = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N; i++) {
                current[i] = saved[i + 1];
            }
            N--;
            return item;
        }
    }

    public static void main(String[] args) {

    }

}

@61b979ebb9ac14bd9207a2e3369eb09a@"
"b03611011","7","1.47","182848","@01a0536a81be976041fa235e3f95ec07@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
        M=0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);
            d.removeFirst();
            Iterator e = d.iterator();
            
            while (e.hasNext()&&d.N>0) {
                d.N--;
                System.out.println(e.next());

            }
        }
    }
}
@01a0536a81be976041fa235e3f95ec07@"
"r04631021","2","1.41","187456","@3dd1cc5bbf2a061c3ac5829bb59097c7@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       public boolean hasNext() { return current != null; }
       public void remove() {  throw new UnsupportedOperationException();  }
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Deque test = new Deque( ) ;
        test.addLast(""1"");
        System.out.println(test.first.item) ;
        test.addFirst(""2"");
        test.addFirst(""3"");
        System.out.println(test.first.item) ;
        test.removeFirst() ;
        System.out.println(test.isEmpty());
        System.out.println(test.last.item) ;
        test.addFirst(""4"");
        System.out.println(test.first.item) ;
//        System.out.println(test.last.item) ;
        //test.addLast(""a"") ;
        //test.removeLast() ;
        //System.out.println(test.last.item) ;
       
        /*Deque<String> D = new Deque<String>() ;
        while (!StdIn.isEmpty()){
            String item = StdIn.readString() ;
            if(!item.equals(""-"")) D.
        }*/
    }
    
}


@3dd1cc5bbf2a061c3ac5829bb59097c7@"
"r04631021","2","1.4","180912","@bbd5e3dc7e7170433ebc69b2a4e847e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

    /**
     *
     * @return
     */
    @Override
    public Iterator<Item> iterator() { 
        return new ListIterator<Item>(); 
    }
    private class ListIterator<Item> implements Iterator<Item>{
       private Node<Item> current ;
       @Override
       public boolean hasNext() { return current != null; }
       @Override
       public void remove() {  throw new UnsupportedOperationException();  }
       @Override
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       public Item previous(){
           Item item = current.item ;
           current = current.previous ;
           return item ;
       }
 }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
    }
}    



@bbd5e3dc7e7170433ebc69b2a4e847e3@"
"b03611011","7","1.42","185264","@520a44131517acadbf19f2e8a040885d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@520a44131517acadbf19f2e8a040885d@"
"r03522826","3","0.36","102528","@d06c7ce78a0654d9f26e31f0e0047079@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        if(1 == N){last = first;}
        else if(2 == N){last.previous = first;}
        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
        if(1 == N){first = last;}
        else if(2 == N){first.next = last;}
        else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            //String [] data = br.readLine().split("" "");
            String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@d06c7ce78a0654d9f26e31f0e0047079@"
"r04631046","0","0.36","102528","@3ad46e45005dd864a34096f20051f406@
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deques<Item> implements Iterable<Item> {

    private int N;              // size of the Deques
    private Item[] data;        // new datas of the Deques
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deques() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            data[0] = item;
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            data[N] = item;
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {}

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current[0];
            saved = (Item[])(new Object[N]);
            saved = current;
            current = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                current[i] = saved[i + 1];
            }
            N--;
            return item;
        }
    }

    public static void main(String[] args) {
        Deques dq = new Deques();
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(2);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(3);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(4);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(5);
        System.out.print(dq.size() + ""\n"");
        dq.addLast(1);
        System.out.print(dq.size() + ""\n"");
        dq.removeFirst();
        System.out.print(dq.size() + ""\n"");
        dq.removeLast();
        System.out.print(dq.size() + ""\n"");
        dq.iterator();
        System.out.print(dq.iterator().next()+ ""\n"");
        System.out.print(dq.iterator().next()+ ""\n"");


    }

}

@3ad46e45005dd864a34096f20051f406@"
"r04631046","0","0","0","@399fa182b15042342bb36a4494cd0881@import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            data[0] = item;
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            data[N] = item;
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {}

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current[0];
            saved = (Item[])(new Object[N]);
            saved = current;
            current = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                current[i] = saved[i + 1];
            }
            N--;
            return item;
        }
    }

    public static void main(String[] args) {
        Deque dq = new Deque();
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(2);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(3);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(4);
        System.out.print(dq.size() + ""\n"");
        dq.addFirst(5);
        System.out.print(dq.size() + ""\n"");
        dq.addLast(1);
        System.out.print(dq.size() + ""\n"");
        dq.removeFirst();
        System.out.print(dq.size() + ""\n"");
        dq.removeLast();
        System.out.print(dq.size() + ""\n"");
        dq.iterator();
        System.out.print(dq.iterator().next()+ ""\n"");
        System.out.print(dq.iterator().next()+ ""\n"");


    }

}

@399fa182b15042342bb36a4494cd0881@"
"r04228027","6","0.94","102432","@d52b52449eb564784cc244c93a11621f@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private class node<Item>{
        Item item;
        node<Item> next;
        node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
           node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
        node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty()) last.next = null;
       size --;
       return temp.item;
       
   }
   
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       
       public ListIterator(node<Item> first) {
            current = first;
        }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public boolean hasNext(){
           return current != null;
       }
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        Scanner scan = new Scanner(System.in);
        int input;
        int var;
        while(true){
            System.out.print(""輸入欲執行的指令: "");
            input = scan.nextInt();
            if(1 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addFirst(var);
            }
            if(2 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addLast(var);
            }
            if(3 == input)
                a.removeFirst();
            if(4 == input)
                a.removeLast();
            if(5 == input)
                System.out.print(a.size()+""\n"");
            if(6 == input){
                for (Object i : a) {
                    System.out.print(i);
                }
            }
            if(0 == input)
                break;
        }   
    }    
}

@d52b52449eb564784cc244c93a11621f@"
"r04228027","6","0.94","102192","@6b355b17ac0024cf01f039de279de730@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
           node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
        node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty()) last.next = null;
       size --;
       return temp.item;
       
   }
   
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       
       public ListIterator(node<Item> first) {
            current = first;
        }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public boolean hasNext(){
           return current != null;
       }
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        Scanner scan = new Scanner(System.in);
        int input;
        int var;
        while(true){
            System.out.print(""輸入欲執行的指令: "");
            input = scan.nextInt();
            if(1 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addFirst(var);
            }
            if(2 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addLast(var);
            }
            if(3 == input)
                a.removeFirst();
            if(4 == input)
                a.removeLast();
            if(5 == input)
                System.out.print(a.size()+""\n"");
            if(6 == input){
                for (Object i : a) {
                    System.out.print(i);
                }
            }
            if(0 == input)
                break;
        }   
    }    
}

@6b355b17ac0024cf01f039de279de730@"
"r03522826","3","0.35","99568","@2d74d8baf5c61076501a300ec59cebf8@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        if(1 == N){last = first;}
        else if(2 == N){last.previous = first;}
        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
        if(1 == N){first = last;}
        else if(2 == N){first.next = last;}
        else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@2d74d8baf5c61076501a300ec59cebf8@"
"r04228027","6","0.95","102448","@adc2d9ea7001ace50b5c00c288b49029@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
           node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
        node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty()) last.next = null;
       size --;
       return temp.item;
       
   }
   
    @Override
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       
       public ListIterator(node<Item> first) {
            current = first;
        }
       @Override
       public void remove(){
           throw new UnsupportedOperationException();
       }
       @Override
       public boolean hasNext(){
           return current != null;
       }
       @Override
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        Scanner scan = new Scanner(System.in);
        int input;
        int var;
        while(true){
            System.out.print(""輸入欲執行的指令: "");
            input = scan.nextInt();
            if(1 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addFirst(var);
            }
            if(2 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addLast(var);
            }
            if(3 == input)
                a.removeFirst();
            if(4 == input)
                a.removeLast();
            if(5 == input)
                System.out.print(a.size()+""\n"");
            if(6 == input){
                for (Object i : a) {
                    System.out.print(i);
                }
            }
            if(0 == input)
                break;
        }   
    }    
}

@adc2d9ea7001ace50b5c00c288b49029@"
"r03522809","7","1.41","177936","@c9053ae593a67ca0e80ef04ae1c61fa6@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
        

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        return first.item;
    }


    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }


    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    public static void main(String[] args)throws Exception {
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-,"";
        String ans;
        String[] word =ws.split("","");
        Deque stack=new Deque();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);

            }
                j++;
        }        
        

     }
    }
}
@c9053ae593a67ca0e80ef04ae1c61fa6@"
"r03522826","3","0.38","102416","@2d74d8baf5c61076501a300ec59cebf8@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        if(1 == N){last = first;}
        else if(2 == N){last.previous = first;}
        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
        if(1 == N){first = last;}
        else if(2 == N){first.next = last;}
        else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@2d74d8baf5c61076501a300ec59cebf8@"
"r03522826","3","0.36","102432","@d79b56b1c68178cd13bf2f499bc7dae0@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        N++;
        if(1 == N){last = first;}
        else if(2 == N){last.previous = first;}
        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        N++;
        if(1 == N){first = last;}
        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
//            for(int i = 0; i < N; i++)
//            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@d79b56b1c68178cd13bf2f499bc7dae0@"
"r04631046","0","0","0","@5af99098f1d1c0c2d69b1ad24c0ed076@
import java.util.Iterator;
import java.lang.NullPointerException;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            data[0] = item;
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            data[N] = item;
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            if (N == 1) {
                Item item = current[0];
                data[0] = null;
                N--;
                return item;
            } else {
                Item item = current[0];
                saved = (Item[]) (new Object[N]);
                saved = current;
                current = (Item[]) (new Object[N - 1]);
                for (int i = 0; i < N - 1; i++) {
                    current[i] = saved[i + 1];
                }
                N--;
                return item;
            }
        }
    }

    public static void main(String[] args) {
        Deque dq = new Deque();

        dq.addFirst(5);

        dq.addFirst(2);
        
        dq.removeLast();

        System.out.print(dq.removeFirst() + ""\n"");

    }

}

@5af99098f1d1c0c2d69b1ad24c0ed076@"
"r04631021","2","1.39","183600","@8dd4dfb42d55976232d88efb126cdf04@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

    /**
     *
     * @return
     */
    @Override
    public Iterator iterator() { 
        return new ListIterator(); 
    }
    private class ListIterator implements Iterator{
       private Node<Item> current ;
       @Override
       public boolean hasNext() { return current != null; }
       @Override
       public void remove() {  throw new UnsupportedOperationException();  }
       @Override
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       
 }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
    }
}    



@8dd4dfb42d55976232d88efb126cdf04@"
"r03631015","9","1.44","168016","@9942940b3eb395d6517af8fbb0fcce23@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
@9942940b3eb395d6517af8fbb0fcce23@"
"r03522826","3","0.36","102432","@d167bec603ceeb6c0b8a7b1f0a0c9c5e@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldlast;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
//            for(int i = 0; i < N; i++)
//            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@d167bec603ceeb6c0b8a7b1f0a0c9c5e@"
"r04631021","2","1.37","181696","@e8e2366b7bab1bb167c47c580a730628@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

        
    public Iterator iterator() { 
        return new ListIterator(); 
    }
    private class ListIterator implements Iterator{
       private Node<Item> current ;
       
       public boolean hasNext() { return current != null; }
       
       public void remove() {  throw new UnsupportedOperationException();  }
       
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       
 }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
    }
}    



@e8e2366b7bab1bb167c47c580a730628@"
"r04631021","2","1.38","178032","@e8e2366b7bab1bb167c47c580a730628@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

        
    public Iterator iterator() { 
        return new ListIterator(); 
    }
    private class ListIterator implements Iterator{
       private Node<Item> current ;
       
       public boolean hasNext() { return current != null; }
       
       public void remove() {  throw new UnsupportedOperationException();  }
       
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       
 }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
    }
}    



@e8e2366b7bab1bb167c47c580a730628@"
"r04631021","2","1.42","173600","@e8e2366b7bab1bb167c47c580a730628@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    private static class Node<Item> {
        private Item item;
        private Node next;
        private Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

        
    public Iterator iterator() { 
        return new ListIterator(); 
    }
    private class ListIterator implements Iterator{
       private Node<Item> current ;
       
       public boolean hasNext() { return current != null; }
       
       public void remove() {  throw new UnsupportedOperationException();  }
       
       public Item next()
    {
        if (!hasNext()) throw new NoSuchElementException();
        
        Item item = current.item;
        current = current.next;
        return item;
        
    }
       
 }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
    }
}    



@e8e2366b7bab1bb167c47c580a730628@"
"r04921115","0","0.35","102416","@4c1f34497dcbb942c85341c13f9a5a5c@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return first == null;
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.next = oldfirst;
       if(oldfirst == null){
         last = first;
       }else{
    	   oldfirst.prev = first;
       }
       N++;
   }
   
//add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       oldlast.next = last;
       last.prev = oldlast;
       N++;
   }
   
//remove front
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   //first.prev = null;
	   N--;
//	   if(N==0){
//		   last = null;
//		   first = null;
//	   }else{
//		   first = first.next;
//		   first.prev = null;
//	   }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   N--;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null)&&(current.next!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> s = new Deque<String>();
//       while (!StdIn.isEmpty()) {
//       	   String item = StdIn.readString();
//       	   s.addFirst(item);
//       	   String item2 = StdIn.readString();
//    	   s.addFirst(item2);
//    	   String item3 = StdIn.readString();
//       	   s.addFirst(item3);
//       	   String pop = s.removeFirst();
//       	   StdOut.print(pop+"""");
//
//       	   String pop2 = s.removeFirst();
//       	   StdOut.print(pop2+"""");
//
//       	   String pop3 = s.removeFirst();
//       	   StdOut.print(pop3+"""");
//       	   
//       	String pop4 = s.removeFirst();
//    	   StdOut.print(pop4+"""");
       	   
//
//       	   String pop4 = s.removeFirst();
//       	   StdOut.print(pop4+"""");
//       	   s.addFirst(item);
//           if (!item.equals(""-"")) s.removefirst(item);
//           else if (!s.isEmpty()) StdOut.print(s.pop() + "" "");
//       }
//       StdOut.println(""("" + s.size() + "" left on stack)"");
   }
}
@4c1f34497dcbb942c85341c13f9a5a5c@"
"r04631026","9","1.38","183376","@9942940b3eb395d6517af8fbb0fcce23@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
@9942940b3eb395d6517af8fbb0fcce23@"
"r03522826","8","1.43","183584","@eb71cb92036ad727bd28d3c719ae0d0f@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
//            for(int i = 0; i < N; i++)
//            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
            System.out.println(s.removeFirst());
            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@eb71cb92036ad727bd28d3c719ae0d0f@"
"r04228027","6","1.41","184016","@1d799bed577959983a6b3966e23c0bdf@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null || last == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
           node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
        node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty())last.next = null;
       size --;
       return temp.item;
       
   }
   
    @Override
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       
       public ListIterator(node<Item> first) {
            current = first;
        }
       @Override
       public void remove(){
           throw new UnsupportedOperationException();
       }
       @Override
       public boolean hasNext(){
           return current != null;
       }
       @Override
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        Scanner scan = new Scanner(System.in);
        int input;
        int var;
        while(true){
            System.out.print(""輸入欲執行的指令: "");
            input = scan.nextInt();
            if(1 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addFirst(var);
            }
            if(2 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addLast(var);
            }
            if(3 == input)
                a.removeFirst();
            if(4 == input)
                a.removeLast();
            if(5 == input)
                System.out.print(a.size()+""\n"");
            if(6 == input){
                for (Object i : a) {
                    System.out.print(i);
                }
            }
            if(0 == input)
                break;
        }   
    }    
}

@1d799bed577959983a6b3966e23c0bdf@"
"r03522809","7","1.42","171712","@bd6ad468df82c86bb02447f0a6d44d45@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
        

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        return first.item;
    }


    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }


    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    public static void main(String[] args)throws Exception {
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-,"";
        String ans;
        String[] word =ws.split("","");
        Deque stack=new Deque();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);

            }
                j++;
        }        
        

     }
    }
}
@bd6ad468df82c86bb02447f0a6d44d45@"
"r04228027","9","1.43","179040","@4f70e3f9b65ef8ef381093c2e608ac31@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null || last == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
       if(item==null) throw new java.lang.NullPointerException();    
       node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
       if(item==null) throw new java.lang.NullPointerException();     
       node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty())last.next = null;
       size --;
       return temp.item;
       
   }
   
    @Override
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       public ListIterator(node<Item> first) {
            current = first;
        }
       @Override
       public void remove(){
           throw new UnsupportedOperationException();
       }
       @Override
       public boolean hasNext(){
           return current != null;
       }
       @Override
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        Scanner scan = new Scanner(System.in);
        int input;
        int var;
        while(true){
            System.out.print(""輸入欲執行的指令: "");
            input = scan.nextInt();
            if(1 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addFirst(var);
            }
            if(2 == input){
                System.out.print(""輸入欲加入的值: "");
                var = scan.nextInt();
                a.addLast(var);
            }
            if(3 == input)
                a.removeFirst();
            if(4 == input)
                a.removeLast();
            if(5 == input)
                System.out.print(a.size()+""\n"");
            if(6 == input){
                for (Object i : a) {
                    System.out.print(i);
                }
            }
            if(0 == input)
                break;
        }   
    }    
}

@4f70e3f9b65ef8ef381093c2e608ac31@"
"b02611002","0","0.45","102336","@d3567e951d76bb96a2f957afa05f8e15@import javax.xml.soap.Node;
import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private Node first = null;
    private Node current = first;
    private class Node {
        Item item;
        Node next;
    }

    // construct an empty deque
    public Deque(){

    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return 0;
    }

    // add the item to the front
    public void addFirst(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
    }

    // add the item to the end
    public void addLast(Item item){

    }

    // remove and return the item from the front
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        return first.item;
    }

    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{      //DequeIterator實作Iterator<>
                                                                // ，故需包含hesNext()及next()
        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }


    public static void main(String[] args) throws Exception {

//        Deque DequeTest = new Deque();
//        System.out.println(DequeTest.iterator());
//        Iterator it = DequeTest.iterator();
//
//        for (Object o : DequeTest) System.out.println(o);

        // read file from args[0] in Java 7 style
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//
//            // read a line and split by ','
//            String[] data = br.readLine().split("","");
//
//            // store the first integer in variable stringCount (number of announced strings)
//            int stringCount = Integer.parseInt(data[0]);
//
//            // store the second integer in variable num (dimension of matrix: num * num)
//            int num = Integer.parseInt(data[1]);
//
//            // initilization of a String array in Java
//            String[] announce = new String[stringCount];
//            String[][] matrix = new String[num][num];
//
//            // printf in Java (you should comment out or delete this in your final submission)
//            System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);

    }
}

@d3567e951d76bb96a2f957afa05f8e15@"
"r04631021","10","0.145","177984","@79b9f71a9ee5859e58c1a6026230fa3e@import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    public static class Node<Item> {
        public Item item;
        public Node next;
        public Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

        
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        //Deque qe = new Deque();

//        qe.addLast(""a"");
//        qe.addLast(""b"");
//        qe.addLast(""c"");
//        qe.addLast(""d"");
        //qe.addFirst(""a"");
        //qe.addFirst(""bc"");
        //qe.addLast(""c"");
        //qe.removeLast();
        //qe.removeFirst();
        //qe.removeFirst();
        //qe.removeFirst();
        //qe.removeLast();
        //qe.removeLast();
        //qe.removeLast();
        //qe.addLast(""a"");
        //qe.addFirst(""a"");
        //qe.removeLast();

       //Iterator it=qe.iterator();

        //System.out.println(""Initial Size of Queue :""+qe.size());

        //while(it.hasNext())
        //{
           // String iteratorValue=(String)it.next();
            //System.out.println(""Queue Next Value :""+iteratorValue);
        //}

        //System.out.println(""Final Size of Queue :""+qe.size());
    }
}    



@79b9f71a9ee5859e58c1a6026230fa3e@"
"r03522809","7","1.4","175744","@d06f723b1395c42fae2b78cdc4d58ccb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    public static void main(String[] args)throws Exception {
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque stack=new Deque();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);

            }
                j++;
        }        
        

     }
    }
}
    
    

@d06f723b1395c42fae2b78cdc4d58ccb@"
"r04631009","7","1.14","174208","@4235a6fca0bf9ed45e12530101bb54a0@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator();}
    private class ListIterator implements Iterator<Item>
    {
       private Node current=first;
       public boolean hasNext() {return current!=null;}
       public void remove() {}
       public Item next()
               {
                   Item item=current.item;
                   current=current.next;
                   return item;
               }
    }
    private Node first;
    private Node last;
    private  int number;
    private class Node
    {
        Item item;
        Node next;
        Node previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node newFirst=new Node();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node newLast=new Node();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
        assert check();
        return item;
    }
    public Item removeLast() //From website
    {
       Item item=last.item;
       Node oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        testing.addLast(""i"");
        testing.addFirst(""b"");
        testing.addLast(""j"");
        testing.addFirst(""k"");
        testing.addFirst(""p"");
        testing.addLast(""q"");
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        // System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        }catch(NullPointerException e){System.out.println(""It's empty. Don't remove!"");}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}
@4235a6fca0bf9ed45e12530101bb54a0@"
"r04631041","7","1.41","181024","@72ab536c86a6d495ca1aa160cb54fbef@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     Node<Item> newFirst=new Node<Item>();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        Node<Item> newLast=new Node<Item>();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {   
        if(isEmpty()) throw new NoSuchElementException(""Stack underflow!"");
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
       assert check();
        if (number==0){
           first=null;
           last=null;
       }
        return item;
    }
    public Item removeLast() //From website
    {  
       if(isEmpty()) throw new NoSuchElementException(""Stack underflow!"");
       Item item=last.item;
       Node<Item> oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       if (number==0){
           first=null;
           last=null;
       }
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        //testing.addLast(""i"");
        //testing.addFirst(""b"");
        //testing.addLast(""j"");
        //testing.addFirst(""k"");
        //testing.addFirst(""p"");
        //testing.addLast(""q"");
        System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
         System.out.println(testing.removeLast());
        testing.addFirst(""sd"");
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        //i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@72ab536c86a6d495ca1aa160cb54fbef@"
"r04921115","1","1.27","180048","@6275fc7b2e6f15b9fab3772fb6b381c7@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return first == null;
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       first.next = oldfirst;
       N++;
       if(isEmpty()) last = first;
       //else oldfirst.prev = first;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       last.next = null;
       last.prev = oldlast;
       N++;
       if(isEmpty()) first = last;
       else oldlast.next = last;
   }
   
// V remove front
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   //first.prev = null;
	   N--;
       if(isEmpty()) last = null;
//	   if(N==0){
//		   last = null;
//		   first = null;
//	   }else{
//		   first = first.next;
//		   first.prev = null;
//	   }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   N--;
       if(isEmpty()) first = null;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null)&&(current.next!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> s = new Deque<String>();
//       while (!StdIn.isEmpty()) {
//       	   String item = StdIn.readString();
//       	   s.addFirst(item);
//       	   String item2 = StdIn.readString();
//    	   s.addFirst(item2);
//    	   String item3 = StdIn.readString();
//       	   s.addFirst(item3);
//       	   String pop = s.removeLast();
//       	   StdOut.println(pop+"""");
//
//       	   String pop2 = s.removeFirst();
//       	   StdOut.println(pop2+"""");
//
//       	   String pop3 = s.removeLast();
//       	   StdOut.println(pop3+"""");
       	   
       	   
//
//       	   String pop4 = s.removeFirst();
//       	   StdOut.print(pop4+"""");
//       	   s.addFirst(item);
//           if (!item.equals(""-"")) s.removefirst(item);
//           else if (!s.isEmpty()) StdOut.print(s.pop() + "" "");
//       }
//       StdOut.println(""("" + s.size() + "" left on stack)"");
   }
}
@6275fc7b2e6f15b9fab3772fb6b381c7@"
"r04921115","1","1.25","185104","@6275fc7b2e6f15b9fab3772fb6b381c7@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return first == null;
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       first.next = oldfirst;
       N++;
       if(isEmpty()) last = first;
       //else oldfirst.prev = first;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       last.next = null;
       last.prev = oldlast;
       N++;
       if(isEmpty()) first = last;
       else oldlast.next = last;
   }
   
// V remove front
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   //first.prev = null;
	   N--;
       if(isEmpty()) last = null;
//	   if(N==0){
//		   last = null;
//		   first = null;
//	   }else{
//		   first = first.next;
//		   first.prev = null;
//	   }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   N--;
       if(isEmpty()) first = null;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null)&&(current.next!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> s = new Deque<String>();
//       while (!StdIn.isEmpty()) {
//       	   String item = StdIn.readString();
//       	   s.addFirst(item);
//       	   String item2 = StdIn.readString();
//    	   s.addFirst(item2);
//    	   String item3 = StdIn.readString();
//       	   s.addFirst(item3);
//       	   String pop = s.removeLast();
//       	   StdOut.println(pop+"""");
//
//       	   String pop2 = s.removeFirst();
//       	   StdOut.println(pop2+"""");
//
//       	   String pop3 = s.removeLast();
//       	   StdOut.println(pop3+"""");
       	   
       	   
//
//       	   String pop4 = s.removeFirst();
//       	   StdOut.print(pop4+"""");
//       	   s.addFirst(item);
//           if (!item.equals(""-"")) s.removefirst(item);
//           else if (!s.isEmpty()) StdOut.print(s.pop() + "" "");
//       }
//       StdOut.println(""("" + s.size() + "" left on stack)"");
   }
}
@6275fc7b2e6f15b9fab3772fb6b381c7@"
"r04631041","10","0.139","177808","@da15245e3af1ab44943d0c44652a4424@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item>{
    public Iterator<Item> iterator() {return new ListIterator<Item>(first);}
//    private class ListIterator implements Iterator<Item>
//    {
//       private Node current=first;
//       public boolean hasNext() {return current!=null;}
//       public void remove() {}
//       public Item next()
//               {
//                   Item item=current.item;
//                   current=current.next;
//                   return item;
//               }
//    }
      private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    
    private Node<Item> first;
    private Node<Item> last;
    private  int number;
    private class Node<Item>
    {
        Item item;
        Node<Item> next;
        Node<Item> previous;
    }
    public Deque()
    {
       first=null;
       last=null;
       number=0;
        assert check();
    }
    public boolean isEmpty()
    {return first==null;}
    public int size()
    {return number;}
    
    public void addFirst (Item item)//From website
    {
     if (item.equals(null)) throw new NullPointerException();
     Node<Item> newFirst=new Node<Item>();
     newFirst.item=item;
     if (first != null){
         newFirst.next=first;
         first.previous=newFirst;
     }
     first=newFirst;
     if (last==null) last=first;
     number++;
     assert check();
     }
    public void addLast (Item item)//From website
    {
        if (item.equals(null)) throw new NullPointerException();
        Node<Item> newLast=new Node<Item>();
        newLast.item=item;
        if (last!=null){
            newLast.previous=last;
            last.next=newLast;
        }
        last=newLast;
        if (first==null) first=last;
        number++;
        assert check();
    }
    public Item removeFirst()
    {   
        if(isEmpty()) throw new NoSuchElementException(""Stack underflow!"");
        Item item=first.item;
        first=first.next;
        number--;
        if (isEmpty()) last=null;
        else first.previous=null;
       assert check();
        if (number==0){
           first=null;
           last=null;
       }
        return item;
    }
    public Item removeLast() //From website
    {  
       if(isEmpty()) throw new NoSuchElementException(""Stack underflow!"");
       Item item=last.item;
       Node<Item> oldLast=last;
       last=oldLast.previous;
       if (last==null)
           first=null;
       else
           last.next=null;
       number--;
       assert check();
       if (number==0){
           first=null;
           last=null;
       }
       return item;
    }
    public static void main(String[] args){
        try{
        Deque<String> testing= new Deque<String>();
        testing.addFirst(""x"");
        testing.addLast(""e"");
        testing.addLast(""a"");
        //testing.addLast(""i"");
        //testing.addFirst(""b"");
        //testing.addLast(""j"");
        //testing.addFirst(""k"");
        //testing.addFirst(""p"");
        //testing.addLast(""q"");
        System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeFirst());
        //System.out.println(testing.removeLast());
        //System.out.println(testing.removeFirst());
        System.out.println(testing.removeFirst());
        System.out.println(testing.removeLast());
         System.out.println(testing.removeLast());
        testing.addFirst(""sd"");
        System.out.println(testing.size());
        Iterator<String> i=testing.iterator();
        while(i.hasNext()){
            String s=i.next();
            System.out.print(s+""\t"");
        }      
        //i.remove();
        }catch(NullPointerException e){System.out.println(e.getMessage());}
         
    }
    private boolean check() {
        if (number < 0) {
            return false;
        }
        else if (number == 0) {
            if (first != null) return false;
            if (last  != null) return false;
        }
        else if (number == 1) {
            if (first == null || last == null) return false;
            if (first != last)                 return false;
            if (first.next != null)            return false;
        }
        else {
            if (first == null || last == null) return false;
            if (first == last)      return false;
            if (first.next == null) return false;
            if (last.next  != null) return false;

            // check internal consistency of instance variable N
            int numberOfNodes = 0;
            for (Node x = first; x != null && numberOfNodes <= number; x = x.next) {
                numberOfNodes++;
            }
            if (numberOfNodes != number) return false;

            // check internal consistency of instance variable last
            Node lastNode = first;
            while (lastNode.next != null) {
                lastNode = lastNode.next;
            }
            if (last != lastNode) return false;
        }

        return true;
    }  
}

@da15245e3af1ab44943d0c44652a4424@"
"r04945009","0","1.27","180048","@d75327435b16d7a43d194071011b9529@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 
    
    private class Node
    {
        Item item;
        Node left;
        Node right;
    }
    
    public Deque() {}                          // construct an empty deque

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
        Deque0 a = new Deque0();
        a.addFirst(1);
        a.addFirst(2);
        System.out.println(a.removeLast());
        System.out.println(a.removeLast());
        a.addFirst(1);
        System.out.println(a.removeLast());
    }
}

@d75327435b16d7a43d194071011b9529@"
"r04945009","0","1.27","180048","@d75327435b16d7a43d194071011b9529@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 
    
    private class Node
    {
        Item item;
        Node left;
        Node right;
    }
    
    public Deque() {}                          // construct an empty deque

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
        Deque0 a = new Deque0();
        a.addFirst(1);
        a.addFirst(2);
        System.out.println(a.removeLast());
        System.out.println(a.removeLast());
        a.addFirst(1);
        System.out.println(a.removeLast());
    }
}

@d75327435b16d7a43d194071011b9529@"
"r03522809","7","1.38","178624","@a896883c6adb8a09fd61c77f811ff5bb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    public static void main(String[] args)throws Exception {
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);

            }
                j++;
        }        
        

     }
    }
}
@a896883c6adb8a09fd61c77f811ff5bb@"
"r03522809","7","1.41","168816","@568c537fca245036e42d3487c85e2a6d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException(""item is null"");
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    public static void main(String[] args) {
        Deque<String> s = new Deque<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals(""-"")) s.addFirst(item);
            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
        }
        StdOut.println(""("" + s.size() + "" left on stack)"");
    }

//    public static void main(String[] args)throws Exception {
//     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
////        String[] words = br.readLine().split("" ""); 
//        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
//        String ans;
//        String[] word =ws.split("","");
//        Deque <String> stack=new Deque<String>();
//        int N = word.length;
//        int i =0,j=0;
//
//        while ( j != N )
//        {
//            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
//            else{stack.addLast(word[j]);
//
//            }
//                j++;
//        }        
//        
//
//     }
//    }
}
@568c537fca245036e42d3487c85e2a6d@"
"r04945009","6","1.33","180048","@65d174600b083741c19ea16419f150c3@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 
    
    private class Node
    {
        Item item;
        Node left;
        Node right;
    }
    
    public Deque() {}                          // construct an empty deque

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
        Deque a = new Deque();
        a.addFirst(1);
        a.addFirst(2);
        System.out.println(a.removeLast());
        System.out.println(a.removeLast());

    }
}

@65d174600b083741c19ea16419f150c3@"
"r04631013","0","1.38","178624","@c0ce0906578021235bf05f0100e42d0f@public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    
       /**
     * Initializes an empty Deque.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
 /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    
    
     public void addFirst(Item item)    {      // add the item to the front
         if (item==null) throw new NullPointerException(""Deque underflow"");  
          Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        N++;
     }
     
     public void addLast(Item item)  {         // add the item to the end
          if (item==null) throw new NullPointerException(""Deque underflow"");  
     Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
     }
     
     public Item removeFirst() {               // remove and return the item from the front
       if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");  
       Item item = first.item;
       first = first.next;            // delete first node
        N--;
        if (isEmpty()) last = null; 
        return item;   
     }
     
     
     public Item removeLast() {                // remove and return the item from the end
       if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");  
       Item item = last.item;
      last = last.previous;
      N--;
       if (isEmpty()) last = null; 
       return item;
     }
     
     
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    
    public static void main(String[] args) {  // unit testing
Deque<String> d = new Deque<String>();
d.addLast(""3"");
 String item = ""1 "";
d.addLast(item);
System.out.println(""("" + d.size() + "" left on queue)"");
System.out.println(""("" + d.removeFirst() + "" is the answer"");

    }
}

@c0ce0906578021235bf05f0100e42d0f@"
"r04945009","8","1.48","178512","@1f602091eda3c21e335e2de9f7f4af87@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 
    
    private class Node
    {
        Item item;
        Node left;
        Node right;
    }
    
    public Deque() {}                          // construct an empty deque

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        if (isEmpty()) { throw new java.util.NoSuchElementException(); }
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) { throw new java.util.NoSuchElementException(); }
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
        Deque a = new Deque();
        a.addFirst(1);
        a.addFirst(2);
        System.out.println(a.removeLast());
        System.out.println(a.removeLast());

    }
}

@1f602091eda3c21e335e2de9f7f4af87@"
"r04631013","7","1.47","179392","@dd4670ef31a11ca251d0b429fa12cac9@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    
       /**
     * Initializes an empty Deque.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
 /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    
    
     public void addFirst(Item item)    {      // add the item to the front
         if (item==null) throw new NullPointerException(""Deque underflow"");  
          Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        N++;
     }
     
     public void addLast(Item item)  {         // add the item to the end
          if (item==null) throw new NullPointerException(""Deque underflow"");  
     Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
     }
     
     public Item removeFirst() {               // remove and return the item from the front
       if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");  
       Item item = first.item;
       first = first.next;            // delete first node
        N--;
        if (isEmpty()) last = null; 
        return item;   
     }
     
     
     public Item removeLast() {                // remove and return the item from the end
       if (isEmpty()) throw new NoSuchElementException(""Deque underflow"");  
       Item item = last.item;
      last = last.previous;
      N--;
       if (isEmpty()) last = null; 
       return item;
     }
     
     
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    
    public static void main(String[] args) {  // unit testing
Deque<String> d = new Deque<String>();
d.addLast(""3"");
 String item = ""1 "";
d.addLast(item);
System.out.println(""("" + d.size() + "" left on queue)"");
System.out.println(""("" + d.removeFirst() + "" is the answer"");

    }
}

@dd4670ef31a11ca251d0b429fa12cac9@"
"r04921115","8","1.38","182352","@fecd64992ba8fa8388e223895f9bed78@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return (first == null || last == null);
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       first.next = null;	
       
       N++;
       if(isEmpty()) last = first;
       else first.next = oldfirst;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       last.next = null;
       last.prev = oldlast;
       N++;
       if(isEmpty()) first = last;
       else oldlast.next = last;
   }
   
// V remove front
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   //first.prev = null;
	   N--;
       if(isEmpty()) last = null;
//	   if(N==0){
//		   last = null;
//		   first = null;
//	   }else{
//		   first = first.next;
//		   first.prev = null;
//	   }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   if(last.prev!=null){last = last.prev;}	         // delete last node
	   last.next = null;
	   N--;
       if(isEmpty()) first = null;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> d = new Deque<String>();
//	   d.addFirst(""one"");
//	   d.addFirst(""two"");
//	   d.addFirst(""three"");
//	   d.addFirst(""four"");
//
//	   d.removeFirst();
//
//	   for (String s : d) {
//           System.out.println(s); // prints only ""four""
//       }
   }
}
@fecd64992ba8fa8388e223895f9bed78@"
"r03522809","7","1.43","177920","@571d87c4eb049458dc7e702c9b469695@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;



public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NoSuchElementException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);
            }
                j++;
        }        
        

     
    }
}
    
    

@571d87c4eb049458dc7e702c9b469695@"
"r04945009","8","1.44","181456","@0190057d7e84580241faa4b6d0838f7c@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 
    
    private class Node
    {
        Item item;
        Node left;
        Node right;
    }

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        if (isEmpty()) { throw new java.util.NoSuchElementException(); }
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) { throw new java.util.NoSuchElementException(); }
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
    }
}

@0190057d7e84580241faa4b6d0838f7c@"
"r03522826","8","1.44","179344","@c4e6282710963d4a18d42816b03f08d7@



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}

@c4e6282710963d4a18d42816b03f08d7@"
"r04631046","2","0.25","99024","@3ede2ab8519f208bd993519c57ca8425@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[]) (new Object[1]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?

    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            data[0] = item;
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N + 1]);
            data[N] = item;
            for (int i = 0; i < N; i++) {
                data[i] = olddata[i];
            }
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[0];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N--;
            return item;
        } else {
            Item item = data[N - 1];
            olddata = (Item[]) (new Object[N]);
            olddata = data;
            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i];
            }
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current[0] != null;
        }

        public void remove() {

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            if (N == 1) {
                Item item = current[0];
                data[0] = null;
                N--;
                return item;
            } else {
                Item item = current[0];
                saved = (Item[]) (new Object[N]);
                saved = current;
                current = (Item[]) (new Object[N - 1]);
                for (int i = 0; i < N - 1; i++) {
                    current[i] = saved[i + 1];
                }
                N--;
                return item;
            }
        }
    }

    public static void main(String[] args) {
        Deque dq = new Deque();

        dq.addFirst(5);

        dq.addFirst(2);

        System.out.print(dq.iterator().next() + ""\n"");
        System.out.print(dq.iterator().next() + ""\n"");

    }

}

@3ede2ab8519f208bd993519c57ca8425@"
"r03522809","7","1.38","175648","@7c7b604eea31fa39aaf939a2d5c78a1d@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) first = null;
        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addLast(word[j]);
            }
                j++;
        }        
    }
}
    
    

@7c7b604eea31fa39aaf939a2d5c78a1d@"
"r04945009","8","1.47","166992","@e55e009b7ab5b4818aaca56305c0d662@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Deque<Item> implements Iterable<Item> {
    
    private Node first = null;
    private Node last = null;
    private int size = 0; 

    private class Node
    {
        Item item;
        Node left;
        Node right;
    }

    public boolean isEmpty()                 // is the deque empty?
    { return size() == 0; }

    public int size()                        // return the number of items on the deque
    { return size; }

    public void addFirst(Item item)          // add the item to the front
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.left = null;
        first.right = oldfirst;
        if (isEmpty()) last = first;
        else           oldfirst.left = first;
        size++;
    }

    public void addLast(Item item)           // add the item to the end
    {
        if (item == null) { throw new NullPointerException(); }
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.right = null;
        last.left = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.right = last;
        size++;
    }

    public Item removeFirst()                // remove and return the item from the front
    {
        if (isEmpty()) { throw new NoSuchElementException(); }
        Item item = first.item;
        first = first.right;
        size--;
        if (isEmpty()) last = null;
        return item;
    }

    public Item removeLast()                 // remove and return the item from the end
    {
        if (isEmpty()) { throw new NoSuchElementException(); }
        Item item = last.item;
        last = last.left;
        size--;
        if (isEmpty()) first = null;
        return item;
    }
    
    public Iterator<Item> iterator() { return new DequeIterator();}        // return an iterator over items in order from front to end
    private class DequeIterator implements Iterator<Item>
    {
        private Node current = first;
        
        public boolean hasNext() { return current != null; }
        public void remove() { throw new UnsupportedOperationException(); }
        public Item next()
        {
            if (!hasNext()) { throw new NoSuchElementException(); }
            Item item = current.item;
            current = current.right;
            return item;
        }
    }
    
    public static void main(String[] args)   // unit testing
    {
        Deque a = new Deque();
        a.addFirst(1);
        System.out.println(a.size());
        a.addFirst(""good"");
        System.out.println(a.size());
        System.out.println(a.removeFirst());
        System.out.println(a.removeLast());
        System.out.println(a.size());
        a.addFirst(1);
        System.out.println(a.removeLast());
    }
}

@e55e009b7ab5b4818aaca56305c0d662@"
"r03522826","8","1.45","186096","@c4e6282710963d4a18d42816b03f08d7@



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}

@c4e6282710963d4a18d42816b03f08d7@"
"r03522826","7","1.46","187216","@e8df253fd029e7543e98221f5ae350b6@



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
//        if(isEmpty()){
//            last = null;
//        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
//       if(isEmpty()){
//           first = null;
//       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}

@e8df253fd029e7543e98221f5ae350b6@"
"r04631013","7","1.65","167280","@0ee2901de821a26ac73ecc22c539fdda@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chenchen
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    
       /**
     * Initializes an empty Deque.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
 /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }
    
    
     public void addFirst(Item item)    {      // add the item to the front
         if (item==null) throw new java.lang.NullPointerException(""Deque underflow"");  
          Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) last = first;
        N++;
     }
     
     public void addLast(Item item)  {         // add the item to the end
          if (item==null) throw new java.lang.NullPointerException(""Deque underflow"");  
     Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
     }
     
     public Item removeFirst() {               // remove and return the item from the front
       if (isEmpty()) throw new java.util.NoSuchElementException(""Deque underflow"");  
       Item item = first.item;
       first = first.next;            // delete first node
        N--;
        if (isEmpty()) last = null; 
        return item;   
     }
     
     
     public Item removeLast() {                // remove and return the item from the end
       if (isEmpty()) throw new java.util.NoSuchElementException(""Deque underflow"");  
       Item item = last.item;
      last = last.previous;
      N--;
       if (isEmpty()) last = null; 
       return item;
     }
     
     
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    
    public static void main(String[] args) {  // unit testing
Deque<String> d = new Deque<String>();
d.addLast(""3"");
d.addLast(""2"");
d.addLast(""1"");
d.removeLast();
d.removeLast();
d.removeLast();
d.addLast(""7"");
System.out.println(""("" + d.removeFirst() + "" is the answer"");
System.out.println(""("" + d.size() + "" left on queue)"");
    }
}

@0ee2901de821a26ac73ecc22c539fdda@"
"r04921115","8","1.44","164192","@95e7bc2031dfcf6e0cdbc27013be9267@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return (first == null || last == null);
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       first.next = null;	
       
       N++;
       if(isEmpty()) last = first;
       else first.next = oldfirst;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       last.item = item;
       last.next = null;
       last.prev = oldlast;
       N++;
       if(isEmpty()) first = last;
       else oldlast.next = last;
   }
   
// V remove front // right!!!
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   N--;
       if(isEmpty()) last = null;
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   N--;
       if(isEmpty()) first = null;
	   return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new ListIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class ListIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public ListIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> d = new Deque<String>();
//	   d.addFirst(""one"");
//	   d.addFirst(""two"");
//	   d.addFirst(""three"");
//	   d.addFirst(""four"");
//
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();

//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();


	   for (String s : d) {
           System.out.println(s); // prints only ""four""
       }
   }
}
@95e7bc2031dfcf6e0cdbc27013be9267@"
"r03222054","10","0.162","171200","@1a57c7ae40206fc891978dcc61d1ed6b@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private static final class NodeIterator<Item> implements Iterator<Item> {
        private Node<Item> next;

        public NodeIterator(final Deque<Item> deque) {
            if (deque.first != null) {
                this.next = deque.first;
            } else {
                this.next = deque.last;
            }
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            final Item item = next.item;
            next = next.next;
            return item;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private static final class Node<Item> {
        private Item item;
        private Node<Item> next;

        public Node(final Item i, final Node<Item> n) {
            item = i;
            next = n;
        }
    }

    private Node<Item> first = null;
    private Node<Item> last = null;
    private int size;

    /**
     * Construct an empty deque
     */
    public Deque() {
    }

    /**
     * Is the deque empty?
     * 
     * @return true if there are no first or last items
     */
    public boolean isEmpty() {
        return first == null && last == null;
    }

    /**
     * Return the number of items on the deque
     * 
     * @return an int >= 0
     */
    public int size() {
        return size;
    }

    /**
     * Insert the item at the front
     * 
     * @param item
     */
    public void addFirst(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            first = new Node<Item>(item, last);
        } else {
            final Node<Item> newFirst = new Node<Item>(item, first);
            first = newFirst;
            if (last == null) {
                last = first.next;
            }
        }
        if (last == null) {
            last = first;
        }
        
        size++;
    }

    /**
     * Insert the item at the end
     * 
     * @param item
     *            the item to add
     */
    public void addLast(final Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (last == null) {
            last = new Node<Item>(item, null);
            if (first != null) {
                first.next = last;
            }
        } else {
            final Node<Item> newLast = new Node<Item>(item, null);
            final Node<Item> oldLast = last;
            oldLast.next = newLast;
            last = newLast;
            if (first == null) {
                first = oldLast;
            }
        }
        if (first == null) {
            first = last;
        }
        size++;
    }

    /**
     * Delete and return the item at the front
     * 
     * @return the item removed
     */
    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }

        final Node<Item> oldFirst = first;
        if (oldFirst == last) {
            first = null;
            last = null;
        } else {
            final Node<Item> newFirst = first.next;
            first = newFirst;
        }
        size--;
        return oldFirst.item;
    }

    /**
     * Delete and return the item at the end
     * 
     * @return the item removed
     */
    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        final Node<Item> oldLast = last;

        if (first == last) {
            // last item left
            first = null;
            last = null;
        } else if (first != null) {
            // find penultimate Node and set as last
            final Node<Item> newLast = findPenultimateNode();
            newLast.next = null;
            last = newLast;
        } else {
            last = null;
        }
        size--;

        if (oldLast != null) {
            return oldLast.item;
        } else {
            return first.item;
        }
    }

    /**
     * Return an iterator over items in order from front to end
     * 
     * @return an iterator over the items in this queue
     */
    public Iterator<Item> iterator() {
        return new NodeIterator<Item>(this);
    }

    private Node<Item> findPenultimateNode() {
        Node<Item> newLast = first;
        while (newLast.next != null && newLast.next != last) {
            newLast = newLast.next;
        }
        // now at penultimate node i.e. last.previous or last-1
        // newLast.next = null
        return newLast;
    }
    
    public static void main(String argv[])
    {
        
    }
}
@1a57c7ae40206fc891978dcc61d1ed6b@"
"r03522809","7","1.37","181728","@46e2794aa6f0c1ba65ba4b4756d992bd@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) last = null;

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeLast());
            else{stack.addLast(word[j]);
            }
                j++;
        }        
    }
}
    
    

@46e2794aa6f0c1ba65ba4b4756d992bd@"
"r03522809","7","1.4","183248","@78aa1badeabcd5ad589698372c726a21@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {first = null;last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeLast());
            else{stack.addLast(word[j]);
            }
                j++;
        }        
    }
}
    
    


@78aa1badeabcd5ad589698372c726a21@"
"b03611011","7","0.83","100976","@28c6de3ef859d481646c72cf32eb6185@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        first.previous=null;
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        last.next=null;
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@28c6de3ef859d481646c72cf32eb6185@"
"b03611011","7","1.46","185744","@e36626b2437831edcc99db2604856bf3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first.item=null;
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last.item=null;
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@e36626b2437831edcc99db2604856bf3@"
"r03522831","8","1.45","182384","@59827f161e0772dd4ba8cf7cea45921b@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@59827f161e0772dd4ba8cf7cea45921b@"
"r03522809","7","1.38","183904","@a3877aeed67aba60d92b028116970915@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals(null)) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,-,F,-,-,G,-,-,-,H,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeLast());
            else{stack.addLast(word[j]);
            }
                j++;
        }        
    }
}
@a3877aeed67aba60d92b028116970915@"
"b03611011","7","1.46","185840","@b5d35796ba9a1129787efb99468bd654@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
                first.item=null;
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
                last.item=null;
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@b5d35796ba9a1129787efb99468bd654@"
"b03611011","6","1.44","188768","@a05f72cb5409870632faea068a715f7b@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            first.item=null;
            last.item=null;
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first.item = null;
        first = first.next;            // delete first node
        N--;
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            first.item=null;
            last.item=null;
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last.item=null;
        last = last.previous;            // delete first node
        N--;
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@a05f72cb5409870632faea068a715f7b@"
"b02611002","0","0.61","100640","@35c3896428886ff03bc5f714b0013786@import javax.xml.soap.Node;
import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private int n;
    private Node<Item> first;
    private Node<Item> last;
    private Node<Item> current=first;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }

    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{      //DequeIterator實作Iterator<>
                                                                // ，故需包含hesNext()及next()
        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }


    public static void main(String[] args) throws Exception {

//        Deque DequeTest = new Deque();
//        System.out.println(DequeTest.iterator());
//        Iterator it = DequeTest.iterator();
//
//        for (Object o : DequeTest) System.out.println(o);

        // read file from args[0] in Java 7 style
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//
//            // read a line and split by ','
//            String[] data = br.readLine().split("","");
//
//            // store the first integer in variable stringCount (number of announced strings)
//            int stringCount = Integer.parseInt(data[0]);
//
//            // store the second integer in variable num (dimension of matrix: num * num)
//            int num = Integer.parseInt(data[1]);
//
//            // initilization of a String array in Java
//            String[] announce = new String[stringCount];
//            String[][] matrix = new String[num][num];
//
//            // printf in Java (you should comment out or delete this in your final submission)
//            System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);

    }
}

@35c3896428886ff03bc5f714b0013786@"
"r04631031","9","1.4","176560","@9942940b3eb395d6517af8fbb0fcce23@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
@9942940b3eb395d6517af8fbb0fcce23@"
"b03611011","8","1.41","185600","@a07e73fc7097177da90351125699cf97@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first.item=null;
        first = first.next;            // delete first node
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last.item=null;
        last = last.previous;            // delete first node
        N--;
        if(N==0){
        first=null;last=null;
        }
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@a07e73fc7097177da90351125699cf97@"
"r03522809","5","1.41","175024","@f62f10b35eceef0acb59fd752c522504@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if ("""".equals(item)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if ("""".equals(item)) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""-,A,B,C,D,E,F,G,H,-,-,-,-"";
        String ans;
        String s ="""";
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        
        int N = word.length;
        int i =0,j=0;
        

        
        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addFirst(word[j]);
            }
                j++;
        }        
    }
}

@f62f10b35eceef0acb59fd752c522504@"
"r03849033","0","1.3","178192","@643a7118620bd4a96873115f2ed99535@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
     before.next=after;
     after.previous=before;
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size>0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     size++;
     Node node = new Node();
     node.item=item;//sets new node equal to the item
     node.previous=before;//sets new node's previous to before which is the beginning sentinel
     node.next=before.next;//sets new node's next to the old first node which was befores next.
     before.next.previous=node;//sets old first item's previous to the new Node making the old first second in the list.
     before.next=node;//sets before's next to the new Node making the new Node first in the list.

    }
    public void addLast(Item item)           // insert the item at the end
    {
     size++;
     Node node = new Node();
     node.item=item;//sets node item to item
     node.next=after;//sets new node's next to after 
     after.previous.next=node;//sets old last node's next to the new node 
     node.previous=after.previous;//sets new node's previous to old last node
     after.previous=node;//now after's previous is the new node making it last in the list.


    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Node first= before.next;//gets the first node.
     Node second=first.next;//gets the second element in the list
     second.previous=before;//sets second's previous to before
     before.next=second;//sets before's next to second
     return first.item;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Node last = after.previous;//sets last node
     Node second2Last= after.previous.previous;//sets second2Last
     second2Last.next=after;//sets second2Last's next to after
     after.previous=second2Last;//sets after's previous to second2last
     return last.item;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=after;

     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {



 }

}
@643a7118620bd4a96873115f2ed99535@"
"b02611002","0","0.58","102432","@2412e0a01b3b839accfedf9b12bf1bbc@import javax.xml.soap.Node;
import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private int n, index;
    private Node<Item> first;
    private Node<Item> last;
    private Node<Item> current=first;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }

    
    
    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new DequeIterator();
    }

    
    
    private class DequeIterator implements Iterator<Item>{      //DequeIterator實作Iterator<>
                                                                // ，故需包含hesNext()及next()
        public boolean hasNext() {
            return current!=null;
        }
        
        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }


    public static void main(String[] args) throws Exception {

//        Deque DequeTest = new Deque();
//        System.out.println(DequeTest.iterator());
//        Iterator it = DequeTest.iterator();
//
//        for (Object o : DequeTest) System.out.println(o);

        // read file from args[0] in Java 7 style
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//
//            // read a line and split by ','
//            String[] data = br.readLine().split("","");
//
//            // store the first integer in variable stringCount (number of announced strings)
//            int stringCount = Integer.parseInt(data[0]);
//
//            // store the second integer in variable num (dimension of matrix: num * num)
//            int num = Integer.parseInt(data[1]);
//
//            // initilization of a String array in Java
//            String[] announce = new String[stringCount];
//            String[][] matrix = new String[num][num];
//
//            // printf in Java (you should comment out or delete this in your final submission)
//            System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);

    }
}

@2412e0a01b3b839accfedf9b12bf1bbc@"
"r03522809","7","1.39","184288","@b2c949b66787ea95bc3f919bde19cdda@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,F,G,H,-,-"";
        String ans;

        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        
        int N = word.length;
        int i =0,j=0;
        
       
        
        while ( j != N )
        {
            if(word[j].equals(""-"")) System.out.println(stack.removeFirst());
            else{stack.addFirst(word[j]);
            }
                j++;
        }        
    }
}
    
    

@b2c949b66787ea95bc3f919bde19cdda@"
"b03611011","8","1.4","183248","@fa3d1ae8f58836fce4b347cd21f92445@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first.previous=null;
        first = first.next;            // delete first node
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last.next=null;
        last = last.previous;            // delete first node
        N--;
        if(N==0){
        first=null;last=null;
        }
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@fa3d1ae8f58836fce4b347cd21f92445@"
"r04921115","8","1.43","183232","@0b0f022603ce7650efbee50abfb8f829@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return (first == null || last == null);
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       first.next = null;	
       
       if (oldfirst == null) {
           first.next = null;
       }else {
           first.next = oldfirst;
           oldfirst.prev = first;        
       }
       
       if (last == null) {
           last = first;
       }
       
       N++;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       if(oldlast == null){
    	   last.prev = null;
       }else{
    	   last.prev = oldlast;
    	   oldlast.next = last;
       }
       last.item = item;
       last.next = null;
       if(first == null){
    	   first= last;
       }
       N++;
   }
   
// V remove front // right!!!
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   N--;
       if(isEmpty()) last = null;
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   if(last!=null && last.next!=null){
		   last.next = null;
	   }
	   if(last==null){
		   first=null;
	   }
	   N--;
       return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new DequeIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class DequeIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public DequeIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> d = new Deque<String>();
//	   d.addFirst(""one"");
//	   d.addFirst(""two"");
//	   d.addFirst(""three"");
//	   d.addFirst(""four"");
//
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();
	   
//	   d.addLast(""1one"");
//	   d.addLast(""1two"");
//	   d.addLast(""1three"");
//	   d.addLast(""1four"");
	   
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();

//	   d.removeLast();
//	   d.removeLast();


//	   for (String s : d) {
//           System.out.println(s); // prints only ""four""
//       }
   }
}
@0b0f022603ce7650efbee50abfb8f829@"
"b03611011","7","0.78","102608","@1add2f050f1fd23b4d898c103e19f6fb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
                first.previous=null;
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
                last.next=null;
        N--;
        if(N==0){
        first=null;last=null;
        }
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@1add2f050f1fd23b4d898c103e19f6fb@"
"r04631046","5","1.01","101472","@15a88f8e44f8970464891a5fa22a3aa3@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[])(new Object[1000]);
        olddata = (Item[])(new Object[1000]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?
    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
//            olddata = (Item[]) (new Object[N]);
            olddata = data;
//            data = (Item[]) (new Object[N + 1]);
            data[0] = item;
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
//            olddata = (Item[]) (new Object[N]);
//            olddata = data;
//            data = (Item[]) (new Object[N + 1]);
            data[N] = item;
//            for (int i = 0; i < N; i++) {
//                data[i] = olddata[i];
//            }
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N = 0;
            return item;
        } else {
            Item item = data[0];
//            olddata = (Item[]) (new Object[N]);
            olddata = data;
//            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N = 0;
            return item;
        } else {
            Item item = data[N - 1];
//            olddata = (Item[]) (new Object[N]);
//            olddata = data;
//            data = (Item[]) (new Object[N - 1]);
//            for (int i = 0; i < N - 1; i++) {
//                data[i] = olddata[i];
//            }
            data[N-1]=null;
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current[0] != null;
        }

        public void remove() {

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            if (N == 1) {
                Item item = current[0];
                data[0] = null;
                N = 0;
                return item;
            } else {
                Item item = current[0];
//                saved = (Item[]) (new Object[N]);
                saved = current;
//                current = (Item[]) (new Object[N - 1]);
                for (int i = 0; i < N - 1; i++) {
                    current[i] = saved[i + 1];
                }
                N--;
                return item;
            }
        }
    }

    public static void main(String[] args) {
        Deque dq = new Deque();

        dq.addFirst(5);

        dq.addFirst(2);

        System.out.print(dq.iterator().next() + ""\n"");

    }

}

@15a88f8e44f8970464891a5fa22a3aa3@"
"r04631046","5","1.08","102320","@8f3827050be25583f94e10a432218f64@
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;              // size of the Deque
    private Item[] data;        // new datas of the Deque
    private Item[] olddata;     // for saving datas
//    construct an empty deque

    public Deque() {
        data = (Item[])(new Object[100]);
        olddata = (Item[])(new Object[100]);
        data[0] = null;
        N = 0;
    }
//    is the deque empty?
    public boolean isEmpty() {
        return data[0] == null;
    }
//    return the number of items on the deque

    public int size() {
        return N;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
//            olddata = (Item[]) (new Object[N]);
            olddata = data;
//            data = (Item[]) (new Object[N + 1]);
            data[0] = item;
            for (int i = 0; i < N; i++) {
                data[i + 1] = olddata[i];
            }
            N++;
        }

    }

    public void addLast(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
        if (N == 0) {
            data[0] = item;
            N++;
        } else {
//            olddata = (Item[]) (new Object[N]);
//            olddata = data;
//            data = (Item[]) (new Object[N + 1]);
            data[N] = item;
//            for (int i = 0; i < N; i++) {
//                data[i] = olddata[i];
//            }
            N++;
        }

    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N = 0;
            return item;
        } else {
            Item item = data[0];
//            olddata = (Item[]) (new Object[N]);
            olddata = data;
//            data = (Item[]) (new Object[N - 1]);
            for (int i = 0; i < N - 1; i++) {
                data[i] = olddata[i + 1];
            }
            N--;
            return item;
        }
    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        if (N == 1) {
            Item item = data[0];
            data[0] = null;
            N = 0;
            return item;
        } else {
            Item item = data[N - 1];
//            olddata = (Item[]) (new Object[N]);
//            olddata = data;
//            data = (Item[]) (new Object[N - 1]);
//            for (int i = 0; i < N - 1; i++) {
//                data[i] = olddata[i];
//            }
            data[N-1]=null;
            N--;
            return item;
        }

    }

    public Iterator iterator() {
        return new ListIterator<Item>(data);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Item[] current;
        private Item[] saved;
        private int N;

        public ListIterator(Item[] data) {
            current = data;
            N = data.length;
        }

        public boolean hasNext() {
            return current[0] != null;
        }

        public void remove() {

            throw new UnsupportedOperationException();

        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            if (N == 1) {
                Item item = current[0];
                data[0] = null;
                N = 0;
                return item;
            } else {
                Item item = current[0];
//                saved = (Item[]) (new Object[N]);
                saved = current;
//                current = (Item[]) (new Object[N - 1]);
                for (int i = 0; i < N - 1; i++) {
                    current[i] = saved[i + 1];
                }
                N--;
                return item;
            }
        }
    }

    public static void main(String[] args) {
        Deque dq = new Deque();

        dq.addFirst(5);

        dq.addFirst(2);

        System.out.print(dq.iterator().next() + ""\n"");

    }

}

@8f3827050be25583f94e10a432218f64@"
"b03611011","8","1.4","180704","@4afce71f915969d23b5a4c748860357d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        N--;
        if(N==0){
        first=null;last=null;
        }
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@4afce71f915969d23b5a4c748860357d@"
"b02611002","1","0.69","102416","@8831f93f64253eabe9820670591e3a33@import javax.xml.soap.Node;
import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private int n, index;
    private Node<Item> first;
    private Node<Item> last;
    private Node<Item> current=first;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    public Iterator<Item> iterator(){
        return new DequeIterator();
    }



    private class DequeIterator implements Iterator<Item>{      //DequeIterator實作Iterator<>
                                                                // ，故需包含hesNext()及next()
        public boolean hasNext() {
            return current!=null;
        }

        public Item next() {
            if (n<=0) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }


    public static void main(String[] args) throws Exception {

//        Deque DequeTest = new Deque();
//        System.out.println(DequeTest.iterator());
//        Iterator it = DequeTest.iterator();
//
//        for (Object o : DequeTest) System.out.println(o);

        // read file from args[0] in Java 7 style
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//
//            // read a line and split by ','
//            String[] data = br.readLine().split("","");
//
//            // store the first integer in variable stringCount (number of announced strings)
//            int stringCount = Integer.parseInt(data[0]);
//
//            // store the second integer in variable num (dimension of matrix: num * num)
//            int num = Integer.parseInt(data[1]);
//
//            // initilization of a String array in Java
//            String[] announce = new String[stringCount];
//            String[][] matrix = new String[num][num];
//
//            // printf in Java (you should comment out or delete this in your final submission)
//            System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);

    }
}

@8831f93f64253eabe9820670591e3a33@"
"r04631046","9","1.41","178320","@9942940b3eb395d6517af8fbb0fcce23@import java.util.Iterator;
import java.util.NoSuchElementException;

class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
}
@9942940b3eb395d6517af8fbb0fcce23@"
"r04631027","0","0","0","@f357201d3b71549652af5996ca7f09ae@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;
    public Deque() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

   public boolean isEmpty()  
   {return first==null; }// is the deque empty?

   public int size()                        // return the number of items on the deque
   {return N;}
   
   public void addFirst(Item item)          // add the item to the front
   {Node oldfirst;
        oldfirst = first;
        first = new Node();
        first.item = (String) item;
        first.next = oldfirst;
        if (isEmpty()) first = last;
        else oldfirst.next = last;
        N++;
       }
   public void addLast(Item item)           // add the item to the end
   {   Node oldlast;
        oldlast = last;
        last = new Node();
        last.item = (String) item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
}
   public String removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        String item = first.item;
        first = first.next;
        N--;
      //  if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   public String removeLast()                 // remove and return the item from the end
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node a;
        String item = last.item;
        
        a=last;
        last.next = a;
        N--;
       // if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
   public Iterator iterator()
   {
        return null;
   
   }
   
    public static void main(String[] args) {
        // TODO code application logic here
    }

        

       

      
        public void remove() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    
}
class Node{
String item;
Node next;

}
@f357201d3b71549652af5996ca7f09ae@"
"b03611011","7","0.84","102448","@429a0cf91a3250b14cc1caa0f70fc57c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        first.previous=null;
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        last = last.previous;            // delete first node
        last.next=null;
        N--;
        if(N==0){
        first=null;last=null;
        }
        return item;                   // return the saved item
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@429a0cf91a3250b14cc1caa0f70fc57c@"
"r04631027","0","0","0","@14b968668d503421f6a1c35d0cb1a0e2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package deque;

import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque implements Iterable{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;
    public Deque() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

   public boolean isEmpty()  
   {return first==null; }// is the deque empty?

   public int size()                        // return the number of items on the deque
   {return N;}
   
   public void addFirst(String item)          // add the item to the front
   {Node oldfirst;
        oldfirst = first;
        first = new Node();
        first.item = (String) item;
        first.next = oldfirst;
        if (isEmpty()) first = last;
        else oldfirst.next = last;
        N++;
       }
   public void addLast(String item)           // add the item to the end
   {   Node oldlast;
        oldlast = last;
        last = new Node();
        last.item = (String) item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
}
   public String removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        String item = first.item;
        first = first.next;
        N--;
      //  if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   public String removeLast()                 // remove and return the item from the end
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node a;
        String item = last.item;
        
        a=last;
        last.next = a;
        N--;
       // if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
   public Iterator iterator()
   {
        return null;
   
   }
   
    public static void main(String[] args) {
        // TODO code application logic here
    }

        

       

      
        public void remove() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    
}
class Node{
String item;
Node next;

}
@14b968668d503421f6a1c35d0cb1a0e2@"
"r04631027","0","0.84","102448","@14b968668d503421f6a1c35d0cb1a0e2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package deque;

import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque implements Iterable{
    private int N;               // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;
    public Deque() {
        first = null;
        last = null;
        N = 0;
    }// construct an empty deque

   public boolean isEmpty()  
   {return first==null; }// is the deque empty?

   public int size()                        // return the number of items on the deque
   {return N;}
   
   public void addFirst(String item)          // add the item to the front
   {Node oldfirst;
        oldfirst = first;
        first = new Node();
        first.item = (String) item;
        first.next = oldfirst;
        if (isEmpty()) first = last;
        else oldfirst.next = last;
        N++;
       }
   public void addLast(String item)           // add the item to the end
   {   Node oldlast;
        oldlast = last;
        last = new Node();
        last.item = (String) item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
}
   public String removeFirst()                // remove and return the item from the front
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        String item = first.item;
        first = first.next;
        N--;
      //  if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   public String removeLast()                 // remove and return the item from the end
   {if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node a;
        String item = last.item;
        
        a=last;
        last.next = a;
        N--;
       // if (isEmpty()) last = null;   // to avoid loitering
        return item;}
   
   public Iterator iterator()
   {
        return null;
   
   }
   
    public static void main(String[] args) {
        // TODO code application logic here
    }

        

       

      
        public void remove() {
            throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
        }
    
}
class Node{
String item;
Node next;

}
@14b968668d503421f6a1c35d0cb1a0e2@"
"b03611011","10","0.14","171024","@c3e95560152200831f7fdb0075e85b82@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first;     // top of stack
    private Node<Item> last;
    private int N,M;                // size of the stack

    // helper linked list class
    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() // construct an empty deque
    {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) // add the item to the front
    {
        if(item==null)throw new NullPointerException();
        Deque.Node<Item> oldfirst = first;
        first = new Deque.Node<Item>();
        first.item = item;
        first.next = oldfirst;
        
        if(N==0){last=first;}
            else{
                oldfirst.previous = last;
            }
        N++;
        
    }

    public void addLast(Item item) // add the item to the end
    {
        if(item==null)throw new NullPointerException();
            Deque.Node<Item> oldlast = new Deque.Node<Item>();
            oldlast = last;
            last = new Deque.Node<Item>();
            last.item = item;

            if(N==0){first=last;}
            else{
                oldlast.next = last;
            }
            last.previous=oldlast;
        N++;
    }

    public Item removeFirst() // remove and return the item from the front
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
                N--;
        if (N == 0) {
            first = null;
            last = null;
        }else{
        first = first.next;            // delete first node
        first.previous=null;
        }
        return item;                   // return the saved item
    }

    public Item removeLast() // remove and return the item from the end
    {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;        // save item to return
        N--;
        if (N == 0) {
            first = null;
            last = null;
        }else{
        last = last.previous;            // delete first node
        last.next=null;
        }
        return item;                   // return the saved item
        
    }
    
    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            String[] cha = fund.split("" "");
            Deque d = new Deque();
            d.addFirst(cha[0]);
            d.addFirst(cha[1]);
            d.addFirst(cha[2]);
            d.addFirst(cha[3]);            
            d.addLast(cha[4]);
            d.addLast(cha[5]);
            d.addLast(cha[6]);
            d.removeLast();
            d.removeLast();
            d.removeLast();

            d.removeFirst();
            Iterator e = d.iterator();
            d.M=d.N;
            while (e.hasNext()&&d.M>0) {
                d.M--;
                System.out.println(e.next());
            }
        }
    }
}
@c3e95560152200831f7fdb0075e85b82@"
"r03849033","0","0.36","102480","@29fdddb2952afc229dac1aebe2295412@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
     before.next=after;
     after.previous=before;
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size>0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     size++;
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     before.next=oldbefore;
     if(oldbefore==null){
            after = before;
     } else {   oldbefore.previous=before; }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     size++;
     Node oldafter = after;
     after = new Node();
     after.item=item;
     after.previous=oldafter;
     if(oldafter==null){
            before = after;
     } else {   oldafter.next=before; }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Node first= before.next;//gets the first node.
     Node second=first.next;//gets the second element in the list
     second.previous=before;//sets second's previous to before
     before.next=second;//sets before's next to second
     return first.item;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Node last = after.previous;//sets last node
     Node second2Last= after.previous.previous;//sets second2Last
     second2Last.next=after;//sets second2Last's next to after
     after.previous=second2Last;//sets after's previous to second2last
     return last.item;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=after;

     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {
  // TODO Auto-generated method stub
  Deque d = new Deque();

  d.addFirst(1);
  d.addFirst(2);

  Iterator i = d.iterator();
  System.out.println(i.hasNext());
  while(i.hasNext()){
   System.out.println(i.next());
  }


 }

}
@29fdddb2952afc229dac1aebe2295412@"
"r04631013","8","1.39","176704","@ee4b98db73212b71a9519dc0d140ad8f@
import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chenchen
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     *
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;
    }

    public void addFirst(Item item) {      // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) {
            last = first;
        }
        N++;
    }

    public void addLast(Item item) {         // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.previous;
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {  // unit testing
        Deque<String> d = new Deque<String>();
        d.addLast(""3"");
        d.addLast(""2"");
        d.addLast(""1"");
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.removeFirst();
        d.addLast(""5"");

        System.out.println(""("" + d.removeLast() + "" is the answer"");

}
}
@ee4b98db73212b71a9519dc0d140ad8f@"
"r04631027","0","0.14","171024","@19dee5d2105576c062c39d21f4e82656@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@19dee5d2105576c062c39d21f4e82656@"
"r04631027","4","1.43","183680","@593f4b60380f0397b65b985ad902d14b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
public void addLast(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@593f4b60380f0397b65b985ad902d14b@"
"r02b48003","9","1.38","176624","@69c97ac50548036163fb740456128d5a@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author clint
 */
public class Deque<Item> implements Iterable<Item> {
    private Node first; // pointer at the front
    private Node last;  // pointer at the back
    private int size;   // number of elements
    
    private class Node {
        /* the basic building block in the class */
        Node prev;
        Item item;
        Node next;
    } // end inner class Node
    
    public Deque() {
        /* construct an empty deque */
        first = null;
        last = null;
        size = 0;
    } // end constructor
    
    public boolean isEmpty() {
        /* is the deque empty? */
        return first == null;
    } // end func isEmpty
    
    public int size() {
        /* return the number of items on the deque */
        return size;
    } // end func size
    
    public void addFirst(Item item) {
        /* add the item to the front */
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            // if empty: set a new node
            first = new Node(); // create a new node
            first.prev = null;  // set previous point to null
            first.item = item;  // assign item
            first.next = null;  // set next point to null
            last = first;       // update reference last
        } else {
            // if not empty
            Node oldFirst = first; 
            first = new Node();    // create a new node
            first.prev = null;     // set previous point to null
            first.item = item;     // assign item
            first.next = oldFirst; // set next point to original first node
            oldFirst.prev = first; // original first node point back to new first node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addFirst
    
    public void addLast(Item item) {
        /* add the item to the end */
        // Throw a java.lang.NullPointerException if the client attempts to add a null item
        if (item == null) {
            throw new NullPointerException();
        }
        
        if (last == null) {
            // if empty: set a new node
            last = new Node();  // create a new node
            last.prev = null;   // set previous point to null
            last.item = item;   // assign item
            last.next = null;   // set next point to null
            first = last;       // update reference first
        } else {
            // if empty: set a new node
            Node oldLast = last;
            last = new Node();    // create a new node
            last.prev = oldLast;  // set previous point to original last node
            last.item = item;     // assign item
            last.next = null;     // set next point to null
            oldLast.next = last;  // original last node point to new last node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addLast
    
    public Item removeFirst() {
        /* remove and return the item from the front */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the first item and move the first pointer to the next node
        Item item = first.item;             
        first = first.next;
        
        // if the next node is not null, set previous to null
        if (first != null) { first.prev = null; } 
        
        // decrement size and return
        if (size > 0) { size -= 1; }
        return item;
    } // end func removeFirst
    
    public Item removeLast() {
        /* remove and return the item from the end */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the last item and move the first pointer to the previous node
        Item item = last.item;
        last = last.prev;
        if (last != null) { last.next = null; }
        
        // decrement size
        if (size > 0) { size -= 1; }
        return item;
    }  // end func removeLast
    
    @Override
    public Iterator<Item> iterator() {
        /* return an iterator over items in order from front to end */
        return new DequeIterator();
    } // end func iterator
    
    private class DequeIterator implements Iterator<Item> {
        // initiation
        private Node current = first;
        
        @Override
        public boolean hasNext() {
            return current != null;
        } // end func hasNext
        
        @Override
        // throw a java.util.NoSuchElementException 
        // if the client calls the next() method in the iterator and
        // there are no more items to return.
        public Item next() {
            if (current == null) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current   = current.next;
            return item;
        } // end func next
        
        @Override
        // throw UnsupportedOperationException 
        // if the client calls the remove() method in the iterator
        public void remove() {
             throw new UnsupportedOperationException();
        }
    } // end inner class DequeIterator
    
    @Override
    public boolean equals(Object obj) {
        Deque<Item> that = (Deque) obj;
        Item[] arr01 = (Item[]) new Object[size];
        Item[] arr02 = (Item[]) new Object[size];
        int idx;
        
        idx = 0;
        for (Item item : this) {
            arr01[idx] = item;
            idx += 1;        
        } // end loop for
        
        idx = 0;
        for (Item item : that) {
            arr02[idx] = item;
            idx += 1;
        } // end loop for
        
        for (idx = 0; idx < size; idx += 1){
            if (arr01[idx] != arr02[idx]) { return false; }
        } // end loop for
        
        return true;
    } // end func equals
    
    public static void main(String[] args) {
        Deque<Integer> dequeInt01 = new Deque<>();
        Deque<Integer> dequeInt02 = new Deque<>();
        dequeInt01.addFirst(0);
        dequeInt01.addFirst(1);
        dequeInt02.addFirst(0);
        dequeInt02.addFirst(1);
        System.out.println(dequeInt01.equals(dequeInt02));
        //System.out.println(dequeInt.removeFirst());
        //System.out.println(dequeInt.removeFirst());
        //for (Integer num : dequeInt) {
        //    System.out.println(num);
        //}
    }
} // end class 

@69c97ac50548036163fb740456128d5a@"
"r04631027","5","0.71","102528","@d081907d189e5fcae5218599538f523f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        
        first.next = oldfirst;
        //if (isEmpty()) first = last;
       // else           oldlast.next = last;
        N++;
    }
public void addLast(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@d081907d189e5fcae5218599538f523f@"
"r04945009","0","1.43","183680","@429895381f09b5d49af97591ac2df7a6@import java.util.Iterator;
import java.util.NoSuchElementException;


class Deque0<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left=null, right=null;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque0() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    if (isEmpty()) tail = null;
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    if (isEmpty()) head = null;
    checkInvariants();
    return prevTail.item;
  }
    public static void main(String[] args) {
        Deque0 a = new Deque0();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();

    }
}
@429895381f09b5d49af97591ac2df7a6@"
"r04945009","0","1.43","183680","@429895381f09b5d49af97591ac2df7a6@import java.util.Iterator;
import java.util.NoSuchElementException;


class Deque0<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left=null, right=null;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque0() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    if (isEmpty()) tail = null;
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    if (isEmpty()) head = null;
    checkInvariants();
    return prevTail.item;
  }
    public static void main(String[] args) {
        Deque0 a = new Deque0();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();

    }
}
@429895381f09b5d49af97591ac2df7a6@"
"r02b48003","10","0.139","184672","@60e60c032f7e432d8ad9ba3064e0243b@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *
 * @author clint
 */
public class Deque<Item> implements Iterable<Item> {
    private Node first; // pointer at the front
    private Node last;  // pointer at the back
    private int size;   // number of elements
    
    private class Node {
        /* the basic building block in the class */
        Node prev;
        Item item;
        Node next;
    } // end inner class Node
    
    public Deque() {
        /* construct an empty deque */
        first = null;
        last = null;
        size = 0;
    } // end constructor
    
    public boolean isEmpty() {
        /* is the deque empty? */
        return first == null && last == null;
    } // end func isEmpty
    
    public int size() {
        /* return the number of items on the deque */
        return size;
    } // end func size
    
    public void addFirst(Item item) {
        /* add the item to the front */
        if (item == null) {
            throw new NullPointerException();
        }
        if (first == null) {
            // if empty: set a new node
            first = new Node(); // create a new node
            first.prev = null;  // set previous point to null
            first.item = item;  // assign item
            first.next = null;  // set next point to null
            last = first;       // update reference last
        } else {
            // if not empty
            Node oldFirst = first; 
            first = new Node();    // create a new node
            first.prev = null;     // set previous point to null
            first.item = item;     // assign item
            first.next = oldFirst; // set next point to original first node
            oldFirst.prev = first; // original first node point back to new first node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addFirst
    
    public void addLast(Item item) {
        /* add the item to the end */
        // Throw a java.lang.NullPointerException if the client attempts to add a null item
        if (item == null) {
            throw new NullPointerException();
        }
        
        if (last == null) {
            // if empty: set a new node
            last = new Node();  // create a new node
            last.prev = null;   // set previous point to null
            last.item = item;   // assign item
            last.next = null;   // set next point to null
            first = last;       // update reference first
        } else {
            // if empty: set a new node
            Node oldLast = last;
            last = new Node();    // create a new node
            last.prev = oldLast;  // set previous point to original last node
            last.item = item;     // assign item
            last.next = null;     // set next point to null
            oldLast.next = last;  // original last node point to new last node
        } // end if-else
        
        // increment size
        size += 1;
    } // end func addLast
    
    public Item removeFirst() {
        /* remove and return the item from the front */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the first item and move the first pointer to the next node
        Item item = first.item;             
        first = first.next;
        
        // if the next node is not null, set previous to null
        if (first == null) {
            last = null;
        } else {
            first.prev = null; 
        } // end if-else
        
        // decrement size and return
        if (size > 0) { size -= 1; }
        return item;
    } // end func removeFirst
    
    public Item removeLast() {
        /* remove and return the item from the end */
        // throw a java.util.NoSuchElementException 
        // if the client attempts to remove an item from an empty deque
        if (isEmpty()) { 
            throw new NoSuchElementException();
        } 
        
        // if not empty, 
        // get the last item and move the first pointer to the previous node
        Item item = last.item;
        last = last.prev;
        if (last == null) {
            first = null;
        } else {
            last.next = null; 
        } // end if-else
        
        // decrement size
        if (size > 0) { size -= 1; }
        return item;
    }  // end func removeLast
    
    @Override
    public Iterator<Item> iterator() {
        /* return an iterator over items in order from front to end */
        return new DequeIterator();
    } // end func iterator
    
    private class DequeIterator implements Iterator<Item> {
        // initiation
        private Node current = first;
        
        @Override
        public boolean hasNext() {
            return current != null;
        } // end func hasNext
        
        @Override
        // throw a java.util.NoSuchElementException 
        // if the client calls the next() method in the iterator and
        // there are no more items to return.
        public Item next() {
            if (current == null) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current   = current.next;
            return item;
        } // end func next
        
        @Override
        // throw UnsupportedOperationException 
        // if the client calls the remove() method in the iterator
        public void remove() {
             throw new UnsupportedOperationException();
        }
    } // end inner class DequeIterator
    
    @Override
    public boolean equals(Object obj) {
        Deque<Item> that = (Deque) obj;
        Item[] arr01 = (Item[]) new Object[size];
        Item[] arr02 = (Item[]) new Object[size];
        int idx;
        
        idx = 0;
        for (Item item : this) {
            arr01[idx] = item;
            idx += 1;        
        } // end loop for
        
        idx = 0;
        for (Item item : that) {
            arr02[idx] = item;
            idx += 1;
        } // end loop for
        
        for (idx = 0; idx < size; idx += 1){
            if (arr01[idx] != arr02[idx]) { return false; }
        } // end loop for
        
        return true;
    } // end func equals
    
    public static void main(String[] args) {
        Deque<Integer> dequeInt01 = new Deque<>();
        Deque<Integer> dequeInt02 = new Deque<>();
        dequeInt01.addFirst(0);
        dequeInt01.addFirst(1);
        dequeInt02.addFirst(0);
        dequeInt02.addFirst(1);
        System.out.println(dequeInt01.equals(dequeInt02));
        dequeInt01.removeFirst();
        dequeInt01.removeFirst();
        System.out.println(dequeInt01.isEmpty());
        //System.out.println(dequeInt.removeFirst());
        //System.out.println(dequeInt.removeFirst());
        //for (Integer num : dequeInt) {
        //    System.out.println(num);
        //}
    }
} // end class 

@60e60c032f7e432d8ad9ba3064e0243b@"
"r04631027","5","0.72","102464","@a592c9624f72221a08bea16233ae6355@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        
        
        if (isEmpty()) first = last;
        else           first.next = oldfirst;
        N++;
    }
public void addLast(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@a592c9624f72221a08bea16233ae6355@"
"r04945009","0","0.71","102528","@feac503d536456449c84c5519a7d666d@import java.util.Iterator;
import java.util.NoSuchElementException;


class Deque0<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left=null, right=null;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque0() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
    public static void main(String[] args) {
        Deque0 a = new Deque0();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();

    }
}
@feac503d536456449c84c5519a7d666d@"
"r04631013","8","1.35","177920","@c93d55521449134fc71b61170a0501f5@
import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chenchen
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     *
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;
    }

    public void addFirst(Item item) {      // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if (isEmpty()) {
            last = first;
        }
        N++;
    }

    public void addLast(Item item) {         // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;            // delete first node
//        first.previous = null;
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
        last = last.previous;
//        last.next = null;
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {  // unit testing
        Deque<String> d = new Deque<String>();
        d.addLast(""3"");
        d.addLast(""2"");
        d.addLast(""1"");
//        d.addFirst(""0"");
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
      
        d.addFirst(""5"");

        System.out.println(""("" + d.removeFirst() + "" is the answer"");

}
}
@c93d55521449134fc71b61170a0501f5@"
"r03522826","8","1.41","184496","@48bf853f235d15fad8972cae29828f85@



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item.equals(""null"")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item.equals(""null"")) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addLast(data[0]);
            s.addLast(data[1]);
            s.addLast(data[2]);
            s.addLast(data[3]);
            s.addLast(data[4]);
            s.addLast(data[5]);
            s.addLast(data[6]);
            s.addLast(data[7]);
            s.addLast(data[8]);
//            s.addLast(data[9]);
//            s.addLast(data[10]);
//            s.addLast(data[11]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeLast());
            
            
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}

@48bf853f235d15fad8972cae29828f85@"
"r03849033","0","0.24","99056","@248826ad5cca227dd3d923848c82c42f@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size>0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     size++;
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     before.next=oldbefore;
     if(oldbefore==null){
            after = before;
     } else {   oldbefore.previous=before; }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     size++;
     Node oldafter = after;
     after = new Node();
     after.item=item;
     after.previous=oldafter;
     if(oldafter==null){
            before = after;
     } else {   oldafter.next=before; }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Item it=before.item;
     if(before.next==null){after=null;}
     else{
         before.next.previous=null;
         before=before.next;
     }
     return it ;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Item it=after.item;
     if(before.next==null){before=null;}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     return it ;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=after;

     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {
  // TODO Auto-generated method stub
  Deque d = new Deque();

  d.addFirst(1);
  d.addFirst(2);

  Iterator i = d.iterator();
  System.out.println(i.hasNext());
  while(i.hasNext()){
   System.out.println(i.next());
  }


 }

}
@248826ad5cca227dd3d923848c82c42f@"
"r04945009","10","0.139","173136","@2684762e5e3f1af0efbeb163b5bbbac8@import java.util.Iterator;
import java.util.NoSuchElementException;


class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left=null, right=null;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    if (isEmpty()) tail = null;
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    if (isEmpty()) head = null;
    checkInvariants();
    return prevTail.item;
  }
    public static void main(String[] args) {
        Deque a = new Deque();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();
        a.addFirst(1);
        a.addFirst(2);
        a.removeLast();
        a.removeLast();

    }
}
@2684762e5e3f1af0efbeb163b5bbbac8@"
"r04631027","5","0.72","102560","@512f838510c93341572846a45781f2a6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else           first.next = oldfirst;
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@512f838510c93341572846a45781f2a6@"
"r04631027","4","0.48","99232","@fd0c2e2779b0fba098792a30c58b63f2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else           first.next = oldfirst;
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last = a.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@fd0c2e2779b0fba098792a30c58b63f2@"
"r04631027","4","0.47","102464","@b6a7d2c3a56ec9dbbc89691ef5722783@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else           first.next = oldfirst;
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last = a.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@b6a7d2c3a56ec9dbbc89691ef5722783@"
"r04631027","4","0.47","98528","@f9e806ef683f36a2024401e1116231df@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else           first.next = oldfirst;
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last.next = a;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@f9e806ef683f36a2024401e1116231df@"
"d04631001","0","0.48","99232","@5839ad7aa9e6f05811f061b54cd7ca90@import java.io.BufferedReader;
import java.io.FileReader;


public class Deque<Item> implements Iterable{
    
    private Node<Item> first;
    private Node<Item> last;
    private int N;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty()
    { return first == null; }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }       
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
         
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }        
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}
@5839ad7aa9e6f05811f061b54cd7ca90@"
"d04631001","0","0.47","102464","@427358c20d4a5eff4d209f1f3d8d1798@
package deque;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;
public class Deque<Item> implements Iterable{    
    private Node<Item> first;
    private Node<Item> last;
    private int N;   
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }    
    public boolean isEmpty()
    { return first == null; }    
    public int size(){
        return N;
    }    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }           
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
            
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}

@427358c20d4a5eff4d209f1f3d8d1798@"
"r04631027","0","0.58","102416","@38f2b300af209e521f7cb01f9e396215@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      first.next = oldfirst;
        //if (isEmpty()) first = last;
        //else           
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        //last.next = null;
        last.next = last;
        //if (isEmpty()) first = last;
       // else           
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last.next = a;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@38f2b300af209e521f7cb01f9e396215@"
"r04631027","4","0.5","102368","@82215985493bf9ca1c9c30e27c878bb9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      first.next = oldfirst;
        //if (isEmpty()) first = last;
        //else           
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last.next = a;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@82215985493bf9ca1c9c30e27c878bb9@"
"r03522809","7","1.37","179792","@d7eef3c6b1c55a5d53dac4932f58f869@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null || last == null;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,F,G,H,-,-,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addLast(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        
        j=0;
        
//        System.out.print(iter.next());
        
    }
}
    
    

@d7eef3c6b1c55a5d53dac4932f58f869@"
"r04631027","4","0.47","101648","@fd006b9cfcdf8e6596a69465ba901a20@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else first.next = oldfirst;  
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last.next = a;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@fd006b9cfcdf8e6596a69465ba901a20@"
"b02611002","7","0.82","102432","@95dd2e1bece338ee4195512b8345e74b@import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private int n, index;
    private Node<Item> first;
    private Node<Item> last;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    @Override
    public Iterator<Item> iterator(){
        return new DequeIterator<Item>(first);
    }


    private class DequeIterator<Item> implements Iterator<Item> {      //DequeIterator實作Iterator<>
                                                                // ，故需包含hesNext()及next()
        private Node<Item> current;

        public DequeIterator(Node<Item> first){current=first;}

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }


    public static void main(String[] args) throws Exception {

//        Deque DequeTest = new Deque();
//        System.out.println(DequeTest.iterator());
//        Iterator it = DequeTest.iterator();
//
//        for (Object o : DequeTest) System.out.println(o);

        // read file from args[0] in Java 7 style
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//
//            // read a line and split by ','
//            String[] data = br.readLine().split("","");
//
//            // store the first integer in variable stringCount (number of announced strings)
//            int stringCount = Integer.parseInt(data[0]);
//
//            // store the second integer in variable num (dimension of matrix: num * num)
//            int num = Integer.parseInt(data[1]);
//
//            // initilization of a String array in Java
//            String[] announce = new String[stringCount];
//            String[][] matrix = new String[num][num];
//
//            // printf in Java (you should comment out or delete this in your final submission)
//            System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);

    }
}

@95dd2e1bece338ee4195512b8345e74b@"
"d04631001","0","1.37","179792","@4d118a99c1cfda05d0ff88bde092b75f@
public class Deque<Item> implements Iterable{
    
    private Node<Item> first;
    private Node<Item> last;
    private int N;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty()
    { return first == null; }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }       
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
         
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }        
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}

@4d118a99c1cfda05d0ff88bde092b75f@"
"r03522809","7","1.45","182000","@7c63cbd420f8f445dae83df730f93715@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        
        return N==0;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,F,G,H,-,-,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addLast(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        j=0;
        
//        System.out.print(iter.next());
        
    }
}
@7c63cbd420f8f445dae83df730f93715@"
"r04631027","0","0.59","102480","@e8e27c270106692c6d8a0273f45b2fc3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else first.next = oldfirst;  
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldfirst = last;
        last = new Node<Item>();
        last.item = item;
        last.next = oldfirst;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;        // save item to return
        last = last.next;            // delete first node
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@e8e27c270106692c6d8a0273f45b2fc3@"
"b02611002","7","0.84","102416","@c479fc177827ed143001fe309ee030a1@import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    private int n, index;
    private Node<Item> first;
    private Node<Item> last;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==1) {first = last;}
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==1) {first = last;}
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    @Override
    public Iterator<Item> iterator(){
        return new DequeIterator<Item>(first);
    }


    private class DequeIterator<Item> implements Iterator<Item> {      //DequeIterator實作Iterator<>
                                                                       // ，故需包含hesNext()及next()
        private Node<Item> current;

        public DequeIterator(Node<Item> first){current=first;}

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
    }
}

@c479fc177827ed143001fe309ee030a1@"
"r03849033","0","0.82","102352","@09f55cdf95c512116e1beb4e3cdc76a7@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size>0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     size++;
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     before.next=oldbefore;
     if(size==0){
            after = before;
     } else {   oldbefore.previous=before; }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     size++;
     Node oldafter = after;
     after = new Node();
     after.item=item;
     after.previous=oldafter;
     if(size==0){
            before = after;
     } else {   oldafter.next=after; }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Item it=before.item;
     if(before.next==null){after=null;}
     else{
         before.next.previous=null;
         before=before.next;
     }
     return it ;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Item it=after.item;
     if(before.next==null){before=null;}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     return it ;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=null;

     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@09f55cdf95c512116e1beb4e3cdc76a7@"
"r04631013","10","0.142","169136","@403463d1495821391828b5f222caf48a@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chenchen
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     *
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;
    }

    public void addFirst(Item item) {      // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if (isEmpty()) {
            last = first;
        }
        N++;
    }

    public void addLast(Item item) {         // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        N--;
          
         if (isEmpty()) {
            last = null;
            first = null;
        }
         else{
             first = first.next;     
first.previous = null;
         }
     
     
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
       
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        else{
        last = last.previous;
        last.next = null;
        }
        
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {  // unit testing
        Deque<String> d = new Deque<String>();
        d.addLast(""3"");
        d.addLast(""2"");
        d.addLast(""1"");
//        d.addFirst(""0"");
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
      
        d.addFirst(""5"");

        System.out.println(""("" + d.removeFirst() + "" is the answer"");

}
}
@403463d1495821391828b5f222caf48a@"
"d04631001","0","0.84","102416","@b9a2699fb4de41047ebb7475b61f9985@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable{
    
    private Node<Item> first;
    private Node<Item> last;
    private int N;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty()
    { return first == null; }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }       
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
         
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
    private class ListIterator<Item> implements Iterator<Item> {
        private Node current = first;
        
        public boolean hasNext() {
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        
    }        
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}
@b9a2699fb4de41047ebb7475b61f9985@"
"r04631013","10","0.141","181552","@403463d1495821391828b5f222caf48a@import java.util.Iterator;
import java.util.NoSuchElementException;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chenchen
 * @param <Item>
 */
public class Deque<Item> implements Iterable<Item> {

    private Node<Item> first; // beginning of queue
    private Node<Item> last; // end of queue
    private int N; // number of elements on queue
// helper linked list class

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     *
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return N == 0;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return N;
    }

    public void addFirst(Item item) {      // add the item to the front
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Deque.Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if (isEmpty()) {
            last = first;
        }
        N++;
    }

    public void addLast(Item item) {         // add the item to the end
        if (item == null) {
            throw new java.lang.NullPointerException(""Deque underflow"");
        }
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.previous = oldlast;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public Item removeFirst() {               // remove and return the item from the front
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        N--;
          
         if (isEmpty()) {
            last = null;
            first = null;
        }
         else{
             first = first.next;     
first.previous = null;
         }
     
     
        return item;
    }

    public Item removeLast() {                // remove and return the item from the end
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = last.item;
       
        N--;
        if (isEmpty()) {
            last = null;
            first = null;
        }
        else{
        last = last.previous;
        last.next = null;
        }
        
        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }
// an iterator, doesn't implement remove() since it's optional

    private class ListIterator<Item> implements Iterator<Item> {

        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {  // unit testing
        Deque<String> d = new Deque<String>();
        d.addLast(""3"");
        d.addLast(""2"");
        d.addLast(""1"");
//        d.addFirst(""0"");
        d.removeFirst();
        d.removeFirst();
        d.removeLast();
      
        d.addFirst(""5"");

        System.out.println(""("" + d.removeFirst() + "" is the answer"");

}
}
@403463d1495821391828b5f222caf48a@"
"d04631001","0","0.82","102352","@f7e7fe2842667b7802c57bba8bfc4e5c@import java.util.Iterator;
public class Deque<Item> implements Iterable{
    
    private Node<Item> first;
    private Node<Item> last;
    private int N;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty()
    { return first == null; }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }       
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
         
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
    private class ListIterator<Item> implements Iterator<Item> {
        private Node current = first;
        
        public boolean hasNext() {
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        
    }        
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}
@f7e7fe2842667b7802c57bba8bfc4e5c@"
"r04921115","8","1.41","178656","@26c236dccc370934c9771b9f888b3279@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque (initialize)
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return (first == null);
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       
       if (oldfirst == null) {
           first.next = null;
       }else {
           first.next = oldfirst;
           oldfirst.prev = first;        
       }
       
       if (last == null) {
           last = first;
       }
      
       N++;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       if(oldlast == null){
    	   last.prev = null;
       }else{
    	   last.prev = oldlast;
    	   oldlast.next = last;
       }
       
       last.item = item;
       last.next = null;//*
       
       if(first == null){
    	   first = last;
       }
       N++;
   }
   
// V remove front // right!!!
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   N--;
       if(isEmpty()) last = null;
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   last = last.prev;	         // delete last node
	   last.next = null;
	   if(last==null){
		   first=null;
	   }
	   if(isEmpty()) first=null;
	   N--;
       return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new DequeIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class DequeIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public DequeIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> d = new Deque<String>();
//	   d.addFirst(""one"");
//	   d.addFirst(""two"");
//	   d.addFirst(""three"");
//	   d.addFirst(""four"");
	   
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeFirst();
//	   for (String s : d) {
//           System.out.println(s); // prints only ""four""
//       }
//	   d.addLast(""1one"");
////	   d.removeLast();
//
//	   d.addLast(""1two"");
//	   d.addLast(""1three"");
//	   d.addLast(""1four"");
//	   
////	   d.removeFirst();
//
//
//	   d.removeLast();
//	   d.removeLast();
//
//	   //.removeLast();
//	   d.removeLast();
	   //d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();

//	   d.removeLast();
//	   d.removeLast();


//	   for (String s : d) {
//           System.out.println(s); // prints only ""four""
//       }
   }
}
@26c236dccc370934c9771b9f888b3279@"
"r04631027","4","0.46","102400","@fd006b9cfcdf8e6596a69465ba901a20@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author YuChing
 */
public class Deque<Item> implements Iterable<Item>{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return N;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void addFirst(Item item) {
        if(item==null) throw new NullPointerException("""");
        first.item = item;
        Node<Item> oldfirst = first;
        first = new Node<Item>();
      
        if (isEmpty()) first = last;
        else first.next = oldfirst;  
        N++;
    }
public void addLast(Item item) {
    if(item==null) throw new NullPointerException("""");
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }
    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = last.item;
        Node<Item> a= last;
        last.next = a;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the <tt>Queue</tt> data type.
     */
    public static void main(String[] args) {
       
        }
       
    }


@fd006b9cfcdf8e6596a69465ba901a20@"
"b03611038","10","0.14","176880","@7bcad4869a95f6d29f70d82bca8a04f0@import java.util.Iterator;
import java.util.NoSuchElementException;

 public class Deque<Item> implements Iterable<Item> {
     private Node<Item> first;
     private Node<Item> last;
     private int N;

   
     
     
     
private static class Node<Item>{
     private Item item;
     private Node<Item> next, left;
     
 }

public Deque(){
    first = null;
    last = null;
    N = 0;
}
 public boolean isEmpty(){
     return N == 0;
 }
 public int size(){
     return N;
 }   
 private void connect(Node a, Node b){
     a.next = b;
     b.left = a;
 }
 public void addFirst(Item item){
     if(item == null){
         throw new NullPointerException();
     }
     Node<Item> oldfirst = first;
     first = new Node<>();
     first.item = item;
     first.left = null;
     if(N == 0){
         
         last = first;
     }
     else{
         connect(first, oldfirst);
     } 
        
         N++;
 }  

  public void addLast(Item item){
       if(item == null){
         throw new NullPointerException();
     }
      Node<Item> oldlast = last;
      last = new Node<>();
      last.item = item;
      last.next = null;
      if(N == 0){
          first = last;
      }
      else {
          connect(oldlast, last);
      }
      N++;
  }     
  public Item removeFirst(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = first.item;
      first = first.next;
      if(first != null){
      first.left = null;
      }
     if(first == null){
         last = first;
     }
      N--; 
      return remove;
  }      
  public Item removeLast(){
      if(isEmpty()){
          throw new NoSuchElementException();
      }
      Item remove = last.item;
      last = last.left;
      if(last != null){
          last.next = null;
      }
      if(last == null){
          first = last;
      }
      N--;      
      return remove;
  }
    @Override
    public Iterator<Item> iterator() {
      
        
        return new ListIterator<>(first);
        
    }
    private class ListIterator<Item> implements Iterator<Item>{
         private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }
  @Override
        public boolean hasNext() {
            return current != null;
        }
  @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
  @Override
        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next; 
            return item;
     }
    }
     public static void main(String[] args){
         
     } 
 }

@7bcad4869a95f6d29f70d82bca8a04f0@"
"d04631001","0","0.46","102400","@a00dab84edf89d4a1236ef324864eec4@
import java.util.Iterator;


public class Deque<Item> implements Iterable{
    
    private Node<Item> first;
    private Node<Item> last;
    private int N;
    
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }
        
    public Deque(){ 
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty()
    { return first == null; }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item) {
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = null;
        if (isEmpty()) last = first;
        else           oldfirst.next = first;
        N++;
    }       
    
    public void addLast(Item item){
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    }

    public Item removeFirst(){
        if (isEmpty()) throw new NoSuchElementException(""Queue underflow"");
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }
    
    public Item removeLast(){
        Item item = last.item;
        last = last.next;
        N--;
        if (isEmpty()) first = null;   // to avoid loitering
        return item;
    }
         
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first) {};
    }       
    private class ListIterator<Item> implements Iterator<Item> {
        private Node current = first;
        
        public boolean hasNext() {
            return current != null;
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
        
    }        
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {//args[0]
            
        }
    }
    
}
@a00dab84edf89d4a1236ef324864eec4@"
"b02611002","6","0.72","102384","@e90ca63d1d576c1f1332098611262aff@import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    public int n, index;
    private Node<Item> first;
    private Node<Item> last;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==1) {first = null; last=null;}
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==1) {first = null; last=null;}
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    @Override
    public Iterator<Item> iterator(){
        return new DequeIterator<Item>(first);
    }


    private class DequeIterator<Item> implements Iterator<Item> {      //DequeIterator實作Iterator<>
                                                                       // ，故需包含hesNext()及next()
        private Node<Item> current;

        public DequeIterator(Node<Item> first){current=first;}

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
    }
}

@e90ca63d1d576c1f1332098611262aff@"
"r03522809","8","1.35","178080","@2d3feb58807a9e074e97cc50a87cccb2@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }

    public boolean isEmpty() {
        
        return N==0;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;first = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,F,G,H,-,-,-,I,J,K,-,-,-,C,C,C,-,-,-,-,-,-,-,-"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addFirst(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        
    }
}

@2d3feb58807a9e074e97cc50a87cccb2@"
"b02611002","7","0.82","102368","@61ce779a61fdd4a07935f676ef31cdf8@import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    public int n, index;
    private Node<Item> first;
    private Node<Item> last;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==0) {first = null; last=null;}
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==0) {first = null; last=null;}
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    @Override
    public Iterator<Item> iterator(){
        return new DequeIterator<Item>(first);
    }


    private class DequeIterator<Item> implements Iterator<Item> {      //DequeIterator實作Iterator<>
                                                                       // ，故需包含hesNext()及next()
        private Node<Item> current;

        public DequeIterator(Node<Item> first){current=first;}

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
    }
}

@61ce779a61fdd4a07935f676ef31cdf8@"
"d04631001","10","0.139","175600","@5d68ed2a4a1c07e42831def8eb8ba13a@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.front = first;
        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;

        N--;
        if (N == 1) {
            first = last;
        } 
        if (isEmpty()) {
            first = null;
            last = null;
        } else {
            last.next = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;

        N--;
        if (N == 1) {
            last = first;
        }
        if (isEmpty()) {
            last = null;
            first = null;
        } else {
            first.front = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    public static void main(String[] args) {
        try {
            Deque de = new Deque();
            String loca0 = ""a b c d e"";
            de.addLast(loca0);
            Object a = de.removeLast();
            System.out.printf(""%s"", a);
        } catch (java.lang.NullPointerException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}

@5d68ed2a4a1c07e42831def8eb8ba13a@"
"b02611002","7","0.83","102400","@58ef69f27e9ffc16b55ee5ce31bd7cec@import java.util.*;
import java.lang.NullPointerException;
import java.lang.UnsupportedOperationException;
import java.util.NoSuchElementException;


public class Deque<Item> implements Iterable {      // Deque實作Iterable，故需包含方法iterator()

    public int n, index;
    private Node<Item> first;
    private Node<Item> last;

    private class Node<Item> {
        Item item;
        Node<Item> next;
        Node<Item> prev;
    }

    // construct an empty deque
    public Deque(){
        first = null;
        last = null;
        n = 0;
    }

    // is the deque empty?
    public boolean isEmpty(){
        return first == null;
    }

    // return the number of items on the deque
    public int size(){
        return n;
    }

    // add the item to the front
    public void addFirst(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        if (!(n==0)){
            oldfirst.prev=first;
        }else {
            last=first;
        }
        n++;
    }

    // add the item to the end
    public void addLast(Item item){
        if (item == null) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        if (isEmpty()) first = last;
        else {
            oldlast.next = last;
        }
        n++;
    }

    // remove and return the item from the front
    public Item removeFirst(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==0) {first=null; last=null; return null;}
        Item item = first.item;
        first = first.next;
        n--;
        return item;
    }

    // remove and return the item from the end
    public Item removeLast(){
        if (isEmpty()) {throw new NoSuchElementException();}
        else if (n==0) {first=null; last=null; return null;}
        Item item = last.item;
        last = last.prev;
        n--;
        return item;
    }



    // return an iterator over items in order from front to end
    @Override
    public Iterator<Item> iterator(){
        return new DequeIterator<Item>(first);
    }


    private class DequeIterator<Item> implements Iterator<Item> {      //DequeIterator實作Iterator<>
                                                                       // ，故需包含hesNext()及next()
        private Node<Item> current;

        public DequeIterator(Node<Item> first){current=first;}

        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) throws Exception {
    }
}

@58ef69f27e9ffc16b55ee5ce31bd7cec@"
"r04631027","10","0.136","183680","@b7f1fd1bda380f78727f8575e1936dc2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.Iterator;
import java.util.NoSuchElementException;
/**
 *
 * @author 林康維
 */
public class Deque<Item> implements Iterable {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int N;               // number of elements on queue
    

    public static class Node<Item> {
        public Item item;
        public Node next;
        public Node previous;
    }
    public Deque() {
        first = null;
        last  = null;
        N = 0;
    }
    
    public boolean isEmpty() {
        return (first == null || last == null);
    }
    public int size() {
        return N;     
   }
    public void addFirst (Item item){
        if(item == null)throw new java.lang.NullPointerException();
        Node oldfirst = first;
        first = new Node() ;
        first.item = item ;
        first.previous = null ;
        first.next = null ;     
        if(isEmpty()) {
            last = first ;    
        }
        else
        {
            first.next = oldfirst ;
            oldfirst.previous = first  ;
        }
        
        N++ ;
    }
    public void addLast (Item item){
        if(item == null)throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node();
        last.item = item;
        last.previous = null ;
        last.next = null;
        if (isEmpty()) {
            first = last ;    
        }
        else{
            oldlast.next = last;
            last . previous = oldlast ;
        }
        N++;
    }
    
        public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = first.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = first.item;
        first = first.next;
        first.previous = null ;
        N--;
        //if (isEmpty()) last = null;   // to avoid loitering
        return item;
                 }
    }
    public Item removeLast() {///////////////////
        if (isEmpty()) throw new NoSuchElementException();
        if(N==1){
        Item item = last.item;
            first = null ;
            last = null ;
            N = 0 ;
            return item;
        }
        else{
        Item item = last.item;        // save item to return
        last = last . previous ;
        last.next = null ;
        N--;
        //if (isEmpty()) first = null;
        return item;                   // return the saved item
        }
        }

        
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        
        //Deque qe = new Deque();

//        qe.addLast(""a"");
//        qe.addLast(""b"");
//        qe.addLast(""c"");
//        qe.addLast(""d"");
        //qe.addFirst(""a"");
        //qe.addFirst(""bc"");
        //qe.addLast(""c"");
        //qe.removeLast();
        //qe.removeFirst();
        //qe.removeFirst();
        //qe.removeFirst();
        //qe.removeLast();
        //qe.removeLast();
        //qe.removeLast();
        //qe.addLast(""a"");
        //qe.addFirst(""a"");
        //qe.removeLast();

       //Iterator it=qe.iterator();

        //System.out.println(""Initial Size of Queue :""+qe.size());

        //while(it.hasNext())
        //{
           // String iteratorValue=(String)it.next();
            //System.out.println(""Queue Next Value :""+iteratorValue);
        //}

        //System.out.println(""Final Size of Queue :""+qe.size());
    }
}    



@b7f1fd1bda380f78727f8575e1936dc2@"
"r03522809","8","1.41","184976","@932b5dbcf9229d3d6b2885ca4e50b59c@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        first  = last;
        N = 0;
    }

    public boolean isEmpty() {
        
        return N==0;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;first = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//        String[] words = br.readLine().split("" ""); 
        String ws =""A,B,C,D,E,F,G,H,-,-,-,I,J,K,-,-,-,C,C,C,-,-,-,-,"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addFirst(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        
    }
}
@932b5dbcf9229d3d6b2885ca4e50b59c@"
"d04631001","10","0.142","183168","@3dd6bff155b0c0d8eca811b0b8d1760a@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {

    private int N;
    private Node<Item> first;
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
        private Node<Item> front;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {

        return N == 0;

    }

    public int size() {
        return N;
    }

    public void addLast(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldlast = last;
        last = new Node<>();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldlast.next = last;
            last.front = oldlast;
        }
        N++;
    }

    public void addFirst(Item item) {
        if (item == null) {
            throw new java.lang.NullPointerException();
        }
        Node<Item> oldfirst = first;
        first = new Node<>();
        first.item = item;
        first.next = oldfirst;
        if (isEmpty()) {
            last = first;
        } else {
            oldfirst.front = first;
        }
        N++;

    }

    public Item removeLast() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = last.item;
        last = last.front;

        N--;
        if (N == 1) {
            first = last;
        } 
        if (isEmpty()) {
            first = null;
            last = null;
        } else {
            last.next = null;
        }
        return item;
    }

    public Item removeFirst() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;

        N--;
        if (N == 1) {
            last = first;
        }
        if (isEmpty()) {
            last = null;
            first = null;
        } else {
            first.front = null;
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first);

    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public void remove() {
            throw new java.lang.UnsupportedOperationException();
        }

        @Override
        public Item next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
        try {
            Deque de = new Deque();
            String input1 = ""a b c d e"";
            de.addLast(input1);
            Object a = de.removeLast();
            System.out.printf(""%s"", a);
        } catch (java.lang.NullPointerException exception) {
            System.out.printf(""%d"", 1);
        }

    }
}

@3dd6bff155b0c0d8eca811b0b8d1760a@"
"b02611002","10","0.159","164144","@7d76c824f521e17c461b162bdd00ba45@import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Created by Yang Chi-Chang on 2016/3/25.
 */
public class Deque<E> implements Iterable {

    private Object[] elementData;
    private int size;
    private static final int DEFAULT_SIZE = 10;

    public Deque(){
        this.elementData = new Object[DEFAULT_SIZE];
        size = 0;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    public int size(){
        return size;
    }

    public void addFirst(E e){
        if(e == null) throw new NullPointerException();
        for(int i = size++ ; i > 0 ; i--)
            elementData[i] = elementData[i-1];
        elementData[0] = e;
        resize();
    }

    public void addLast(E e){
        if(e == null) throw new NullPointerException();
        elementData[size++] = e;
        resize();
    }

    public E removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        E first = (E) elementData[0];
        for(int i = 0 ; i < size-1 ; i++)
            elementData[i] = elementData[i+1];
        size--;
        resize();
        return first;
    }

    public E removeLast(){
        if(isEmpty()) throw new NoSuchElementException();
        resize();
        return (E) elementData[size--];
    }



    private void resize(){
        if(size == elementData.length){
            Object[] copy = new Object[2*elementData.length];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        } else if (size <= elementData.length/4){
            Object[] copy = new Object[elementData.length/2];
            for(int i = 0 ; i < size ; i++){
                copy[i] = elementData[i];
            }
            elementData = copy;
        }
    }


    public String toString(){
        String s = ""["";
        for(int i = 0; i < size; i++)
            s += elementData[i] + "","";
        s = s.substring(0,s.length()-1)+""]"";
        return s;
    }


    @Override
    public Iterator<E> iterator() {
        Iterator<E> iterator = new Iterator<E>() {

            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public E next() {
                if(!hasNext()) throw new NoSuchElementException();
                return (E) elementData[index++];
            }

            public void remove(){
                throw new UnsupportedOperationException();
            }

        };
        return iterator;
    }
}
@7d76c824f521e17c461b162bdd00ba45@"
"r03522826","10","0.142","181280","@43feab38feb612b03e2a1b16086a87c2@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        public Node<Item> left, right;
        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) { throw new NullPointerException(); }
            this.item = item;
        }
        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }         
   public void checkInvariants() {
    assert N >= 0;
    assert N > 0 || (first == null && last == null);
    assert (first == null && last == null) || (first != null && last != null);
  }

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
        Node<Item> prevHead = first;
        Node<Item> newHead = new Node<Item>(item);
        if (prevHead != null) {
          newHead.connectRight(prevHead);
        } else {
          last = newHead;
        }
        first = newHead;
         N++;
         checkInvariants();
   }

   public void addLast(Item item)           // add the item to the end
   {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = last;
        if (prevTail != null) {
          prevTail.connectRight(newTail);
        } else {
          first = newTail;
        }
        last = newTail;
        N++;
        checkInvariants();
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.right;            // delete first node
        
        N--;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) {
           throw new java.util.NoSuchElementException();
       }
        N--;
        Node<Item> prevTail = last;
        last = prevTail.left;
        prevTail.left = null;
        if (last != null) last.right = null;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return prevTail.item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            
            System.out.println(s.N);
//          System.out.println(s.N);
            
   }
}
@43feab38feb612b03e2a1b16086a87c2@"
"r04921115","8","0.9","102416","@35496d5ceee41759cdea7d5e58edbce9@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {
    private int N;                // size of the stack
    private Node<Item> first;     // top of stack
    private Node<Item> last;     // bottom of stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> prev;
    }

   // construct an empty deque (initialize)
   public Deque(){
       first = null;
       last = null;
       N = 0;
   }
   
   // is the deque empty?
   public boolean isEmpty(){             
	   return (first == null && last == null);
   }
   
   // return the number of items on the deque
   public int size(){
       return N;
   }

   
//add front
   // add the item to the front
   public void addFirst(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldfirst = first;
       first = new Node<Item>();
       first.item = item;
       first.prev = null;
       
       if (oldfirst == null) {
           first.next = null;
       }else {
           first.next = oldfirst;
           oldfirst.prev = first;        
       }
       
       if (last == null) {
           last = first;
       }
      
       N++;
   }
   
// V add end
   // add the item to the end
   public void addLast(Item item){
	   if(item==null) throw new NullPointerException(""null pointer"");
	   Node<Item> oldlast = last;
       last = new Node<Item>();
       if(oldlast == null){
    	   last.prev = null;
       }else{
    	   last.prev = oldlast;
    	   oldlast.next = last;
       }
       
       last.item = item;
       last.next = null;//*
       
       if(first == null){
    	   first = last;
       }
       N++;
   }
   
// V remove front // right!!!
   // remove and return the item from the front
   public Item removeFirst(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = first.item;        // save item to return
	   first = first.next;            // delete first node
	   if(N==1){
		   last = null;
		   first=null;
	   }
	   N--;
       if(isEmpty()){
		   first.next = null;
		   first.prev = null;
		   last=null;
		   last.next = null;
		   last.prev = null;
       }
	   return item;                   // return the saved item
   }

//remove end
   // remove and return the item from the end
   public Item removeLast(){                
	   if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
	   Item item = last.item;        // save item to return
	   if(last.prev==null){
	   
	   }else{
		   last = last.prev;	         // delete last node
	   }
	   last.next = null;
	   if(last==null){
		   first=null;
	   }
	   if(isEmpty()){
		   first=null;
		   first.next = null;
		   first.prev = null;
		   last=null;
		   last.next = null;
		   last.prev = null;
	   }
	   if(N==1){
		   last = null;
		   first=null;
	   }
	   N--;
       return item;                   // return the saved item
   }
   
   // return an iterator over items in order from front to end
   public Iterator<Item> iterator() {
       return new DequeIterator<Item>(first);
   }

   // an iterator, doesn't implement remove() since it's optional
   private class DequeIterator<Item> implements Iterator<Item> {
       private Node<Item> current;

       public DequeIterator(Node<Item> first) {
           current = first;
       }
       
       public boolean hasNext()  { return (current!=null);}
       public void remove()      { throw new UnsupportedOperationException();  }

       public Item next() {
           if (!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next; 
           return item;
       }
   }
   
   public static void main(String[] args){
	   Deque<String> d = new Deque<String>();
//	   d.addFirst(""f1"");
//	   d.addFirst(""f2"");
//	   d.addFirst(""f3"");
//	   d.addFirst(""f4"");
//	   d.addLast(""f5"");
//	   d.addLast(""f6"");
//
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();
//	   d.removeLast();

//	   d.addFirst(""f3"");
//	   
//	   d.removeFirst();
//	   d.removeFirst();
//	   d.removeLast();
//	   
//	   d.addLast(""last1"");
//	   d.addLast(""last2"");
//	   d.addLast(""last3"");
//	   d.removeLast();
//	   d.removeLast();

//	   for (String s : d) {
//           System.out.println(s); // prints only ""four""
//       }
   }
}
@35496d5ceee41759cdea7d5e58edbce9@"
"r03849033","0","1.17","174288","@0c9171b7257bb981ce1571028b9c95ce@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     before.next=oldbefore;
     if(isEmpty()){
            after = before;
     } else {   oldbefore.previous=before; }
         size++;
    }
    public void addLast(Item item)           // insert the item at the end
    {
     Node oldafter = after;
     after = new Node();
     after.item=item;
     after.previous=oldafter;
     if(isEmpty()){
            before = after;
     } else {   oldafter.next=after; }
      size++;
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     size--;
     Item it=before.item;
     if(before.next==null){after=null;}
     else{
         before.next.previous=null;
         before=before.next;
     }
     return it ;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     size--;
     Item it=after.item;
     if(before.next==null){before=null;}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     return it ;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=after;
     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@0c9171b7257bb981ce1571028b9c95ce@"
"r03522809","8","1.4","179888","@1b87f7145702c26ef11e9fd5c49bb5a3@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        
        return N==0;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;first = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//      String[] words = br.readLine().split("" ""); 
        
        String ws =""A,B,C,D,E,F,G,H,-,-,-,I,J,K,-,-,-,C,C,C,-,-,-,-,"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addFirst(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        
    }
}

@1b87f7145702c26ef11e9fd5c49bb5a3@"
"r03849033","0","1.16","175728","@cc941bb77865923cfb285358bab7a224@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     before.next=oldbefore;
     if(isEmpty()){
            after = before;
     } else {   oldbefore.previous=before; }
         size++;
    }
    public void addLast(Item item)           // insert the item at the end
    {
     Node oldafter = after;
     after = new Node();
     after.item=item;
     after.previous=oldafter;
     if(isEmpty()){
            before = after;
     } else {   oldafter.next=after; }
      size++;
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     Item it=before.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         before.next.previous=null;
         before=before.next;
     }
     size--;
     return it ;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     Item it=after.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=after;
     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@cc941bb77865923cfb285358bab7a224@"
"r03522809","8","1.41","175184","@a842914cbfa25f111ff89e880b1f5097@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.Iterable;


public class Deque<Item> implements Iterable<Item> {
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue

    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
        private Node<Item> pre;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        
        return N==0;
    }

    public int size() {
        return N;
    }
    
    public void addFirst(Item item) {
        if (item.equals("""")) throw new java.lang.NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.pre = null;
        if (isEmpty()) last = first;
        else           oldfirst.pre = first;
        N++;
    }
        public void addLast(Item item) {
        if (item.equals("""")) throw new java.lang.NullPointerException();
            Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        last.pre = oldlast;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        N++;
    } 
    public Item removeFirst() {
        if (isEmpty()) throw new java.util.NoSuchElementException();
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;
        if (isEmpty()) {last = null;first = null;}

        return item;                   // return the saved item
    }

    public Item removeLast() {
        if (isEmpty()) throw new java.util.NoSuchElementException();
        Item item = last.item;
        last = last.pre;
        N--;
        if (isEmpty()) {last = null;first = null;}   // to avoid loitering
 
        return item;
    }

    public Item peek() {
        if (isEmpty()) throw new java.util.NoSuchElementException();
        return first.item;
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + "" "");
        return s.toString();
    }
       
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;
        
        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }
        public boolean hasNext()  { return current != null;                   }
        public void remove()      { throw new java.lang.UnsupportedOperationException();}
        public Item next() {
            if (!hasNext()) throw new java.util.NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
     
//    public static void main(String[] args) {
//        Deque<String> s = new Deque<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) s.addFirst(item);
//            else if (!s.isEmpty()) StdOut.print(s.removeLast() + "" "");
//        }
//        StdOut.println(""("" + s.size() + "" left on stack)"");
//    }

    public static void main(String[] args) {

//      String[] words = br.readLine().split("" ""); 
        
        String ws =""A,B,C,D,E,F,G,H,-,-,-,I,J,K,-,-,-,C,C,C,-,-,-,-,"";
        String ans;
        String[] word =ws.split("","");
        Deque <String> stack=new Deque<String>();
        Stack <String> sta=new Stack<String>();
        Iterator<String> iter = stack.iterator();
        Iterator<String> it = sta.iterator();    
        int N = word.length;
        int i =0,j=0;

        while ( j != N )
        {
            if(word[j].equals(""-"")){System.out.println(stack.removeFirst());
                             sta.pop();}
            else{stack.addFirst(word[j]);
                 sta.push(word[j]);
            }
                j++;
        }
        
    }
}

@a842914cbfa25f111ff89e880b1f5097@"
"r03522831","10","0.141","177456","@43feab38feb612b03e2a1b16086a87c2@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class Deque<Item> implements Iterable<Item>
{
    private int N;               // number of elements on queue
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private Node<Item> temp;     // pre end of queue
    
   private static class Node<Item> {
        private Item item;
        public Node<Item> left, right;
        public Node(Item item) {
            // FIXME: maybe it's a bad practice to throw exception in constructor
            if (item == null) { throw new NullPointerException(); }
            this.item = item;
        }
        public void connectRight(Node<Item> other) {
            this.right = other;
            other.left = this;
        }
    }
   
   public Deque(){
        first = null;
        last  = null;
        temp  = null;
        N = 0;
    }                          // construct an empty deque

   public boolean isEmpty() // is the deque empty? 
   {
        return first == null;
    }         
   public void checkInvariants() {
    assert N >= 0;
    assert N > 0 || (first == null && last == null);
    assert (first == null && last == null) || (first != null && last != null);
  }

   public int size()  // return the number of items on the deque
   {
        return N;
    }                      

   public void addFirst(Item item)          // add the item to the front
   {
        Node<Item> prevHead = first;
        Node<Item> newHead = new Node<Item>(item);
        if (prevHead != null) {
          newHead.connectRight(prevHead);
        } else {
          last = newHead;
        }
        first = newHead;
         N++;
         checkInvariants();
   }

   public void addLast(Item item)           // add the item to the end
   {
        Node<Item> newTail = new Node<Item>(item);
        Node<Item> prevTail = last;
        if (prevTail != null) {
          prevTail.connectRight(newTail);
        } else {
          first = newTail;
        }
        last = newTail;
        N++;
        checkInvariants();
   }
   public Item removeFirst()                // remove and return the item from the front
   {
        if (isEmpty()) throw new NoSuchElementException(""Stack underflow"");
        Item item = first.item;        // save item to return
        first = first.right;            // delete first node
        
        N--;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return item;
   }
   public Item removeLast()                 // remove and return the item from the end
   {
       if (isEmpty()) {
           throw new java.util.NoSuchElementException();
       }
        N--;
        Node<Item> prevTail = last;
        last = prevTail.left;
        prevTail.left = null;
        if (last != null) last.right = null;
        checkInvariants();
        if(N==0){first = null; last = null;}
        return prevTail.item;
   }
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Deque.Node<Item> current;

        public ListIterator(Deque.Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.right; 
            return item;
        }
    }
   public static void main(String[] args)   // unit testing
   {
            Deque <String> s = new Deque<String>();
            s.addFirst(""2"");
            s.addFirst(""1"");
            s.addLast(""3"");
            s.addLast(""4"");
            
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            System.out.println(s.removeFirst());
            
            System.out.println(s.N);
//          System.out.println(s.N);
            
   }
}
@43feab38feb612b03e2a1b16086a87c2@"
"r03849033","1","1.25","183328","@75b47ac5d98fd8ea479143ab54046684@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     if(isEmpty()){
            after = before;
     } else {
         before.next=oldbefore;
         oldbefore.previous=before;
     }
         size++;
    }
    public void addLast(Item item)           // insert the item at the end
    {
     Node oldafter = after;
     after = new Node();
     after.item=item;
     if(isEmpty()){
            before = after;
     } else {   
        oldafter.next=after;
        after.previous=oldafter;}
      size++;
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     Item it=before.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         before.next.previous=null;
         before=before.next;
     }
     size--;
     return it ;
    }

    public Item removeLast()                 // delete and return the item at the end
    {
     Item it=after.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=null;
     }
     public void remove(){

     }

     public Item next(){
      Item item=current.item;
      current=current.next;
      return item;   
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@75b47ac5d98fd8ea479143ab54046684@"
"r04631009","0","0","0","@97c3129fc8b04e20abd05971e4ddaaab@        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);

            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());

        }
    }
    
}
@97c3129fc8b04e20abd05971e4ddaaab@"
"r04631009","8","1.44","184160","@1a80ca0e0631457d8e5fc4fbc72c470b@import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Cyuan
 */
public class Deque<Item> implements Iterable<Item>{
    
    private int N;
    private Node<Item> first;
    private Node<Item> last;
    
    
    private static class Node<Item>{
        private Item item;
        private Node<Item> next;
        private Node<Item> previous;
       
    }
    
    public Deque(){
        first = null;
        last = null;
        N = 0;
    }
    
    public boolean isEmpty(){
        return 0 == N;
    }
    
    public int size(){
        return N;
    }
    
    public void addFirst(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        first.previous = null;
        if(isEmpty()) last = first;
        else oldfirst.previous = first;
        N++;
//        if(1 == N){last = first;}
//        else if(2 == N){last.previous = first;}
//        else{oldfirst.previous = first;}
        
    }
    
    public void addLast(Item item){
        if(item.equals(null)) throw new NullPointerException();
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.previous = oldlast;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast.next = last;
        N++;
//        if(1 == N){first = last;}
//        else if(2 == N){first.next = last;}
        //else{oldlast.next = last;}
    }
    
    public Item removeFirst(){
        if(isEmpty()) throw new NoSuchElementException();
        Item item = first.item;
        first = first.next;
        //if(1 != N){first.previous = null;}
        N--;
        if(isEmpty()){
            last = null;
        }
        return item;
    }
    
    public Item removeLast(){
        if(isEmpty())throw new NoSuchElementException();
        Item item = last.item;
        last = last.previous;
        //if(1 != N){last.next = null;}
        N--;
       if(isEmpty()){
           first = null;
       }
        return item;
    }
    
    public Iterator<Item> iterator(){
        return new ListIterator<Item>(first);
    }
    
    private class ListIterator<Item> implements Iterator<Item>{
        private Node<Item> current;
        
        public ListIterator(Node<Item> first){
            current = first;
        } 
        
        public boolean hasNext(){return current != null;}
        
        public void remove(){throw new UnsupportedOperationException();}
        
        public Item next(){
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String [] data = br.readLine().split("" "");
            //String [] data = new String [9];
            Deque<String> s = new Deque<String>();
            s.addFirst(data[0]);
            s.addFirst(data[1]);
            s.addFirst(data[2]);
            s.addFirst(data[3]);
            s.addFirst(data[4]);
            s.addFirst(data[5]);
            s.addFirst(data[6]);
            s.addFirst(data[7]);
            s.addFirst(data[8]);
//            s.addLast(data[0]);
//            s.addLast(data[1]);
//            s.addLast(data[2]);
//            System.out.print(s.size()+""\n"");
            int N = s.size();
            for(int i = 0; i < N; i++)
            System.out.println(s.removeFirst());
            
            
            System.out.print(s.isEmpty());
             System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//            System.out.println(s.removeFirst());
//            System.out.println(s.removeLast());
//           System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.size()+""\n"");
//            System.out.println(s.removeLast());
//            System.out.print(s.isEmpty()+""\n"");
//            System.out.print(s.size()+""\n"");
        }
    }
    
}
@1a80ca0e0631457d8e5fc4fbc72c470b@"
"r03849033","2","1.4","182144","@2c020c4160076411aa57a23ea47d5b75@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
     Node oldbefore = before;
     before = new Node();
     before.item=item;
     if(isEmpty()){
            after = before;
     } else {
         before.next=oldbefore;
         oldbefore.previous=before;
     }
         size++;
     }
    }
    public void addLast(Item item)           // insert the item at the end
    {
      if(item==null){throw new java.lang.NullPointerException();}   
     else{
     Node oldafter = after;
     after = new Node();
     after.item=item;
     if(isEmpty()){
            before = after;
     } else {   
        oldafter.next=after;
        after.previous=oldafter;}
      size++;
      }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(before==after){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current.next!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(hasNext()){
      Item item=current.item;
      current=current.next;
      return item;  }
      else{throw new java.util.NoSuchElementException();}
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {


 }

}
@2c020c4160076411aa57a23ea47d5b75@"
"r03849033","4","1.4","181072","@79c75d39870516fd21bbd5a797d6b2cd@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.next=before;
        if(isEmpty()){   after=nd;  }else{
            before.previous=nd;        }
        before=nd;
        size++;
        }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.previous=after;
        if(isEmpty()){   before=nd;  }else{
            after.next=nd;        }
        after=nd;
        size++;
        }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(before==after){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(before==after){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(hasNext()){
      Item item=current.item;
      current=current.next;
      return item;  }
      else{throw new java.util.NoSuchElementException();}
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@79c75d39870516fd21bbd5a797d6b2cd@"
"r03849033","4","1.43","173056","@2ff3c7df3c8dd4e35af9d1256cd63b77@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.next=before;
        if(isEmpty()){   after=nd;  }else{
            before.previous=nd;        }
        before=nd;
        size++;
        }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.previous=after;
        if(isEmpty()){   before=nd;  }else{
            after.next=nd;        }
        after=nd;
        size++;
        }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(size==1){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(size==1){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(hasNext()){
      Item item=current.item;
      current=current.next;
      return item;  }
      else{throw new java.util.NoSuchElementException();}
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {

 }

}
@2ff3c7df3c8dd4e35af9d1256cd63b77@"
"r03849033","4","1.38","184912","@c50f7d4f508eb14567b9dd9a114baa0b@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.next=before;
        if(isEmpty()){   after=nd;  }else{
            before.previous=nd;        }
        before=nd;
        size++;
        }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.previous=after;
        if(isEmpty()){   before=nd;  }else{
            after.next=nd;        }
        after=nd;
        size++;
        }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(size==1){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(size==1){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(hasNext()){
      Item item=current.item;
      current=current.next;
      return item;  }
      else{throw new java.util.NoSuchElementException();}
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {


 }

}
@c50f7d4f508eb14567b9dd9a114baa0b@"
"r03849033","4","0.47","102432","@9ab4bb8d5e5beb94280ca11523f0a238@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.next=before;
        if(isEmpty()){   after=nd;  }else{
            before.previous=nd;        }
        before=nd;
        size++;
        }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.previous=after;
        if(isEmpty()){   before=nd;  }else{
            after.next=nd;        }
        after=nd;
        size++;
        }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(size==1){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(size==1){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(current.item==null){throw new java.util.NoSuchElementException();} else{
      Item item=current.item;
      current=current.next;
      return item;  }
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {
 

 }

}
@9ab4bb8d5e5beb94280ca11523f0a238@"
"r03849033","4","1.42","179184","@5d30ecbff23b45d62e46d2aca7c3326a@import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
 private int size=0;// number of elements
 private Node before;//sentinel marking the beginning of a list
 private Node after;//sentinel marking the end of a list


    public Deque()                           // construct an empty deque
    {
     before= new Node();
     after = new Node();
    }

    public boolean isEmpty()                 // is the deque empty?
    {
     return size==0;
    }

    public int size()                        // return the number of items on the deque
    {
     return size;
    }

    public void addFirst(Item item)          // insert the item at the front
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.next=before;
        if(isEmpty()){   after=nd;  }else{
            before.previous=nd;        }
        before=nd;
        size++;
        }
    }
    public void addLast(Item item)           // insert the item at the end
    {
     if(item==null){throw new java.lang.NullPointerException();}   
     else{
        Node nd= new Node();
        nd.item=item;
        nd.previous=after;
        if(isEmpty()){   before=nd;  }else{
            after.next=nd;        }
        after=nd;
        size++;
        }
    }
    public Item removeFirst()                // delete and return the item at the front
    {
     if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{
        Item it=before.item;
        if(size==1){
           before= new Node();
           after = new Node();}
         else{
            before.next.previous=null;
            before=before.next;
          }
         size--;
         return it ;
         }
    }

    public Item removeLast()                 // delete and return the item at the end
    {
         if(isEmpty()){ throw new java.util.NoSuchElementException();}   
     else{    
     Item it=after.item;
     if(size==1){
        before= new Node();
        after = new Node();}
     else{
         after.previous.next=null;
         after=after.previous;
     }
     size--;
     return it ;
     }
    }

    public Iterator<Item> iterator()         // return an iterator over items in order from front to end
    {
     return new DequeIterator();
    }

    private class DequeIterator implements Iterator<Item>{
     Node current=before;
     public boolean hasNext(){
      return current!=null;
     }
     public void remove(){
         throw new UnsupportedOperationException();
     }

     public Item next(){
      if(hasNext()){
      Item item=current.item;
      current=current.next;
      return item;  } else{
          throw new java.util.NoSuchElementException();
      }
     }

    }//end class DequeIterator

    private class Node{
     private Item item;
     private Node next;
     private Node previous;
    }

 public static void main(String[] args) {
  
 }

}
@5d30ecbff23b45d62e46d2aca7c3326a@"
"b02611019","9","1.42","176288","@bb307a483f5eb2c36ae3f7439c3679cc@import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<T> implements Iterable<T> {
  private class Node<T> {
    public Node<T> left, right;
    private final T item;

    public Node(T item) {
      // FIXME: maybe it's a bad practice to throw exception in constructor
      if (item == null) { throw new NullPointerException(); }
      this.item = item;
    }

    public void connectRight(Node<T> other) {
      this.right = other;
      other.left = this;
    }
  }

  private class DequeIterator implements Iterator<T> {

    private Node<T> curr = head;

    public boolean hasNext() {
      return curr != null;
    }
    public void remove() {
      throw new UnsupportedOperationException();
    }
    public T next() {
      if (!hasNext()) { throw new NoSuchElementException(); }
      T item = curr.item;
      curr = curr.right;
      return item;
    }
  }

  private Node<T> head, tail;
  private int size;

  public Iterator<T> iterator() {
    return new DequeIterator();
  }


  public Deque() {
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  public void checkInvariants() {
    assert size >= 0;
    assert size > 0 || (head == null && tail == null);
    assert (head == null && tail == null) || (head != null && tail != null);
  }


  public void addFirst(T item) {
      if(item==null){
          throw new  java.lang.NullPointerException();
      }
    Node<T> prevHead = head;
    Node<T> newHead = new Node<T>(item);
    if (prevHead != null) {
      newHead.connectRight(prevHead);
    } else {
      tail = newHead;
    }
    head = newHead;
    size++;
    checkInvariants();
  }

  public void addLast(T item) {
      if(item==null){
          throw new  java.lang.NullPointerException();
      }
    Node<T> newTail = new Node<T>(item);
    Node<T> prevTail = tail;
    if (prevTail != null) {
      prevTail.connectRight(newTail);
    } else {
      head = newTail;
    }
    tail = newTail;
    size++;
    checkInvariants();
  }

  public T removeFirst() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevHead = head;
    head = prevHead.right;
    prevHead.right = null;
    if (head != null) {
      head.left = null;
    }
    checkInvariants();
    return prevHead.item;
  }

  public T removeLast() {
    if (isEmpty()) {
      throw new java.util.NoSuchElementException();
    }
    size--;
    Node<T> prevTail = tail;
    tail = prevTail.left;
    prevTail.left = null;
    if (tail != null) tail.right = null;
    checkInvariants();
    return prevTail.item;
  }
    public static void main(String[] args) {
        
    }
}

@bb307a483f5eb2c36ae3f7439c3679cc@"
"b02611019","0","0","0","@5cd09038ba7adbcbbae55460379ff507@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Deque<Item> implements Iterable<Item> {

    private int N;               // number of elements on queue
    static Node first;    // beginning of queue
    private Node<Item> last;

    private static class Node<Item> {

        private Item item;
        private Node<Item> next;
    }

    public Deque() {
        first = null;
        last = null;
        N = 0;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void addFirst(Item item) {    //push
        if (item != null) {
            Node<Item> oldfirst = first;
            first = new Node<Item>();
            first.item = item;
            first.next = oldfirst;
            N++;
        } else {
            throw new NullPointerException();
        }
    }

    public void addLast(Item item) {     //enquene
        if (item != null) {
            Node<Item> oldlast = last;
            last = new Node<Item>();
            last.item = item;
            last.next = null;
            if (isEmpty()) {
                first = last;
            } else {
                oldlast.next = last;
            }
            N++;
        }
        else {
            throw new NullPointerException();
        }
    }

    public Item removeFirst() {  //dequene
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;
        }   // to avoid loitering

        return item;
    }

    public Item removeLast() {   //pop
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        N--;

        return item;
    }

    public Iterator<Item> iterator() {
        return new ListIterator<Item>();
    }

    private class ListIterator<Item> implements Iterator<Item> {

        private Node<Item> current;

        public ListIterator() {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }
    }

    public static void main(String[] args) {
//        Queue<String> q = new Queue<String>();
//        while (!StdIn.isEmpty()) {
//            String item = StdIn.readString();
//            if (!item.equals(""-"")) {
//                q.enqueue(item);
//            }
//            else if (!q.isEmpty()) {
//                StdOut.print(q.dequeue() + "" "");
//            }
//        }
//        StdOut.println(""("" + q.size() + "" left on queue)"");       
//        
        Deque<String> d = new Deque<String>();

        d.addLast(""1"");
        //d.addFirst("""");
        if (d.isEmpty()) {
            System.out.printf(""is Empty"");
        } else {
            System.out.printf(""Not empty"");
        }

        System.out.printf(d.removeFirst());
        
    }

}

@5cd09038ba7adbcbbae55460379ff507@"
"r04921115","0","0.098","105376","@83a691c85724ef74d97d6b88966b30eb@import java.util.*;
import java.lang.*;
import java.util.NoSuchElementException;

public class MyConvexHull {
	public static void main(String[] args) throws Exception{
	    int N = Integer.parseInt(args[0]);
		Point2D[] a = new Point2D[N];
		double min_y = 0;
		double min_x = 0;
		for(int i = 0; i<N; i++){
				double x =StdRandom.uniform();
				double y =StdRandom.uniform();
				if(i==0){
					min_y = y;
				}else{
					if(y < min_y){
						min_y = y;
					}
				}
				//System.out.println(""x"" + x + "" ,""+ ""y"" + y);
				a[i] = new Point2D(x, y);
		}
		for(int i = 0; i<N; i++){
			if(a[i].y()==min_y){
				min_x = a[i].x();
				StdDraw.setPenColor(StdDraw.RED);
			}else{
				StdDraw.setPenColor(StdDraw.BLUE);
			}
			StdDraw.filledCircle(a[i].x(), a[i].y(), 0.01);
		}
		
		for(int i = 0; i<N; i++){
			
		}
	}
}

@83a691c85724ef74d97d6b88966b30eb@"
"b03611015","10","0.141","176848","@8a2ac543e7073540bb7e028b8dee994e@
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
    private class DequeIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public Item next() {
            if (current == null) {
                throw new java.util.NoSuchElementException();
            }
            Item item = current.item;
            current = current.next;
            return item;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private Node first = null;
    private Node last = null;
    private int size = 0;

    private class Node {
        private Item item;
        private Node next;
        private Node previous;
    }

    /*
     * construct an empty deque
     */
    public Deque() {
    }

    /*
     * is the deque empty?
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /*
     * return the number of items on the deque
     */
    public int size() {
        return size;
    }

    private void checkAdd(Item item) {
        if (item == null) {
            throw new NullPointerException();
        }
    }

    /*
     * insert the item at the front
     */
    public void addFirst(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            first.previous = node;
            node.next = first;
            first = node;
        }
        size++;
    }

    /*
     * insert the item at the end
     */
    public void addLast(Item item) {
        checkAdd(item);
        Node node = new Node();
        node.item = item;
        if (size() == 0) {
            first = node;
            last = node;
        } else {
            last.next = node;
            node.previous = last;
            last = node;
        }
        size++;
    }

    private void checkRemove() {
        if (isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
    }

    /*
     * delete and return the item at the front
     */
    public Item removeFirst() {
        checkRemove();
        Item item = first.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node second = first.next;
            second.previous = null;
            first.next = null;
            first = second;
        }
        size--;
        return item;
    }

    /*
     * delete and return the item at the end
     */
    public Item removeLast() {
        checkRemove();
        Item item = last.item;
        if (first == last) {
            first = null;
            last = null;
        } else {
            Node oldLast = last;
            last = oldLast.previous;
            last.next = null;
            oldLast.previous = null;
            oldLast = null;
        }
        size--;
        return item;
    }

    /*
     * return an iterator over items in order from front to end
     * 
     * @see java.lang.Iterable#iterator()
     */
    public java.util.Iterator<Item> iterator() {
        return new DequeIterator();
    }
}

@8a2ac543e7073540bb7e028b8dee994e@"
"b02611019","9","1.41","178608","@8f438ee7616f72c60161e41c4cbd1d90@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null || last == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
       if(item==null) throw new java.lang.NullPointerException();    
       node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
       if(item==null) throw new java.lang.NullPointerException();     
       node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty())last.next = null;
       size --;
       return temp.item;
       
   }
   
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator<Item>(first);
   }
   
   private class ListIterator<Item> implements Iterator<Item>{
       private node<Item> current;
       public ListIterator(node<Item> first) {
            current = first;
        }
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public boolean hasNext(){
           return current != null;
       }
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        a.addFirst(""aa"");
        a.addLast(""bb"");
        StdOut.print(a.removeFirst());
        StdOut.print(a.removeLast());
        a.addLast(""bb"");
    }    
}

@8f438ee7616f72c60161e41c4cbd1d90@"
"b02611019","9","1.4","175904","@725bee976243a7c31b4032fd23cfc874@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null || last == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
       if(item==null) throw new java.lang.NullPointerException();    
       node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
       if(item==null) throw new java.lang.NullPointerException();     
       node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty())last.next = null;
       size --;
       return temp.item;
       
   }
   
   public Iterator<Item> iterator(){         // return an iterator over items in order from front to end
      return new ListIterator();
   }
   
   private class ListIterator implements Iterator<Item>{
       private node<Item> current =first;
       
       public void remove(){
           throw new UnsupportedOperationException();
       }
       public boolean hasNext(){
           return current != null;
       }
       public Item next(){
           if(!hasNext()) throw new NoSuchElementException();
           Item item = current.item;
           current = current.next;
           return item;
       }
   }
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        a.addFirst(""aa"");
        a.addLast(""bb"");
        StdOut.print(a.removeFirst());
        StdOut.print(a.removeLast());
        a.addLast(""bb"");
    }    
}

@725bee976243a7c31b4032fd23cfc874@"
"b02611019","0","0.128","111056","@fd65f4c44b04c4a60aa080d28b529758@
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class Deque<Item> implements Iterable<Item>  {
    
    private node<Item> first;
    private node<Item> last;
    private int size;
    
    private static class node<Item> {
        private Item item;
        private node<Item> next;
        private node<Item> prev;
    }
    
   public Deque(){                    // construct an empty deque
       first = null;
       last = null;
       size = 0;
   }
   public boolean isEmpty(){                 // is the deque empty?
       return first == null || last == null;
   }

   public int size(){                        // return the number of items on the deque
       return size;
   }

   public void addFirst(Item item){          // add the item to the front
       if(item==null) throw new java.lang.NullPointerException();    
       node<Item> temp = new node();
           temp.item = item;
           if(isEmpty()){
               temp.next = null;
               temp.prev = null;
               last = temp;
               first = temp;
           }else{
               temp.next = first;
               first.prev = temp;
               first = temp;
           }
           size ++;
           
   }

   public void addLast(Item item){           // add the item to the end
       if(item==null) throw new java.lang.NullPointerException();     
       node<Item> temp = new node();
        temp.item = item;
        temp.next = null;
        if(isEmpty()){
            temp.prev = null;
            first = temp;
            last = temp;
        }else{
            temp.prev = last;
            last.next = temp;
            last = temp;
        }
        size ++;
   }

   public Item removeFirst(){                // remove and return the item from the front
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = first;
       first = first.next;
       if(!isEmpty()) first.prev = null;
       size --;
       return temp.item;
   }

   public Item removeLast(){                 // remove and return the item from the end
       if(isEmpty()) throw new NoSuchElementException(""Queue underflow"");
       node<Item> temp = last;
       last = last.prev;
       if(!isEmpty())last.next = null;
       size --;
       return temp.item;
       
   }
   
   public Iterator<Item> iterator(){
        return new DequeIterator();
   	}
   
   private class DequeIterator implements Iterator<Item>{
   		private node current = first;
   		public boolean hasNext(){
   		    return current != null;	
   		}
   		public Item next(){
   		    if(!this.hasNext()){
                throw new NoSuchElementException();
   		    }
   			Item item = current.item;
   			current = current.next;
   			return item;
   		}
   		public void remove(){
   		    throw new UnsupportedOperationException();  
   		}
   	}
   
    

    public static void main(String[] args) {
        // TODO code application logic here
         Deque a = new Deque();
        a.addFirst(""aa"");
        a.addLast(""bb"");
        StdOut.print(a.removeFirst());
        StdOut.print(a.removeLast());
        a.addLast(""bb"");
    }    
}


@fd65f4c44b04c4a60aa080d28b529758@"
